package Test::Utils;

use strict;
use warnings;

use Cwd;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Copy;
use File::Path qw{make_path};
use File::Temp qw{tempdir};
use List::Util qw{uniq};

use parent qw{Exporter};

use Readonly;

Readonly our $TRUE    => 1;
Readonly our $FALSE   => 0;
Readonly our $SUCCESS => 1;
Readonly our $FAILURE => 0;
Readonly our $YES     => 'yes';
Readonly our $NO      => 'no';

Readonly our $AMPERSAND          => q{&};
Readonly our $ASTERISK           => q{*};
Readonly our $COLON              => q{:};
Readonly our $COMMA              => q{,};
Readonly our $DASH               => q{-};
Readonly our $DOUBLE_COLON       => q{::};
Readonly our $DOT                => q{.};
Readonly our $DOLLAR_SIGN        => q{$};
Readonly our $EMPTY              => q{};
Readonly our $EQUALS_SIGN        => q{=};
Readonly our $PERIOD             => q{.};
Readonly our $PERCENT            => q{%};
Readonly our $QUESTION_MARK      => q{?};
Readonly our $SLASH              => q{/};
Readonly our $SEMICOLON          => q{;};
Readonly our $SPACE              => q{ };
Readonly our $TEMPLATE_DELIMITER => q{@};
Readonly our $UNDERSCORE         => q{_};
Readonly our $PLUS_SIGN          => q{+};
Readonly our $MINUS_SIGN         => q{-};

our @EXPORT_OK = ();

our %EXPORT_TAGS = (
  'subs' => [
    qw(
      fetch_test_descriptions
    ),
  ],
  'booleans' => [
    qw(
      $TRUE
      $FALSE
      $SUCCESS
      $FAILURE
      $YES
      $NO
    ),
  ],
  'chars' => [
    qw(
      $ASTERISK
      $AMPERSAND
      $COLON
      $COLOR
      $COMMA
      $DASH
      $DOLLAR_SIGN
      $DOUBLE_COLON
      $DOT
      $EMPTY
      $EQUALS_SIGN
      $PERIOD
      $PERCENT
      $PLUS_SIGN
      $MINUS_SIGN
      $QUESTION_MARK
      $SEMICOLON
      $SLASH
      $SPACE
      $TEMPLATE_DELIMITER
      $UNDERSCORE
    )
  ],
);

foreach my $k ( keys %EXPORT_TAGS ) {
  push @EXPORT_OK, @{ $EXPORT_TAGS{$k} };
}

$EXPORT_TAGS{'all'} = [@EXPORT_OK];

########################################################################
# Usage      : fetch_test_descriptions(fh)
# Purpose    : read test descriptions from __DATA__ section to
#            : determine test plan
# Parameters : fh => handle to source of name => description pairs
# Returns    : hash of test (name, description)
# Errors     : none
########################################################################
sub fetch_test_descriptions {
########################################################################
  my ($fh) = @_;

  my %test_descriptions;

  no warnings 'once';  ## no critic (ProhibitNoWarning)

  while ( my $test = <$fh> ) {
    chomp $test;

    $test =~ s/\A\s*(.*)\s*\z/$1/xsm;

    next if $test =~ /^[#]/xsm || !$test;
    last if $test =~ /^END_OF_PLAN/xsm;

    my ( $name, $description ) = split /\s*=>\s*/xsm, $test;
    $test_descriptions{$name} = $description;
  }

  return %test_descriptions;
}

1;

__END__
