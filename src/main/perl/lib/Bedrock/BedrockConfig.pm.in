#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Config;

use strict;
use warnings;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION);
}

use IO::File;
use File::Basename;

use Bedrock::XML;
use Bedrock::Dump;
use Data::Dumper;
use Scalar::Util qw/reftype/;

use parent qw/Bedrock::Hash/;

# Note: 'warn' is used instead of a logging function in this module,
# since this function may be called prior to logging being configured
# - Bedrock::Config is used to get configuration information, which
# includes logging configuration thus its premature to assume logging
# is available.

sub new {
  my $class = shift;
  $class = ref($class) || $class;

  my $file = shift;

  die "[$file] - only .xml files are supported as Bedrock configuration files.\n"
    if $file && $file !~/\.xml$/i;
  
  my $self = $file ? Bedrock::XML->new(&_locate_file($file)) : {};

  return bless $self, $class;
}

# misnamed
sub newFromXML { 
  warn "deprecated: no need to use this! use new() instead.\n";
  goto &new;
}

sub newFromString {
  my $class = shift;
  $class = ref($class) || $class;
  my $self = Bedrock::XML->newFromString(shift);

  bless $self, $class;
}

sub dbnames {
  my $self = shift;

  if ( @_ ) {
    $self->{'_dbnames'} = shift;
  }

  $self->{'_dbnames'};
}

=pod

=head2 _locate_file

 _locate_file( file )

=cut

sub _locate_file {
  my $file = shift;

  if ( $file =~ m!/! ) {
    # No search for config file if filename specified with path

    die "_locate_file: Config file $file not found"
      unless -e $file;

    die "_locate_file: Cannot open config file $file for reading."
      unless -r $file;

    return $file;
  }
  elsif ( -e $file ) {
    # file exists in current directory, but can we read it?
    die "_locate_file: Cannot open config file $file for reading."
      unless -r $file;

    return $file;
  }
  else {
    # search for config file in path
    my @search_paths;

    push @search_paths, $ENV{CONFIG_PATH}
      if $ENV{CONFIG_PATH};

    die  "_locate_file: Could not locate $file and BEDROCK_CONFIG_PATH not set in environment"
      unless $ENV{BEDROCK_CONFIG_PATH};

    push @search_paths, $ENV{BEDROCK_CONFIG_PATH};

    for my $dir ( @search_paths ) {
      my $fullpath = $dir . '/' . $file;
      next unless -e $fullpath;

      # found it but it's unreadable
      die "_locate_file: Cannot open config file $fullpath for reading."
	unless -r $fullpath;

      # found it
      return $fullpath;
    }

    die "_locate_file: Could not locate $file in " . join(':', @search_paths);
  }
}

sub merge_config {
  my ($self, $config) = @_;

  if ( $config ) {
    
    # merge source-config with master
    map { $self->{$_} = $config->{$_} if  $_ ne 'MODULES'; } keys %$config;
    
    # merge modules separately
    $self->merge_modules($config);
  }
  
  return $self;
}

sub merge_modules {
  my ($self, $config) = @_;

  # no modules in source or config
  unless ( $self->{MODULES} && @{$self->{MODULES}} ) {
    $self->{MODULES} = $config->{MODULES}
      if exists $config->{MODULES};
  }
  elsif ( exists $config->{MODULES} && @{$config->{MODULES}} ) {
    # get the binding names for existing modules as these should be
    # unique and use these to create a hash of all module configurations
    my %modules;
    map { $modules{$_->{binding}} = $_; } @{$self->{MODULES}};
    
    # possible overrwite modules from source
    map { $modules{$_->{binding}} = $_; } @{$config->{MODULES}};
    
    $self->{MODULES} = [ values %modules ];
  }

  return $self;
}

sub merge {
  my ($self, $file) = @_;

  if ( -s $file ) {
    my $config = Bedrock::XML->new($file);
    $self->merge_config($config);
  }

  return $self;
}

sub XML {
  my $self = shift;
  my $in_out = shift;

  warn "$self::XML() has been deprecated, consider using <var --xml>\n";

  die "Usage: \$config.XML('in|out', option, value, ...)"
    unless $in_out =~ /^(in|out)$/;

  die "XML config object not set in tagx.xml"
    unless $self->{XML}->{$in_out};

  if ( @_ == 1 || @_ % 2 ) {
    return $self->{XML}->{$in_out}->{ $_[0] };
  }
  else {
    my $config = $self->{XML}->{$in_out};
    my $last;
    my %options = @_;

    while ( my ( $opt, $value ) = each %options ) {
      $last = $config->{$opt};
      $config->{$opt} = $value;
    }

    return $last;
  }
}

=pod

=head2 get_module_config

 get_module_config([module-name])

Returns a startup module's configuration object or the entire array of
module configurations.

=cut

sub get_module_config {
  my ($self, $module_name) = @_;

  return $self->{MODULES}
    if ! $module_name;
  
  return undef
    if $self->{MODULES} || reftype($self->{MODULES}) ne 'ARRAY';
  
  foreach my $m (@{$self->{MODULES}}) {
    return $m->{config}
      if $m && reftype($m) eq 'HASH' && $m->{module} =~ /^$module_name$/i;
  }
  
  return undef;
}

1;

