#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Config;

use strict;
use warnings;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION);
}

use IO::File;
use File::Basename;

use Bedrock::XML;
require JSON::PP;
use YAML qw/LoadFile Dump/;
use Bedrock::Dump;
use Data::Dumper;
use Scalar::Util qw/reftype/;
use Bedrock::Serializer qw/evolve devolve/;

use parent qw/Bedrock::Hash/;

# Note: 'warn' is used instead of a logging function in this module,
# since this function may be called prior to logging being configured
# - Bedrock::Config is used to get configuration information, which
# includes logging configuration thus its premature to assume logging
# is available.

sub new {
  my $class = shift;
  $class = ref($class) || $class;

  my $file = shift;
  
  $file = &_locate_file($file)
    if $file;

  my $self;

  my $this = $file;
  
  for ($this) {
    
    /\.xml$/ && do {
      $self = Bedrock::XML->new($file);

      $self->{_config_path} = $file;
      last;
    };

    /\.json$/ && do {
      local $/;
      my $json;
      
      open (my $fh, '<', $file)
        or die "could not open $file for reading";

      $json = <$fh>;
      
      close $fh;
      
      $self = JSON::PP->new->utf8->decode($json);
      $self->{_config_path} = $file;
      
      last;
    };

    /\.yaml$/ && do {

      $self = LoadFile($file);
      $self->{_config_path} = $file;
      
      last;
    };
      
    $self = {};
  }
  
  return bless $self, $class;
}

# misnamed
sub newFromXML { 
  warn "deprecated: no need to use this! use new() instead.\n";
  goto &new;
}

sub newFromString {
  my $class = shift;
  $class = ref($class) || $class;
  my $self = Bedrock::XML->newFromString(shift);

  bless $self, $class;
}

sub dbnames {
  my $self = shift;

  if ( @_ ) {
    $self->{'_dbnames'} = shift;
  }

  $self->{'_dbnames'};
}

=pod

=head2 _locate_file

 _locate_file( file )

Searches the Bedrock path hierarchy looking for the specified
configuration file. If any of the directories specfied ends with
"config" then the C<_locate> will also look in directories the
C<config.d> sub-directory.

=over 5

=item 1. $ENV{CONFIG_PATH}

=item 2. $ENV{BEDROCK_CONFIG_PATH}

=item 3. $ENV{@libdir@/bedrock/config}

=back

=cut

sub _locate_file {
  my ($self, $file) = @_;
  
  if ( ! ref($self) ) {
    $file = $self;
    undef $self;
  }
  
  my $path;
  
  if ( $file && $file =~ m!^/! ) {
    # No search for config file if filename specified with path
    $path = $file;
  }
  elsif ( $file && !-e $file ) {
    
    # search for config file in path
    my @search_paths = (@ENV{qw/CONFIG_PATH BEDROCK_CONFIG_PATH/}, '@libdir@/bedrock/config');
    @search_paths = grep { defined $_ && /./ } @search_paths;
    push @search_paths, map { /config$/ ? "$_.d" : () } @search_paths;
    
    for my $dir (@search_paths) {
      if ( -d "$dir" && -e "$dir/$file" ) {
        $path = "$dir/$file";
        last;
      }
    }
  }

  if ($path) {
    # found it but it's unreadable
    die "_locate_file: Cannot open config file $path for reading."
      if !-r $path;
  }
  else {
    die "_locate_file: Config file $file not found";
  }
  
  return $path;
}

sub merge_config {
  my ($self, $config) = @_;

  if ( $config ) {
    
    # merge source-config with master
    map { $self->{$_} = $config->{$_} if  $_ ne 'MODULES'; } keys %$config;
    
    # merge modules separately
    $self->merge_modules($config);
  }
  
  return $self;
}

sub merge_modules {
  my ($self, $config) = @_;

  # no modules in source or config
  unless ( $self->{MODULES} && @{$self->{MODULES}} ) {
    $self->{MODULES} = $config->{MODULES}
      if exists $config->{MODULES};
  }
  elsif ( exists $config->{MODULES} && @{$config->{MODULES}} ) {
    # get the binding names for existing modules as these should be
    # unique and use these to create a hash of all module configurations
    my %modules;
    map { $modules{$_->{binding}} = $_; } @{$self->{MODULES}};
    
    # possible overrwite modules from source
    map { $modules{$_->{binding}} = $_; } @{$config->{MODULES}};
    
    $self->{MODULES} = [ values %modules ];
  }

  return $self;
}

sub merge {
  my ($self, $file) = @_;

  if ( -s $file ) {
    my $config = Bedrock::XML->new($file);
    $self->merge_config($config);
  }

  return $self;
}

sub to_json {
  my ($self) = @_;

  return JSON::PP->new->utf8->pretty->encode(devolve $self);
}

sub to_yaml {
  my ($self) = @_;

  return Dump $self;
}

sub to_xml {
  my ($self) = @_;
  
  return Bedrock::XML::writeXMLString($self);
}

sub XML {
  my $self = shift;
  my $in_out = shift;

  warn ref($self) . "::XML() has been deprecated, consider using <var --xml>\n";

  die "Usage: \$config.XML('in|out', option, value, ...)"
    unless $in_out =~ /^(in|out)$/;

  die "XML config object not set in tagx.xml"
    unless $self->{XML}->{$in_out};

  if ( @_ == 1 || @_ % 2 ) {
    return $self->{XML}->{$in_out}->{ $_[0] };
  }
  else {
    my $config = $self->{XML}->{$in_out};
    my $last;
    my %options = @_;

    while ( my ( $opt, $value ) = each %options ) {
      $last = $config->{$opt};
      $config->{$opt} = $value;
    }

    return $last;
  }
}

=pod

=head2 get_module_config

 get_module_config([module-name])

Returns a startup module's configuration object or the entire array of
module configurations.

=cut

sub get_module_config {
  my ($self, $module_name) = @_;

  return $self->{MODULES}
    if ! $module_name;
  
  return undef
    if $self->{MODULES} || reftype($self->{MODULES}) ne 'ARRAY';
  
  foreach my $m (@{$self->{MODULES}}) {
    return $m->{config}
      if $m && reftype($m) eq 'HASH' && $m->{module} =~ /^$module_name$/i;
  }
  
  return undef;
}

1;

