#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Config;

# note we do not use Bedrock::Logger here since Bedroc::Config is used
# to gather config files which later are used to initialize
# logging...use carp, croak;

use strict;
use warnings;

BEGIN {

  use Carp;

  local $SIG{__DIE__} = \&Carp::confess;
}

use Bedrock qw{:booleans slurp_file};
use Bedrock::Dump;
use Bedrock::Serializer qw{ evolve devolve};
use Bedrock::XML;
use Bedrock::Constants qw{:defaults :chars};

use English qw{ -no_match_vars };
use File::Basename;
use JSON::PP qw{ decode_json encode_json };
use List::Util qw{ pairs uniq };
use Scalar::Util qw{ reftype };
use YAML qw{ LoadFile Dump };

use parent qw{ Exporter Bedrock::Hash };

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

########################################################################
sub new {
########################################################################
  my ( $class, $file ) = @_;

  $class = ref $class || $class;

  my $self = $file ? _load_config($file) : {};
  $self = bless $self, $class;

  return $self;
}

########################################################################
sub newFromXML {  ## no critic (NamingConventions::Capitalization)
########################################################################
  my ( $self, @args ) = @_;

  carp "WARN: newFromXML is deprecated: use new() instead.\n";

  return $self->new(@args);
}

########################################################################
sub newFromString {  ## no critic (NamingConventions::Capitalization)
########################################################################
  my ( $class, @args ) = @_;

  $class = ref $class || $class;

  my $self = Bedrock::XML->newFromString(@args);

  return bless $self, $class;
}

########################################################################
sub dbnames {
########################################################################
  my (@args) = @_;

  return _set_get( 'dbnames', @args );
}

########################################################################
# Usage      : get_module_config(name)
#            : get_module_config()
# Purpose    : Returns the array of modules or the configuration object
#            : a specific module.
# Parameters : name => name of a module (or fragment of the name)
# Returns    : array of modules or hash representing a configuration
#            : for the module
# Errors     : throws exception if there is no MODULES object
########################################################################
sub get_module_config {
########################################################################
  my ( $self, $module_name ) = @_;

  my $modules = $self->{MODULES};

  carp "no MODULES or MODULES is not an arra\n"
    if !is_array($modules);

  return $modules
    if !$module_name;

  my $module = $self->get_module($module_name);

  return $module ? $module->{config} : $module;
}

########################################################################
sub locate_file {
########################################################################
  goto &_locate_file;
}

########################################################################
sub merge_config {
########################################################################
  my ( $self, $config ) = @_;

  return $self
    if !$config;

  if ($config) {

    # merge source-config with master
    foreach my $key ( keys %{$config} ) {
      next if $key eq 'MODULES';

      $self->{$key} = $config->{$key};
    }

    # merge modules separately
    $self->merge_modules($config);
  }

  return $self;
}

########################################################################
sub get_module {
########################################################################
  my ( $self, $name ) = @_;

  my $modules = $self->{MODULES};

  return $modules
    if !$name;

  my ($module) = grep { $_->{module} =~ /$name$/xsmi } @{$modules};

  return $module;
}

########################################################################
sub merge {
########################################################################
  my ( $self, $file ) = @_;

  croak "no such file ($file) or empty"
    if !$file || !-s $file;

  my $config = eval { return Bedrock::XML->new($file); };

  croak "could not read $file\n$EVAL_ERROR"
    if !$config;

  croak 'invalid configuration file, root object must be hashes or arrays'
    if !ref $config;

  if ( is_array($config) ) {
    my ( $key, undef, undef ) = fileparse( $file, qr/[.][^.]+$/xsm );
    $key = uc $key;

    if ($key) {
      $config = Bedrock::Hash->new( $key => $config );
    }
  }

  return $self->merge_config($config);
}

########################################################################
sub merge_modules {
########################################################################
  my ( $self, $config ) = @_;

  my $config_modules = $config->{MODULES};
  my $modules        = $self->{MODULES};

  if ( is_array($config_modules) && @{$config_modules} ) {

    if ( is_array($modules) && @{$modules} ) {
      # use the binding names to create a merged hash of modules
      my %merged_modules = map { ( $_->{binding}, $_ ); } @{$modules};

      foreach my $m ( @{$config_modules} ) {

        if ( exists $merged_modules{ $m->{binding} } ) {
          die sprintf 'duplicate binding name for modules (%s)', $m->{binding}
            if !$m->{overwrite} || $m->{overwrite} !~ /^y/ixsm;
        }

        $merged_modules{ $m->{binding} } = $m;
      }

      $self->{MODULES} = [ values %merged_modules ];
    }
    else {
      $self->{MODULES} = $config_modules;
    }
  }

  return $self;
}

########################################################################
sub to_json {
########################################################################
  my ($self) = @_;

  return JSON::PP->new->utf8->pretty->encode( devolve $self);
}

########################################################################
sub to_yaml {
########################################################################
  my ($self) = @_;

  return Dump( devolve $self);
}

########################################################################
sub to_xml {
########################################################################
  my ($self) = @_;

  return Bedrock::XML::writeXMLString($self);
}

########################################################################
sub XML {
########################################################################
  my ( $self, @args ) = @_;

  my $in_out = shift @args;

  croak q{Usage: $config.XML('in|out', option, value, ...)}  ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
    if $in_out !~ /^in|out$/xsm;

  croak 'XML config object not set in tagx.xml'
    if !$self->{XML}->{$in_out};

  my $xml_config = $self->{XML}->{$in_out};

  # set or get values from XML config object
  my $last_value;

  if ( @args == 1 || @args % 2 ) {
    $last_value = $xml_config->{ $args[0] };
  }
  else {

    foreach my $p ( pairs @args ) {
      my ( $key, $value ) = @{$p};

      $last_value = $xml_config->{$key};

      $xml_config->{$key} = $value;
    }
  }

  return $last_value;
}

########################################################################
sub get_include_dir {
########################################################################
  my ($self) = @_;

  my @include_dir = @ENV{qw(INCLUDE_DIR BEDROCK_INCLUDE_DIR)};

  push @include_dir, @{$self}{qw(INCLUDE_DIR BEDROCK_INCLUDE_DIR)};

  push @include_dir, $DEFAULT_BEDROCK_INCLUDE_DIR;

  @include_dir = uniq grep {defined} @include_dir;

  return join $COLON, @include_dir;
}

########################################################################
sub get_pebble_dir {
########################################################################
  my ($self) = @_;

  my @pebble_dir = @ENV{qw(PEBBLE_DIR BEDROCK_PEBBLE_DIR)};

  push @pebble_dir, @{$self}{qw(PEBBLE_DIR BEDROCK_PEBBLE_DIR)};

  push @pebble_dir, $DEFAULT_BEDROCK_PEBBLE_DIR;

  @pebble_dir = uniq grep {defined} @pebble_dir;

  return join $COLON, @pebble_dir;
}

########################################################################
sub init_plugin_path {
########################################################################
  my ($self) = @_;

  return if !$self->{PLUGIN_PATH};

  # add PLUGIN_PATH to @INC
  my @plugin_inc = split /:/xsm, $self->{PLUGIN_PATH};

  foreach my $path (@plugin_inc) {
    if ( !any {/$path/xsm} @INC ) {
      push @INC, $path;
    }
  }

  return;
}

# + --------------- +
# | PRIVATE METHODS |
# + --------------- +

########################################################################
sub _set_get {
########################################################################
  my ( $key, $self, @args ) = @_;

  if (@args) {
    $self->{$key} = $args[0];
  }

  return $self->{$key};
}

########################################################################
{
  my %config_readers = (
    xml => sub {
      my ($file) = @_;

      return Bedrock::XML->new($file);
    },
    json => sub {
      my ($file) = @_;

      my $json = slurp_file $file;

      return decode_json($json);
    },

    yaml => sub {
      my ($file) = @_;

      return LoadFile($file);
    },

    yml => sub {
      my ($file) = @_;

      return LoadFile($file);
    },

  );

########################################################################
  sub _load_config {
########################################################################
    my ($file) = @_;

    $file = _locate_file($file);

    my $ext;

    if ( $file =~ /[.](xml|json|ya?ml)$/xsm ) {
      $ext = $1;
    }

    croak 'config files must have .xml, .json or .yaml extension'
      if !$ext;

    my $config = eval { return $config_readers{$ext}->($file); };

    croak "could not load $file\n$EVAL_ERROR"
      if !$config;

    $config->{_config_path} = $file;

    return $config;
  }
}

########################################################################
sub _locate_file {
########################################################################
  my ( $self, $file ) = @_;

  if ( !ref $self ) {
    $file = $self;
    undef $self;
  }

  my $path;

  # search for config files unless absolute file
  if ( $file && $file =~ m{^/}xsm ) {
    $path = $file;
  }
  elsif ( $file && !-e $file ) {

    # search for config file in path
    my @search_paths = (
      $ENV{CONFIG_PATH}, $ENV{BEDROCK_CONFIG_PATH},
      $DEFAULT_BEDROCK_CONFIG_PATH,
    );

    # remove undefined and ''
    @search_paths = map { $_ ? $_ : () } @search_paths;

    # add corresponding config.d sub-directories to search
    push @search_paths, map { /config$/xsm ? "$_.d" : () } @search_paths;

    for my $dir (@search_paths) {
      if ( -d "$dir" && -e "$dir/$file" ) {
        $path = "$dir/$file";
        last;
      }
    }
  }

  croak "_locate_file: Config file $file not found"
    if !$path;

  croak "_locate_file: Cannot open config file $path for reading."
    if !-r $path;

  return $path;
}

1;

__END__

=pod

=head1 NAME

Bedrock::Config - methods for interacting with a serialized configuration file.

=head1 SYNOPSIS

 use Bedrock::BedrockConfig;

 my $config = Bedrock::Config->new($config_file);

=head1 DESCRIPTION

The L<Bedrock::Config> object provides methods for interacting with
serialized configuration files used by Bedrock. Configuration files
can be serialized as Bedrock XML, JSON or YAML.

=head1 METHODS AND SUBROUTINES

=head2 new

 new( filename )

Reads and deserializes a serialized configuration file specified and
returns a L<Bedrock::Config> object. 

=head2 dbnames

=head2 locate_file

=head2 merge

=head2 merge_config

=head2 merge_modules

=head2 newFromString

=head2 newFromXML

=head2 to_json

 to_json(object)

=head2 to_xml

 to_xml(object)

=head2 to_yaml

 to_yaml(object)

=head2 get_module_config

 get_module_config([module-name])

Returns a startup module's configuration object or the entire array of
module configurations.

 my $session_config = $config->get_module_config

=cut

=head2 XML

 XML([in|out], key)
 XML([in|out], key, value, key, value, ...)

Get or set values from the XML configuration object. The first
parameter indicates either the XMLin or XMLout configuration.

  <!-- XML Options -->
  <object name="XML">
    <scalar name="handler">Bedrock::Serializer::XML</scalar>
    <object name="out">
      <scalar name="NoAttr">1</scalar>
      <scalar name="KeepRoot">0</scalar>
      <scalar name="RootName">response</scalar>
      <scalar name="NoSort">1</scalar>
      <array name="KeyAttr"></array>
      <scalar name="XMLDecl">1</scalar>
      <scalar name="NoEscape">1</scalar>
    </object>
    <object name="in">
      <scalar name="NoAttr">0</scalar>
      <scalar name="KeepRoot">1</scalar>
      <array name="KeyAttr"></array>
    </object>
  </object>

=head2 locate_file

 locate_file( file )
 $self->locate_file( file )

Searches the Bedrock config path hierarchy looking for the specified
configuration file. If any of the directories specfied ends with
"config" then C<locate_file> will also look in the
C<config.d> sub-directory.

=over 5

=item 1. $ENV{CONFIG_PATH}

=item 2. $ENV{BEDROCK_CONFIG_PATH}

=item 3. $ENV{@libdir@/bedrock/config}

=back

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=head1 SEE ALSO

L<Bedrock::XML>

=cut
