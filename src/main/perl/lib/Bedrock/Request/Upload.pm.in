package Bedrock::Request::Upload;

use Role::Tiny;

# Dependencies strictly for this Role
use Bedrock::Hash;
use Bedrock::Dump;
use Digest::MD5;
use File::Basename;
use File::Temp qw(tempdir);
use Crypt::CBC;
use Carp qw(croak);
use Scalar::Util qw(blessed);
use Readonly;

Readonly my $UPLOAD_BUFFER_SIZE => 4 * 1024;
Readonly my $UPLOAD_FILE_PERMS  => oct 777;

# We expect the consumer (Context) to provide these methods
requires 'request_adapter';
requires 'config';
requires 'debug';
requires 'info';
requires 'warn';

#
# The method is named 'upload_file' to maintain backward compatibility
# with your existing code calling $ctx->upload_file
#
sub upload_file {
  my ( $self, $form_var, @args ) = @_;

  # ---------------------------------------------------------
  # 1. Argument Parsing (Preserving legacy flexibility)
  # ---------------------------------------------------------
  my $options = ( ref $args[0] eq 'HASH' ) ? $args[0] : {@args};

  # ---------------------------------------------------------
  # 2. Get the Upload via the Adapter
  # ---------------------------------------------------------
  # This uses the Bedrock::Request adapter to handle mod_perl vs CGI::Tiny
  my $req    = $self->request_adapter;
  my $upload = $req->upload($form_var);

  unless ($upload) {
    # Check if it was just a missing field or empty upload
    $self->warn("upload_file: No file found for field '$form_var'");
    die "upload_file upload error: No file received";
  }

  my $fh = $upload->{fh};

  # ---------------------------------------------------------
  # 3. Logic moved from Context.pm
  # ---------------------------------------------------------
  my $md5_digest = Digest::MD5->new->addfile($fh)->hexdigest;
  $fh->seek( 0, 0 );

  my $platform = $req->param('platform') || '';

  $options->{path} //= $self->config->{UPLOAD_PATH} // tempdir( CLEANUP => 1 );

  $self->debug( 'upload_file options: ' . Bedrock::Dump::compact($options) );

  # Content-Type Validation
  $options->{'content-type'} //= $options->{'Content-type'};

  if ( $options->{'content-type'} ) {
    my $allowed_ref
      = ref $options->{'content-type'} eq 'ARRAY'
      ? $options->{'content-type'}
      : [ $options->{'content-type'} ];

    $self->debug( "upload_file acceptable content-types: " . join( ', ', @$allowed_ref ) );

    if ( !grep { $_ eq $upload->{type} } @$allowed_ref ) {
      die sprintf 'upload_file content_type error: uploading (%s), must be one of (%s)',
        $upload->{type}, join( ', ', @$allowed_ref );
    }
  }

  # Windows Path Handling (Legacy IE/Edge)
  if ( ( $platform && $platform =~ /win/i ) || $upload->{filename} =~ /^[a-z]:\\/i ) {
    fileparse_set_fstype('MSWin32');
  }
  else {
    fileparse_set_fstype('Unix');
  }

  my ( $name, $path, $ext ) = fileparse( $upload->{filename}, qr/[.][^.]*/ );

  # Prepare Directory
  if ( !-d $options->{path} ) {
    mkdir $options->{path}, $UPLOAD_FILE_PERMS
      or die "unable to create path: $options->{path}";
  }

  if ( !-w $options->{path} ) {
    die "unable to write to path: $options->{path}";
  }

  my $upload_filename = $options->{filename} || ( $name . $ext );
  my $dest_file       = "$options->{path}/$upload_filename";

  $self->info( "upload_file processing: file => [$dest_file], content-type => [" . $upload->{type} . "]" );
  $self->info( "upload_file processing: file => [$dest_file], content-type => [" . ( $upload->{type} // 'unknown' ) . "]" );
  # Size Limits
  my $maxsize = $options->{maxsize};
  if ($maxsize) {
    $maxsize *= 1024            if $maxsize =~ s/k$//i;
    $maxsize *= ( 1024 * 1024 ) if $maxsize =~ s/m$//i;
  }

  # Encryption Setup
  my $cipher;
  if ( $options->{passkey} ) {
    $options->{cipher} ||= 'Cipher::DES';
    $cipher = Crypt::CBC->new(
      -cipher      => $options->{cipher},
      -key         => $options->{passkey},
      -nodeprecate => 1,
    );
    $cipher->start('encrypting');
    $dest_file .= '.enc';
  }

  # Write File
  open my $out_fh, '>', $dest_file or die "could not open $dest_file for writing";

  my $total = 0;
  while ( my $bytes = read( $fh, my $buffer, $UPLOAD_BUFFER_SIZE ) ) {
    $total += $bytes;
    die "File size limit reached.\n" if $maxsize && $total >= $maxsize;

    print {$out_fh} ( $cipher ? $cipher->crypt($buffer) : $buffer );
  }
  print {$out_fh} $cipher->finish if $cipher;
  close $out_fh;

  return unless -s $dest_file;

  # Stats Return
  my %stats;
  my @file_info = stat $dest_file;
  @stats{qw(dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks)} = @file_info;

  return Bedrock::Hash->new(
    %stats,
    md5_digest     => $md5_digest,
    file           => $dest_file,
    $form_var      => "$name$ext",
    'content-type' => $upload->{type},
    cipher         => $options->{cipher} // '',
  );
}

1;
