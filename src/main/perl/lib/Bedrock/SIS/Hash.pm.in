#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package SIS::Hash;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use UNIVERSAL qw(isa);
use SIS::Dump;

sub FIRSTKEY	{ my $a = scalar keys %{$_[0]}; each %{$_[0]} }
sub NEXTKEY	{ each %{$_[0]} }
sub FETCH	{ $_[0]->{$_[1]} }
sub EXISTS	{ exists $_[0]->{$_[1]} }
sub STORE	{ $_[0]->{$_[1]} = $_[2] }
sub DELETE	{ delete $_[0]->{$_[1]} }
sub CLEAR	{ %{$_[0]} = () }

sub TIEHASH
{
    my $class = shift;
    my $self = bless {}, $class;
    %{$self} = @_;
    $self;
}

sub _regular_dump
{
    goto &SIS::Dump::regular;
}

sub _compact_dump
{
    goto &SIS::Dump::compact;
}

sub flatten
{
    my $self = shift;
    my $path = shift;
    my $href = shift;

    # Starter condition
    $href = {} unless defined ($href);
    $path = '' unless defined ($path);

    for my $key (keys %{$self}) {
	$href->{$path . '/' . $key} = $self->{$key};
	if ( ref ( $self->{$key} ) ) {
	    $self->{$key}->flatten ( $path . '/' . $key, $href );
	}
    }

    wantarray ? %{$href} : $href;
}

sub new
{
    my $proto = shift;
    my $class = ref ($proto) || $proto;
    my $self = bless {}, $class;
    tie %{$self}, $class, @_;
    $self;
}

#
# Function for setting a value -- advantage of using this as opposed to setting directly
# is that if value for any key is a hash, it is converted to a suitable object.
#
sub set
{
    my $self = shift;
    my %args;
    if ( @_ == 1 ) {
	%args = %{$_[0]};
    } else {
	%args = @_;
    }

    my ($key, $value);
    while (($key, $value) = each %args) {
	# Check if the value is a hash, If it is, make it a SIS::Config object
	if ( &isa( $value, 'HASH' ) ) {
	    $self->{$key} = $self->new->set( $value );
	} else {
	    # Store the value
	    $self->{$key} = $value;
	}
    }
}

#
# Method for extracting a value -- useful as the method of a subclass
#
sub get
{
    my $self = shift;
    my $key = shift;
    $self->{$key};
}

sub print
{
    my $self = shift;
    my $str = &_regular_dump( $self );
    return $str unless @_ > 0;
    open( FILE, "> $_[0]" ) or die "$self->print: Could not create $_[0]: $!";
    print FILE $str;
    close FILE;
}

sub print_compact
{
    my $self = shift;
    my $str = &_compact_dump( $self );
    return $str unless @_ > 0;
    open( FILE, "> $_[0]" ) or die "$self->print_compact: Could not create $_[0]: $!";
    print FILE $str;
    close FILE;
}

#
# Deprecated methods
#
sub value
{
    my $self = shift;
    my ($pack, $file, $line) = caller;
    warn "$self->value: Usage of deprecated method at $file($line)\n";
    if ( @_ > 0 ) {
	wantarray ? @{$self}{@_} : $self->{$_[0]};
    } else {
	keys %{$self};
    }
}

sub keys
{
    my $self = shift;
    my ($pack, $file, $line) = caller;
    warn "$self->value: Usage of deprecated method at $file($line)\n";
    keys %{$self};
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.2  2000/10/06 15:40:05  sridhar
# Foolish decision to initialize hash in new() after doing tie(). Should
# be done in TIEHASH() instead.
#
# Revision 1.1  2000/09/18 14:20:26  sridhar
# Moved some generally useful modules under Perl/SIS to Perl/Bedrock/SIS.
#
# Revision 1.3  2000/07/05 17:54:35  sridhar
# Moved out regular_dump and compact_dump to a separate module.
#
# Revision 1.2  2000/06/21 15:58:16  sridhar
# 1. Added method CLEAR() for emptying the hash
# 2. Can initialize hash at construction
# 3. Added method get() to get a value
#
# Revision 1.1  2000/06/06 19:49:18  sridhar
# Tied module for managing hashes
#
#
