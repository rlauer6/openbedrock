#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package SIS::Iterator;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $array = shift;
    my $self = bless {'array' => $array, 'cur' => 0}, $class;
    $self;
}

sub pos
{
    my $self = shift;
    $self->{'cur'} = @{$self->{'array'}} if $self->{'cur'} > @{$self->{'array'}};
    $self->{'cur'};
}

sub begin
{
    $_[0]->{'cur'} = 0;
}

sub end
{
    my $self = shift;
    $self->{'cur'} = @{$self->{'array'}};
}

sub curr
{
    my $self = shift;
    $self->{'array'}->[$self->{'cur'}];
}

sub next
{
    my $self = shift;
    $self->{'array'}->[$self->{'cur'}++];
}

sub prev
{
    my $self = shift;
    $self->{'array'}->[--$self->{'cur'}];
}

sub valid
{
    my $self = shift;
    my $cur = $self->{'cur'};
    return $cur >= 0 && $cur < @{$self->{'array'}} ? 1 : 0;
}

1;

package SIS::Array;

use strict;
use Tie::Array;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Tie::StdArray);
}

sub TIEARRAY
{
    my $class = shift;
    my $self = bless [], $class;
    push @{$self}, @_ if @_ > 0;
    $self;
}

sub new
{
    my $proto = shift;
    my $class = ref ($proto) || $proto;
    my $self = bless [], $class;
    tie @{$self}, $class, @_;
    $self;
}

sub set
{
    my $self = shift;
    my ($index, $value) = @_;
    my $old = $self->[$index];
    $self->[$index] = $value;
    $old;
}

sub get		{$_[0]->[$_[1]]}
sub length	{scalar(@{$_[0]})}
sub push	{my $a = shift; push @{$a}, @_}
sub pop		{pop @{$_[0]}}
sub shift	{shift @{$_[0]}}
sub unshift	{my $self = shift; unshift @{$self}, @_}
sub splice
{
    my $self = shift;
    my $offset = shift;
    my $length = shift;
    # Passing args to splice as splice @{$self}, @_ wouldn't work
    # Need to shift the offset and length out of the args and then invoke
    # splice() with explicit args as show below
    splice @{$self}, $offset, $length, @_;
}

sub join	{join($_[1], @{$_[0]})}
sub isEmpty	{@{$_[0]} > 0 ? 0 : 1}
sub iterator	{SIS::Iterator->new($_[0])}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.3  2001/01/16 17:49:28  sridhar
# 1. Array has an `iterator()' method which returns an iterator which
# can be used for stepping forward and back in the array.
# 2. Fixed method `splice()' -- perl's splice function requires offset
# and length to be passed explicitly and not as an array.
#
# Revision 1.2  2000/11/29 20:51:07  sridhar
# Added isEmpty() method.
#
# Revision 1.1  2000/09/18 14:20:26  sridhar
# Moved some generally useful modules under Perl/SIS to Perl/Bedrock/SIS.
#
# Revision 1.3  2000/09/11 17:44:00  sridhar
# Added methods which were formerly under BLM::Array -- specifically,
# push(), pop(), shift(), unshift(), splice() and join().
#
# Revision 1.2  2000/08/11 13:37:12  sridhar
# Added a couple of methods: set() for setting a particular array item,
# get() for fetching a particular array item, and length() for getting
# the length of the array.
#
# Revision 1.1  2000/06/06 19:37:32  sridhar
# Tied module for array manipulation
#
#
