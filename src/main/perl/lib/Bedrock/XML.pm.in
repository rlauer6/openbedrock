#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::XML;

use strict;
use IO::Scalar;
use Symbol;
use Bedrock::XML::Container::Scalar;
use Bedrock::XML::Container::Object;
use Bedrock::XML::Container::Array;

sub start_handler
{
    my $self = shift;
    my $p = shift;
    my $e = shift;
    my $obj = $self->{'obj'};
    if (lc($e) eq 'object') {
	my $newObj = Bedrock::XML::Container::Object->new( $p, @_);
	$obj = $obj ? $obj->new_object( $p, $e, $newObj ) : $newObj;
    } elsif ( lc($e) eq 'array' ) {
	my $newArray = Bedrock::XML::Container::Array->new( $p, @_);
	$obj = $obj ? $obj->new_array( $p, $e, $newArray ) : $newArray;
    } elsif ( lc($e) eq 'scalar' ) {
	$p->xpcroak( "<scalar> must be contained in <object> or <array>" ) unless $obj;
	my $newScalar = Bedrock::XML::Container::Scalar->new( $p, @_);
	$obj = $obj->new_scalar( $p, $e, $newScalar );
    } else {
	$p->xpcroak( "unsupported tag <$e> encountered" );
    }
    $self->{'obj'} = $obj;
}

sub end_handler
{
    my $self = shift;
    my $obj = $self->{'obj'};
    my $parent = $obj->end_body(@_);
    $self->{'obj'} = $parent if defined($parent);
}

sub char_handler
{
    my $self = shift;
    $self->{'obj'}->text( @_ );
}

sub final_handler
{
    my $self = shift;
    $self->{'obj'}->finalize;
}

sub unquote_xml
{
    $_[0] =~ s/&lt;/</g;
    $_[0] =~ s/&gt;/>/g;
    $_[0] =~ s/&apos;/\'/g;
    $_[0] =~ s/&quot;/\"/g;
    $_[0] =~ s/&amp;/\&/g;
    $_[0];
}

sub quote_xml
{
    $_[0] =~ s/&/&amp;/g;
    $_[0] =~ s/</&lt;/g;
    $_[0] =~ s/>/&gt;/g;
    $_[0] =~ s/\'/&apos;/g;
    $_[0] =~ s/\"/&quot;/g;
    $_[0];
}

sub split_opts
{
    my $str = shift;
    return unless length($str) > 0;
    local($_);
    $_ = $str;
    my @options;
    while ( length ) {
	s/^\s+// and next;

	unless ( s/^([\w-]+)\s*=\s*// ) {
	    die "Invalid option name at: [$_]";
	}
	push @options, $1;

	unless ( s/^(\x22([^\x22]*)\x22|\x27([^\x27]*)\x27)// ) {
	    die "Invalid option value at: [$_]";
	}
	my $value = $2;
	push @options, &unquote_xml($value);
    }
    @options;
}

sub parse
{
    my $self = shift;
    my $newscan = 1;

    my $input = $self->{'input'};
    my $optstring = '';
    my $text = '';
    my ($element);

    my $tag_start = '^(scalar|object|array)(?=\W)';
    my $tag_end   = '^(/scalar|/object|/array)>';
    my $opt_esc   = '^([^>]*)>';

  INPUT:
    while (<$input>) {
      MAIN: {

	  #
	  # Check whether we are into a new scan or collecting options
	  # for a matched tag
	  #
	  unless ( $newscan ) {

	      # Collecting options for a matched tag -- Look for tag end which is
	      # an un-escaped '>'
	      if ( s/$opt_esc//o ) {

		  # Found an un-escaped '>', which terminates the current tag and its options
		  # $optstring contains the options collected so far
		  $optstring .= $1;
		  $self->start_handler($self, $element, &split_opts($optstring));
		  $element = $optstring = '';

		  # Start a new scan after this
		  $newscan = 1;

		  # Handle possible left over stuff after the '>'
		  redo MAIN;
	      } else {

		  # No terminating '>' in entire line -- start by reading input again
		  $optstring .= $_;
		  next INPUT;
	      }
	  }

	  # New scan from here -- scan afresh for tags.
	  # if no '<' found in line, skip line
	  unless ( s/^(.*?)<//oi ) {
	      $text .= $_;
	      next INPUT;
	  }

	  # We did find a '<' -- could be we have a possible supported tag next
	  # The text before the '<' needs to be processed.
	  $text .= $1;

	  $self->char_handler( $self, $text ) if length($text);
	  $text = '';

	  # Check if we have a supported tag
	  if ( s/$tag_start//oi ) {
	      $element = $1;

	      # After creating object of suitable type depending on the tag, check
	      # if the tag ends on the same line. Tag ending is an un-escaped '>'.
	      if ( s/$opt_esc//oi ) {

		  # The tag definition ended on same line -- all options specified on
		  # one line
		  $optstring = $1;
		  $self->start_handler($self, $element, &split_opts($optstring));
		  $element = $optstring = '';

		  # And rescan the string for more tags -- Note that $newscan is unchanged
		  # from its value of 1, so we don't need to set it here
		  redo MAIN;
	      } else {

		  # Tag definition did not end on one line -- Further input is consumed for
		  # looking for the tag ending
		  $newscan = 0;

		  # Start collection of the options string
		  $optstring = $_;
	      }

	  } elsif ( s/$tag_end//oi ) {

	      # Check whether we have hit a tag-body-ending tag
	      # and if so, end the current object
	      $self->end_handler( $self );

	      # And rescan string for more tags
	      redo MAIN;
	  } elsif ( s/^!--// ) {
	      # Consume comments
	      do {
		  last if ( s/.*?-->// );
	      } while ( <$input> );
	      redo MAIN;
	  } else {

	      # Unsupported tag hit -- croak hard
	      die "What is this: <$_>\n";
	  }
      }
    }
    $self->final_handler($self);
}

sub new
{
    my $class = shift;
    my $file = shift;
    my $self = bless {}, $class;
    local(*FILE);
    open(FILE, $file) or die "Unable to open $file: $!\n";
    $self->{'input'} = *FILE;
    my $ref = $self->parse;
    close FILE;
    $ref;
}

sub newFromString
{
    my $class = shift;
    my $string = shift;
    my $self = bless {}, $class;
    my $fd = gensym;
    tie *{$fd}, 'IO::Scalar', \$string;
    $self->{'input'} = $fd;
    my $ref = $self->parse;
    $ref;
}

sub printxml
{
    my ($fd, $id, $ref, $nspaces) = @_;
    $nspaces = 0 unless defined($nspaces);
    my $spaces = ' ' x $nspaces;
    if ( &UNIVERSAL::isa($ref, 'HASH') ) {
	print $fd $spaces, qq(<object $id>\n);
	for my $key (sort keys %{$ref}) {
	    my $value = $ref->{$key};
	    &quote_xml($key);
	    if ( ref($value) ) {
		&printxml($fd, qq(name="$key"), $value, $nspaces + 1);
	    } else {
		&quote_xml($value);
		print $fd $spaces, qq( <scalar name="$key">), $value, "</scalar>\n";
	    }
	}
	print $fd $spaces, "</object>\n";
    } elsif ( &UNIVERSAL::isa($ref, 'ARRAY') ) {
	print $fd $spaces, qq(<array $id>\n);
	for my $value (@{$ref}) {
	    if ( ref($value) ) {
		&printxml($fd, '', $value, $nspaces + 2);
	    } else {
		&quote_xml($value);
		print $fd $spaces, " <scalar>", $value, "</scalar>\n";
	    }
	}
	print $fd $spaces, "</array>\n";
    } elsif ( ref($ref) ) {
	die "Invalid reference type encountered: <$ref>";
    } else {
	print $fd '';
    }
}

sub writeXML
{
    my $ref = shift;

    if ( @_ == 1 ) {
	if ( ref($_[0]) ) {
	    &printxml( $_[0], '', $ref);
	} else {
	    my $file = shift;
	    open( FILE, ">$file" ) or die "Unable to open $file: $!\n";
	    &printxml( *FILE, '', $ref);
	    close FILE;
	}
    } else {
	my $string;
	my $fd = gensym;
	tie *{$fd}, 'IO::Scalar', \$string;
	&printxml( $fd, '', $ref);
	return $string;
    }
}

sub writeXMLString
{
    my $ref = shift;
    my $string;
    my $fd = gensym;
    tie *{$fd}, 'IO::Scalar', \$string;
    &printxml( $fd, '', $ref );
    $string;
}

sub xpcroak
{
    my $self = shift;
    die "Error encountered: @_";
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.6  2010/11/29 15:57:52  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.5  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.4  2001/02/14 15:35:42  sridhar
# Added copyright and GPL notice
#
# Revision 1.3  2000/11/09 19:12:03  sridhar
# Kicked out usage of XML::Parser -- was giving SIGSEGV inside
# mod_perl. Using a limited parser based on Bedrock's parser.
#
# Revision 1.2  2000/11/07 13:51:18  sridhar
# Added methods for reading making an object from XML in string, and
# writing XML to a string.
#
# Revision 1.1  2000/11/01 18:37:44  sridhar
# Adding XML capability to Bedrock. Basically we have a class here which
# can read and write arbitrary perl data structures in XML format.
#
#
