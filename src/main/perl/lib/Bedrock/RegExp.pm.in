package Bedrock::RegExp;

use strict;
use warnings;

use version;
use English qw(-no_match_vars);

use Bedrock qw(:booleans);
use Bedrock::Constants qw(:chars :booleans);
use Data::Dumper;

use Scalar::Util qw(blessed reftype);

use Log::Log4perl;
use Log::Log4perl::Level;

use parent qw(Exporter);

our @EXPORT = (qw(regexp_compile regexp_capture_group));

sub get_logger {
  my ($self) = @_;

  if ( blessed($self) && $self->can('get_logger') ) {
    return $self->get_logger;
  }

  if ( !Log::Log4perl->initialized() ) {
    Log::Log4perl->easy_init( $ENV{DEBUG} ? $DEBUG : $ERROR );
  }

  return Log::Log4perl->get_logger;
}

########################################################################
# Usage      : regexp_capture_group
# Purpose    : returns a key/value pairs representing the matched
#            : capture groups for a regexp
# Parameters : blessed ref that can('get_logger') or none
# Returns    : hash of key/vaues
# Errors     : none
########################################################################
sub regexp_capture_group {
########################################################################
  my ($self) = @_;

  ## no critic (ProhibitPunctuationVars)

  my $logger = get_logger($self);

  # named captured group
  my %capture_group = %LAST_PAREN_MATCH;

  $logger->trace(
    sprintf "CAPTURE:\n%s\nLAST_MATCH_START:\n%s\nVERSION:\n%s",
    Dumper( \@{^CAPTURE} ),
    Dumper( \@LAST_MATCH_START ),
    $PERL_VERSION,
  );

  # create $_1, .. $_n
  # introduced after perl 5.25.7
  if ( version->parse($PERL_VERSION) >= version->parse('v5.27') ) {

    $logger->trace( 'result: ', Dumper( \@{^CAPTURE} ) );

    if ( @{^CAPTURE} ) {
      foreach ( 1 .. @{^CAPTURE} ) {
        $capture_group{ $UNDERSCORE . $_ } = ${^CAPTURE}[ $_ - 1 ];
      }
    }
  }
  else {
    if ($#+) {
      foreach ( 1 .. $#+ ) {
        ## no critic (ProhibitStringyEval, RequireInterpolationOfMetachars
        $capture_group{ $UNDERSCORE . $_ } = eval sprintf '$%d', $_;
      }
    }
  }

  $logger->trace( 'capture group: ', Dumper( \%capture_group ) );

  return \%capture_group;
}

########################################################################
# Usage      : compile_regexp(regexp|string)
# Purpose    : returns a regular expression the argument if the
#            : argument does not look like a regexp
# Parameters : a regular expression of the form qr/.../ or /.../
# Returns    : Regexp or original string if it doesn's smell like a regexp
# Errors     : throws an exception if evaluation of regexp fails
########################################################################
sub regexp_compile {
########################################################################
  my ($arg) = @_;

  return $arg
    if is_regexp($arg);

  my $regexp;

  if ( ( $arg =~ /\Aqr/xsm ) || $arg =~ /\A\/([^\/]+)\/[xsmi]?$/xsm ) {
    ## no critic (ProhibitStringyEval, RequireInterpolationOfMetachars))

    $regexp = eval { $1 ? eval q{qr/$1/} : eval $arg; };

    die "$arg doesn't look like a regular expression\n"
      if !$regexp;

    return $regexp;
  }

  return $arg;
}

1;

__END__

## no critic (RequirePodSections)

=pod

=head1 NAME

Bedrock::RegExp;

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 METHODS AND SUBROUTINES

=head1 AUTHOR

=head1 SEE OTHER

=cut
