package Bedrock::RegExp;

use strict;
use warnings;

use version;
use English qw(-no_match_vars);

use Bedrock qw(:booleans);
use Bedrock::Constants qw(:chars :booleans);
use Data::Dumper;

use Scalar::Util qw(blessed reftype);

use Log::Log4perl;
use Log::Log4perl::Level;

use parent qw(Exporter);

our @EXPORT = (qw(regexp_compile regexp_capture_group regexp_evaluate)); ## no critic

########################################################################
sub get_logger {
########################################################################
  my ($self) = @_;

  if ( blessed($self) && $self->can('get_logger') ) {
    return $self->get_logger;
  }

  if ( !Log::Log4perl->initialized() ) {
    Log::Log4perl->easy_init( $ENV{DEBUG} ? $DEBUG : $ERROR );
  }

  return Log::Log4perl->get_logger;
}

########################################################################
sub regexp_evaluate {
########################################################################
  my ( $str, $regexp, $all ) = @_;

  # BSG: Ensure the regex is compiled once before entering the loop
  my $re = regexp_compile($regexp);

  my %capture_group;

  if ($all) {
    # BSG: Perform global match and collect all capture groups
    while ( $str =~ /$re/g ) {
      my $cg = regexp_capture_group();

      foreach my $key ( keys %{$cg} ) {
        if ( exists $capture_group{$key} ) {
          # Promote to array reference if multiple matches occur
          if ( ref( $capture_group{$key} ) ne 'ARRAY' ) {
            $capture_group{$key} = [ $capture_group{$key} ];
          }

          push @{ $capture_group{$key} }, $cg->{$key};
        }
        else {
          $capture_group{$key} = $cg->{$key};
        }
      }
    }
  }
  else {
    # BSG: Single match evaluation
    if ( $str =~ $re ) {
      %capture_group = %{ regexp_capture_group() };
    }
  }

  return wantarray ? %capture_group : \%capture_group;
}

########################################################################
# Usage      : regexp_capture_group
# Purpose    : returns a key/value pairs representing the matched
#            : capture groups for a regexp
# Parameters : blessed ref that can('get_logger') or none
# Returns    : hash of key/vaues
# Errors     : none

########################################################################
sub regexp_capture_group {
########################################################################
  my ($self) = @_;

  my $logger = get_logger($self);

  # %LAST_PAREN_MATCH is the English alias for %+ (named captures)
  my %capture_group = %LAST_PAREN_MATCH;

  # BSG: Iterate through the match buffers to create _1 .. _n
  # This replaces the eval sprintf fallback for a cleaner implementation.
  if ($#+) {
    foreach my $i ( 1 .. $#+ ) {
      if ( defined $-[$i] ) {
        # Create the standard Bedrock $_1, $_2 keys
        if ( defined ${^LAST_RESUBPARSE} ) {
          $capture_group{ $UNDERSCORE . $i } = substr ${^LAST_RESUBPARSE}, $-[$i], $+[$i] - $-[$i];
        }
        # Fallback to punctuation variables if LAST_RESUBPARSE is unavailable
        $capture_group{ $UNDERSCORE . $i } //= do {
          no strict 'refs'; ## no critic
          ${$i};
        };
      }
    }
  }

  if ( $logger->is_trace ) {
    $logger->trace( 'capture group: ', Dumper( \%capture_group ) );
  }

  return \%capture_group;
}

########################################################################
sub regexp_compile {
########################################################################
  my ($arg) = @_;

  return $arg if is_regexp($arg);

  # BSG: The "Gate" - we've made it wider to support modern regexes.
  if ( $arg =~ m{\A qr }xms || $arg =~ m{\A / (.*) / ([gimsx]*) \z}xms ) {
    my $pattern  = $1 // $arg;
    my $modifier = $2 // $EMPTY;

    # BSG: The "Old School" Eval - exactly as it was, but inside our wider gate.
    my $re = eval {
      # We don't catch $@ here; we let it bubble up if it fails.
      return defined($1) ? qr/(?$modifier)$pattern/ : eval $arg; ## no critic
    };

    # If the eval failed, $@ is now populated by the Perl engine.
    die "$arg doesn't look like a regular expression\n"
      if !$re || $EVAL_ERROR;

    return $re;
  }

  return $arg;
}

1;

__END__

## no critic (RequirePodSections)

=pod

=head1 NAME

Bedrock::RegExp - support for compiling regular expressions

=head1 SYNOPSIS

 use Bedrock::RegExp;

 my $re = regexp_compile($regexp_str);

 $str =~ $re;

 my $capture_group = regexp_capture_group();

=head1 DESCRIPTION

Provides support for compiling regular expressions and retrieving the
capture group of a matched regular expression. These methods are used
by tags like C<E<lt>ifE<gt>> and C<E<lt>catchE<gt>>.

This class exports two methods - C<regexp_compile()> and C<regexp_capture_group()>.

=head1 METHODS AND SUBROUTINES

=head2 regexp_compile

 regexp_compiled(regexp)

Returns a compiled regular expression from a string or regexp that is
passed.  If a regexp is passed it simply gets returned.

A regular expression is considered anything that begins with C<qr> or
if the string matches the regular expression C</\/([^\/]+)\//>. In
other words, a string between two C</> charaters.

Throws an exception if the regular expression cannot be compiled.

=head2 regexp_capture_group

 regexp_capture_group()

Returns a hash reference to a hash of key/value pairs that represent
the matched capture groups (if any). Named capture groups are returned
in addition to the matched groups C<$1>..C<$n> which are return as the
keys C<_1>..C<_n>.

=head2 regexp_evaluate

 regexp_evaluate(str, regexp, all)

Compiles and evaluates a regular expression.  In list context returns
a hash representing the capture groups. In scalar context, returns a
hash reference.  Set C<all> to a true value to return all matches. The
returned value of each hash key will either be a scalar or possibly an
array reference if you have set the C<all> flag and there are multiple
matches.

The keys for the capture groups will contain both named capture groups
and the keys C<_1> through C<_n> representing Perl's C<$1> through
C<$n> for matches

 my $capture_groups = regexp_evaluate("foobar bar buzbaz", qr/(.z)/, 1);

 print Dumper($capture_groups);
 $VAR1 = {
           '_1' => [
                     'uz',
                     'az'
                   ]
         };

=head1 AUTHOR

Rob Lauer - rlauer6@comcast.net

=cut
