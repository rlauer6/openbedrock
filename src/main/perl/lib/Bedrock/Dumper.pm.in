package Bedrock::Dumper;

use strict;
use warnings;

use Role::Tiny;

use Bedrock qw{:booleans};
use Bedrock::Constants qw{:chars :booleans};
use Text::URLEncode qw{Htmlencode};

use English qw{-no_match_vars};
use Scalar::Util qw/reftype/;
use parent qw(Exporter);

our @EXPORT_OK = qw(dumper);

########################################################################
sub compact {
########################################################################
  my ( $ref, $prefix, $string, $encode ) = @_;

  # prefix -- what prints on a line before the current item's key and value
  $prefix //= $EMPTY;

  # What has been printed so far
  $string //= $EMPTY;

  if ( is_hash($ref) ) {

    # need to keep track of empty hashes
    my $i = 0;

    for my $key ( keys %{$ref} ) {
      my $value = $ref->{$key};

      if ( ref $value ) {

        # recursive invocation if value is a reference

        # $p is the prefix for the recursive call to compact()
        # Need to have this since we want $prefix unchanged after the
        # recursive call
        my $p = $i ? $SPACE x length $prefix : $prefix;

        # Append the key to the current item
        if ( length $p ) {
          $p .= ".$key";
        }
        else {
          $p = $key;
        }

        # And invoke compact()
        $string = compact( $value, $p, $string, $encode );
      }
      else {
        $string .= $i ? $SPACE x length $prefix : $prefix;

        if ( length $prefix ) {
          $string .= $DOT;
        }

        if ($encode) {
          $value = _Htmlencode($value);
        }

        $string .= "$key = ($value)\n";
      }

      $i++;
    }

    # Need this to mark empty hashes
    if ( !$i ) {
      $string .= "$prefix = (*** Empty Hash ***)\n";
    }
  }
  elsif ( is_array($ref) ) {

    # To keep track of empty arrays
    my $i = 0;

    for ( ; $i < @{$ref}; $i++ ) {
      my $value = $ref->[$i];

      if ( ref $value ) {

        # $p is the prefix for the recursive call to compact()
        # Need to have this since we want $prefix unchanged after the
        # recursive call
        my $p = $i ? $SPACE x length $prefix : $prefix;

        # Append current item index
        $p .= ".[$i]";

        $string = compact( $value, $p, $string, $encode );
      }
      else {
        $string .= $i ? $SPACE x length $prefix : $prefix;

        if ($encode) {
          $value = _Htmlencode($value);
        }

        $string .= ".[$i] = ($value)\n";
      }
    }

    # To mark empty arrays
    if ( !$i ) {
      $string .= "$prefix = (*** Empty Array ***)\n";
    }
  }
  else {
    if ($encode) {
      $ref = _Htmlencode($ref);
    }

    $string .= "$prefix = ($ref)\n";
  }

  return $string;
}

########################################################################
sub regular {
########################################################################
  my ( $ref, $nspaces, $string, $encode ) = @_;

  use Data::Dumper;

  $nspaces ||= 2;
  $string //= $EMPTY;

  if ( is_hash($ref) ) {
    $string .= "{\n";

    for my $key ( keys %{$ref} ) {
      my $value = $ref->{$key};

      $string .= $SPACE x $nspaces . "$key => ";

      if ( ref $value ) {
        $string = regular( $value, $nspaces + 2, $string, $encode );
      }
      else {
        if ( $encode && defined $value ) {
          $value = _Htmlencode($value);
        }

        $string .= defined $value ? "($value)\n" : "*** Undefined ***\n";
      }
    }

    $string .= $SPACE x $nspaces . "}\n";
  }
  elsif ( is_array($ref) ) {
    $string .= "[\n";

    my ( $i, $value );

    for ( $i = 0; $i < @{$ref}; $i++ ) {
      $value = $ref->[$i];

      $string .= $SPACE x $nspaces . "[$i] .. ";

      if ( ref $value ) {
        $string = &regular( $value, $nspaces + 2, $string, $encode );
      }
      else {
        if ($encode) {
          $value = _Htmlencode($value);
        }

        $value //= $EMPTY;

        $string .= "($value)\n";
      }
    }
    $string .= $SPACE x $nspaces . "]\n";
  }
  else {
    if ($encode) {
      $ref = _Htmlencode($ref);
    }

    $ref //= $EMPTY;
    $string .= "($ref)\n";
  }

  return $string;
}

########################################################################
sub _Htmlencode {
########################################################################
  my ($str) = @_;

  return Htmlencode($str);
}

########################################################################
sub _regular_dump {
########################################################################
  goto &Bedrock::Dumper::regular;
}

########################################################################
sub _compact_dump {
########################################################################
  goto &Bedrock::Dumper::compact;
}

########################################################################
sub dumper {
########################################################################
  my ( $self, %args ) = @_;

  my ( $type, $file, $encode ) = @args{qw{type file encode}};

  $type //= $EMPTY;
  $file //= $EMPTY;

  return $type ne 'compact'
    ? Bedrock::Dumper::print( $self, $file, $encode )
    : print_compact( $self, $file, $encode );
}

########################################################################
sub print {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $file, $encode ) = @_;

  my $str = regular( $self, $EMPTY, $EMPTY, $encode );

  return $file ? _print( $file, $str ) : $str;
}

########################################################################
sub print_compact {
########################################################################
  my ( $self, $file, $encode ) = @_;

  my $str = compact( $self, $EMPTY, $EMPTY, $encode );

  return $file ? _print( $file, $str ) : $str;
}

########################################################################
sub _print {
########################################################################
  my ( $file, $str ) = @_;

  open my $fh, '>', $file
    or die "Could not create $file: $OS_ERROR";

  print {$fh} $str;

  close $fh;

  return $str;
}

1;

__END__

## no critic (RequirePodSections)

=pod

=head1 NAME

Bedrock::Dumper - Bedrock's Data::Dumper

=head1 SYNOPSIS

 use Bedrock::Dumper qw(dumper);

 dumper($obj, type => 'compact', file => 'foo.out', encode => 1);

=head1 DESCRIPTION

An data dumper, ostensibly used to avoid using C<Data::Dumper>.

=head1 METHODS AND SUBROUTINES

L<Bedrock::Dumper> does not export any methods by default. Only C<dumper()> can be imported.

=head2 dumper

 dumper(object, options)

Returns a string representing a serialized version of the
object. Optionally writes the string to a file.

=over 5

=item type

One of:

 compact
 regular

default: regular

=back

=head2 print

 Bedrock::Dumper::print(object, [file, encode])

Returns the 'regular' serialized object.

=over 5

=item file

 optional name of a file to write the serialized object to

=item encode

boolean used to indicate the string should be HTML encoded

=back

=head2 print_compact

 print_compact(object, [file, encode])

Same as L</print> but object representation is a bit terser.

=head1 AUTHOR

J. Sridhar

=head1 SEE OTHER

L<Bedrock::Dump>

=cut
