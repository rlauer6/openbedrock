#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2024, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

########################################################################
package Bedrock::Exception;
########################################################################

use overload '""' => 'to_string', fallback => 1;

sub new {
  my ( $class, %args ) = @_;
  return bless \%args, $class;
}

sub message { return shift->{message} }
sub type    { return shift->{type} // 'generic' }
sub payload { return shift->{payload} }

sub to_string {
  my $self = shift;
  return $self->message;
}

# The missing method!
sub throw {
  my ($self) = @_;
  die $self;
}

########################################################################
package Bedrock::CGI;
########################################################################

use Apache::Bedrock qw(cache);
use Apache::Request::CGI;
use Bedrock qw(:booleans resolve_stream choose);
use Bedrock::Constants qw(:chars :booleans);
use Bedrock::Context;
use Bedrock::Handler;
use Carp;
use English qw(-no_match_vars);
use File::Basename;
use File::Temp qw(tempdir);
use JSON;
use List::Util qw(uniq pairs);
use Module::Load;
use Scalar::Util qw(reftype blessed);
use Text::TagX;
use Text::URLEncode qw(Htmlencode);

use Role::Tiny::With;
with 'Bedrock::Logger';

use Readonly;

Readonly::Scalar our $BOLD      => 'font-weight:800';
Readonly::Scalar our $RED       => 'color:red';
Readonly::Scalar our $FONT_SIZE => 'font-size:125%';
Readonly::Scalar our $MARGIN    => 'margin:10px';
Readonly::Scalar our $PURPLE    => 'color:purple';

Readonly::Scalar our $SERVER_ERROR           => 500;
Readonly::Scalar our $METHOD_NOT_IMPLEMENTED => 501;
Readonly::Scalar our $NOT_FOUND              => 404;
Readonly::Scalar our $BAD_REQUEST            => 400;

use parent qw(Exporter Class::Accessor);

our @EXPORT_OK = qw(
  $BOLD
  $FONT_SIZE
  $MARGIN
  $PURPLE
  $RED
  attribute
  element
  element_end
  element_start
  raise
  style
);

our %EXPORT_TAGS = ( all => [@EXPORT_OK] );

__PACKAGE__->mk_accessors(
  qw(
    autoflush
    bedrock_handler
    cache
    cgi
    config
    content_type
    content_type
    context
    cookieless
    dispatch_action
    dispatch_map
    headers
    output_buffer
    output_handle
    request
    session
  )
);

use Bedrock qw(:booleans);
########################################################################
sub new {
########################################################################
  my ( $class, %options ) = @_;

  $options{config}  = delete $options{CONFIG};
  $options{session} = delete $options{SESSION};
  $options{autoflush} //= $FALSE;
  $options{cache}     //= $TRUE;

  foreach ( keys %options ) { $options{ lc $_ } = $options{$_}; }

  my $self = $class->SUPER::new( \%options );

  # 1. Environment Detection
  my $is_web = is_web();

  my $r;

  # 2. Request Object Protection
  # In CLI mode, we must hide ARGV from Apache::Request::CGI
  # so CLI::Simple can parse the flags later.
  {
    local @ARGV = $is_web ? @ARGV : ();
    $r = Apache::Request::CGI->new( output_handle => $self->output_handle );
  }

  $self->request($r);

  my $bedrock_handler = Bedrock::Handler->new( $r, $self->cache ? ( cache => cache() ) : () );
  $self->bedrock_handler($bedrock_handler);
  $self->config( $bedrock_handler->get_config );

  # 3. Micro-MVC Routing (Web Only)
  my $route_params = $is_web && $self->dispatch_map ? $self->init_route : {};

  $self->context(
    Bedrock::Context->new(
      REQUEST_HANDLER => $r,
      CONFIG          => $self->config,
      route_params    => $route_params,
    )
  );

  $self->clear;

  $self->init_input;

  # 4. Web Initialization (Web Only)
  return $self
    if !$is_web;

  $self->init_headers;

  return $self;
}

########################################################################
sub init_route {
########################################################################
  my ($self) = @_;

  my $r = $self->request;

  require Bedrock::Router;

  my $map = $self->dispatch_map;

  my @routes;

  foreach my $p ( pairs %{$map} ) {
    my ( $pattern, $method ) = @{$p};

    push @routes, { pattern => $pattern, method => $method };

    # If a route is /snippet/:name, intuitively /snippet should also work.
    # We check if the pattern ends in /:param and auto-register the base.
    next if $pattern !~ m{^(.+)/:[^/]+$}xsm;

    my $base = $1;

    # Only add if the user didn't explicitly define it
    if ( !exists $map->{$base} ) {
      push @routes, { pattern => $base, method => $method };
    }
  }

  return
    if !$r->uri || !@routes;

  my $match = Bedrock::Router->new( { routes => \@routes } )->match( $r->uri );

  return
    if !$match;

  my ( $pattern, $method, $params ) = @{$match}{qw(pattern method params)};

  $self->dispatch_action( 'action_' . $method );

  $self->get_logger->debug( sprintf 'Bedrock::CGI matched route [%s] -> [%s]', $pattern, $method );

  return $params;
}

########################################################################
sub display_error {
########################################################################
  my ( $self, $message, $status ) = @_;

  $status //= 500;

  # Ensure the underlying request object knows the status
  if ( $self->request->can('status') ) {
    $self->request->status($status);
  }

  # EXPLICIT FIX: Force the Status header for CGI environments.
  # Without this, Apache often defaults to '200 OK' even if we output error text.
  $self->request->headers_out( 'Status', $status );

  # If we are in JSON mode (likely for an API), return JSON error
  return $self->print_json( { error => $message, status => $status } )
    if $self->content_type =~ /json/xsm;

  # Otherwise simple text
  return $self->print($message);
}

########################################################################
sub is_cli {
########################################################################
  return !$ENV{GATEWAY_INTERFACE};
}

########################################################################
sub is_web {
########################################################################
  return $ENV{GATEWAY_INTERFACE};
}

########################################################################
sub run {
########################################################################
  my ($self) = @_;

  if ( is_web() ) {
    my $result = eval { return $self->dispatch(); };

    my $err = $EVAL_ERROR;

    return $err ? $self->handle_exception($err) : $result;
  }

  require CLI::Simple;

  my $cli = CLI::Simple->new(
    option_specs => ['conf-dir=s'],
    commands     => {
      install => sub {
        my ($c) = @_;
        return $self->install( conf_dir => $c->get_conf_dir );
      },
      default => sub {
        print "Bedrock Service CLI\n";
        print "Usage: $PROGRAM_NAME [options] command\n\n";
        print "Commands:\n";
        print "  install    Generate Apache configuration\n";
        print "\nOptions:\n";
        print "  --conf-dir Directory to write configuration (default: STDOUT)\n";
        return 1;
      }
    }
  );

  return $cli->run();
}

########################################################################
sub install {
########################################################################
  my ( $self, %args ) = @_;

  # --- Convention: Service Name matches Script Name ---
  my $script_path = $PROGRAM_NAME;
  my $script_base = basename( $script_path, qw(.cgi .pl) );

  # Service Name (e.g. 'my-service')
  my $service_name = $args{service_name} // $script_base;

  # Script URL (e.g. '/cgi-bin/my-service.cgi')
  my $script_name = basename($script_path);
  my $script_url  = $args{script_url} // "/cgi-bin/$script_name";

  # --- Routing: Generate LocationMatch ---
  my $location_regex = $args{location_regex};

  if ( !$location_regex && $self->dispatch_map ) {
    my @prefixes;

    foreach my $route ( keys %{ $self->dispatch_map } ) {
      # Naive extraction of static prefix: /customer/:id -> customer
      my ($static_prefix) = split /\/:/xsm, $route;

      # Remove leading slash/empty parts
      $static_prefix =~ s{^/}{}xsm;

      next if !$static_prefix;

      push @prefixes, $static_prefix;
    }

    if (@prefixes) {
      my $union = join q{|}, uniq(@prefixes);
      $location_regex = "^/($union)";
    }
  }

  # Fallback if map didn't yield usable prefixes
  $location_regex //= "^/$service_name";

  # --- Generate Config Content ---
  my $timestamp      = scalar localtime;
  my $config_content = <<"EOT";
# Auto-generated config for $service_name
# Generated by Bedrock::CGI on $timestamp
# Script: $script_path

Action $service_name $script_url virtual

<LocationMatch "$location_regex">
  SetHandler $service_name
</LocationMatch>
EOT

  # --- Write Output ---
  my $conf_dir = $args{conf_dir};
  my $fh;

  if ($conf_dir) {
    die "Error: Configuration directory '$conf_dir' does not exist.\n"
      if !-d $conf_dir;

    my $file = "$conf_dir/$service_name.conf";
    open $fh, '>', $file or die "Cannot write to $file: $OS_ERROR\n";
    print "Installing configuration to $file... ";
  }
  else {
    # Default to STDOUT if no dir provided
    open $fh, '>&', \*STDOUT or die "Cannot dup STDOUT: $OS_ERROR";
  }

  print {$fh} $config_content;
  close $fh;

  if ($conf_dir) {
    print "Done.\n";
    print "Remember to enable: a2enconf $service_name\n";
  }

  return 1;
}

########################################################################
sub dispatch {
########################################################################
  my ($self) = @_;

  my $action = $self->dispatch_action;

  if ( !$action ) {
    # If a map was provided but no route matched, this is a 404
    if ( $self->dispatch_map ) {
      $self->log->warn( sprintf 'No route matched for URI [%s]', $self->request->uri );
      return $self->display_error( 'Not Found', 404 );
    }
    return;
  }

  return $self->$action()
    if $self->can($action);

  # Route matched, but code is missing
  $self->log->error( sprintf 'Route resolved to action [%s] but method not found in %s', $action, ref($self) );

  return $self->display_error( 'Method Not Implemented', $METHOD_NOT_IMPLEMENTED );
}

########################################################################
sub init_headers {
########################################################################
  my ($self) = @_;

  my $headers = $self->headers;

  return $self->set_content_type
    if !$headers || !ref $headers;

  my @headers = is_hash($headers) ? %{$headers} : @{$headers};
  $self->request->headers_out(@headers);

  return;
}

########################################################################
sub set_content_type {
########################################################################
  my ($self) = @_;

  my $content_type = $self->content_type;

  $content_type //= 'text/html';

  $self->content_type($content_type);

  $self->handler->headers_out( 'Content-type', $content_type );

  return $content_type;
}

########################################################################
sub config {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args == 1 && ref $args[0] ) {
    $self->set( 'config', shift @args );
  }

  my $config = $self->get('config');

  return $config
    if !@args;

  return @{$config}{@args};
}

########################################################################
sub clear {
########################################################################
  my ($self) = @_;

  return $self->output_buffer($EMPTY);
}

########################################################################
sub cgi {
########################################################################
  my ($self) = @_;

  my $cgi = $self->get('cgi');

  return $cgi
    if $cgi;

  $cgi = $self->context->cgi;

  $self->set( 'cgi', $cgi );

  return $cgi;
}

########################################################################
sub init_input {
########################################################################
  my ($self) = @_;

  # Try to load BLM::Startup::Input.
  # This is the standard Bedrock way to process inputs and route params.
  my $class = 'BLM::Startup::Input';
  eval { load $class };

  if ($EVAL_ERROR) {
    $self->get_logger->warn("Could not load $class: $EVAL_ERROR");
    return;
  }

  my $config = $self->config->get_module_config('Input');

  # Instantiate Input module. We assume it takes (Context, Config)
  # and that it automatically merges route_params from the context
  # if configured to do so.
  my $input = eval { $class->new( $self->context, $config ) };

  if ( $EVAL_ERROR || !$input ) {
    $self->get_logger->error("Failed to instantiate $class: $EVAL_ERROR");
    return;
  }

  # Replace the raw hash in context with this full object
  $self->context->input($input);

  return $input;
}

########################################################################
sub exec { warn 'deprecated - use parse()'; goto &parse; }  ## no critic

########################################################################
sub parse {
########################################################################
  my ( $self, $thing, %args ) = @_;

  # 1. Extract error strategy
  my $on_error = delete $args{on_error};

  # 2. Setup Phase
  my $fh = eval { return resolve_stream($thing); };

  if ($EVAL_ERROR) {
    # LOGIC BRANCH: If on_error is 'return', log and exit.
    if ( defined $on_error && $on_error eq 'return' ) {
      $self->log->error("Template Setup Error: $EVAL_ERROR");
      return;
    }

    # Otherwise, throw the object
    Bedrock::Exception->new(
      message => "Template Setup Error: $EVAL_ERROR",
      type    => 'template_setup',
      payload => { input => $thing }
    )->throw;
  }

  # 3. Processing Phase
  my $output = $EMPTY;

  open my $output_fh, '>', \$output
    or die "could not open scalar ref for writing\n";

  my $tx = Text::TagX->new( $fh, $output_fh );

  my $session = choose {
    return delete $args{session}
      if $args{session};

    return $self->get('session')
      if $self->get('session');

    return sub { return $self->session };
  };

  $tx->param( session => $session );

  # Auto-injection...
  $args{input}   //= $self->context->input;
  $args{config}  //= $self->context->config;
  $args{session} //= $self->context->session;
  $args{context} //= $self->context;
  $args{env} = Bedrock::Hash->new(%ENV);

  map { $tx->param( $_ => $args{$_} ) } keys %args;

  eval { $tx->output; };
  my $proc_err = $EVAL_ERROR;

  # Cleanup
  $tx->close;
  $output_fh->close;
  if ( $fh && !ref $thing ) { close $fh; }

  print {*STDERR} Dumper( [ proc_err => $proc_err, tx => $tx ] );

  if ($proc_err) {
    my $line_number;
    my $tagx_error_obj;

    # FIX: Use the accessor method ->error()
    if ( $tx->can('error') ) {
      $tagx_error_obj = $tx->error;

      # Introspect the returned TagX::Error object (array of hashrefs)
      if ( $tagx_error_obj && ref($tagx_error_obj) && @{$tagx_error_obj} ) {
        $line_number = $tagx_error_obj->[0]->{line};
      }
    }

    # 1. Update the string message so generic loggers (and check_error regex) see context
    if ( $line_number && $proc_err !~ /line/i ) {
      $proc_err .= " at line $line_number";
    }

    # 2. Build the Exception Payload with full fidelity
    my $payload = {
      input       => $thing,
      line_number => $line_number,
      tagx_error  => $tagx_error_obj,  # The full error object
    };

    # LOGIC BRANCH: Controller requests silent failure
    if ( defined $on_error && $on_error eq 'return' ) {
      $self->log->error("Template Render Error: $proc_err");
      return;
    }

    # LOGIC BRANCH: Controller provided a callback
    if ( ref($on_error) eq 'CODE' ) {
      # We can pass the Exception object to the callback!
      my $ex = Bedrock::Exception->new(
        message => $proc_err,
        type    => 'template_render',
        payload => { input => $thing }
      );
      return $on_error->($ex);
    }

    # DEFAULT: Throw up the stack
    die Bedrock::Exception->new(
      message => $proc_err,
      type    => 'template_render',
      payload => { input => $thing }
    );
  }

  return $output;
}

########################################################################
sub handle_exception {
########################################################################
  my ( $self, $err ) = @_;

  # Raw Perl Crash (string)
  return $self->display_error( "<h1>$SERVER_ERROR Internal Server Error</h1><p>Unhandled Crash:</p><pre>$err</pre>",
    $SERVER_ERROR )
    if !blessed $err;

  # Bedrock Exception
  if ( $err->type eq 'template_render' || $err->type eq 'template_setup' ) {
    # FIX: Pass the input (template source) to check_error
    my $source_input = $err->payload->{input};
    my $pretty_html  = $self->check_error( $err->message, $source_input );

    return $self->display_error( $pretty_html, $SERVER_ERROR );
  }

  return $self->display_error( $err->message, $SERVER_ERROR );
}

########################################################################
sub _handle_parse_error {
########################################################################
  my ( $self, $raw_error, $strategy ) = @_;

  # STRATEGY: 'return' (Silent failure / Controller Mode)
  # Log it, return undef, let controller handle the 500 response
  if ( defined $strategy && !ref($strategy) && $strategy eq 'return' ) {
    $self->log->error($raw_error);
    return;
  }

  # STRATEGY: Callback (Custom Logic)
  # Pass both RAW (for logging/logic) and FORMATTED (for display)
  if ( ref($strategy) eq 'CODE' ) {
    my $formatted_html = $self->check_error($raw_error);
    return $strategy->( $raw_error, $formatted_html );
  }

  # STRATEGY: Default / Legacy (POC Mode)
  # Crash loudly with the formatted HTML in a <pre> block
  my $formatted_html = $self->check_error($raw_error);
  die element( 'pre', $formatted_html );
}

########################################################################
sub check_error {
########################################################################
  my ( $self, $eval_error, $source_input ) = @_;

  return if !$eval_error;

  $self->clear;

  my $err_msg = Htmlencode($eval_error);

  # 1. Attempt to find the line number in the error message
  my $offending_line_no;
  if ( $err_msg =~ /line\s*(\d+)/xsm ) {
    $offending_line_no = $1;
  }

  # 2. If we have source input, let's load it to show context
  my @lines;
  if ( defined $source_input ) {
    # Use our helper to turn the input (file or ref) into a handle
    # We wrap in eval just in case the file is gone/unreadable
    my $fh = eval { resolve_stream($source_input) };
    if ($fh) {
      @lines = <$fh>;
    }
  }

  # 3. Format the Output Header
  # CORRECTED: Nest element_start inside element to handle attributes
  my $output = element( element_start( 'h3', style($RED) ), "Template Error" );

  $output .= element( element_start( 'pre', style( $MARGIN, $BOLD ) ), $err_msg );

  # If we couldn't load source, stop here
  return $output if !@lines;

  # 4. Generate "Fancy Line Numbers"
  for my $i ( 0 .. $#lines ) {
    my $line_num = $i + 1;
    my $code     = Htmlencode( $lines[$i] );

    # Strip trailing newline for cleaner formatting inside div
    $code =~ s/\R//;

    # Format: "  1: <code>"
    my $formatted_line = sprintf( '%4d: %s', $line_num, $code );

    # Highlight the offender
    if ( defined $offending_line_no && $line_num == $offending_line_no ) {
      # Make it BOLD and PURPLE
      # element_start returns a string, so simple concatenation works here
      my $span = element_start( 'span', style( $BOLD, $PURPLE ) );
      $formatted_line = $span . $formatted_line . element_end('span');
    }

    $lines[$i] = $formatted_line;
  }

  # Wrap the code block
  my $code_block = join( "\n", @lines );

  # CORRECTED: Nest element_start for the container div
  $output
    .= element( element_start( 'div', style("background-color:#fee; border:1px solid red; padding:10px; overflow:auto;") ),
    element( 'pre', $code_block ) );

  return $output;
}

########################################################################
sub handler { goto &request; }
########################################################################

########################################################################
sub session {
########################################################################
  my ( $self, @args ) = @_;

  # 1. OPTIMIZATION: If acting as a Setter, skip lazy-loading
  if ( @args == 1 && ref( $args[0] ) !~ /ARRAY/ ) {
    my $ref = $args[0];
    $self->set( session => $ref );
    return $ref;
  }

  # 2. Check Cache
  my $session = $self->get('session');

  # 3. Build on Demand (Lazy Load)
  if ( !$session ) {
    $session = $self->init_session();

    if ($session) {
      $self->set( 'session', $session );
      $self->context->session($session);
    }
  }

  return if !$session;

  # 4. Standard Accessor Logic
  return $session if !@args;

  # Key/Value Setter: $self->session( key => 'value' )
  return $session->{ $args[0] } = $args[1] if @args > 1;

  # Array Lookup: $self->session( ['key1', 'key2'] )
  my $ref = $args[0];
  if ( reftype($ref) eq 'ARRAY' ) {
    return @{$session}{ @{$ref} };
  }

  # Should be unreachable due to Optimization block above, but safe to keep
  return $session;
}

########################################################################
sub init_session {
########################################################################
  my ($self) = @_;

  my $session;
  my $session_manager = $ENV{BEDROCK_SESSION_MANAGER} // $self->config('BEDROCK_SESSION_MANAGER');
  $session_manager //= 'UserSession';

  my $config = $self->config->get_module_config($session_manager);

  if ($config) {
    $config->{cookieless_sessions} = $self->cookieless;

    my $class = "BLM::Startup::$session_manager";

    load $class;

    $session = $class->new( $self->context, $config );

    # REMOVED: $self->session($session);  <-- This was causing the recursion

    # Keep this, it updates the context contextually
    $self->context->session($session);
  }

  return $session;
}

########################################################################
sub print {  ## no critic
########################################################################
  my ( $self, @args ) = @_;

  if ( $self->autoflush ) {
    $self->flush_output( join $EMPTY, @args );
  }
  else {
    $self->output_buffer( join $EMPTY, @args );
  }

  return;
}

########################################################################
sub print_json {
########################################################################
  my ( $self, $data ) = @_;

  $self->request->headers_out( 'Content-type' => 'application/json' );

  return $self->print( JSON->new->encode($data) );
}

########################################################################
sub output_buffer {
########################################################################
  my ( $self, @args ) = @_;

  my $output_buffer = $self->get('output_buffer');

  return $output_buffer
    if !@args;

  $output_buffer .= $args[0];

  $self->set( output_buffer => $output_buffer );

  return $output_buffer;
}

########################################################################
sub log {  ## no critic
########################################################################
  my ( $self, $message, $level ) = @_;

  $level //= 'info';

  return $self->get_logger;
}

########################################################################
sub redirect {
########################################################################
  my ( $self, @headers ) = @_;

  $self->clear;

  return $self->cgi->redirect(@headers);
}

########################################################################
sub attribute {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  my $attribute = shift @args;

  return sprintf '%s="%s"', $attribute, join $SEMICOLON, @args;
}

########################################################################
sub style {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  return attribute( 'style', @args );
}

########################################################################
sub element_start {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  my $element = shift @args;
  my $attributes;

  if (@args) {
    $attributes = $SPACE . join $SPACE, @args;
  }

  return sprintf '<%s%s>', $element, $attributes // $EMPTY;
}

########################################################################
sub element_end {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  return sprintf '</%s>', $args[0];
}

########################################################################
sub element {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  my ( $element_start, $content ) = @args;

  $content //= $EMPTY;

  my $element;

  if ( $element_start !~ /\A</xsm ) {
    $element       = $element_start;
    $element_start = element_start($element_start);
  }
  else {
    $element = $element_start;

    # FIX: Allow digits in tag names (e.g. h1, h2, h3)
    # Was: ([[:lower:][:upper:]]+)
    $element =~ s/\A<(\w+)\s+.*\z/$1/xsm;
  }

  return sprintf '%s%s%s', $element_start, $content, element_end($element);
}

########################################################################
sub flush_output {
########################################################################
  my ( $self, $content ) = @_;

  if ( $self->handler->headers_out ) {
    $self->handler->send_http_header;
  }

  my $buffer = $self->output_buffer;

  if ( length $buffer ) {
    $self->handler->print($buffer);

    $self->clear;
  }

  # TBD: re-evaluate this...I think i wanted $content to replace $buffer?
  # otherwise why not just do this:
  #
  # $self->flush_output;
  # $self->print($content);
  # $self->flush_output;
  #
  # or is this a quick way of sending headers and content without
  # ever doing a 'print' ?

  elsif ($content) {
    $self->handler->print($content);
  }

  return;
}

########################################################################
sub raise {
########################################################################
  my (@args) = @_;

  # 1. Handle Method Invocation ($self->raise)
  # If the first argument is a Bedrock::CGI object (or subclass), shift it off.
  if ( @args && blessed( $args[0] ) && $args[0]->isa(__PACKAGE__) ) {
    shift @args;
  }

  # 2. Handle Syntactic Sugar: raise("Something went wrong", type => 'db')
  # If we have an odd number of arguments, assume the first is the message.
  if ( @args % 2 == 1 ) {
    my $message = shift @args;
    unshift @args, 'message', $message;
  }

  # 3. Instantiate and Throw
  return Bedrock::Exception->new(@args)->throw;
}

# flush output, close session
########################################################################
sub DESTROY {
########################################################################
  my ($self) = @_;

  $self->flush_output;

  if ( $self->session ) {
    $self->session->closeBLM;
  }

  return;
}

1;

__END__

=pod

=head1 NAME

Bedrock::CGI - Base class for creating hybrid Bedrock Web Services and CLI tools

=head1 SYNOPSIS

  #!/usr/bin/env perl
  
  package MyService;
  use base qw(Bedrock::CGI);
  
  # 1. Modulino Hook: Allows running as a script or loading as a class
  caller or __PACKAGE__->main();
  
  sub new {
      my ($class) = @_;
      # 2. Define Routes
      return $class->SUPER::new(
          autoflush    => 1,
          dispatch_map => {
              '/customer/:id' => 'get_customer',
              '/status'       => 'status',
          }
      );
  }
  
  # 3. Define Actions (prefixed with 'action_')
  sub action_get_customer {
      my ($self) = @_;
      
      # Unified Parameter Access (works for /customer/123 OR ?id=123)
      my $id = $self->context->param('id');
      
      $self->print_json({ id => $id, name => "Barney" });
  }

  sub main {
      # 4. Run: Detects environment (Web vs CLI) automatically
      return MyService->new->run();
  }

  1;

=head1 USAGE

=head2 Web Service

When invoked by Apache (via C<GATEWAY_INTERFACE>), the script acts as
a RESTful controller, dispatching requests based on the
C<dispatch_map>.

=head2 Command Line (CLI)

When invoked from the shell, the script acts as a management tool.

  # Generate and print Apache configuration to STDOUT
  ./my-service.cgi install

  # Install configuration to specific directory
  ./my-service.cgi install --conf-dir /etc/apache2/conf-available

=head1 DESCRIPTION

C<Bedrock::CGI> facilitates the creation of "Modulino" style web
services. These scripts are hybrid: they function as high-performance
CGI scripts when accessed via the web, but morph into powerful CLI
tools when run from the command line.

This eliminates the need for separate installation scripts,
configuration generators, or maintenance tools. The service describes
itself.

=head2 Micro-MVC Routing

Pass a C<dispatch_map> to the constructor to enable internal
routing. The map keys are URI patterns (supported by
L<Bedrock::Router>) and the values are method suffixes.

When a route matches, C<Bedrock::CGI> calls the corresponding method
prefixed with C<action_>.

=head2 Unified Parameters

When using the router, captured parameters (like C<:id>) are injected
directly into the Bedrock Context.

You should use C<context-E<gt>param()> to access inputs. This method
provides a unified view:

=over 4

=item 1. Route Parameters (e.g., C</user/:id>) - I<Highest Priority>

=item 2. Standard CGI Parameters (e.g., C<?sort=desc> or POST body)

=back

=head1 METHODS

=head2 new

 new( %options )

Constructor.

=over 4

=item * B<dispatch_map>: Hash reference mapping URI patterns to method suffixes.

=item * B<autoflush>: Boolean (default 0). If true, prints output immediately.

=item * B<cache>: Boolean (default 1). Enables Bedrock caching.

=back

=head2 run

 run()

The main entry point. It detects the execution environment:

=over 4

=item * B<Web Mode>: If C<GATEWAY_INTERFACE> is detected, it initializes the session, headers, and calls C<dispatch()>.

=item * B<CLI Mode>: If running in a shell, it lazy-loads L<CLI::Simple> and processes command-line arguments (like C<install>).

=back

=head2 install

 install( %args )

Generates an Apache 2.4 configuration file for this service.

By default, this derives the B<Service Name> from the script filename (e.g., C<user-service.cgi> becomes C<user-service>) and generates a C<LocationMatch> directive based on your C<dispatch_map>.

B<CLI Options:>

=over 4

=item * B<--conf-dir>: Directory to write the configuration file. If omitted, writes to STDOUT.

=back

=head2 dispatch

 dispatch()

Evaluates the current URI against the C<dispatch_map>. If a match is found, executes the corresponding C<action_*> method. Returns 404 if no route matches, or 501 if the method is missing.

=head2 print_json

 print_json( $data )

Sets the C<Content-Type> header to C<application/json> and prints the data structure as a JSON string.

=head2 context

Returns the L<Bedrock::Context> object. Use this to access C<param()>, C<config()>, and database handles.

=head2 cgi

Returns the underlying C<Bedrock::Request> adapter.

=head2 parse

 parse( $template, %vars )

Processes a Bedrock template snippet with the provided variables.

B<Error Handling:>

By default, parsing errors (syntax, missing tags) throw a L<Bedrock::Exception> object, which is caught by C<run()> to display a formatted error page.

You can alter this behavior by passing an C<on_error> argument:

  # 1. Silent Mode: Log error and return undef
  $self->parse( $tpl, on_error => 'return' );

  # 2. Callback Mode: Handle the exception object manually
  $self->parse( $tpl, on_error => sub {
      my ($e) = @_;
      warn "Template failed: " . $e->message;
      return "Default Content";
  });

=head2 redirect

 redirect( $url )

Sends an HTTP redirect header.

=head1 NAMING CONVENTIONS

To ensure the auto-installation works correctly, follow these conventions:

=over 4

=item 1. Name your script file in kebab-case (e.g., C<customer-lookup.cgi>).

=item 2. The derived Service Name will be C<customer-lookup>.

=item 3. The generated config will use C<SetHandler customer-lookup>.

=back

=head1 DEPLOYMENT

Because the service handles its own configuration, deployment is trivial.
Here is a complete Dockerfile for a C<Bedrock::CGI> microservice:

  FROM bedrock-debian
  
  # Copy & Install Service
  COPY customer-service.cgi /usr/lib/cgi-bin/customer-service.cgi
  RUN /usr/lib/cgi-bin/customer-service.cgi install --conf-dir /etc/apache2/conf-available
  RUN a2enconf customer-service

=head1 RELATIONSHIP TO APACHE::BEDROCK

The primary distinction between C<Apache::Bedrock> and C<Bedrock::CGI>
is the entry point of the application.

C<Apache::Bedrock> is **Template-First**. It treats the URL as a path
to a document (e.g., C<index.html>). The Bedrock engine parses that
file, executing any logic tags embedded within it. This is excellent
for content-heavy sites but can lead to "logic creep," where complex
business rules get awkwardly stuffed into HTML tags.

C<Bedrock::CGI> is **Code-First**. It treats the URL as a path to a
program (e.g., C<service.cgi>). The script runs first, executing your
Perl methods to handle input, authentication, and database queries. It
only touches the template engine when you explicitly call C<parse()>.

=head2 The Balancing Act

Web development often swings between two extremes of "Doing It Wrong":

=over 4

=item * Writing complex Perl logic inside HTML templates.

=item * Burying chunks of HTML markup inside Perl strings.

=back

C<Bedrock::CGI> provides the tooling to strike the correct balance. It
encourages a clean separation of concerns: use the C<action_> methods
for your logic, and use the C<parse()> method to inject that data into
clean, logic-free Bedrock templates. This allows you to leverage Perl
for what it does best (processing) and Bedrock for what it does best
(presentation).

=head1 A GENTLE COMPARISON

How does C<Bedrock::CGI> fit into the landscape of web tools?

=head2 vs. PHP

PHP conquered the web by making deployment trivial: just upload a file
and it runs. C<Bedrock::CGI> adopts this ease of deployment - there are
no app servers to restart or complex PSGI stacks to configure - but it
rejects the PHP habit of intermingling database cursors with HTL
tags. It offers the "copy-and-paste" simplicity of PHP with the
structural discipline of Perl.

=head2 vs. HTML::Mason

Mason is the spiritual sibling of C<Apache::Bedrock> - both are
powerful "Template-First" systems. However, Mason provides a complex
inheritance model (autohandlers, dhandlers, method modifiers) that
often acts as a "foot-gun" for maintenance. It is all too easy to
build applications where business logic is smeared across a chaotic
mix of F<.mas> components, F<.html> endpoints, and Perl modules,
creating a "Big Ball of Mud" that is nearly impossible to debug.

C<Bedrock::CGI> takes a different stance: B<Restrictions define
structure.> By forcing a clear separation between the Controller (the
CGI script) and the View (the Template), it prevents the "Spaghetti
Code" architectures that legacy Mason apps are infamous for.

=head2 vs. Template::Toolkit

Template::Toolkit (TT) is the industry standard for strict separation
of concerns in Perl. However, TT usually requires a heavy external
framework to drive it. C<Bedrock::CGI> occupies a "middle ground": it
enforces the same separation of logic and view as TT, but it comes as
a self-contained, lightweight Modulino. You get the MVC separation
without the boilerplate.

=head2 vs. Dancer

Dancer is a fantastic micro-framework that relies on a DSL (Domain
Specific Language) to define routes and logic. It is elegant, but it
introduces a layer of syntax "magic" that can obscure what is actually
happening. C<Bedrock::CGI> eschews DSLs in favor of standard Perl
Object-Oriented design. If you know how to write a Perl method, you
know how to write a Bedrock action. Furthermore, C<Bedrock::CGI> runs
natively under Apache without needing a separate PSGI application
server (like Starman) to manage.

=head2 vs. Mojolicious

Mojolicious is a "Batteries Included" framework in the literal sense:
it includes its own non-blocking web server, WebSocket implementation,
and event loop. It is designed to run standalone. C<Bedrock::CGI> is
designed to integrate. It assumes you already have a robust web server
(Apache) and provides the rich application layer - templating, database
abstraction, sessions, and caching - to run on top of it. If you need a
standalone chat server, use Mojolicious. If you need a powerful
business application engine that integrates seamlessly with your
existing Apache infrastructure, use C<Bedrock::CGI>.

=head1 AUTHOR

Rob Lauer - <bigfoot@cpan.org>

=head1 SEE ALSO

L<Bedrock::Context>, L<CLI::Simple>, L<Bedrock::Router>

=cut
