package Bedrock::Handler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2025, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock qw(choose);
use Bedrock::Apache::Constants qw(:http);
use Bedrock::BedrockConfig;
use Bedrock::Constants qw(:chars :defaults :booleans);
use Bedrock::Context;
use Carp qw(confess croak carp);
use Cwd qw(realpath fastcwd);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(fileparse);
use File::Find;
use Scalar::Util qw(reftype);
use List::Util qw( any uniq);
use Symbol;

our @EXPORT_OK = qw(
  bind_blm_module
  bind_module
  get_blm_config
  mlogger
  mlogger_debug
  mlogger_info
  mlogger_warn
  mlogger_trace
  mlogger_notice
  mlogger_error
  require_module
);

our %EXPORT_TAGS = (
  all     => [@EXPORT_OK],
  mlogger => [
    qw(
      mlogger_debug
      mlogger_trace
      mlogger_info
      mlogger_warn
      mlogger_notice
      mlogger_error
    )
  ],
  bind => [
    qw(
      bind_blm_module
      bind_module
    )
  ]
);

__PACKAGE__->mk_accessors(
  qw(
    benchmark
    benchmarking_enabled
    cache
    config
    file
    filename
    path
    pwd
    request
    uri_dir
    uri_name
  )
);

use parent qw( Exporter Class::Accessor);

our $VERSION = '@PACKAGE_VERSION@';  ## no critic

########################################################################
sub log_benchmark {
########################################################################
  my ( $self, $message, $elapsed ) = @_;

  return
    if !$self->benchmarking_enabled;

  my ( $t0, $t1, $t2 ) = ( @{ $self->benchmark }, Benchmark->new );

  mlogger_notice( $self->request, sprintf '(BENCHMARK) %s: %s', $message, timestr( timediff( $t2, $t1 ), 'all' ) );

  if ($elapsed) {
    mlogger_notice( $self->request, '(BENCHMARK) Elapsed time: %s', timestr( timediff( $t2, $t0 ) ) );
  }

  $self->benchmark->[1] = $t2;

  return;
}

########################################################################
sub new {
########################################################################
  my ( $class, $r, %options ) = @_;

  $options{bedrock_config_path} = $ENV{BEDROCK_CONFIG_PATH} //= $DEFAULT_BEDROCK_CONFIG_PATH;

  @options{qw(pwd request)} = ( fastcwd(), $r );

  my $self = $class->SUPER::new( \%options );

  $self->init_benchmarking;

  $self->init_request;

  my $config = eval { return $self->load_config };

  # sometimes one or more configuration files are malformed, helpful
  # to know how far we got loading the configuration files
  if ( !$config || $EVAL_ERROR ) {
    my $error = $EVAL_ERROR;

    mlogger_error( $r, 'error loading configuration files: %s', $error );
    mlogger_error( $r, 'processed the following files: %s',     Dumper( [ $self->config_files_processed ] ) );

    croak $error;
  }
  else {
    mlogger_debug( $r, 'processed the following files: %s', Dumper( [ $self->config_files_processed ] ) );
  }

  $self->log_benchmark('config load time');

  return $self;
}

########################################################################
sub init_benchmarking {
########################################################################
  my ($self) = @_;

  my $benchmarking = $self->benchmarking_enabled;

  return
    if !$benchmarking;

  my ($enabled) = $benchmarking =~ /^(enabled|on|yes|1)$/xsmi ? 1 : 0;
  $self->benchmarking_enabled($enabled);

  return
    if !$enabled;

  require Benchmark;

  Benchmark->import(qw(:all timediff timestr :hireswallclock));
  my $t0 = Benchmark->new;
  $self->benchmark( [ $t0, $t0 ] );

  return;
}

########################################################################
sub cache_enabled {
########################################################################
  my ($self) = @_;

  return $self->cache ? $TRUE : $FALSE;
}

########################################################################
sub init_request {
########################################################################
  my ($self) = @_;

  my $r = $self->request;

  # * under 'mod_perl' naked directory requests are passed along prior to
  #   file checking.  Thus the content_type is directory
  #
  # * under 'mod_cgi' those same requests come through via the "virtual"
  #   modifier on the Action directive:
  #
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual

  $self->file($EMPTY);

  if ( $r->content_type && $r->content_type =~ /directory/xsm ) {
    $ENV{PATH_TRANSLATED} = $r->filename;
    $r->content_type('text/html');
  }

  $self->file( $r->filename );

  # Parse for the URI components
  if ( $r->uri ) {
    my ( $uri_name, $uri_dir ) = fileparse( $r->uri );
    $self->uri_name($uri_name);
    $self->uri_dir($uri_dir);
  }

  if ( $r->filename ) {
    my ( $filename, $path ) = fileparse( $r->filename );
    $self->filename($filename);
    $self->path($path);
  }

  {
    no warnings 'uninitialized';  ## no critic ProhibitNoWarnings

    if ( $ENV{BEDROCK_DUMP_ENV} ) {
      foreach ( keys %ENV ) {
        mlogger_debug( $r, 'ENV{%s} => %s', $_, $ENV{$_} );
      }
    }

    mlogger_debug( $r, 'BEDROCK_CONFIG_PATH.....[%s]', $ENV{BEDROCK_CONFIG_PATH} // $EMPTY );
    mlogger_debug( $r, 'CONFIG_PATH.............[%s]', $ENV{CONFIG_PATH}         // $EMPTY );
    mlogger_debug( $r, 'CONTENT TYPE............[%s]', $r->content_type          // $EMPTY );
    mlogger_debug( $r, 'Cookie..................[%s]', $r->headers_in->{Cookie}  // $EMPTY );
    mlogger_debug( $r, 'HTTP_COOKIE.............[%s]', $ENV{HTTP_COOKIE}         // $EMPTY );
    mlogger_debug( $r, 'PATH_INFO...............[%s]', $ENV{PATH_INFO}           // $EMPTY );
    mlogger_debug( $r, 'PATH_TRANSLATED.........[%s]', $ENV{PATH_TRANSLATED}     // $EMPTY );
    mlogger_debug( $r, 'SCRIPT_NAME.............[%s]', $ENV{SCRIPT_NAME}         // $EMPTY );
    mlogger_debug( $r, 'URI.....................[%s]', $r->uri                   // $EMPTY );
    mlogger_debug( $r, 'URI_DIR.................[%s]', $self->uri_dir            // $EMPTY );
    mlogger_debug( $r, 'URI_NAME................[%s]', $self->uri_name           // $EMPTY );
    mlogger_debug( $r, 'filename................[%s]', $self->filename           // $EMPTY );
    mlogger_debug( $r, 'mod_perl................[%s]', $ENV{MOD_PERL}            // $EMPTY );
    mlogger_debug( $r, 'path....................[%s]', $self->path               // $EMPTY );
    mlogger_debug( $r, 'request file............[%s]', $self->file               // $EMPTY );
  }

  return $self;
}

########################################################################
# full_path( path, filename, default-extension)
# returns a formatted fully qualifed pathname with a default extension
########################################################################
sub full_path {
########################################################################
  my ( $path, $name, $default_ext ) = @_;

  my $ext;

  $name //= q{};
  $path //= q{};

  ( $name, $path, $ext ) = fileparse( "$path/$name", qr/[.][^.]+$/xsm );

  return sprintf '%s%s%s', $path, $name, ( $ext || $default_ext );
}

########################################################################
# read_config(path, file)
# returns a Bedrock::Config object
########################################################################
sub read_config {
########################################################################
  my ( $self, $path, $filename ) = @_;

  my $full_path = choose {
    return $path
      if $path =~ /[.]xml$/xsm;

    return full_path( $path, $filename, '.xml' );
  };

  return
    if !$full_path;

  my $r = $self->request;

  my $config = eval { return Bedrock::Config->new($full_path); };

  if ( !$config || $EVAL_ERROR ) {

    mlogger_warn(
      $r,
      sprintf 'error reading config: %s',
      Dumper(
        [ full_path => $full_path,
          error     => $EVAL_ERROR,
          os_error  => $OS_ERROR
        ]
      )
    );
  }
  else {
    $r->log->debug("successfully read $full_path");
    $self->config_files_processed($full_path);
  }

  return $config;
}

########################################################################
sub fetch_blm_config {
########################################################################
  my ( $self, $blm_config, @paths ) = @_;

  if ( $blm_config !~ /[.]xml$/xsm ) {
    $blm_config .= '.xml';
  }

  my $config = $self->get_config;

  if ( !@paths ) {
    push @paths, $self->get_config_paths;
  }

  push @paths, $self->get_module_paths( paths => \@paths );

  my ($filename) = grep { -e $_ } map { sprintf '%s/%s', $_, $blm_config } @paths;

  die "$blm_config does not exist\n"
    if !$filename || !-e $filename;

  push @{ $config->{MODULES} }, Bedrock::XML->new($filename);

  return $config;
}

########################################################################
sub is_mod_perl {
########################################################################
  return $ENV{MOD_PERL};
}

########################################################################
sub request_handler { carp "method is deprecated. use request()\n"; goto &request; }
sub apache_handler  { carp "method is deprecated. use request()\n"; goto &request; }
########################################################################

########################################################################
sub _log {
########################################################################
  my ( $self, $message, $level ) = @_;

  my $depth = 0;
  my @stack;

  while ( my @frame = caller( $depth++ ) ) {
    push @stack, \@frame;
  }

  my $frame;

  while ( $frame = pop @stack ) {
    last if $frame->[3] !~ /eval/xsm;
  }

  my $r = $self->request;

  my $log_message = sprintf '%s[%s]: %s', $frame->[3], $frame->[2], $message;

  return $r->log->$level($log_message);
}

########################################################################
sub log_info  { return _log( @_, 'info' ) }
sub log_error { return _log( @_, 'error' ) }
sub log_warn  { return _log( @_, 'warn' ) }
sub log_debug { return _log( @_, 'debug' ) }
########################################################################

########################################################################
sub load_config_from_cache {
########################################################################
  my ($self) = @_;

  my $cache = $self->cache;
  return
    if !$cache;

  my $key = $ENV{SERVER_NAME} // $PROGRAM_NAME;  # for test t/00-cache.t

  my $r = $self->request;

  # Retrieve from injected cache
  my $cached_config = $cache->get($key);

  my $config = choose {
    return $cached_config
      if $cached_config;

    return $self->get_bedrock_config($r);
  };

  if ($config) {
    $config->{BEDROCK_CACHE_TIMESTAMP} //= scalar localtime;
  }

  my $config_files_processed = $cached_config ? $cached_config->{_config_files_processed} : $self->{_config_files_processed};

  if ( !$cached_config || !%{$cached_config} ) {
    $config->{_config_files_processed} = $config_files_processed;

    # Store in injected cache
    $cache->set( $key, $config );

    delete $config->{_config_files_processed};
  }

  if ( !$cached_config ) {
    $self->merge_tagx_apps_configs( config => $config );
  }

  if ($cached_config) {
    $self->{_config_files_processed} = [ $self->config_files_processed, @{$config_files_processed} ];
    delete $config->{_config_files_processed};
  }

  return $config;
}

########################################################################
sub load_config {
########################################################################
  my ($self) = @_;

  my $config = $self->config;

  return $config
    if $config;

  if ( $self->cache_enabled ) {
    $config = $self->load_config_from_cache;
  }
  else {
    $config = $self->get_bedrock_config;
  }

  return $self->config($config);
}

########################################################################
sub get_config { goto &load_config; }
########################################################################

# config(object) set config object
# config(key)    return specified key from config object
# config()       return config object
########################################################################
sub config {
########################################################################
  my ( $self, @args ) = @_;

  if ( $args[0] && ref $args[0] ) {
    $self->set( 'config', $args[0] );
  }
  elsif ( $args[0] ) {
    return $self->get('config')->{ $args[0] };
  }

  return $self->get('config');
}

########################################################################
sub get_uri_dir { return shift->uri_dir; }
########################################################################

########################################################################
sub restore_dir {
########################################################################
  my ($self) = @_;

  if ( $self->pwd() ) {
    chdir $self->pwd();
  }

  return $self->pwd();
}

########################################################################
sub get_bedrock_admin_dir {
########################################################################
  my ($self) = @_;

  return $self->config('BEDROCK_ADMIN_DIR') || '/bedrock';
}

########################################################################
sub error {
########################################################################
  my ( $self, $err_msg, $code ) = @_;

  my $r = $self->request;

  $code //= $SERVER_ERROR;

  $r->log->error($err_msg);

  $self->restore_dir;

  return $code;
}

########################################################################
sub read_data_sources {
########################################################################
  my ( $self, @paths ) = @_;

  $self->request->log->debug( sprintf 'looking for data sources in: %s', join $COMMA, @paths );

  # look for data-sources.(xml|yml|json) which define database connection strings
  my $data_source_config = Bedrock::Config->new;

  foreach my $p ( map { sprintf '%s/data-sources', $_ } @paths ) {
    foreach my $ext (qw(xml json yml yaml)) {
      my $data_sources = sprintf '%s.%s', $p, $ext;
      next if !-e $data_source_config;

      my $config = $data_source_config->fetch_config($data_sources);
      next if !$config;
      $data_source_config->merge_config($config);

      $self->config_files_processed($data_sources);
    }
  }

  return $data_source_config;
}

########################################################################
sub get_bedrock_config_path {
########################################################################
  my ( $self, $r ) = @_;

  $r //= $self->request;

  my $bedrock_config_path = $ENV{BEDROCK_CONFIG_PATH} // $EMPTY;

  if ($bedrock_config_path) {
    $bedrock_config_path = realpath($bedrock_config_path) // $EMPTY;

    if ( !$bedrock_config_path ) {
      mlogger_error( $r, 'invalid BEDROCK_CONFIG_PATH %s', $ENV{BEDROCK_CONFIG_PATH} );
    }
  }
  else {
    mlogger( $r, 'No BEDROCK_CONFIG_PATH found. You probably have a misconfigured system.' );
  }

  return $bedrock_config_path;
}

########################################################################
# Module paths are paths under config.d or if you have specfied a
# different CONFIG_PATH like `/usr/src/app/config`, then the module
# path would be `/usr/src/app/config.d`. There you would add your
# application plugin configurations in the `plugins` or `startup`
# directories.
########################################################################
sub get_module_paths {
########################################################################
  my ( $self, %args ) = @_;

  my @paths = @{ $args{paths} };

  # -- look for module configs
  my @module_paths;

  ######################################################################
  # NOTE: The order is important here (startup, plugin) - we want
  # local configurations (plugins) to override system configurations
  # (startup).
  ######################################################################

  foreach my $p (@paths) {

    foreach my $dir (qw(startup plugin)) {
      next if $p !~ /[.]d$/xsm || !-d "$p/$dir";

      push @module_paths, "$p/$dir";
    }
  }

  return @module_paths;
}

########################################################################
sub get_blm_config {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj};

  return $self->{config};
}

########################################################################
sub bind_blm_module {
########################################################################
  my ( $self, $blm_name ) = @_;

  my $config = $self->get_config;

  my $module_config = $config->get_module_config($blm_name);

  die "could not find config for $blm_name\n"
    if !$module_config;

  my $context = Bedrock::Context->new(
    REQUEST => $self->request,
    CONFIG  => $config,
  );

  return bind_module(
    config  => $module_config,
    module  => $blm_name,
    context => $context,
  );
}

########################################################################
sub merge_module_configs {
########################################################################
  my ( $self, %args ) = @_;

  my $r = $self->request;
  my ( $config, $module_paths ) = @args{qw(config module_paths)};

  mlogger_debug( $r, Dumper( [ module_paths => $module_paths ] ) );

  foreach my $path ( @{$module_paths} ) {

    my @config_files = _list_files(
      path => $path,
      type => qr/[.](xml|ya?ml|json)$/xsmi,
    );

    foreach my $file (@config_files) {
      $r->log->debug( sprintf 'Found a potential module configuration file: [%s]', $file );

      $r->log->debug( sprintf 'Merging [%s]', $file );

      $config = eval {
        my $module_config = Bedrock::Config->new($file);

        my ( $module_name, $binding ) = @{$module_config}{qw(module binding)};

        if ( !$module_name || !$binding ) {
          mlogger_info( $r, 'skipping %s - no binding or name in configuration: %s', $file, Dumper($module_config) );
        }
        else {
          $config->merge_modules( { MODULES => [$module_config] } );
        }

        return $config;
      };

      die "error processing $file\n$EVAL_ERROR\n"
        if !$config || $EVAL_ERROR;

      $self->config_files_processed($file);
    }
  }

  return;
}

########################################################################
sub require_module {
########################################################################
  my ($modfile) = @_;

  $modfile =~ s/::/\//xsmg;

  if ( $modfile !~ /[.]pm\z/xsm ) {
    $modfile =~ s/\z/\.pm/xsm;
  }

  return require $modfile;
}

########################################################################
sub bind_module {
########################################################################
  my (%args) = @_;

  my ( $module, $context, $config, $tagx ) = @args{qw(module context config tagx)};
  $args{type} //= 'hash';

  my $type = $args{type} eq 'object' ? 'hash' : $args{type};

  require_module $module;

  my $obj;

  ## no critic
  my %tie_subs = (
    hash => sub {
      $obj = bless {}, $module;
      return tie %{$obj}, $module, $context, $config, $tagx;
    },
    array => sub {
      $obj = bless [], $module;
      return tie @{$obj}, $module, $context, $config, $tagx;
    },
    handle => sub {
      $obj = bless gensym, $module;
      return tie *{$obj}, $module, $context, $config, $tagx;
    },
  );

  my $func = $tie_subs{$type}->();

  if ( $func->can('init_plugin') ) {
    $func->init_plugin( $args{context}, $args{config} );
  }

  return $obj;
}

########################################################################
sub merge_user_configs {
########################################################################
  my ( $self, %args ) = @_;

  my $r = $self->request;

  my ( $paths, $config ) = @args{qw(paths config)};

  my @files_processed = $self->config_files_processed;

  foreach my $path ( @{$paths} ) {
    $r->log->debug( sprintf 'Searching [%s] for config files', $path );

    my @config_files = _list_files(
      path   => $path,
      type   => qr/[.](xml|ya?ml|json)$/xsmi,
      filter => [qw(tagx.xml tagx_apps.xml)]
    );

    foreach my $file (@config_files) {
      if ( any { $file =~ /$_/xsm } @files_processed ) {
        $r->log->debug( sprintf 'skipping [%s]...already processed', $file );
        next;
      }

      $r->log->debug( sprintf 'attempting to merge...[%s]', $file );

      my $rv = eval { $config->merge($file); };

      if ( !$rv || $EVAL_ERROR ) {
        $r->log->warn($EVAL_ERROR);
        $r->log->warn( sprintf 'ERROR: could not merge: [%s]', $file );
        next;
      }

      $self->config_files_processed($file);
    }
  }

  return;
}

########################################################################
sub get_config_paths {
########################################################################
  my ( $self, %args ) = @_;

  my ( $bedrock_config_path, $r ) = @args{qw(bedrock_config_path r)};

  $bedrock_config_path //= $self->get_bedrock_config_path($r);

  $r //= $self->request;

  my @config_paths;

  if ( $ENV{CONFIG_PATH} ) {

    if ( $ENV{CONFIG_PATH} =~ /^:/xsm ) {
      @config_paths = $bedrock_config_path;
    }

    @config_paths = ( @config_paths, split /[:]/xsm, $ENV{CONFIG_PATH} );

    @config_paths = uniq map { realpath($_) } grep { $_ && -d $_ } @config_paths;
  }
  elsif ($bedrock_config_path) {
    push @config_paths, $bedrock_config_path;
    $r->log->info( sprintf 'No application CONFIG_PATH found. Using BEDROCK_CONFIG_PATH:[%s]', $bedrock_config_path );
  }
  else {
    $r->log->error('No CONFIG_PATH or BEDROCK_CONFIG_PATH. You probably have a misconfigured system.');
  }

  return @config_paths;
}

# Poorly name method for creating the global config
########################################################################
sub get_bedrock_config {
########################################################################
  my ( $self, $r ) = @_;

  $r //= $self->request;

  my $bedrock_config_path = $self->get_bedrock_config_path // $EMPTY;

  my @config_paths = $self->get_config_paths( bedrock_config_path => $bedrock_config_path );

  # this potentially adds .d sub-directories
  my @paths = Bedrock::Config::validate_config_paths( @config_paths, $bedrock_config_path );

  mlogger_debug( $r, 'paths: %s', join $COMMA, @paths );

  my $config = $self->get_tagx_config( bedrock_config_path => $bedrock_config_path, config_paths => \@config_paths, );

  if ( !$config || !keys %{$config} ) {
    my $error = <<'END_OF_MESSAGE';
ERROR: No or empty 'tagx.xml'
  BEDROCK_CONFIG_PATH => [%s]
  CONFIG_PATH         => [%s]
END_OF_MESSAGE

    my $err = sprintf $error, $bedrock_config_path, ( join $SEMICOLON, @config_paths ) // $EMPTY;
    croak $err;
  }

  my $dbnames = $self->read_data_sources(@paths);
  $config->dbnames($dbnames);  # yet another poorly name method!

  # -- look for module configs
  mlogger_debug(
    $r,
    Dumper(
      [ paths        => \@paths,
        config_paths => \@config_paths
      ]
    )
  );

  my @module_paths = $self->get_module_paths( paths => \@paths );

  mlogger_debug( $r, Dumper( [ \@module_paths ] ) );

  $self->merge_module_configs(
    config       => $config,
    module_paths => \@module_paths,
  );

  # -- extra configs
  $self->merge_user_configs( config => $config, paths => \@paths );

  # -- not sure why we ever needed this line
  $config->{CONFIG_PATH} = join $SEMICOLON, grep {defined} @config_paths;

  # override use of BEDROCK_IMAGE_URL if app defines own
  if ( $config->{IMAGE_URL} ) {
    $config->{BEDROCK_IMAGE_URL} = $config->{IMAGE_URL};
  }

  # And voila! we have the merged config
  return $config;
}

########################################################################
sub get_tagx_config {
########################################################################
  my ( $self, %args ) = @_;

  my $r = $self->request;

  ######################################################################
  # $bedrock_config_path  => Bedrock's default configuration
  # $config_paths         => array of paths where we might find `tagx.xml`
  ######################################################################

  my ( $bedrock_config_path, $config_paths ) = @args{qw(bedrock_config_path config_paths)};
  $config_paths //= [];

  mlogger_debug( $r, 'config paths to search: %s', join q{,}, $bedrock_config_path, @{$config_paths} );

  my @files = grep { -e $_ } map {"$_/tagx.xml"} uniq( $bedrock_config_path, @{$config_paths} );

  die "ERROR: no tagx.xml found. Check BEDROCK_CONFIG_PATH ($bedrock_config_path)\n"
    if !@files;

  if ( @files == 1 ) {
    mlogger_info( $r, 'found 1 tagx.xml file (%s)', $files[0] );
    return $self->read_config(@files);
  }

  ######################################################################
  # - `tagx.xml` must exist in root of the configuration path
  # - Bedrock's default `tagx.xml` should always have REPLACE_CONFIG
  #   eq 'yes' unless you want to merge!
  # - If multiple paths are found all `tagx.xml` files found are merged
  ######################################################################

  mlogger_info( $r, q{found multiple tagx.xml files...reading Bedrock's default (%s)}, $files[0] );

  my $config = $self->read_config( shift @files );  # this should be Bedrock's default tagx.xml

  if ( $config->{REPLACE_CONFIG} && $config->{REPLACE_CONFIG} =~ /^y/ixsm ) {
    mlogger_info( $r, q{REPLACE_CONFIG=%s...replacing Bedrock's `tagx.xml`}, $config->{REPLACE_CONFIG} );
    # overwrite Bedrock's default `tagx.xml`
    $config = $self->read_config( shift @files );
  }

  foreach (@files) {
    mlogger_warn( $r, q{Merging %s with Bedrock's default `tagx.xml`!}, $_ );
    $config->merge_config( $self->read_config($_) );
  }

  return $config;
}

########################################################################
sub merge_tagx_apps_configs {
########################################################################
  my ( $self, %args ) = @_;

  my ( $r, $config, $request ) = @args{qw(r config)};
  $r //= $self->request;

  my ( $bedrock_config_path, $config_paths ) = @args{qw(bedrock_config_path config_paths)};

  $bedrock_config_path //= $self->get_bedrock_config_path;
  $config_paths        //= [ $self->get_config_paths ];

  # -- directory configs
  # directory configs are either typically in tagx_apps.xml
  # <object>
  #  <object name="/foo">
  #   ...
  #  </object>
  # </object>

  my $tagx_apps = $config->{APP_CONFIG} // 'tagx_apps.xml';
  $r->log->debug( sprintf 'APP_CONFIG: %s', $tagx_apps // $EMPTY );

  if ( !$tagx_apps ) {
    $r->log->warn('no APP_CONFIG found in config object...nothing to merge.');
    return;
  }

  if ($tagx_apps) {
    my $app_config = $self->read_config( $bedrock_config_path, $tagx_apps );

    mlogger_debug( $r, 'found a root tagx_apps.xml ' . Dumper($app_config) );

    my $document_root = $ENV{DOCUMENT_ROOT};

    # you can only have custom tagx_app configurations if you have a
    # root level tagx_app file
    if ($app_config) {
      foreach my $path ( @{$config_paths} ) {
        my $custom_app_config = $self->read_config( $path, $tagx_apps );
        mlogger_debug( $r, 'custom config: ' . Dumper($custom_app_config) );

        $app_config->merge_config($custom_app_config);
      }
    }

    if ( $app_config && keys %{$app_config} ) {
      # in case we have directory specific configuration files...
      my $dir = $self->get_uri_dir;

      if ( $dir && defined $document_root ) {
        $dir =~ s/^$document_root//xsm;
      }

      $dir = $dir // $EMPTY;

      $dir =~ s/\/$//xsm;

      $r->log->debug( sprintf 'directory: %s', $dir );

      foreach my $key ( keys %{$app_config} ) {
        if ( $key ne "$dir" ) {
          delete $app_config->{$key};
        }
      }

      # merge what's left since it must be our directory
      $config->merge_config( $app_config->{$dir} );
    }
  }

  return;
}

########################################################################
sub mlogger_debug  { return mlogger( shift, level => 'debug',  message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
sub mlogger_info   { return mlogger( shift, level => 'info',   message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
sub mlogger_warn   { return mlogger( shift, level => 'warn',   message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
sub mlogger_trace  { return mlogger( shift, level => 'debug',  message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
sub mlogger_error  { return mlogger( shift, level => 'error',  message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
sub mlogger_notice { return mlogger( shift, level => 'notice', message => shift, @_ > 0 ? ( args => [@_] ) : () ); }
########################################################################

########################################################################
sub mlogger {
########################################################################
  my ( $r, %args ) = @_;

  my ( $level, $message, $params ) = @args{qw(level message args)};

  chomp $message;

  if ( exists $args{args} && @{$params} ) {
    $message = sprintf $message, @{$params};
  }

  foreach ( split /\n/xsm, $message ) {
    $r->log->$level($_);
  }

  return;
}

########################################################################
sub config_files_processed {
########################################################################
  my ( $self, @args ) = @_;

  $self->{_config_files_processed} //= [];

  if (@args) {
    push @{ $self->{_config_files_processed} }, @args;
  }

  return @{ $self->{_config_files_processed} };
}

########################################################################
sub _list_files {
########################################################################
  my (%args) = @_;

  my ( $path, $type, $filter ) = @args{qw(path type filter)};

  croak 'ERROR: filter must be an array ref'
    if $filter && !ref $filter;

  $type = ref($type) && reftype($type) eq 'REGEXP' ? $type : qr/[.]$type$/xsmi;

  no warnings 'File::Find';  ## no critic

  my @files;

  find(
    sub {
      my $name = $_;

      if ( /$type/xsm && !any { $_ eq $name } @{$filter} ) {
        push @files, $File::Find::name;
      }
    },
    $path
  );

  return @files;
}

1;

__END__

=pod

=head1 NAME

Bedrock::Handler - The Core Bedrock Request Handler

=head1 SYNOPSIS

  use Bedrock::Handler;
  
  # 1. In your mod_perl handler (e.g., Apache::Bedrock)
  #    Initialize your specific cache driver (Redis, Memcached, etc.)
  my $cache = Bedrock::RedisCache->new( ... );

  # 2. Inject the cache into the Handler constructor
  my $handler = Bedrock::Handler->new( 
      $r, 
      cache => $cache 
  );

  # The handler will now automatically check the cache for 
  # configuration objects before parsing XML files.

=head1 DESCRIPTION

C<Bedrock::Handler> is the workhorse of the Bedrock framework. It is
responsible for orchestrating the request lifecycle, including:

=over 4

=item *

Initializing the request context (environment, paths, URI parsing).

=item *

Loading and merging configuration files (F<tagx.xml>, F<tagx_apps.xml>, etc.).

=item *

Managing the C<Bedrock::Config> object.

=item *

Binding modules and plugins.

=back

=head1 METHODS AND SUBROUTINES

=head2 new( $r, %options )

Creates a new Handler instance.
B<$r> is the Apache request object.
B<%options> may contain:

=over 4

=item * B<cache> - An object instance conforming to the Cache Interface described above.

=back

=head2 apache_handler (deprecated)

 See L</request>

=head2 cache_enabled

Returns a boolean value indicating if caching is enabled.  Caching is
enabled when the constructor is passed a valid caching object. See
L</CACHING STRATEGY> for details.

=head2 config

Returns the fully merged Bedrock configuration object.

=head2 config_files_processed

=head2 error

Logs a message to the log file and restores the original directory.

=head2 fetch_blm_config

 fetch_blm_config(config-name, paths)

Populates the main config file with a module's configuration. Returns
the main configuration object. To access the specific module
configuration use the C<get_module_config()> method.

=over 5

=item config-name

Name of the configuration.

Example: 'mysql-session'

=item paths

List of paths to search for module configs.

Default: $ENV{BEDROCK_CONFIG_PATH}

=back

=head2 full_path

 full_path(path, filename, default-extension)

Returns a formatted fully qualified path to a file with a default extension

=head2 get_bedrock_admin_dir

Returns the relative URI for the Bedrock documenation. Typically C</bedrock>.

=head2 get_bedrock_config

 get_bedrock_config()

Returns the configuration object. If it has not yet been initialized,
this method will attempt to load the configuration object by calling
C<load_config()>.

Bedrock looks for configuration files, including F<tagx.xml> in paths
indicated by C<$ENV{BEDROCK_CONFIG_PATH}> and C<$ENV{CONFIG_PATH}>.

If Bedrock detects multiple F<tagx.xml> files in your paths, Bedrock
will use the value of C<REPLACE_CONFIG> in the most recently read
configuration file to determine whether values in this F<tagx.xml>
should be merged or replace the previous configuration.

 <scalar name="REPLACE_CONFIG">yes</scalar>

=head2 get_config

Deprecated: use load_config()

=head2 get_uri_dir

Returns the directory portion of URI parsed from the request object's C<uri()> method.
=head2 load_config

 load_config()

Returns Bedrock's configuration object.  Note that the hash that is
returned is the fully exploded configuration environment for Bedrock.
The configuration (may) have come from the cache if caching has been
enabled.  See L<CONFIGURATION CACHING>

=head2 is_mod_perl

Returns the mod_perl version string if mod_perl is enabled, undef otherwise.

=head2 load_config_from_cache

Loads the serialized configuration object from cache.

=head2 log_debug, log_info, log_warn, log_error

These methods are basically equivalent to Apache's request object methods
for logging. These methods will additionally log the caller and the
line number of the caller.

Equivalent to:

 my $r = $self->request;

 $r->log->debug(sprintf '[%s]: %s %s', $caller, $caller_line_no, $message);

I<NOTE: Apache's default log message size is apparently 8K. There does not
seem to be any way to increase that size. Apache will truncate message
longer than 8K.>

=head2 mlogger( $r, level => $level, message => $msg )

A utility method to handle multi-line logging. Apache's standard
logger escapes newlines, making stack traces or C<Data::Dumper> output
unreadable. C<mlogger> splits the message by newline and logs each
line individually to the Apache error log.

Use the convenience `mlogger_{level}` methods like this:

 mlogger_debug(request, message, [args]);

If you supply and C<args> parameter then the message is assumed to be
a `sprintf` template with C<args> as the parameters to print.

=head2 pwd

Set/get the current working directory. This does not alter the path!

=head2 read_config

 read_config(path, file)

Reads a Bedrock configuration file and returns a C<Bedrock::Config>
object. Updates the C<config_files_processed> array.

=head2 read_data_source

Reads the F<data-sources.xml> file.

=head2 restore_dir

Restores the directory to the current working directory at the time
that this object was instantiated.

=head2 request

Returns the request object. Apache running with C<mod_perl> enabled will
return an L<Apache2::RequestRec> object.  If Bedrock is running as a
CGI this method will return an L<Apache::Bedrock::Request::CGI> object.

=head2 request_handler (deprecated)

See L</request>

=head2 uri_dir

See L</get_uri_dir>

=head1 CACHING STRATEGY

Historically, Bedrock used C<IPC::Shareable> to cache configuration
objects in shared memory. This has been replaced with a B<Dependency
Injection> model to allow for greater flexibility (e.g., Redis,
Memcached, or localized testing mocks).

=head2 Enabling Caching

Caching is enabled automatically if a valid C<cache> object is passed
to the C<new()> constructor. A C<cache> object is typically
instatiated at the beginning of the request cyle by C<Apache::Bedrock>
when it sees an environment variable named C<BEDROCK_CACHE_ENGINE>. It
then passes that object the constructor.

  my $handler = Bedrock::Handler->new( $r, cache => $CACHE );

If no C<cache> argument is provided, C<Bedrock::Handler> defaults to
strictly loading configuration files from disk on every request
(useful for development/debugging).

=head2 Why cache the configuration?

Creating Bedrock's configuration object is the result of merging
several different configuration files. Caching Bedrock's config
object can avoid a lot of config file mashing which includes; file
I/O, XML parsing, and merging of hash objects.

Caching of the configuration file can be used with C<mod_perl> or when
running Bedrock as a CGI, making Bedrock's startup times significantly
faster.

=head2 The Cache Interface (Contract)

C<Bedrock::Handler> does not care I<how> the data is stored, only that
the injected object supports the following two methods:

=over 4

=item B<get( $key )>

Returns the deserialized configuration hash/object associated with
C<$key>. Returns C<undef> on a miss.

=item B<set( $key, $data )>

Stores the C<$data> object under C<$key>. The driver is responsible
for any serialization (JSON, Storable, etc.) required by the backing
store.

=back

=head2 Cache Keys

The handler uses the current C<SERVER_NAME> environment variable as
the cache key.

  $key = $ENV{SERVER_NAME} // $PROGRAM_NAME;

This ensures that virtual hosts sharing the same Bedrock instance
maintain distinct configuration caches.

=head1 ENVIRONMENT VARIABLES

=over 4

=item * B<BEDROCK_CONFIG_PATH> - The root directory for Bedrock
configuration files.

=item * B<BEDROCK_BENCHMARK> - If set to C<on>, C<yes>, or C<1>,
enables C<Benchmark> timing for configuration loading.

=back

=head1 SEE ALSO

L<Bedrock::Cache>, L<Apache::Bedrock>

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=cut
