package Bedrock::Handler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use vars qw/@ISA @EXPORT_OK %EXPORT_TAGS/;

@EXPORT_OK = qw/%BEDROCK_CONFIG_CACHE/;
@ISA = qw/Exporter/;

%EXPORT_TAGS = (all => \@EXPORT_OK);

use Apache2::Const -compile =>
qw( HTTP_UNAUTHORIZED NOT_FOUND OK SERVER_ERROR FORBIDDEN DECLINED REDIRECT :log);

use constant NOT_FOUND    => Apache2::Const::NOT_FOUND;
use constant SERVER_ERROR => Apache2::Const::SERVER_ERROR;
use constant FORBIDDEN    => Apache2::Const::FORBIDDEN;
use constant OK           => Apache2::Const::OK;
use constant DECLINED     => Apache2::Const::DECLINED;
use constant REDIRECT     => Apache2::Const::REDIRECT;

use Cwd qw/realpath fastcwd/;
use English;
use File::Basename;
use File::Find;
use Bedrock::BedrockConfig;
use Data::Dumper;

my $MOD_PERL;
my %BEDROCK_CONFIG_CACHE;

# Note on cacheing...
# so the thought here, is smoke 'em if you got em...if this succeeds,
# great, if not, well too bad, we'll fall back and Bedrock will work
# anyway.  It's experimental and unclear how much cacheing configs
# aids in startup time.  My sense is it could be significant for more
# trafficked sites and for sites with a lot of configuration files
# that need to be merged.  OTOH, deserialization of the cached
# configuration in not free.

if ( $ENV{BEDROCK_CACHE_CONFIG} ) {
  eval {
    require IPC::Shareable;
    {
      local $SIG{__WARN__} = sub { };
      tie %BEDROCK_CONFIG_CACHE, 'IPC::Shareable',
        {
        key    => 'BCFG',
        create => 0,
        size   => 1024 * ( $ENV{BEDROCK_CACHE_CONFIG_SIZE} || 256 )
        };
    }
  };

  # this happens way before logging, so let's at least give someone a
  # clue that their attempt at cacheing the config did not succeed
  warn "cacheing not successful: $@\n";
}

=pod

=head1 NAME

C<Bedrock::Handler> - common Bedrock handler methods

=head1 SYNOPSIS

 my $bedrock_handler = Bedrock::Handler->new($r);

=head1 DESCRIPTION

Class to be used to provide some helper functions for writing Bedrock
request handlers.  Performs a common set of initialization activities
like creating Bedrock's configuration environment from the various
configuration files that are supported by Bedrock.

=head1 METHODS

=head2 new

 new( request-object )

Creates a new instance of a Bedrock handler object.

=cut

sub new {
  my ($class, $r)  = @_;
  my $self = bless {}, $class;

  $self->pwd(fastcwd());
  $self->config_files_processed([]);

  $self->request_handler($r);

  $MOD_PERL = exists $ENV{MOD_PERL};

  $self->init_request;

  eval { $self->load_config; };

  # sometimes one .xml files is malformed, helpful to know how far we
  # got loading the configuration files
  if ( $@ ) {
    $r->log_error("error loading configuration files: $@");
    $r->log_error("procesed the following files: \n" . join("\n", $self->config_files_processed));

    die $@;
  }

  $self;
}

sub init_request {
  my $self = shift;

  my $r = $self->request_handler;
  
  #
  # under mod_perl naked directory requests are passed along prior to
  # file checking.  Thus the content_type is directory
  #
  # under mod_cgi those same requests come through via the "virtual" modifier on the Action directive
  #   8<
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual
  #   8<
  
  $self->{file} = do {
    if ( $r->content_type && $r->content_type =~ /directory/ ) {
      $ENV{PATH_TRANSLATED} = $r->filename;
      $r->content_type('text/html');
      "";
    }
    else {
      $r->filename;
    }
  };

  # Parse for the URI components
  if ( $r->uri ) {
    @{$self}{qw/uri_name uri_dir/} = fileparse($r->uri);
  }

  if ( $r->filename ) {
    @{$self}{qw/filename path/} = fileparse( $r->filename );
  }
  
  { 
    no warnings 'uninitialized';

    $self->log_debug( sprintf( "SCRIPT_NAME......[%s] " , $ENV{SCRIPT_NAME}) );
    $self->log_debug( sprintf( "request file.....[%s] " , $self->{file}) );
    $self->log_debug( sprintf( "URI..............[%s] " , $r->uri) );
    $self->log_debug( sprintf( "URI_DIR..........[%s] " , $self->{uri_dir}) );
    $self->log_debug( sprintf( "URI_NAME.........[%s] " , $self->{uri_name}) );
    $self->log_debug( sprintf( "PATH_INFO........[%s] " , $ENV{PATH_INFO}) );
    $self->log_debug( sprintf( "PATH_TRANSLATED..[%s] " , $ENV{PATH_TRANSLATED}) );
    $self->log_debug( sprintf( "filename.........[%s] " , $self->{filename}) );
    $self->log_debug( sprintf( "path.............[%s] " , $self->{path}) );
    $self->log_debug( sprintf( "mod_perl.........[%s] " , ($self->is_mod_perl) ? 'yes' : 'no'));
  }
}

sub read_config {
  my ($self, $path, $file) = @_;

  my $conf;
  
  if ( $path && $file ) {
    $file = $file . '.xml'
      if $file !~/\.xml$/;

    my $fqp = $path . '/' . $file;
    
    $conf = eval {
      Bedrock::Config->new( $fqp );
    };
    
    if ($@) {
      $self->log_warn('could not read ' . $fqp . ":[$@] [$OS_ERROR]");
    }
    else {
      $self->log_debug("successfully read $fqp");
      $self->config_files_processed($fqp);
    }
  }
  
  return $conf;
}

sub is_mod_perl {
  return $MOD_PERL;
}

=pod

=head2 apache_handler

 apache_handler( [request-handler] )

Set or get the Apache request handler.

=cut

sub apache_handler {
  my $self = shift;
  
  if ( @_ ) {
    $self->{_apache_handler} = shift;
  }

  return $self->{_apache_handler};
}

sub request_handler { goto &apache_handler; }

sub _log {
  my ($r, $message, $level) = @_;
  
  my $depth = 0;
  my @stack;
  
  while (my @frame = caller($depth++) ) {
    push @stack, \@frame;
  }

  my $frame;
  
  while ($frame = pop @stack) {
    last if $frame->[3] !~/eval/;
  }
  
  $r->request_handler->log->$level( $frame->[3] . '[' . $frame->[2] . ']: ' . $message );
}

=pod

=head2 log_info

=head2 log_error

=head2 log_warn

=head2 log_debug

 log_debug( message )

Logs a message at the given log level to Apache's error log.

=cut

sub log_info  { _log(@_, 'info') };
sub log_error { _log(@_, 'error') };
sub log_warn  { _log(@_, 'warn') };
sub log_debug { _log(@_, 'debug') };

=pod

=head2 load_config

 load_config()

Returns Bedrock's configuration object.  Note that the hash that is
returned is the fully exploded configuration environment for Bedrock.
The configuration (may) have come from the cache if cacheing has been
enabled.  See L<CONFIGURATION CACHEING>

=cut

sub load_config {
  my $self = shift;
  
  my $config = $self->config;
  my $key;
  
  if ( ! $config ) {
    if ( $ENV{BEDROCK_CACHE_CONFIG} && $ENV{BEDROCK_CACHE_CONFIG} =~/(yes|y|on)/i ) {
      my $server_name = $ENV{SERVER_NAME} // $$;
      $key = '$server_name:' . $self->get_uri_dir;

      if ( exists $BEDROCK_CONFIG_CACHE{$key} ) {
        $config = Bedrock::Config->newFromString($BEDROCK_CONFIG_CACHE{$key});
        $config->{BEDROCK_CACHE_LOADED} = time;
      }
    }
    
    if ( !$config) {
      $config = $self->get_bedrock_config;
    }
   
    $BEDROCK_CONFIG_CACHE{$key} = Bedrock::XML::writeXML($config)
      if $key;

    $self->config($config);
  }
  
  return $config;
}

sub get_config { goto &load_config; }

# set config or get value
sub config {
  my ($self, $config, $key) = @_;

  if ( $config && ref($config) ) {
    $self->{_config} = $config;
  }
  elsif ( $key )  {
    return $self->{_config}->{$key};
  }
  else {
    return $self->{_config}
  }
}

sub _list_xml_files {
  my ($path, @filter) = @_;
  
  my @files;
  
  find(sub {
         my $name = $_;
         push @files, $File::Find::name
           if /\.xml$/ && ! grep { /^$name$/ } @filter;
       }, $path);

  return @files;
}

=pod

=head2 get_uri_dir

=cut

sub get_uri_dir { goto &uri_dir; }

# set or get uri_dir
sub uri_dir { 
  my ($self, $uri_dir) = @_;

  if ( $uri_dir) {
    $self->{uri_dir} = $uri_dir;
  }

  return $self->{uri_dir};
}

=pod

=head2 restore_dir

=cut

sub restore_dir {
  my $self = shift;
  
  if ( $self->pwd ) {
    chdir $self->pwd;
  }
}

=pod

=head2 get_bedrock_admin_dir

=cut

sub get_bedrock_admin_dir {
  my $self = shift;

  $self->config('BEDROCK_ADMIN_DIR') || '/bedrock';
}

sub error {
  my ($self, $err_msg, $code) = @_;
  $code = $code || SERVER_ERROR;

  $self->log_error( $err_msg );

  $self->restore_dir;

  return $code;
}

=pod

=head2 get_bedrock_config

 get_bedrock_config()

Bedrock looks for the master F<tagx.xml> in
C<$ENV{BEDROCK_CONFIG_PATH}>, however it can be overridden or merged
with local configuration files.  To override the master, add this to
the master F<tagx.xml> file

 <scalar name="REPLACE_CONFIG">yes</scalar>

=cut

sub get_bedrock_config {
  my $self = shift;

  my ($bedrock_config_path, $config_path);
  
  if ( $ENV{BEDROCK_CONFIG_PATH} ) {
    $bedrock_config_path = realpath( $ENV{BEDROCK_CONFIG_PATH} );
  }
  else {
    $self->log_warn(
      'No BEDROCK_CONFIG_PATH found. You probably have a misconfigured system.'
    );
  }

  if ( $ENV{CONFIG_PATH} ) {
    $config_path = realpath( $ENV{CONFIG_PATH} );
  }
  else {
    $self->log_warn(
          'No application CONFIG_PATH found. Using BEDROCK_CONFIG_PATH:['
        . $bedrock_config_path
        . ']' );
  } ## end else [ if ( $ENV{CONFIG_PATH})]

  my @paths = grep { defined } ($bedrock_config_path, $config_path);

  # it's probably okay, not to find this...
  my $conf = $self->read_config($bedrock_config_path, 'tagx');

  # Basically we want to allow users these options:
  #
  # 1. use Bedrock's configuration
  # 2. use their own configuration instead of Bedrock's (default)
  # 3. override some of Bedrock's configuration

  # there is no Bedrock configuration, so we need to look for
  # application's config (option #1)
  if ( ! $conf ) {
    $conf = $self->read_config($config_path, 'tagx');
  }
  elsif ( $conf->{REPLACE_CONFIG} =~/^y/i ) {
    $conf = $self->read_config($config_path, 'tagx');
  }
  else {
    $conf->merge_config($self->read_config($config_path, 'tagx'));
  }

  if ( !$conf || 0 == keys %$conf ) {
    die "No or empty 'tagx.xml' \n"
      . "BEDROCK_CONFIG_PATH: [$bedrock_config_path]\n"
      . "CONFIG_PATH: [$config_path]\n";
  }

  # look for data-sources.xml which defines database connection strings
  my $db_conf = $self->read_config($bedrock_config_path, 'data-sources');
  
  if ( $db_conf ) {
    $db_conf->merge($self->read_config($config_path, 'data-sources'));
  }
  else {
    $db_conf = $self->read_config($config_path, 'data-sources');
  }

  $conf->dbnames($db_conf || {});

  # look for more config files to merge
  
  my @config_paths = map { $_ . '.d' } @paths;
  
  foreach my $path ( @config_paths, $config_path ) {
    next if !$path || !-d $path;

    $self->log_debug(sprintf "Searching [%s] for config files", $path);

    for my $file ( _list_xml_files($path, 'tagx.xml', 'tagx_apps.xml') ) {
      $self->log_debug( sprintf "Found a configuration file: [%s]", $file);
      
      $self->config_files_processed($file);
      
      $conf->merge($file);
    }
  }

  # -- look for module configs
  my @module_paths;

  # note the order is important here, we want local configurations
  # to override system configurations
  foreach my $p ( @paths ) {
    foreach my $dir ( qw/startup plugin/ ) {
      push @module_paths, $p . ".d/" . $dir
        if -d $p . ".d/" . $dir;
    }
  }

  foreach my $path ( @module_paths ) {
    foreach my $file ( _list_xml_files($path) ) {
      $self->log_debug( sprintf "Found a potential module configuration file: [%s]", $file);
      $self->log_debug( sprintf "Merging [%s]", $file );

      my $module_config = Bedrock::Config->new($file);
      $conf->merge_modules( { MODULES => [ $module_config ] });
    }
   }

  
  # -- directory configs
  # directory configs are either typically in tagx_apps.xml
  # <object>
  #  <object name="/foo">
  #   ...
  #  </object>
  # </object>

  my $tagx_apps = $conf->{'APP_CONFIG'};
  
  if ( $tagx_apps ) {
    my $app_config = $self->read_config($bedrock_config_path, $tagx_apps);
    
    if ( $app_config ) {
      $app_config->merge_config($self->read_config($config_path, $tagx_apps));
    }  

    if ( $app_config && keys %$app_config ) {
      # in case we have directory specific configuration files...
      my $dir = $self->get_uri_dir;
      
      # Bedrock shell uses DOCUMENT_ROOT differently (explain?)
      $dir =~ s/^$ENV{DOCUMENT_ROOT}//
        if defined $ENV{DOCUMENT_ROOT};

      foreach my $k (keys %$app_config) {
        delete $app_config->{$k}
          if ! $k eq "/$dir";
      }

      # merge what's left since it must be our directory
      $conf->merge_config($app_config);
    }
   }

  # -- not sure why we ever needed this line
  $conf->{CONFIG_PATH} = $config_path;

  # override use of BEDROCK_IMAGE_URL if app defines own
  $conf->{BEDROCK_IMAGE_URL} = $conf->{IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  # And voila! we have the merged config
  $conf;
}


sub pwd {
  my $self = shift;

  if (@_) {
    $self->{_pwd} = shift;
  }

  return $self->{_pwd};
}

sub config_files_processed {
  my $self = shift;

  if ( @_ ) {
    push @{$self->{_config_files_processed}}, @_;
  }

  return @{$self->{_config_files_processed}};
}

=pod

=head1 CONFIGURATION CACHEING

=head2 Why cache the configuration?

Creating Bedrock's configuration object is not a simple matter of
reading 1 configuration file.  Thus cacheing Bedrock's config object
can avoid a lot of config file mashing which includes; file I/O, XML
parsing, and merging of hash objects.

Cacheing of the configuration file can be use with mod_perl or when
running Bedrock as a CGI and make Bedrock's startup times up to 50%
faster.

=head2 Initializing the cache

A shared memory segment should be created sometime before the
Apache parent process is started (typically F<startup.pl>). It should
create the segment in a similar way as show below:

 tie %X, 'IPC::Shareable', { 
                            key     => 'BCFG', 
                            create  => 1, 
                            destroy => 0, 
                            size    => 256 * 1024
                           };

Note that use of the shared memory key C<BCFG> is not optional.  If you
want Bedrock to know about your shared memory segment, you and Bedrock
must agree on the key name - we chose C<BCFG>.

For a non-mod_perl environment (Bedrock running asa a perl CGI script)
you would need to create the shared memory segment at boot time or
before your Apache server was started.  Also, you do NOT want the
shared memory destroyed when the process terminates, thus you would
set `destroy => 0' when tieing the object as shown above.

You also are responsible for providing some other way to
clean up the shared memory segment (if you were concerned about such
things).

=head2 Size Matters

New studies now show what we've all suspected. B<size> I<does> matter.
The cache is populated with a serialized (Bedrock XML) version of the
config object.  Empirically you're going to need at least 128K or so
depending on how many directories you've scattered your Bedrock files
amongst.  Each directory that is I<Bedrock enabled> (.roc file is being
processed therein) may have its own configuration (Learn about
I<tagx_apps.xml> on the Bedrock Wiki).

Our shared memory segment size, must account for the possibility that
you might have a per directory configuration via F<tagx_apps.xml>.
Thus the hash key for getting the configuration object is based on the
directory from which the object is being served.  Make sure the size
here and the size in your shared memory initialization script agree.
Set the cached size (in MB) in the Apache configuration file using the
C<SetEnv> directive.  The default is 256MB.

 SetEnv BEDROCK_CACHE_CONFIG On
 SetEnv BEDROCK_CACHE_CONFIG_SIZE 256

=head2 More Gory Details

In this module (Apache::Bedrock) we tie the hash object
(C<%BEDROCK_CONFIG_CACHE>) to the shared memory segment using the
C<IPC::Shareable> module.  We do this in an eval block in the event
that the shared memory is not available.  If an error occurs during
the tie, we simply will have an empty hash object and thus cacheing is
disabled.  The absence of the shared memory key is essentially then
our trigger to cache or not to cache.

When the Bedrock handler() method is invoked, we check the cache
before creating a config object.

 $BEDROCK_CONFIG_CACHE{$key};

If the serialized object exists, great, if not, we do the config
dance and create a config object.  We then store the serialized
config object back in the hash used to cache the configs.  If we're
not cacheing, we do it anyway, no harm, no foul here.

The I<key> used as the hash index into the cache (not to be confused
with the shared memory "key" that allows multiple processes to access
the same block of shared memory) is composed of the server name from
C<SERVER_NAME> environment variable and the absolute path to the file
being processed through the handler.  This is done because Bedrock
supports the possibility of per directory configurations.

Keeping in mind that the mod_perl handler servers many virtual hosts
we need to make sure that the correct config object is accessed.
Using the key as described above to store and fetch the serialized
config object will (should) insure that the correct config object is
being used for the correct virtual host and for the correct directory
within that virtual host.  Again, recall that Bedrock allows per directory
configuration via F<tagx_apps.xml>.

The shared memory object should probably be destroyed when the Apache
parent is terminated.  Again, note that in this module
(C<Bedrock::Handler>) we neither create, nor destroy the shared memory
segment, but we use it if it is available.  IOW those wishing to take
advantage of cacheing have some housekeeping to do.  Bedrock could
facilitate this operation (and may), however optimizing the framework
is probably something that should be done by those who know what they
are doing to avoid any surprises.

=head2 Cache Manipulation

Flushing the config cache is a simple matter of executing this code:

 #!/usr/bin/perl

 use IPC::Shareable;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 %FOO = ();

Examing the cache is equally trivial

 #!/usr/bin/perl

 use IPC::Shareable;
 use Data::Dumper;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 print Dumper( \%FOO );

...as is destroying the cache

 #!/usr/bin/perl

 use IPC::Shareable;
 
 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 $FOO->remove();

=head2 What else should we cache?

Are there other opportunities to speed up Bedrock using cacheing?  At
first blush, no.  The whole point of a templating package is to merge
dynamic data with templates, so we never know what dynamic data is
being merged.  Of course, that's not always the case, or we might
designate some pages that do get parsed as I<cacheable> since Bedrock
parsing is not instantaneous.

Cacheing processed pages it seems then is generally a non-starter.
We could conceivably cache the raw Bedrock page avoiding the
disk access associated with reading C<.roc> and C<.inc> files into
memory.  Given the advances in the way the O/S handles cacheing of
disk objects, it seems like this might not be a place where a
great deal of additional benefit might be derived with optmizations
efforts - however I<YMMV>.

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut

1;
