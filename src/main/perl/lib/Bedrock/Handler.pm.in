package Bedrock::Handler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

our @EXPORT_OK = qw{ %BEDROCK_CONFIG_CACHE };

use parent qw{ Exporter };

our %EXPORT_TAGS = ( all => \@EXPORT_OK );

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

use Apache2::Const -compile => qw{
  HTTP_UNAUTHORIZED
  NOT_FOUND
  OK
  SERVER_ERROR
  FORBIDDEN
  DECLINED
  REDIRECT
  :log
};

use constant { ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  NOT_FOUND            => Apache2::Const::NOT_FOUND,
  SERVER_ERROR         => Apache2::Const::SERVER_ERROR,
  FORBIDDEN            => Apache2::Const::FORBIDDEN,
  OK                   => Apache2::Const::OK,
  DECLINED             => Apache2::Const::DECLINED,
  REDIRECT             => Apache2::Const::REDIRECT,
  CACHE_BLOCK_SIZE     => 1024,
  DEFAULT_CACHE_BLOCKS => 256,
  EMPTY                => q{},
};

use Bedrock::BedrockConfig;
use Carp;
use Cwd qw/realpath fastcwd/;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Find;
use List::Util qw{ any };

# see pod for notes on caching...

my %BEDROCK_CONFIG_CACHE;

########################################################################
sub cache_enabled {
########################################################################
  my $cache_config = $ENV{BEDROCK_CACHE_CONFIG};

  return $cache_config && $cache_config =~ /^yes|y|on$/ixsm;
}

if (cache_enabled) {
  eval {

    require IPC::Shareable;

    {
      local $SIG{__WARN__} = sub { };

      my $cache_blocks
        = $ENV{BEDROCK_CACHE_CONFIG_SIZE} || DEFAULT_CACHE_BLOCKS;

      my $cache_config = {
        key    => 'BCFG',
        create => 0,
        size   => CACHE_BLOCK_SIZE * $cache_blocks,
      };

      tie %BEDROCK_CONFIG_CACHE, 'IPC::Shareable', $cache_config; ## no critic (Miscellanea::ProhibitTies)
    }
  };

  if ($EVAL_ERROR) {
    carp "caching not successful: $EVAL_ERROR\n";
  }
}

########################################################################
sub new {
########################################################################
  my ( $class, $r ) = @_;

  my $self = bless {}, $class;

  $self->pwd( fastcwd() );

  $self->request_handler($r);

  $self->init_request;

  eval { $self->load_config };

  # sometimes one or more configuration files are malformed, helpful
  # to know how far we got loading the configuration files
  if ($EVAL_ERROR) {
    my $error = $EVAL_ERROR;

    $r->log->error("error loading configuration files: $error");
    $r->log->error( "processed the following files: \n" . join "\n",
      $self->config_files_processed );

    croak $error;
  }

  return $self;
}

########################################################################
sub init_request {
########################################################################
  my ($self) = @_;

  my $r = $self->request_handler;

  # under mod_perl naked directory requests are passed along prior to
  # file checking.  Thus the content_type is directory
  #
  # under mod_cgi those same requests come through via the "virtual" modifier on the Action directive
  #   8<
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual
  #   8<

  $self->{file}                    = EMPTY;
  $self->{_config_files_processed} = [];

  if ( $r->content_type && $r->content_type =~ /directory/xsm ) {
    $ENV{PATH_TRANSLATED} = $r->filename; ## no critic Variables::RequireLocalizedPunctuationVars
    $r->content_type('text/html');
  }
  else {
    $self->{file} = $r->filename;
  }

  # Parse for the URI components
  if ( $r->uri ) {
    @{$self}{qw{ uri_name uri_dir }} = fileparse( $r->uri );
  }

  if ( $r->filename ) {
    @{$self}{qw{ filename path }} = fileparse( $r->filename );
  }

  {
    no warnings 'uninitialized'; ## no critic TestingAndDebugging::ProhibitNoWarnings

    $self->log_debug( sprintf 'SCRIPT_NAME.....[%s]', $ENV{SCRIPT_NAME} );
    $self->log_debug( sprintf 'request file....[%s]', $self->{file} );
    $self->log_debug( sprintf 'URI.............[%s]', $r->uri || q{} );
    $self->log_debug( sprintf 'URI_DIR.........[%s]', $self->{uri_dir} );
    $self->log_debug( sprintf 'URI_NAME........[%s]', $self->{uri_name} );
    $self->log_debug( sprintf 'PATH_INFO.......[%s]', $ENV{PATH_INFO} );
    $self->log_debug( sprintf 'PATH_TRANSLATED.[%s]', $ENV{PATH_TRANSLATED} );
    $self->log_debug( sprintf 'filename........[%s]', $self->{filename} );
    $self->log_debug( sprintf 'path............[%s]', $self->{path} );
    $self->log_debug( sprintf 'mod_perl........[%s]', $ENV{MOD_PERL} );
  }

  return $self;
}

########################################################################
# full_path( path, filename, default-extension)
# returns a formatted fully qualifed pathname with a default extension
########################################################################
sub full_path {
########################################################################
  my ( $path, $filename, $default_ext ) = @_;

  my @parsed_path = fileparse( "$path/$filename", qr/[.][^.]*/xsm );

  $parsed_path[2] ||= $default_ext;

  return sprintf '%s%s%s', @parsed_path[ ( 1, 0, 2 ) ];
}

########################################################################
# read_config(path, file)
# returns a Bedrock::Config object
########################################################################
sub read_config {
########################################################################
  my ( $self, $path, $filename ) = @_;

  return if !$path || !$filename;

  my $full_path = full_path( $path, $filename, '.xml' );

  my $config = eval { return Bedrock::Config->new($full_path); };

  if ( !$config || $EVAL_ERROR ) {
    $self->log_warn( sprintf 'could not read %s: [%s] [%s]',
      $full_path, $EVAL_ERROR, $OS_ERROR );
  }
  else {
    $self->log_debug("successfully read $full_path");
    $self->config_files_processed($full_path);
  }

  return $config;
}

########################################################################
sub is_mod_perl {
########################################################################
  return $ENV{MOD_PERL};
}

########################################################################
sub apache_handler {
########################################################################
  my @args = @_;

  return _set_get( '_apache_handler', @args );
}

########################################################################
sub request_handler { goto &apache_handler; }
########################################################################

########################################################################
sub _log {
########################################################################
  my ( $self, $message, $level ) = @_;

  my $depth = 0;
  my @stack;

  while ( my @frame = caller( $depth++ ) ) {
    push @stack, \@frame;
  }

  my $frame;

  while ( $frame = pop @stack ) {
    last if $frame->[3] !~ /eval/xsm;
  }

  my $r = $self->request_handler;

  my $log_message = sprintf '%s[%s]: %s', $frame->[3], $frame->[2], $message;

  return $r->log->$level($log_message);
}

########################################################################
sub log_info  { return _log( @_, 'info' ) }  ## no critic (Subroutines::RequireArgUnpacking)
sub log_error { return _log( @_, 'error' ) } ## no critic (Subroutines::RequireArgUnpacking)
sub log_warn  { return _log( @_, 'warn' ) }  ## no critic (Subroutines::RequireArgUnpacking)
sub log_debug { return _log( @_, 'debug' ) } ## no critic (Subroutines::RequireArgUnpacking)
########################################################################

########################################################################
sub load_config_from_cache {
########################################################################
  my ($self) = @_;

  my $key = $ENV{SERVER_NAME} // $PID;

  my $config = $BEDROCK_CONFIG_CACHE{$key};

  if ($config) {
    $config = Bedrock::Config->newFromString($config);
  }
  else {
    $config = $self->get_bedrock_config;

    $config->{BEDROCK_CACHE_LOADED} = scalar localtime;

    $BEDROCK_CONFIG_CACHE{$key} = Bedrock::XML::writeXML($config);
  }

  return $config;
}

########################################################################
sub load_config {
########################################################################
  my ($self) = @_;

  my $config = $self->config;

  return $config
    if $config;

  if ( $self->cache_enabled ) {
    $config = $self->load_config_from_cache;
  }
  else {
    $config = $self->get_bedrock_config;
  }

  return $self->config($config);
}

########################################################################
sub get_config { goto &load_config; }
########################################################################

# config(object) set config object
# config(key)    return specified key from config object
# config()       return config object
########################################################################
sub config {
########################################################################
  my ( $self, @args ) = @_;

  if ( $args[0] && ref $args[0] ) {
    $self->{_config} = $args[0];
  }
  elsif ( $args[0] ) {
    return $self->{_config}->{ $args[0] };
  }

  return $self->{_config};
}

########################################################################
sub _find_files {
########################################################################
  my ( $path, $type, @filter ) = @_;

  my @files;

  find(
    sub {
      my $name = $_;

      if ( /[.]$type$/xsm && !any { $_ eq $name } @filter ) {
        push @files, $File::Find::name;
      }
    },
    $path
  );

  return @files;
}

########################################################################
sub _list_xml_files {
########################################################################
  my ( $path, @filter ) = @_;

  return _find_files( $path, 'xml', @filter );
}

########################################################################
sub get_uri_dir { goto &uri_dir; }
########################################################################

# set or get uri_dir
########################################################################
sub uri_dir {
########################################################################
  my (@args) = @_;

  return _set_get( 'uri_dir', @args );
}

########################################################################
sub restore_dir {
########################################################################
  my ($self) = @_;

  if ( $self->pwd ) {
    chdir $self->pwd;
  }

  return $self->pwd;
}

########################################################################
sub get_bedrock_admin_dir {
########################################################################
  my ($self) = @_;

  return $self->config('BEDROCK_ADMIN_DIR') || '/bedrock';
}

########################################################################
sub error {
########################################################################
  my ( $self, $err_msg, $code ) = @_;

  $code //= SERVER_ERROR;

  $self->log_error($err_msg);

  $self->restore_dir;

  return $code;
}

########################################################################
sub read_data_sources {
########################################################################
  my ( $self, @paths ) = @_;

  # look for data-sources.xml which defines database connection strings
  my $data_source_config = Bedrock::Config->new;

  foreach my $p (@paths) {
    my $config = $self->read_config( $p, 'data-sources' );

    if ($config) {
      $data_source_config->merge_config($config);
    }
  }

  return $data_source_config;
}

########################################################################
sub get_bedrock_config {
########################################################################
  my ($self) = @_;

  my ( $bedrock_config_path, $config_path );

  if ( $ENV{BEDROCK_CONFIG_PATH} ) {
    $bedrock_config_path = realpath( $ENV{BEDROCK_CONFIG_PATH} );
  }
  else {
    $self->log_warn(
      'No BEDROCK_CONFIG_PATH found. You probably have a misconfigured system.'
    );
  }

  if ( $ENV{CONFIG_PATH} ) {
    $config_path = realpath( $ENV{CONFIG_PATH} );
  }
  else {
    $self->log_warn(
          'No application CONFIG_PATH found. Using BEDROCK_CONFIG_PATH:['
        . $bedrock_config_path
        . ']' );
  }

  my @paths = grep {defined} ( $bedrock_config_path, $config_path );

  # it's probably okay, not to find this...
  my $config = $self->read_config( $bedrock_config_path, 'tagx' );

  # Basically we want to allow users these options:
  #
  # 1. use Bedrock's configuration
  # 2. use their own configuration instead of Bedrock's (default)
  # 3. override some of Bedrock's configuration

  # there is no Bedrock configuration, so we need to look for
  # application's config (option #1)
  if ( !$config ) {
    $config = $self->read_config( $config_path, 'tagx' );
  }
  elsif ( $config->{REPLACE_CONFIG} =~ /^y/ixsm ) {
    $config = $self->read_config( $config_path, 'tagx' );
  }
  else {
    $config->merge_config( $self->read_config( $config_path, 'tagx' ) );
  }

  if ( !$config || !keys %{$config} ) {
    croak "No or empty 'tagx.xml' \n"
      . "BEDROCK_CONFIG_PATH: [$bedrock_config_path]\n"
      . "CONFIG_PATH: [$config_path]\n";
  }

  my $dbnames = $self->read_data_sources(@paths);
  $config->dbnames($dbnames);

  # look for more config files to merge
  my @config_paths = map { $_ . '.d' } @paths;

  foreach my $path ( @config_paths, $config_path ) {
    next if !$path || !-d $path;

    $self->log_debug( sprintf 'Searching [%s] for config files', $path );

    foreach
      my $file ( _list_xml_files( $path, 'tagx.xml', 'tagx_apps.xml' ) ) {
      $self->log_debug( sprintf 'Found a configuration file: [%s]', $file );

      $self->config_files_processed($file);

      $config->merge($file);
    }
  }

  # -- look for module configs
  my @module_paths;

  # note the order is important here, we want local configurations
  # to override system configurations
  foreach my $p (@paths) {

    foreach my $dir (qw/startup plugin/) {
      my $path = sprintf '%s.d/%s', $p, $dir;

      if ( -d $path ) {
        push @module_paths, $path;
      }
    }
  }

  foreach my $path (@module_paths) {

    foreach my $file ( _list_xml_files($path) ) {
      $self->log_debug(
        sprintf 'Found a potential module configuration file: [%s]', $file );
      $self->log_debug( sprintf 'Merging [%s]', $file );

      my $module_config = Bedrock::Config->new($file);
      $config->merge_modules( { MODULES => [$module_config] } );
    }
  }

  # -- directory configs
  # directory configs are either typically in tagx_apps.xml
  # <object>
  #  <object name="/foo">
  #   ...
  #  </object>
  # </object>

  my $tagx_apps = $config->{'APP_CONFIG'};

  if ($tagx_apps) {
    my $app_config = $self->read_config( $bedrock_config_path, $tagx_apps );

    if ($app_config) {
      $app_config->merge_config(
        $self->read_config( $config_path, $tagx_apps ) );
    }

    if ( $app_config && keys %{$app_config} ) {
      # in case we have directory specific configuration files...
      my $dir = $self->get_uri_dir;

      # Bedrock shell uses DOCUMENT_ROOT differently (explain?)
      if ( defined $ENV{DOCUMENT_ROOT} ) {
        $dir =~ s/^$ENV{DOCUMENT_ROOT}//xsm;
      }

      $dir = $dir // EMPTY;

      foreach my $key ( keys %{$app_config} ) {
        if ( $key ne "/$dir" ) {
          delete $app_config->{$key};
        }
      }

      # merge what's left since it must be our directory
      $config->merge_config($app_config);
    }
  }

  # -- not sure why we ever needed this line
  $config->{CONFIG_PATH} = $config_path;

  # override use of BEDROCK_IMAGE_URL if app defines own
  if ( $config->{IMAGE_URL} ) {
    $config->{BEDROCK_IMAGE_URL} = $config->{IMAGE_URL};
  }

  # And voila! we have the merged config
  return $config;
}

########################################################################
sub _set_get {
########################################################################
  my ( $key, $self, @args ) = @_;

  if (@args) {
    $self->{$key} = $args[0];
  }

  return $self->{$key};
}

########################################################################
sub pwd {
########################################################################
  my (@args) = @_;

  return _set_get( '_pwd', @args );

}

########################################################################
sub config_files_processed {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    push @{ $self->{_config_files_processed} }, @args;
  }

  return @{ $self->{_config_files_processed} };
}

1;

__END__

=pod

=head1 NAME

C<Bedrock::Handler> - common Bedrock handler methods

=head1 SYNOPSIS

 my $bedrock_handler = Bedrock::Handler->new($r);

=head1 DESCRIPTION

Class used to provide some helper functions for writing Bedrock
request handlers.  Performs a common set of initialization activities
like creating Bedrock's configuration environment from the various
configuration files that are supported by Bedrock.

=head1 METHODS AND SUBROUTINES

=head2 new

 new( request-object )

Creates a new instance of a Bedrock handler object.

Set or get the Apache request handler.

=head2 load_config

 load_config()

Returns Bedrock's configuration object.  Note that the hash that is
returned is the fully exploded configuration environment for Bedrock.
The configuration (may) have come from the cache if caching has been
enabled.  See L<CONFIGURATION CACHING>

=head2 log_info

=head2 log_error

=head2 log_warn

=head2 log_debug

 log_debug( message )

Logs a message with stack information at the given log level to
Apache's error log.

new

=head2 cache_enabled

Returns boolean value indicating if the configuration caching is
enabled.  Caching is enabled by setting the environment variable
BEDROCK_CACHE_CONFIG. Any of "on", "yes" or "y" will enable caching
(case insensitive).

default: off

=head2 config

=head2 config_files_processed

=head2 error

=head2 full_path

 full_path(path, filename, default-extension)

Returns a formatted fully qualified path to a file with a default extension

=head2 get_config

Deprecated: use load_config()

=head1 GETTER/SETTER METHODS

=head2 get_bedrock_admin_dir

=head2 get_uri_dir


=head2 request_handler

=head2 restore_dir

=head2 uri_dir

=head2 apache_handler

 apache_handler( [request-handler] )

=head1 ENVIRONMENT METHODS

=head2 is_mod_perl

=head2 pwd

Returns the mod_perl version string if mod_perl is enabled.

=head1 CONFIGURATION FILE METHODS

=head2 get_bedrock_config

 get_bedrock_config()

Bedrock looks for the master F<tagx.xml> in
C<$ENV{BEDROCK_CONFIG_PATH}>, however it can be overridden or merged
with local configuration files.  To override the master, add this to
the master F<tagx.xml> file

 <scalar name="REPLACE_CONFIG">yes</scalar>

=head2 load_config_from_cache

=head2 read_config

 read_config(path, file)

Reads a Bedrock configuration file and returns a C<Bedrock::Config>
object. Updates the C<config_files_processed> array.

=head2 read_data_source

=head2 _find_files

=head2 _list_xml_files

=head1 LOGGING METHODS

The methods are mostly the equivalent to Apache' request object
methods for logging. These methods will additionally log the method
and line number of the caller.  Apache's default log message size is
apparently 8K. There does not seem to be any way to increase that
size. Apache will truncate message longer than 8K.

=head2 log_debug

=head2 log_error

=head2 log_info

=head2 log_warn

=head1 CONFIGURATION CACHING

Bedrock's configuration can be cached to decrease startup
times. Caching is done using shared memory.

=head2 Why cache the configuration?

Creating Bedrock's configuration object is not a simple matter of
reading a single configuration file.  Thus caching Bedrock's config
object can avoid a lot of config file mashing which includes; file
I/O, XML parsing, and merging of hash objects.

Caching of the configuration file can be used with mod_perl or when
running Bedrock as a CGI making Bedrock's startup times up to 50%
faster.

=head2 Initializing the cache

A shared memory segment should be created sometime before the
Apache parent process is started (typically F<startup.pl>). It should
create the segment in a similar way as show below:

 tie %X, 'IPC::Shareable', { 
                            key     => 'BCFG', 
                            create  => 1, 
                            destroy => 0, 
                            size    => 256 * 1024
                           };

Note that use of the shared memory key C<BCFG> is not optional.  If you
want Bedrock to know about your shared memory segment, you and Bedrock
must agree on the key name - we chose C<BCFG>.

For a non-mod_perl environment (Bedrock running as a perl CGI script)
you would need to create the shared memory segment at boot time or
before your Apache server was started.  Also, you do NOT want the
shared memory destroyed when the process terminates, thus you would
set `destroy => 0' when tieing the object as shown above.

You also are responsible for providing some other way to
clean up the shared memory segment (if you were concerned about such
things).

=head2 Cache Size

The cache is populated with a serialized (Bedrock XML) version of the
config object.  Empirically you're going to need at least 128K or so
depending on how many directories you've scattered your Bedrock files
amongst.  Each directory that is I<Bedrock enabled> (.roc file is being
processed therein) may have its own configuration (Learn about
I<tagx_apps.xml> on the Bedrock Wiki).

Our shared memory segment size, must account for the possibility that
you might have a per directory configuration via F<tagx_apps.xml>.
Thus the hash key for getting the configuration object is based on the
directory from which the object is being served.  Make sure the size
here and the size in your shared memory initialization script agree.
Set the cached size (in MB) in the Apache configuration file using the
C<SetEnv> directive.  The default is 256MB.

 SetEnv BEDROCK_CACHE_CONFIG On
 SetEnv BEDROCK_CACHE_CONFIG_SIZE 256

=head2 More Gory Details

In this module (Apache::Bedrock) we tie the hash object
(C<%BEDROCK_CONFIG_CACHE>) to the shared memory segment using the
C<IPC::Shareable> module.  We do this in an eval block in the event
that the shared memory is not available.  If an error occurs during
the tie, we simply will have an empty hash object and thus cacheing is
disabled.  The absence of the shared memory key is essentially then
our trigger to cache or not to cache.

When the Bedrock handler() method is invoked, we check the cache
before creating a config object.

 $BEDROCK_CONFIG_CACHE{$key};

If the serialized object exists, great, if not, we do the config
dance and create a config object.  We then store the serialized
config object back in the hash used to cache the configs.  If we're
not caching, we do it anyway, no harm, no foul here.

The I<key> used as the hash index into the cache (not to be confused
with the shared memory "key" that allows multiple processes to access
the same block of shared memory) is composed of the server name from
C<SERVER_NAME> environment variable and the absolute path to the file
being processed through the handler.  This is done because Bedrock
supports the possibility of per directory configurations.

Keeping in mind that the mod_perl handler server many virtual hosts
we need to make sure that the correct config object is accessed.
Using the key as described above to store and fetch the serialized
config object will (should) insure that the correct config object is
being used for the correct virtual host and for the correct directory
within that virtual host.  Again, recall that Bedrock allows per directory
configuration via F<tagx_apps.xml>.

The shared memory object should probably be destroyed when the Apache
parent is terminated.  Again, note that in this module
(C<Bedrock::Handler>) we neither create, nor destroy the shared memory
segment, but we use it if it is available.  IOW those wishing to take
advantage of caching have some housekeeping to do.

=head2 Cache Manipulation

Flushing the config cache is a simple matter of executing this code:

 #!/usr/bin/perl

 use IPC::Shareable;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 %FOO = ();

Examing the cache is equally trivial

 #!/usr/bin/perl

 use IPC::Shareable;
 use Data::Dumper;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 print Dumper( \%FOO );

...as is destroying the cache

 #!/usr/bin/perl

 use IPC::Shareable;
 
 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };

 $FOO->remove();

=head2 What else should we cache?

Are there other opportunities to speed up Bedrock using caching?  At
first blush, no.  The whole point of a templating package is to merge
dynamic data with templates, so we never know what dynamic data is
being merged.  Of course, that's not always the case, or we might
designate some pages that do get parsed as I<cacheable> since
Bedrock parsing is not instantaneous.

Caching processed pages it seems then is generally a non-starter.
We could conceivably cache the raw Bedrock page avoiding the
disk access associated with reading C<.roc> and C<.inc> files into
memory.  Given the advances in the way the O/S handles caching of
disk objects, it seems like this might not be a place where a
great deal of additional benefit might be derived with optmizations
efforts - however I<YMMV>.

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
