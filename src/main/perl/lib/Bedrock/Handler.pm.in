package Bedrock::Handler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2024, TBC Development Group, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

our @EXPORT_OK = qw( %BEDROCK_CONFIG_CACHE mlogger);
use parent qw( Exporter );

our %EXPORT_TAGS = ( all => \@EXPORT_OK );

our $VERSION = '@PACKAGE_VERSION@';  ## no critic (RequireInterpolationOfMetachars)

use Apache2::Const -compile => qw{
  HTTP_UNAUTHORIZED
  NOT_FOUND
  OK
  SERVER_ERROR
  FORBIDDEN
  DECLINED
  REDIRECT
  :log
};

use constant {  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  NOT_FOUND            => Apache2::Const::NOT_FOUND,
  SERVER_ERROR         => Apache2::Const::SERVER_ERROR,
  FORBIDDEN            => Apache2::Const::FORBIDDEN,
  OK                   => Apache2::Const::OK,
  DECLINED             => Apache2::Const::DECLINED,
  REDIRECT             => Apache2::Const::REDIRECT,
  CACHE_BLOCK_SIZE     => 1024,
  DEFAULT_CACHE_BLOCKS => 256,
};

use Bedrock::Constants qw(:chars :defaults :booleans);
use Carp;
use Cwd qw(realpath fastcwd);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(fileparse);
use File::Find;
use List::Util qw( any uniq);

# see pod for notes on caching...

our %BEDROCK_CONFIG_CACHE;
our $BEDROCK_CACHE_ENABLED;
our $BEDROCK_BENCHMARK;

BEGIN {
  use Bedrock::BedrockConfig;

  Bedrock::Config->import(qw(validate_config_paths));

  $BEDROCK_CACHE_ENABLED = $ENV{BEDROCK_CACHE_ENABLED};

  if ( $ENV{BEDROCK_BENCHMARK} && lc $ENV{BEDROCK_BENCHMARK} eq 'on' ) {
    require Benchmark;

    Benchmark->import(qw(:all :hireswallclock));

    $BEDROCK_BENCHMARK = $TRUE;
  }

  if ( cache_enabled() ) {
    eval {

      require IPC::Shareable;

      {
        local $SIG{__WARN__} = sub { };

        my $cache_blocks = $ENV{BEDROCK_CACHE_CONFIG_SIZE} || DEFAULT_CACHE_BLOCKS;

        my $cache_config = {
          key    => 'BCFG',
          create => 0,
          size   => CACHE_BLOCK_SIZE * $cache_blocks,
        };

        ## no critic (ProhibitTies)
        return tie %BEDROCK_CONFIG_CACHE, 'IPC::Shareable', $cache_config;
      }
    };

    if ($EVAL_ERROR) {
      print {*STDERR} sprintf "caching enabled, but unable to tie cache: $EVAL_ERROR\n";
      print {*STDERR} sprintf "disabling caching...\n";
      $BEDROCK_CACHE_ENABLED = 'off';
    }
    else {
      print {*STDERR} sprintf "successfully initialized caching for pid: %s\n", $PID;
    }
  }

########################################################################
  sub cache_enabled {
########################################################################
    return $BEDROCK_CACHE_ENABLED && $BEDROCK_CACHE_ENABLED =~ /^yes|y|on$/ixsm;
  }
}

########################################################################
sub new {
########################################################################
  my ( $class, $r, %options ) = @_;  # TODO: %options

  $ENV{BEDROCK_CONFIG_PATH} //= $DEFAULT_BEDROCK_CONFIG_PATH;

  my $self = bless {}, $class;

  $self->pwd( fastcwd() );

  $self->request_handler($r);

  $self->init_request;

  my ( $t0, $t1 );

  if ($BEDROCK_BENCHMARK) {
    $t0 = Benchmark->new;
  }

  my $config = eval { return $self->load_config };

  # sometimes one or more configuration files are malformed, helpful
  # to know how far we got loading the configuration files
  if ( !$config || $EVAL_ERROR ) {
    my $error = $EVAL_ERROR;

    mlogger(
      $r,
      level   => 'error',
      message => "error loading configuration files: $error"
    );

    mlogger(
      $r,
      level   => 'error',
      message => sprintf 'processed the following files: %s',
      Dumper( [ $self->config_files_processed ] )
    );

    croak $error;
  }
  else {
    mlogger(
      $r,
      level   => 'debug',
      message => sprintf 'processed the following files: %s',
      Dumper( [ $self->config_files_processed ] )
    );
  }

  if ($BEDROCK_BENCHMARK) {
    $t1 = Benchmark->new;

    $r->log->info( sprintf '(BENCHMARK): config load time: %s', timestr( timediff( $t1, $t0 ), 'all' ) );
  }

  return $self;
}

########################################################################
sub init_request {
########################################################################
  my ($self) = @_;

  my $r = $self->request_handler;

  # * under 'mod_perl' naked directory requests are passed along prior to
  #   file checking.  Thus the content_type is directory
  #
  # * under 'mod_cgi' those same requests come through via the "virtual"
  #   modifier on the Action directive:
  #
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual

  $self->{file} = $EMPTY;

  if ( $r->content_type && $r->content_type =~ /directory/xsm ) {
    $ENV{PATH_TRANSLATED} = $r->filename;  ## no critic RequireLocalizedPunctuationVars
    $r->content_type('text/html');
  }

  $self->{file} = $r->filename;

  # Parse for the URI components
  if ( $r->uri ) {
    @{$self}{qw{ uri_name uri_dir }} = fileparse( $r->uri );
  }

  if ( $r->filename ) {
    @{$self}{qw{ filename path }} = fileparse( $r->filename );
  }

  {
    no warnings 'uninitialized';  ## no critic ProhibitNoWarnings

    if ( $ENV{BEDROCK_DUMP_ENV} ) {
      foreach ( keys %ENV ) {
        $r->log->debug( sprintf 'ENV{%s} => %s', $_, $ENV{$_} );
      }
    }

    $r->log->debug( sprintf 'CONTENT TYPE....[%s]',         $r->content_type // $EMPTY );
    $r->log->debug( sprintf 'SCRIPT_NAME.....[%s]',         $ENV{SCRIPT_NAME} );
    $r->log->debug( sprintf 'CONFIG_PATH.....[%s]',         $ENV{CONFIG_PATH} );
    $r->log->debug( sprintf 'BEDROCK_CONFIG_PATH.....[%s]', $ENV{BEDROCK_CONFIG_PATH} );
    $r->log->debug( sprintf 'PATH_INFO.......[%s]',         $ENV{PATH_INFO} );
    $r->log->debug( sprintf 'PATH_TRANSLATED.[%s]',         $ENV{PATH_TRANSLATED} );
    $r->log->debug( sprintf 'mod_perl........[%s]',         $ENV{MOD_PERL} );
    $r->log->debug( sprintf 'request file....[%s]',         $self->{file} );
    $r->log->debug( sprintf 'URI.............[%s]',         $r->uri || q{} );
    $r->log->debug( sprintf 'URI_DIR.........[%s]',         $self->{uri_dir} );
    $r->log->debug( sprintf 'URI_NAME........[%s]',         $self->{uri_name} );
    $r->log->debug( sprintf 'filename........[%s]',         $self->{filename} );
    $r->log->debug( sprintf 'path............[%s]',         $self->{path} );
  }

  return $self;
}

########################################################################
# full_path( path, filename, default-extension)
# returns a formatted fully qualifed pathname with a default extension
########################################################################
sub full_path {
########################################################################
  my ( $path, $name, $default_ext ) = @_;

  my $ext;

  ( $name, $path, $ext ) = fileparse( "$path/$name", qr/[.][^.]+$/xsm );

  return sprintf '%s%s%s', $path, $name, ( $ext || $default_ext );
}

########################################################################
# read_config(path, file)
# returns a Bedrock::Config object
########################################################################
sub read_config {
########################################################################
  my ( $self, $path, $filename ) = @_;

  return
    if !$path || !$filename;

  my $r = $self->request_handler;

  my $full_path = full_path( $path, $filename, '.xml' );

  my $config = eval { return Bedrock::Config->new($full_path); };

  if ( !$config || $EVAL_ERROR ) {

    mlogger(
      $r,
      level   => 'warn',
      message => sprintf 'error reading config: %s',
      Dumper(
        [ full_path => $full_path,
          error     => $EVAL_ERROR,
          os_error  => $OS_ERROR
        ]
      )
    );
  }
  else {
    $r->log->debug("successfully read $full_path");
    $self->config_files_processed($full_path);
  }

  return $config;
}

########################################################################
sub is_mod_perl {
########################################################################
  return $ENV{MOD_PERL};
}

########################################################################
sub apache_handler {
########################################################################
  my @args = @_;

  return _set_get( '_apache_handler', @args );
}

########################################################################
sub request_handler { goto &apache_handler; }
########################################################################

########################################################################
sub _log {
########################################################################
  my ( $self, $message, $level ) = @_;

  my $depth = 0;
  my @stack;

  while ( my @frame = caller( $depth++ ) ) {
    push @stack, \@frame;
  }

  my $frame;

  while ( $frame = pop @stack ) {
    last if $frame->[3] !~ /eval/xsm;
  }

  my $r = $self->request_handler;

  my $log_message = sprintf '%s[%s]: %s', $frame->[3], $frame->[2], $message;

  return $r->log->$level($log_message);
}

########################################################################
sub log_info  { return _log( @_, 'info' ) }   ## no critic (RequireArgUnpacking)
sub log_error { return _log( @_, 'error' ) }  ## no critic (RequireArgUnpacking)
sub log_warn  { return _log( @_, 'warn' ) }   ## no critic (RequireArgUnpacking)
sub log_debug { return _log( @_, 'debug' ) }  ## no critic (RequireArgUnpacking)
########################################################################

########################################################################
sub load_config_from_cache {
########################################################################
  my ($self) = @_;

  # note the only time $ENV{SERVER_NAME} should be undef is if we are
  # executing outside the web environment, in which case, caching
  # makes little sense.

  my $key = $ENV{SERVER_NAME} // $PROGRAM_NAME;  # for test t/00-cache.t

  my $r = $self->request_handler;

  my $cached_config = $BEDROCK_CONFIG_CACHE{$key};

  my $config = eval {
    if ($cached_config) {
      $r->log->debug('loading configuration from cache');
      return $cached_config;
    }
    else {
      return $self->get_bedrock_config;
    }
  };

  $config->{BEDROCK_CACHE_LOADED} //= scalar localtime;

  my $config_files_processed
    = $cached_config ? $cached_config->{_config_files_processed} : $self->{_config_files_processed};

  if ( !$cached_config || !%{$cached_config} ) {
    $config->{_config_files_processed} = $config_files_processed;

    $BEDROCK_CONFIG_CACHE{$key} = $config;
    delete $config->{_config_files_processed};
  }

  $self->merge_tagx_apps_configs( config => $config );

  if ($cached_config) {
    $self->{_config_files_processed} = [ $self->config_files_processed, @{$config_files_processed} ];
    delete $config->{_config_files_processed};
  }

  return $config;
}

########################################################################
sub load_config {
########################################################################
  my ($self) = @_;

  my $config = $self->config;

  return $config
    if $config;

  if ( $self->cache_enabled ) {
    $config = $self->load_config_from_cache;
  }
  else {
    $config = $self->get_bedrock_config;
  }

  return $self->config($config);
}

########################################################################
sub get_config { goto &load_config; }
########################################################################

# config(object) set config object
# config(key)    return specified key from config object
# config()       return config object
########################################################################
sub config {
########################################################################
  my ( $self, @args ) = @_;

  if ( $args[0] && ref $args[0] ) {
    $self->{_config} = $args[0];
  }
  elsif ( $args[0] ) {
    return $self->{_config}->{ $args[0] };
  }

  return $self->{_config};
}

########################################################################
sub get_uri_dir { goto &uri_dir; }
########################################################################

# set or get uri_dir
########################################################################
sub uri_dir {
########################################################################
  my (@args) = @_;

  return _set_get( 'uri_dir', @args );
}

########################################################################
sub restore_dir {
########################################################################
  my ($self) = @_;

  if ( $self->pwd ) {
    chdir $self->pwd;
  }

  return $self->pwd;
}

########################################################################
sub get_bedrock_admin_dir {
########################################################################
  my ($self) = @_;

  return $self->config('BEDROCK_ADMIN_DIR') || '/bedrock';
}

########################################################################
sub error {
########################################################################
  my ( $self, $err_msg, $code ) = @_;

  my $r = $self->request_handler;

  $code //= SERVER_ERROR;

  $r->log->error($err_msg);

  $self->restore_dir;

  return $code;
}

########################################################################
sub read_data_sources {
########################################################################
  my ( $self, @paths ) = @_;

  # look for data-sources.xml which defines database connection strings
  my $data_source_config = Bedrock::Config->new;

  $self->request_handler->log->debug( sprintf 'looking for data sources in: %s', join $COMMA, @paths );

  foreach my $p (@paths) {

    $self->request_handler->log->debug( sprintf 'path: %s', $p );

    my $config = $self->read_config( $p, 'data-sources' );

    if ($config) {
      $data_source_config->merge_config($config);
    }
  }

  return $data_source_config;
}

########################################################################
sub get_bedrock_config_path {
########################################################################
  my ( $self, $r ) = @_;

  $r //= $self->request_handler;

  my $bedrock_config_path = $ENV{BEDROCK_CONFIG_PATH} // $EMPTY;

  if ($bedrock_config_path) {
    $bedrock_config_path = realpath($bedrock_config_path) // $EMPTY;

    if ( !$bedrock_config_path ) {
      $r->log->error( 'invalid BEDROCK_CONFIG_PATH ' . $ENV{BEDROCK_CONFIG_PATH} );
    }
  }
  else {
    $r->log->error('No BEDROCK_CONFIG_PATH found. You probably have a misconfigured system.');
  }

  return $bedrock_config_path;
}

########################################################################
sub get_module_paths {
########################################################################
  my ( $self, %args ) = @_;

  my @paths = @{ $args{paths} };

  # -- look for module configs
  my @module_paths;

  # note the order is important here, we want local configurations
  # to override system configurations

  foreach my $p (@paths) {

    foreach my $dir (qw(startup plugin)) {
      next if $p !~ /[.]d$/xsm || !-d "$p/$dir";

      push @module_paths, "$p/$dir";
    }
  }

  return @module_paths;
}

########################################################################
sub merge_module_configs {
########################################################################
  my ( $self, %args ) = @_;

  my ( $r, $config, $module_paths ) = @args{qw(r config module_paths)};

  $r //= $self->request_handler;

  mlogger(
    $r,
    level   => 'debug',
    message => Dumper( [ module_paths => $module_paths ] )
  );

  foreach my $path ( @{$module_paths} ) {

    foreach my $file ( _list_xml_files($path) ) {
      $r->log->debug( sprintf 'Found a potential module configuration file: [%s]', $file );

      $r->log->debug( sprintf 'Merging [%s]', $file );

      $config = eval {
        my $module_config = Bedrock::Config->new($file);

        $config->merge_modules( { MODULES => [$module_config] } );

        return $config;
      };

      die "error processing $file\n$EVAL_ERROR\n"
        if !$config || $EVAL_ERROR;

      $self->config_files_processed($file);

    }
  }

  return;
}

########################################################################
sub get_custom_configs {
########################################################################
  my ( $self, %args ) = @_;

  my ( $paths, $module_paths, $config, $r ) = @args{qw(paths module_paths config r)};
  $r //= $self->request_handler;

  my @files_processed = $self->config_files_processed;

  foreach my $path ( @{$paths} ) {

    $r->log->debug( sprintf 'Searching [%s] for config files', $path );

    my @xml_files = _list_files(
      path   => $path,
      type   => 'xml',
      filter => [qw(tagx.xml tagx_apps.xml)]
    );

    foreach my $file (@xml_files) {
      if ( any { $file =~ /$_/xsm } @files_processed ) {
        $r->log->debug( sprintf 'skipping file %s ... already processed', $file );
        next;
      }

      $r->log->debug( sprintf 'Found a configuration file: [%s]', $file );

      my $rv = eval { $config->merge($file); };

      if ( !$rv || $EVAL_ERROR ) {
        $r->log->warn("could not merge $file");
      }
      else {
        $self->config_files_processed($file);
      }
    }
  }

  return;
}

########################################################################
sub get_config_paths {
########################################################################
  my ( $self, %args ) = @_;

  my ( $bedrock_config_path, $r ) = @args{qw(bedrock_config_path r)};

  $bedrock_config_path //= $self->get_bedrock_config_path;
  $r                   //= $self->request_handler;

  my @config_paths;

  if ( $ENV{CONFIG_PATH} ) {

    if ( $ENV{CONFIG_PATH} =~ /^:/xsm ) {
      @config_paths = $bedrock_config_path;
    }

    @config_paths = ( @config_paths, split /[:]/xsm, $ENV{CONFIG_PATH} );

    @config_paths = uniq map { realpath($_) } grep { $_ && -d $_ } @config_paths;
  }
  elsif ($bedrock_config_path) {

    $r->log->info( sprintf 'No application CONFIG_PATH found. Using BEDROCK_CONFIG_PATH:[%s]',
      $bedrock_config_path );
  }
  else {
    $r->log->error('No CONFIG_PATH or BEDROCK_CONFIG_PATH. You probably have a misconfigured system.');
  }

  return @config_paths;
}

########################################################################
sub get_bedrock_config {
########################################################################
  my ($self) = @_;

  my $r = $self->request_handler;

  my $bedrock_config_path = $self->get_bedrock_config_path($r) // $EMPTY;

  my @config_paths = $self->get_config_paths(
    bedrock_config_path => $bedrock_config_path,
    r                   => $r
  );

  # this potentially adds .d sub-directories
  my @paths = validate_config_paths( @config_paths, $bedrock_config_path );

  $r->log->debug( sprintf 'paths: %s', join $COMMA, @paths );

  my $config = $self->get_tagx_config(
    bedrock_config_path => $bedrock_config_path,
    config_paths        => \@config_paths,
    r                   => $r,
  );

  if ( !$config || !keys %{$config} ) {

    my $error = <<'END_OF_MESSAGE';
ERROR: No or empty 'tagx.xml'
  BEDROCK_CONFIG_PATH => [%s]
  CONFIG_PATH         => [%s]
END_OF_MESSAGE

    my $err = sprintf $error, $bedrock_config_path, ( join $SEMICOLON, @config_paths ) // $EMPTY;
    croak $err;
  }

  my $dbnames = $self->read_data_sources(@paths);
  $config->dbnames($dbnames);

  # -- look for module configs
  my @module_paths = $self->get_module_paths( paths => \@paths );

  mlogger( $r, level => 'debug', message => Dumper( [ \@module_paths ] ) );

  $self->merge_module_configs(
    config       => $config,
    module_paths => \@module_paths,
    r            => $r,
  );

  # -- extra configs
  $self->get_custom_configs(
    config       => $config,
    paths        => \@paths,
    module_paths => \@module_paths,
    r            => $r,
  );

  # -- not sure why we ever needed this line
  $config->{CONFIG_PATH} = join $SEMICOLON, grep {defined} @config_paths;

  # override use of BEDROCK_IMAGE_URL if app defines own
  if ( $config->{IMAGE_URL} ) {
    $config->{BEDROCK_IMAGE_URL} = $config->{IMAGE_URL};
  }

  # And voila! we have the merged config
  return $config;
}

########################################################################
sub get_tagx_config {
########################################################################
  my ( $self, %args ) = @_;

  my ( $bedrock_config_path, $config_paths, $r ) = @args{qw(bedrock_config_path config_paths r)};
  $r //= $self->request_handler;

  # it's probably okay, not to find this...
  my $config = $self->read_config( $bedrock_config_path, 'tagx' );

  # remove the path, since we just read the file
  if ($config) {
    $config_paths = [ grep { $_ ne $bedrock_config_path } @{$config_paths} ];
  }

  # RULE: tagx.xml must exist in root of the configuration path
  # RULE: the default tagx.xml should always have REPLACE_CONFIG eq 'yes'
  # RULE: if there is no default (Bedrock) tagx.xml, then take the first one found
  # RULE: if there is a default tagx.xml AND REPLACE_CONFIG eq 'yes', take last one found?
  # RULE: if there is a default tagx.xml AND REPLACE_CONFIG ne 'yes', merge configs
  if ( !$config ) {
    foreach ( @{$config_paths} ) {
      next if !-e "$_/tagx.xml" || /[.]d$/xsm;  # ignore .d/ path

      $config = $self->read_config( $_, 'tagx' );
      last if $config;
    }
  }
  elsif ( $config->{REPLACE_CONFIG} && $config->{REPLACE_CONFIG} =~ /^y/ixsm ) {
    foreach ( @{$config_paths} ) {
      next if !-e "$_/tagx.xml" || /[.]d$/xsm;

      $config = $self->read_config( $_, 'tagx' );
    }
  }
  else {
    # this doesn't necessarily make sense...but we'll merge all
    # tagx.xml files but last one always wins
    foreach ( @{$config_paths} ) {
      next if !-e "$_/tagx.xml" || /[.]d$/xsm;

      $config->merge_config( $self->read_config( $_, 'tagx' ) );
    }
  }

  return $config;
}

########################################################################
sub merge_tagx_apps_configs {
########################################################################
  my ( $self, %args ) = @_;

  my ( $config, $bedrock_config_path, $config_paths, $r )
    = @args{qw(config bedrock_config_path config_paths r)};

  $bedrock_config_path //= $self->get_bedrock_config_path;
  $r                   //= $self->request_handler;
  $config_paths        //= [ $self->get_config_paths ];

  # -- directory configs
  # directory configs are either typically in tagx_apps.xml
  # <object>
  #  <object name="/foo">
  #   ...
  #  </object>
  # </object>

  my $tagx_apps = $config->{'APP_CONFIG'};
  $r->log->debug( sprintf 'APP_CONFIG: %s', $tagx_apps // $EMPTY );

  if ( !$tagx_apps ) {
    $r->log->warn('no APP_CONFIG found in config object?');
    return;
  }

  if ($tagx_apps) {
    my $app_config = $self->read_config( $bedrock_config_path, $tagx_apps );

    mlogger(
      $r,
      level   => 'debug',
      message => 'found a root tagx_apps.xml ' . Dumper($app_config)
    );

    my $document_root = $ENV{DOCUMENT_ROOT};

    # you can only have custom tagx_app configurations if you have a
    # root level tagx_app file
    if ($app_config) {
      foreach my $path ( @{$config_paths} ) {
        my $custom_app_config = $self->read_config( $path, $tagx_apps );
        mlogger(
          $r,
          level   => 'debug',
          message => 'custom config: ' . Dumper($custom_app_config)
        );

        $app_config->merge_config($custom_app_config);
      }
    }

    if ( $app_config && keys %{$app_config} ) {
      # in case we have directory specific configuration files...
      my $dir = $self->get_uri_dir;

      if ( $dir && defined $document_root ) {
        $dir =~ s/^$document_root//xsm;
      }

      $dir = $dir // $EMPTY;

      $dir =~ s/\/$//xsm;

      $r->log->debug( sprintf 'directory: %s', $dir );

      foreach my $key ( keys %{$app_config} ) {
        if ( $key ne "$dir" ) {
          delete $app_config->{$key};
        }
      }

      # merge what's left since it must be our directory
      $config->merge_config( $app_config->{$dir} );
    }
  }

  return;
}

########################################################################
sub mlogger {
########################################################################
  my ( $r, %args ) = @_;

  my ( $level, $message ) = @args{qw(level message)};

  foreach ( split /\n/xsm, $message ) {
    $r->log->$level($_);
  }

  return;
}

########################################################################
sub _set_get {
########################################################################
  my ( $key, $self, @args ) = @_;

  if (@args) {
    $self->{$key} = $args[0];
  }

  return $self->{$key};
}

########################################################################
sub pwd {
########################################################################
  my (@args) = @_;

  return _set_get( '_pwd', @args );

}

########################################################################
sub config_files_processed {
########################################################################
  my ( $self, @args ) = @_;

  $self->{_config_files_processed} //= [];

  if (@args) {
    push @{ $self->{_config_files_processed} }, @args;
  }

  return @{ $self->{_config_files_processed} };
}

########################################################################
sub _find_files {
########################################################################
  my ( $path, $type, @filter ) = @_;

  my @files;

  no warnings 'File::Find';  ## no critic

  find(
    sub {
      my $name = $_;

      if ( /[.]$type$/xsm && !any { $_ eq $name } @filter ) {
        push @files, $File::Find::name;
      }
    },
    $path
  );

  return @files;
}

########################################################################
sub _list_files {
########################################################################
  my (%args) = @_;

  my ( $path, $type, $filter ) = @args{qw(path type filter)};

  return _find_files( $path, 'xml', @{$filter} );
}

########################################################################
sub _list_xml_files {
########################################################################
  my ( $path, @filter ) = @_;

  return _list_files( path => $path, type => 'xml', filter => \@filter );
}

1;

__END__

=pod

=head1 NAME

Bedrock::Handler - common Bedrock handler methods

=head1 SYNOPSIS

 my $bedrock_handler = Bedrock::Handler->new($r);

=head1 DESCRIPTION

Class used to provide some helper functions for writing Bedrock
request handlers.  Performs a common set of initialization activities
like creating Bedrock's configuration environment from the various
configuration files that are supported by Bedrock.

=head1 METHODS AND SUBROUTINES

=head2 new

 new( request-object )

Creates a new instance of a Bedrock handler object.

Set or get the Apache request handler.

=head2 load_config

 load_config()

Returns Bedrock's configuration object.  Note that the hash that is
returned is the fully exploded configuration environment for Bedrock.
The configuration (may) have come from the cache if caching has been
enabled.  See L<CONFIGURATION CACHING>

=head2 cache_enabled

Returns boolean value indicating if the configuration caching is
enabled.  Caching is enabled by setting the environment variable
BEDROCK_CACHE_CONFIG. Any of "on", "yes" or "y" will enable caching
(case insensitive).

default: off

=head2 config

Returns the fully merged Bedrock configuration object.

=head2 config_files_processed

=head2 error

Logs a message to the log file and restores the original directory.

=head2 full_path

 full_path(path, filename, default-extension)

Returns a formatted fully qualified path to a file with a default extension

=head2 get_config

Deprecated: use load_config()

=head1 GETTER/SETTER METHODS

=head2 get_bedrock_admin_dir

Returns the relative URI for the Bedrock documenation. Typically C</bedrock>.

=head2 get_uri_dir

Returns the directory portion of URI parsed from the request object's C<uri()> method.

=head2 request_handler

Returns the request object. Apache running with C<mod_perl> enabled will
return an L<Apache2::RequestRec> object.  If Bedrock is running as a
CGI this method will return an L<Apache::Bedrock::Request_cgi> object.

=head2 restore_dir

Restores the directory to the current working directory at the time
that this object was instantiated.

=head2 uri_dir

See L</get_uri_dir>

=head2 apache_handler (deprecated)

 apache_handler( [request-handler] )

Use L</request_handler> instead.

=head1 ENVIRONMENT METHODS

=head2 is_mod_perl

Boolean indicating whether C<mod_perl> is enabled.

=head2 pwd

Returns the mod_perl version string if mod_perl is enabled.

=head1 CONFIGURATION FILE METHODS

=head2 config

Returns the configuration object if it has been read.

=head2 get_bedrock_config

 get_bedrock_config()

Returns the configuration object. If it has not yet been initialized,
this method will attempt to load the configuration object by calling
C<load_config()>.

Bedrock looks for configuration files, including F<tagx.xml> in paths
indicated by C<$ENV{BEDROCK_CONFIG_PATH}> and C<$ENV{CONFIG_PATH}>.

If Bedrock detects multiple F<tagx.xml> files in your paths, Bedrock
will use the value of C<REPLACE_CONFIG> in the most recently read
configuration file to determine whether values in this F<tagx.xml>
should be merged or replace the previous configuration.

 <scalar name="REPLACE_CONFIG">yes</scalar>

=head2 load_config_from_cache

Loads the serialized configuration object from cache.

=head2 read_config

 read_config(path, file)

Reads a Bedrock configuration file and returns a C<Bedrock::Config>
object. Updates the C<config_files_processed> array.

=head2 read_data_source

Reads the F<data-sources.xml> file.

=head1 LOGGING METHODS

The methods are basically equivalent to Apache' request object methods
for logging. These methods will additionally log the caller and the
line number of the caller.

Equivalent to:

 my $r = $self->request_handler;

 $r->log->debug(sprintf '[%s]: %s %s', $caller, $caller_line_no, $message);

I<NOTE>:

=over 10

Apache's default log message size is apparently 8K. There does not
seem to be any way to increase that size. Apache will truncate message
longer than 8K.

=back

=head2 log_debug

Log a message with caller and caller's line number a the B<debug> level.

=head2 log_info

Log a message with caller and caller's line number a the B<info> level.

=head2 log_warn

Log a message with caller and caller's line number a the B<warn> level.

=head2 log_error

Log a message with caller and caller's line number a the B<error> level.

=head1 CONFIGURATION CACHING

Bedrock's configuration can be cached to potentially decrease startup
times. Caching is done using shared memory.

=head2 Why cache the configuration?

Creating Bedrock's configuration object is the result of merging
several different configuration files. Caching Bedrock's config
object can avoid a lot of config file mashing which includes; file
I/O, XML parsing, and merging of hash objects.

Caching of the configuration file can be used with C<mod_perl> or when
running Bedrock as a CGI, making Bedrock's startup times up to 50%
faster.

=head2 Initializing the Cache

A shared memory segment should be created sometime before the
Apache parent process is started (typically F<startup.pl>). It should
create the segment in a similar way as show below:

 tie %X, 'IPC::Shareable', { 
                            key     => 'BCFG', 
                            create  => 1, 
                            destroy => 0, 
                            size    => 256 * 1024
                           };

Note that use of the shared memory key C<BCFG> is not optional.  If you
want Bedrock to know about your shared memory segment, you and Bedrock
must agree on the key name - we chose C<BCFG>.

For a non-C<mod_perl> environment (Bedrock running as a Perl CGI script)
you would need to create the shared memory segment at boot time or
before your Apache server was started.  Also, you do NOT want the
shared memory destroyed when the process terminates, thus you would
set `destroy => 0' when tieing the object as shown above.

You also are responsible for providing some other way to
clean up the shared memory segment (if you were concerned about such
things).

=head2 Cache Size

The cache is populated with a serialized (Bedrock XML) version of the
config object.  Empirically you're going to need at least 128K or so
depending on how much data is contained in your configuration files.

Since Bedrock allows per directory configurations files, the size of
your configuration object could get quite large. You can learn more about
per directory configuation using I<tagx_apps.xml> on the L<Bedrock Wiki|http://twiki.openbedrock.net>..

Again, you shared memory segment size, must account for the
possibility that you might have a per directory configurations via
F<tagx_apps.xml>.  Thus the hash key for getting the configuration
object is based on the directory from which the object is being
served.  Make sure the size here and the size in your shared memory
initialization script agree.  Set the cached size (in MB) in the
Apache configuration file using the C<SetEnv> directive.  The default
is 256MB.

 SetEnv BEDROCK_CACHE_CONFIG On
 SetEnv BEDROCK_CACHE_CONFIG_SIZE 256

=head2 More Gory Details

In this module  we tie the hash object
(C<%BEDROCK_CONFIG_CACHE>) to the shared memory segment using the
C<IPC::Shareable> module.  We do this in an eval block in the event
that the shared memory is not available. If an error occurs during
the tie, we will have an empty hash object and thus cacheing is
disabled. The absence of the shared memory key is essentially then
our trigger to cache or not to cache.

When the Bedrock handler() method is invoked, we check the cache
before creating a config object.

 $BEDROCK_CONFIG_CACHE{$key};

If the serialized object exists, it gets used, if not, we do the
initialize the config object. The configuration object is then stored
as a serialized object back in the hash used to cache the
configurations.  If we're not caching, we do it anyway, no harm, no
foul here.

The I<key> used as the hash index into the cache (not to be confused
with the shared memory "key" that allows multiple processes to access
the same block of shared memory) is composed of the server name from
C<SERVER_NAME> environment variable and the absolute path to the file
being processed through the handler.  This is done because Bedrock
supports the possibility of per directory configurations.

Keeping in mind that the C<mod_perl> handler server many virtual hosts
so we need to make sure that the correct config object is accessed.
Using the key as described above to store and fetch the serialized
config object will (should) insure that the correct config object is
being used for the correct virtual host and for the correct directory
within that virtual host.  Did we mention that Bedrock allows per
directory configuration via F<tagx_apps.xml>?

The shared memory object should probably be destroyed when the Apache
parent is terminated.  Again, note that in this module
(C<Bedrock::Handler>) we neither create, nor destroy the shared memory
segment, we use it only if it is available.  In other words, if you
want to take advantage of caching you have some housekeeping to do.

=head2 Cache Manipulation

Flushing the config cache is a simple matter of executing this code:

 #!/usr/bin/perl

 use IPC::Shareable;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 %FOO = ();

Examing the cache is equally trivial

 #!/usr/bin/perl

 use IPC::Shareable;
 use Data::Dumper;

 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
 print Dumper( \%FOO );

...as is destroying the cache

 #!/usr/bin/perl

 use IPC::Shareable;
 
 tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };

 $FOO->remove();

=head2 What else should we cache?

Are there other opportunities to speed up Bedrock using caching?  At
first blush, no.  The whole point of a templating package is to merge
dynamic data with templates, so we never know what dynamic data is
being merged.  Of course, that's not always the case, or we might
designate some pages that do get parsed as I<cacheable> since
Bedrock parsing is not instantaneous.

Caching processed pages it seems then is generally a non-starter.
We could conceivably cache the raw Bedrock page avoiding the
disk access associated with reading C<.roc> and C<.inc> files into
memory.  Given the advances in the way the O/S handles caching of
disk objects, it seems like this might not be a place where a
great deal of additional benefit might be derived with optmizations
efforts - however I<YMMV>.

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
