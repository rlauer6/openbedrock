#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Iterator;

use strict;
use warnings;

use Bedrock::Constants qw{:booleans};

sub new {
  my ( $class, $array ) = shift;

  $class = ref $class || $class;

  my $self = bless { 'array' => $array, 'cur' => 0 }, $class;

  return $self;
}

sub pos {  ## no critic (ProhibitBuiltinHomonyms)
  my ($self) = @_;

  if ( $self->{'cur'} > @{ $self->{'array'} } ) {
    $self->{'cur'} = @{ $self->{'array'} };
  }

  return $self->{'cur'};
}

sub begin {
  my ($self) = @_;

  return $self->{'cur'} = 0;
}

sub end {
  my ($self) = @_;

  return $self->{'cur'} = @{ $self->{'array'} };
}

sub curr {
  my ($self) = @_;

  return $self->{'array'}->[ $self->{'cur'} ];
}

sub next {  ## no critic (ProhibitBuiltinHomonyms)
  my ($self) = @_;

  return $self->{'array'}->[ $self->{'cur'}++ ];
}

sub prev {
  my ($self) = @_;

  return $self->{'array'}->[ --$self->{'cur'} ];
}

sub valid {
  my ($self) = @_;

  my $cur = $self->{'cur'};

  return $cur >= 0 && $cur < @{ $self->{'array'} } ? $TRUE : $FALSE;
}

########################################################################
package Bedrock::Array;
########################################################################

use strict;
use warnings;

use Bedrock::BedrockJSON;
use Bedrock::Constants qw{ :chars :booleans};

use English qw{-no_match_vars};

use Scalar::Util qw/reftype/;
use Tie::Array;
use XML::Simple;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

BEGIN {
  use Exporter ();
  use vars qw (@ISA);
  @ISA = qw (Tie::StdArray);
}

########################################################################
sub TIEARRAY {
########################################################################
  my ( $class, @args ) = @_;

  my $self = bless [], $class;

  if (@args) {
    push @{$self}, @args;
  }

  return $self;
}

########################################################################
sub bedrock_xml {
########################################################################
  my ($self) = @_;

  require Bedrock::XML;

  return Bedrock::XML::writeXML($self);
}

########################################################################
sub devolve {
########################################################################
  my ($this) = @_;

  if ( ref($this) =~ /^HASH|ARRAY$/xsm ) {
    return $this;
  }
  elsif ( ref($this) =~ /Bedrock::Hash/xsm ) {
    my %that = map { $_ => devolve( $this->{$_} ) } keys %{$this};
    return \%that;
  }
  elsif ( ref($this) =~ /Bedrock::Array/xsm ) {
    return [ map { devolve($_) } @{$this} ];
  }
  else {
    return $this;
  }
}

########################################################################
sub get {
########################################################################
  my ( $self, $index ) = @_;

  return $self->[ $index + 0 ];
}

########################################################################
sub grep {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $pattern ) = @_;

  my $re = $pattern =~ /^qr/xsm ? eval $pattern : eval "qr/\$pattern/";

  die "Invalid pattern - $EVAL_ERROR "
    if $EVAL_ERROR;

  my @found = grep { $_ =~ $re } @{$self};

  return Bedrock::Array->new(@found);
}

########################################################################
sub isEmpty {  ## no critic (Capitalization)
########################################################################
  my ($self) = @_;

  return @{$self};
}

sub iterator {
  my ($self) = @_;

  return Bedrock::Iterator->new($self);
}

########################################################################
sub join {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $str ) = @_;

  $str //= $EMPTY;

  return CORE::join $str, @{$self};
}

########################################################################
sub json {
########################################################################
  my $self = CORE::shift;

  return Bedrock::JSON::encode( $self->devolve );
}

########################################################################
sub length {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ($self) = @_;

  return scalar @{$self};
}

########################################################################
sub list {
########################################################################
  my ( $self, $array ) = @_;

  $array //= $self;

  die "not an an array ref\n"
    if !ref $array || reftype($array) ne 'ARRAY';

  return @{$array};
}

########################################################################
sub new {
########################################################################
  my ( $class, @args ) = @_;
  $class = ref $class || $class;

  my $self = bless [], $class;
  tie @{$self}, $class, @args;  ## no critic (ProhibitTies)

  return $self;
}

########################################################################
sub map {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $fmt_str, @parms ) = @_;

  if ( !@parms ) {
    @parms = qw(value index);
  }

  my @out;

  my $index = 1;

  foreach my $value ( @{$self} ) {
    push @out,
      sprintf $fmt_str, @{ { value => $value, index => $index++ } }{@parms};
  }

  return wantarray ? Bedrock::Array->new(@out) : CORE::join( $EMPTY, @out );
}

########################################################################
sub matches {
########################################################################
  my ( $self, $str, $flags ) = @_;

  die "invalid flags: only i,m,g or s"
    if $flags && $flags !~ /^[imgs]+$/;

  my $re;
  my $g = $flags =~ s/g//;

  eval "\$re = qr/\$str/" . $flags;

  die "invalid regexp: $str\n$@\n"
    unless $re;

  my @result;

  if ($g) {
    foreach my $str ( @{$self} ) {
      push @result, $str =~ /$re/g;
    }
  }
  else {
    @result = CORE::grep { $_ =~ $re } @{$self};
  }

  return Bedrock::Array->new(@result);
}

########################################################################
sub pop {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my (@args) = @_;

  my $a = CORE::shift @args;

  if ( @args > 0 ) {
    my $count = CORE::shift @args;
    $count--;
    my @a;

    for ( 0 .. $count ) {
      CORE::unshift @a, CORE::pop @{$a};
    }
    return Bedrock::Array->new(@a);
  }
  else {
    return CORE::pop @{$a};
  }
}

########################################################################
sub push {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my (@args) = @_;

  my $a = CORE::shift @args;

  return CORE::push @{$a}, @args;
}

########################################################################
sub set {  ## no critic (ProhibitAmbiguousNames)
########################################################################
  my ( $self, @args ) = @_;

  my ( $index, $value ) = @args;

  my $old = $self->[$index];
  $self->[$index] = $value;

  return $old;
}

########################################################################
sub recordset {
########################################################################
  my ($self) = @_;

  return Bedrock::RecordSet->new($self);
}

########################################################################
sub reverse {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ($self) = @_;

  return Bedrock::Array->new( CORE::reverse @{$self} );
}

########################################################################
sub shift {  ## no critic  (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  if ( @args > 0 ) {
    my $count = CORE::shift @args;
    $count--;

    my @new_array;

    for ( 0 .. $count ) {
      CORE::push @new_array, CORE::shift @{$self};
    }

    return Bedrock::Array->new(@new_array);
  }
  else {
    return CORE::shift @{$self};
  }
}

sub sort {  ## no critic  (ProhibitBuiltinHomonyms)
  my ( $self, @args ) = @_;

  my ( $sort_dir, $sort_type ) = @args;

  $sort_dir = {
    $PLUS_SIGN  => 'asc',
    $MINUS_SIGN => 'desc',
  }->{$sort_dir};

  $sort_dir  //= 'asc';
  $sort_type //= 'alpha';

  my @sorted_list;

  if ( ( $sort_dir eq 'asc' ) && ( $sort_type =~ /^alpha/xsm ) ) {
    @sorted_list = sort { $a cmp $b } @{$self};
  }
  elsif ( ( $sort_dir eq 'desc' ) && ( $sort_type =~ /^alpha/xsm ) ) {
    @sorted_list = sort { $a cmp $b } CORE::reverse @{$self};
  }
  elsif ( ( $sort_dir eq 'asc' ) && ( $sort_type =~ /^num/xsm ) ) {
    @sorted_list = sort { $a <=> $b } @{$self};
  }
  elsif ( ( $sort_dir eq 'desc' ) && ( $sort_type =~ /^num/xsm ) ) {
    @sorted_list = sort { $a <=> $b } CORE::reverse @{$self};
  }

  return Bedrock::Array->new(@sorted_list);
}

sub splice {
  my $self   = CORE::shift;
  my $offset = CORE::shift || 0;

  # Passing args to splice as splice @{$self}, @_ wouldn't work
  # Need to shift the offset and length out of the args and then invoke
  # splice() with explicit args as show below

  if ( @_ == 0 ) {
    return Bedrock::Array->new( splice @{$self}, $offset );
  }
  elsif ( @_ == 1 ) {
    my $length = CORE::shift;
    return Bedrock::Array->new( splice @{$self}, $offset, $length );
  }
  else {
    my $length = CORE::shift;
    return Bedrock::Array->new( splice @{$self}, $offset, $length, @_ );
  }
}

sub unshift {
  my $self = CORE::shift;

  CORE::unshift @{$self}, @_;
}

sub xml {
  my $self    = CORE::shift;
  my %options = @_;

  return XMLout( $self, %options );
}

package Bedrock::Array::Reference;

use Scalar::Util qw/reftype/;
use vars qw{@ISA};

@ISA = qw(Bedrock::Array);

sub TIEARRAY {
  my ( $class, $array ) = @_;

  $array //= [];

  return bless $array, $class;
}

sub new {
  my ( $proto, $ref ) = @_;

  my $class = ref $proto || $proto;

  die 'Not an ARRAY reference - ' . ref $ref
    if !ref $ref || reftype($ref) ne 'ARRAY';

  my $self = [];

  return tie @{$self}, $class, $ref;
}

package Bedrock::RecordSet;

use Scalar::Util qw/reftype/;
use English qw{-no_match_vars};

use vars qw{@ISA};

@ISA = qw(Bedrock::Array::Reference);

sub new {
  my ( $class, @args ) = @_;

  $class = ref $class || $class;

  my $ref
    = ref $args[0] && reftype( $args[0] ) eq 'ARRAY' ? shift @args : [@args];

  foreach ( @{$ref} ) {
    die "invalid element type: must be hash reference - not [$_]\n"
      if !ref $_ || reftype($_) ne 'HASH';
  }

  my $self = [];

  return tie @{$self}, $class, $ref;
}

sub sort {
  my ( $array, @args ) = @_;

  ## no critic (RequireInterpolatinOfMetachars)
  my @sort_string;

  while (@args) {

    my $field = shift @args;
    my $order = shift @args;
    my $type  = shift @args;

    $order = $order || 'asc';
    $type  = $type  || 'alpha';

    push @sort_string, sprintf q($%s->{%s} %s $%s->{%s}),
      ( $order =~ /^a/i ) ? 'a' : 'b',
      $field,
      ( $type  =~ /^n/i ) ? '<=>' : 'cmp',
      ( $order =~ /^a/i ) ? 'b'   : 'a',
      $field;
  }

  my @sorted_array;

  my $sort_cmd = '@sorted_array = sort { ' . CORE::join q{||},
    @sort_string . ' } @{$array};';

  eval "$sort_cmd";  ## no critic (ProhibitStringyEval)

  die "error sorting: $EVAL_ERROR\n"
    if $EVAL_ERROR;

  return Bedrock::RecordSet->new( \@sorted_array );
}

sub STORE {
  my ( $obj, $key, $value ) = @_;

  die "invalid element type: must be hash reference\n"
    if !ref $value || reftype($value) ne 'HASH';

  my $self = tied @{$obj};

  return $self->SUPER::STORE( $key, $value );
}

sub PUSH {
  my ( $obj, @args ) = @_;

  foreach (@args) {
    die "invalid element type: must be hash reference"
      if !ref($_) || reftype($_) ne 'HASH';
  }

  my $self = tied @{$obj};

  return $self->SUPER::PUSH(@args);
}

sub push {  ## no critic (ProhibitBuiltinHomonyms)
  my ( $self, @args ) = @_;

  if ( ref $args[0] && reftype( $args[0] ) eq 'ARRAY' ) {
    foreach ( @{ $args[0] } ) {
      $self->SUPER::push($_);
    }
  }
  elsif ( ref $args[0] && reftype( $args[0] ) eq 'HASH' ) {
    $self->SUPER::push( Bedrock::Hash->new( %{ $args[0] } ) );
  }
  else {
    $self->SUPER::push( Bedrock::Hash->new(@args) );
  }

  return $self;
}

sub grep {  ## no critic (ProhibitBuiltinHomonyms)
  my ( $self, $key, $pattern ) = @_;

  my $re = $pattern =~ /^qr/ ? eval $pattern : eval "qr/\$pattern/";

  die "Invalid pattern - $EVAL_ERROR "
    if $EVAL_ERROR;

  return Bedrock::RecordSet->new( map { $_->{$key} =~ $re ? $_ : () }
      @{$self} );
}

package Bedrock::List;

use vars qw{@ISA};

@ISA = qw(Bedrock::Array);

1;

=pod

=head1 NAME

C<Bedrock::Array> - Implements an array object.

=head1 DESCRIPTION

Implements a Bedrock array object with many interesting methods.

=head1 SYNOPSIS

 my $array = new Bedrock::Array( qw/a b c d e f/ );

 <null --define-array="array" a b c d e f >

=head1 METHODS AND SUBROUTINES

=head2 get

=head2 grep

=head2 join

=head2 json

=head2 isEmpty

=head2 length

=head2 list

=head2 pop

=head2 push

=head2 set

=head2 sort

=head2 splice

=head2 unshift

=head2 map

=head2 bedrock_xml

=head2 xml

=head1 AUTHOR

J. Sridhar

=head1 SEE OTHER

E<lt>arrayE<gt>

=cut
