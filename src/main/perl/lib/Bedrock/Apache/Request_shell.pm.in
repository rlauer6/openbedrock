#!@PERL@

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Request_shell;

use strict;

use File::Basename;
use File::Temp;
use Cwd;

use Bedrock::VERSION;

use Getopt::Long qw/:config permute/;
use AppConfig qw/ARGCOUNT_NONE ARGCOUNT_ONE/;

use constant MSG_ABORT    => 1 << 0;
use constant MSG_DEBUG    => 1 << 1;
use constant MSG_INFO     => 1 << 2;
use constant MSG_STATUS   => 1 << 3;
use constant MSG_WARNING  => 1 << 4;
use constant MSG_ERROR    => 1 << 5;
use constant MSG_SYSERROR => 1 << 6;
use constant MSG_FATAL    => 1 << 7;

sub log {
  return $_[0];
}

sub get_loglevel_str {
  my $self = shift;
  
  return $self->{options}->{loglevel};
}

sub debug {
  my $self = shift;

  warn @_ if $self->{_loglevel} <= MSG_DEBUG;
}

sub info {
  my $self = shift;

  warn @_ if $self->{_loglevel} <= MSG_INFO;
}

sub error {
  my $self = shift;

  warn @_ if $self->{_loglevel} <= MSG_ERROR;
}

sub warn {
  my $self = shift;

  warn @_ if $self->{_loglevel} <= MSG_WARNING;
}

sub log_error {
  my $self = shift;
  print STDERR "@_";
  close STDERR;

  open STDERR, ">&OLD_STDERR";
}

sub content_type {
  'text/html';
}

sub filename {
  my $self = shift;
  $self->{'input'};
}

sub finfo {
  my $self = shift;
  $self->{'input'};
}

sub uri {
  my $self = shift;
  $self->{'input'};
}

sub args {
  my $self = shift;
  @{ $self->{'argv'} };
}

sub content {
  ();
}

sub headers_in {
  ();
}

sub cgi_header_out {
}

sub err_headers_out {
}

sub header_out {
}

sub send_http_header {
}

sub close {
}

sub print {
  my $self = shift;
  print @_;
}

sub usage {
  my $self = shift;
  my $prog = basename($0);
  die "Usage: $prog [options] <File> [ {varname value} ..]
OPTIONS

  --config <ConfigDir>
      Look for configuration file(s) in <ConfigDir>.
      (default: /usr/lib/bedrock/config)

  --logfile <LogFile>
      (default: /tmp/bedrock.log)

  --loglevel LEVEL
      ( LEVEL: debug, info, warn, error )

  --db <DatabaseName>
      Sets the default database connection to name from .bedrock_rc
      (default 'database')

  --help this

  --version report Bedrock version
";
}

sub new {
  my $class = shift;
  my $self = bless {}, $class;

  $self->{'options'} = { logfile  => '/tmp/bedrock-shell.log',
                         loglevel => 'warn',
                         cleanup  => 1,
                         tempdir  => '.',
                         db       => 'database',
                         config   => $ENV{CONFIG_PATH}
                       };

  # look for a .bedrock_rc
  if ( exists $ENV{HOME} && -s $ENV{HOME} . "/.bedrock_rc" ) {
    $self->{config} = AppConfig->new( { CASE   => 1,
                                        CREATE => 1,
                                        ERROR  => sub { },
                                        GLOBAL => { ARGCOUNT => ARGCOUNT_ONE }
                                      },
                                    );

    $self->{config}->define( 'cleanup' => { ARGCOUNT => ARGCOUNT_NONE } );

    $self->{config}->file( $ENV{HOME} . "/.bedrock_rc" );

    my %varlist = $self->{config}->varlist('.');

    $ENV{CONFIG_PATH} = $self->{config}->config() if exists $varlist{config};
    $self->{'options'}->{'logfile'} = $self->{config}->logfile()
    if exists $varlist{logfile};
    $self->{'options'}->{'loglevel'} = $self->{config}->loglevel()
    if exists $varlist{loglevel};
    $self->{'options'}->{'tempdir'} = $self->{config}->tempdir()
    if exists $varlist{tempdir};
    $self->{'options'}->{'cleanup'} = $self->{config}->cleanup()
    if exists $varlist{cleanup};
  }

  $self->{'argv'} = [];

  my $result;

  eval {
    $result = GetOptions(
      $self->{'options'},
      'config=s',
      'logfile=s',
      'loglevel=s',
      'db=s', 'help',
      'version',
      '<>' => sub {
        my $arg = shift;

        if ( $arg =~ /^(\w[^=]*=.*?)/ ) {
          push @{ $self->{'argv'} }, "$arg";
        }
        else {
          $self->{'input'} = "$arg";
        }
      }
    );
  };

  if ($@) {
    my ($emsg) = split /\r/, $@;

    #print $emsg;
  }

  # set loglevel
  for ( $self->{options}->{loglevel} ) {
    /debug/i && do {
      $self->{_loglevel} = MSG_DEBUG;
      last;
    };

    /info/i && do {
      $self->{_loglevel} = MSG_INFO;
      last;
    };
    /warn/i && do {
      $self->{_loglevel} = MSG_WARNING;
      last;
    };

    /error/i && do {
      $self->{_loglevel} = MSG_ERROR;
      last;
    };
  }

  if ( defined $self->{options}->{version} ) {
    printf( "Bedrock Version %s\n",     $Bedrock::VERSION::ID );
    printf( "Bedrock Build Date: %s\n", $Bedrock::VERSION::BUILD_DATE );
    print <<eot;

Check out http://www.openbedrock.net
Copyright (C) 2001, Charles Jones, LLC

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
eot

    exit;
  }

  $self->usage if $self->{'options'}->{'help'} or not $result;

  # Export config path into environment
  # the line below is generated by automake
  $ENV{BEDROCK_CONFIG_PATH} = '/usr/lib/bedrock/config';
  $ENV{CONFIG_PATH}         = $self->{'options'}->{'config'};

  my $db = $self->{'options'}->{'db'};
  if ( defined $db && exists $self->{'config'} ) {
    if ( $self->{'config'}->get( $db . '_db' ) ) {
      $ENV{DBI_DSN} = $ENV{DBI_DSN} || $self->{'config'}->get( $db . '_db' );
      $ENV{DBI_USER} = $ENV{DBI_USER}
      || $self->{'config'}->get( $db . '_username' );
      $ENV{DBI_PASS} = $ENV{DBI_PASS}
      || $self->{'config'}->get( $db . '_password' );
    }
  }

  if ( $self->{'input'} ) {
    $self->{'input'} = getcwd . '/' . $self->{'input'}
    unless $self->{'input'} =~ /^\//;
  }
  else {

    # Handling input
    my $fh = File::Temp->new( TEMPLATE => 'bedrock-shellXXXXX',
                              SUFFIX   => '.roc',
                              DIR      => $self->{'options'}->{'tempdir'},
                              UNLINK   => $self->{'options'}->{'cleanup'}
                            );

    $self->{'options'}->{'fh'} = $fh;
    my $script;
    {
      local $/;
      $script = <>;
    }
    print $fh "$script";
    close $fh;
    $self->{'_tempfile'} = $fh->filename;
    $self->{'input'}     = $fh->filename;

    # note that for STDIN the DOCUMENT_ROOT is the cwd
    $ENV{DOCUMENT_ROOT} = getcwd;
  }

  die "Input file not specified.\n" unless $self->{'input'};
  die "Unable to open input file `$self->{'input'}'\n"
  unless -f $self->{'input'};

  @ARGV = @{ $self->{'argv'} };

  $ENV{DOCUMENT_ROOT} = dirname( $self->{'input'} )
    unless $ENV{DOCUMENT_ROOT};

  open( OLD_STDERR, ">&STDERR" ) or die "Failed to save STDERR";
  open STDERR, ">>" . $self->{'options'}->{'logfile'}
  or die "Unable to open log file " . $self->{'options'}->{'logfile'};

  $self;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.18  2013/05/12 14:45:36  rlauer
# - add implementation of get_loglevel_str()
#
# Revision 1.17  2012/07/31 20:14:30  lauerrc
# - loglevel option not specified in GetOptions
#
# Revision 1.16  2011/09/15 16:05:32  eutl420
# - perl tidy
#
# Revision 1.15  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.14  2011/07/13 18:05:01  eutl420
# - don't override options unless there are values defined in .bedrock_rc to take their place
#
# Revision 1.13  2011/07/06 19:07:56  eutl420
# - added --version to give up Bedrock version number
# - trap bad options by placing eval around GetOptions
#
# Revision 1.12  2011/07/06 16:18:01  eutl420
# - look for $CONFIG_PATH in the environment
# - set the $DOCUMENT_ROOT only if not set already in the environment.  Set it to the cwd if necessary.
#   Necessary is defined as bedrock shell was invoked with no path name for the file or
#   bedrock shell was invoked with no input file (from STDIN)
#
# Revision 1.11  2011/04/02 17:06:00  eutl420
# - check to see if we have a .bedrock_rc config object before accessing it
#
# Revision 1.10  2011/04/01 22:57:37  eutl420
# - when processing arguments with the Getopt::Long callback mechanism
#   the argument is actually and object that stringifies, so since we do not
#   want a reference to an object, but a scalar, do this "$arg" to interpolate
#   the string to a scalar.
#
# Revision 1.9  2011/04/01 18:21:18  eutl420
# - set $self->{'argv'} regardless so that @ARGV gets set properly
#
# Revision 1.8  2011/03/31 00:11:30  eutl420
# - use a call back to process GetOption arguments so we can recognize
#   a file argument versus the CGI style args
# - import the 'permute' option to support above see perldoc Getopt::Long
#
# Revision 1.7  2011/03/30 18:15:41  eutl420
# - use strict, AppConfig, File::Temp
# - in log_error method we no longer just die, first output error to
#   current STDERR log, then re-open original STDERR and return to caller
# - in usage() method, describe new options logfile, db
# - read a .bedrock_rc file if it exists and process arguments
# - bedrock shell will now read from STDIN assuming it is a script.  does this by writing
#   a temporary file for Bedrock to process
# - we now preserve STDERR before redirecting processing errors to log file, this way we can
#   print a meaningful error message to STDERR
#
# Revision 1.6  2011/03/29 15:25:04  eutl420
# - set the default initial log file to /tmp/bedrock-shell.log
# - GetOptions wants hash ref first
#
# Revision 1.5  2011/03/29 14:15:16  eutl420
# - renamed the file in CVS to Request_shell.pm.in so we can use automake tokens to set certain configuration
#   options
# - redirect STDERR to logfile on startup to avoid noise
# - added a new bedrock command line options --logfile, defaults to /tmp/bedrock.log
# - use @\PERL@
# - set $ENV{DOCUMENT_ROOT} to directory of file being processed
# - info() method was not passing argument
# - added methods err_headers_out, header_out though these will never be used by bedrock shell
# - removed default config for GetOptions since the default is set by setting $ENV{BEDROCK_CONFIG_PATH}
#
# Revision 1.4  2010/11/29 15:57:52  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.3  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.2  2001/02/14 15:35:43  sridhar
# Added copyright and GPL notice
#
# Revision 1.1  2001/01/18 18:37:29  sridhar
# Initial version of Apache::Request_shell, a module which mimicks the
# Apache request object for the shell environment.
#
#
