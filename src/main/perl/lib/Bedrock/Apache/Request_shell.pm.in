#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Request_shell;

use strict;
use warnings;

use AppConfig qw{ARGCOUNT_NONE ARGCOUNT_ONE};
use Bedrock::Constants qw{:chars :booleans};
use Bedrock::VERSION qw{ $ID $BUILD_DATE $RELEASE};
use Cwd qw{ getcwd realpath };
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Temp;
use Getopt::Long qw{:config permute no_ignore_case};
use Log::Log4perl::Level;

use Role::Tiny::With;
with 'Bedrock::Logger';

use Readonly;

Readonly::Hash our %LEVELS => (
  debug => $DEBUG,
  info  => $INFO,
  warn  => $WARN,
  error => $ERROR,
  fatal => $FATAL,
);

Readonly our $BEDROCK_CONFIG_PATH => '@libdir@/bedrock/config';  ## no critic (RequireInterpolationOfMetachars)

########################################################################
sub new {
########################################################################
  my ($class) = @_;

  my $self = bless {}, $class;

  my $HOME = $ENV{HOME} || $DOT;

  my $default_rc_file;

  if ( -s $HOME . '/.bedrock_rc' ) {
    $default_rc_file = $HOME . '/.bedrock_rc';
  }

  $self->{'argv'} = [];

  my $result;

  $self->{'options'} = {};

  eval {
    $result = GetOptions(
      $self->{'options'},
      'config=s',
      'db=s', 'help|?',
      'infile=s',
      'logfile|l=s',
      'loglevel|L=s',
      'mime-type=s',
      'outfile=s',
      'rc=s',
      'version|V',
      '<>' => sub {
        my $arg = shift;

        if ( $arg =~ /^(\w[^=]*=.*?)/xsm ) {
          push @{ $self->{'argv'} }, "$arg";
        }
        else {
          $self->{'input'} = "$arg";  # usually filename.roc
        }
      },
    );
  };

  if ( $self->{'options'}->{'help'} || !$result ) {
    $self->usage;
  }

  if ( defined $self->{options}->{version} ) {
    version( $ID, $RELEASE, $BUILD_DATE );
    exit 0;
  }

  # read config from resource file if specified

  if ( $self->{options}->{rc} ) {

    if ( !-s $self->{options}->{rc} ) {
      die sprintf "unable to read resource file: %s\n",
        $self->{options}->{rc};

      exit -1;
    }

    $self->{config} = AppConfig->new(
      { CASE   => $TRUE,
        CREATE => $TRUE,
        ERROR  => sub { },
        GLOBAL => { ARGCOUNT => ARGCOUNT_ONE },
      },
    );

    $self->{config}->define( 'cleanup' => { ARGCOUNT => ARGCOUNT_NONE } );

    $self->{config}->file( $self->{options}->{rc} );

    my %varlist = $self->{config}->varlist($DOT);

    # command line overrides the value in resource file for these options
    if ( exists $varlist{config} && !$self->{options}->{config} ) {
      ## no critic (RequireLocalizedPunctuationVars)
      $ENV{CONFIG_PATH} = realpath( $self->{config}->config() );
    }

    if ( exists $varlist{logfile} && !$self->{options}->{logfile} ) {
      $self->{'options'}->{'logfile'} = $self->{config}->logfile();
    }

    if ( exists $varlist{loglevel} && !$self->{options}->{loglevel} ) {
      $self->{'options'}->{'loglevel'} = $self->{config}->loglevel();
    }

    if ( exists $varlist{tempdir} && !$self->{options}->{tempdir} ) {
      $self->{'options'}->{'tempdir'} = $self->{config}->tempdir();
    }

    if ( exists $varlist{cleanup} && !$self->{options}->{cleanup} ) {
      $self->{'options'}->{'cleanup'} = $self->{config}->cleanup();
    }

    if ( exists $varlist{db} && !$self->{options}->{db} ) {
      $self->{'options'}->{'db'} = $self->{config}->db();
    }
  }

  my %defaults = (
    rc       => $default_rc_file,
    tempdir  => $DOT,
    db       => 'database',
    loglevel => 'warn',
    logfile  => '/tmp/bedrock.log',
    cleanup  => $FALSE,
    tempdir  => $DOT,
    rc       => $HOME . '/.bedrock_rc',
    db       => 'database',
    config   => realpath( $ENV{CONFIG_PATH} // $EMPTY ),
  );

  # set default values
  foreach ( keys %defaults ) {
    next if exists $self->{options}->{$_};
    $self->{options}->{$_} = $defaults{$_};
  }

  # directly specify input file
  if ( defined $self->{options}->{infile} ) {
    $self->{input} = $self->{options}->{infile};
  }

  # redirect STDOUT
  if ( defined $self->{options}->{outfile} ) {
    my $file = $self->{options}->{outfile};

    open STDOUT, '>', $file
      or die "could not open [$file] for output";

    STDOUT->autoflush(1);
  }

  # error parsing input arguments
  if ($EVAL_ERROR) {
    my ($emsg) = split /\r/xsm, $EVAL_ERROR;

    die $emsg;
  }

  # set loglevel
  my $level = $self->{options}->{loglevel} // 'error';

  my $logfile = $self->{options}->{logfile};

  my $log4perl_conf .= <<"END_OF_CONFIG";
log4perl.rootLogger=INFO, Bedrock
log4perl.appender.Bedrock=Log::Log4perl::Appender::File
log4perl.appender.Bedrock.filename = $logfile
log4perl.appender.Bedrock.mode=append
log4perl.appender.Bedrock.layout=PatternLayout
log4perl.appender.Bedrock.layout.ConversionPattern=%d (%r) (%p) [%P] [%l] %c - %m%n
log4perl.category.Bedrock=ERROR, Bedrock
log4perl.additivity.Bedrock.additivity=0
log4perl.category.TagX=ERROR, Bedrock
log4perl.additivity.TagX=0
END_OF_CONFIG

  Log::Log4perl->init( \$log4perl_conf );

  $self->get_logger('Bedrock')->level( $LEVELS{ lc $level } );

  # Export config path into environment...the line below is generated by automake
  {
    ## no critic (RequireLocalizedPunctuationVars)
    $ENV{BEDROCK_CONFIG_PATH} = $BEDROCK_CONFIG_PATH;
    $ENV{CONFIG_PATH}         = $self->{'options'}->{'config'}
      // $BEDROCK_CONFIG_PATH;
  }

  my $db = $self->{'options'}->{'db'};

  if ( defined $db && exists $self->{'config'} ) {
    if ( $self->{'config'}->get( $db . '_db' ) ) {
      ## no critic (RequireLocalizedPunctuationVars)
      $ENV{DBI_DSN}
        = $ENV{DBI_DSN} || $self->{'config'}->get( $db . '_db' );

      $ENV{DBI_USER} = $ENV{DBI_USER}
        || $self->{'config'}->get( $db . '_username' );

      $ENV{DBI_PASS} = $ENV{DBI_PASS}
        || $self->{'config'}->get( $db . '_password' );
    }
  }

  if ( $self->{'input'} ) {
    if ( $self->{'input'} !~ /^\//xsm ) {
      $self->{'input'} = sprintf '%s/%s', getcwd, $self->{'input'};
    }

    # collect STDIN as POSTDATA
    if ( !-t *STDOUT ) {  ## no critic (ProhibitInteractiveTest)
      local $RS = undef;

      push @{ $self->{argv} }, 'POSTDATA=' . <>;
    }
  }
  else {

    # Handling input
    my $fh = File::Temp->new(
      TEMPLATE => 'bedrock-shell-XXXXX',
      SUFFIX   => '.roc',
      DIR      => $self->{'options'}->{'tempdir'},
      UNLINK   => $self->{'options'}->{'cleanup'}
    );

    $self->{'options'}->{'fh'} = $fh;

    my $script;

    {
      local $RS = undef;

      $script = <>;
    }

    $fh->print($script);

    $fh->close();

    $self->{'_tempfile'} = $fh->filename;
    $self->{'input'}     = $fh->filename;

    # note that for STDIN the DOCUMENT_ROOT is the cwd
    $ENV{DOCUMENT_ROOT} = getcwd;  ## no critic (RequireLocalizedPunctuationVars)
  }

  die "Input file not specified.\n"
    if !$self->{'input'};

  die "Unable to open input file `$self->{'input'}'\n"
    if !-f $self->{'input'};

  local @ARGV = @{ $self->{'argv'} };

  $ENV{DOCUMENT_ROOT} //= dirname( $self->{'input'} );

  # someone may be redirecting STDERR
  open my $stderr_old, '>&', STDERR  ## no critic (RequireBriefOpen)
    or die 'Failed to save STDERR';

  # but we're going to send all messages to our log file
  open STDERR, '>>', $self->{'options'}->{'logfile'}
    or die 'Unable to open log file ' . $self->{'options'}->{'logfile'};

  # make it hot
  STDERR->autoflush($TRUE);

  $self->debug( sprintf 'using resource file: %s', $self->{options}->{rc} );

  return $self;
}

########################################################################
sub version {
########################################################################
  my (@version_parts) = @_;

  printf "Bedrock Version %s-%s (%s)\n", @version_parts;

  print <<'END_OF_COPYRIGHT';
Copyright (C) 2001, Charles Jones, LLC
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl-2.0.html>

Additional documentation can be found at <http://www.openbedrock.net>

Written by Jay Sridhar, Rob Lauer <rclauer@gmail.com>
END_OF_COPYRIGHT

  return;
}

########################################################################
sub get_loglevel_str {
########################################################################
  my ($self) = @_;

  return $self->{options}->{loglevel};
}

########################################################################
sub _log {
########################################################################
  my ( $level, $self, @args ) = @_;

  return $self->get_logger->$level(@args);
}

{
  ## no critic (ProhibitBuiltinHomonyms, ProhibitAmbiguousNames)

########################################################################
  sub trace { my (@args) = @_; return _log( 'trace', @args ) }
  sub debug { my (@args) = @_; return _log( 'debug', @args ) }
  sub info  { my (@args) = @_; return _log( 'info',  @args ) }
  sub warn  { my (@args) = @_; return _log( 'warn',  @args ) }
  sub error { my (@args) = @_; return _log( 'error', @args ) }
  sub fatal { my (@args) = @_; return _log( 'fatal', @args ) }
  sub close { return; }
  sub print { my ( $self, @args ) = @_; return print @args; }

  sub log {
    my $self = shift;

    return $self->get_logger;
  }

########################################################################
}

########################################################################
sub log_error {
########################################################################
  my ( $self, @args ) = @_;

  return $self->error(@args);
}

########################################################################
sub content_type {
########################################################################
  my ( $self, $type ) = @_;

  if ($EVAL_ERROR) {
    $self->{content_type} = $type;
  }

  return $self->{'content_type'} || 'text/plain';
}

########################################################################
sub filename { my ($self) = @_; return $self->{'input'}; }
sub finfo    { my ($self) = @_; return $self->{'input'}; }
sub uri      { my ($self) = @_; return $self->{'input'}; }

########################################################################
sub args { my ($self) = @_; return @{ $self->{'argv'} }; }

########################################################################
sub content          { return (); }
sub headers_in       { return (); }
sub cgi_header_out   { return; }
sub err_headers_out  { return; }
sub header_out       { return; }
sub send_http_header { return; }

########################################################################
sub usage {
  my ($self) = @_;

  my $prog = basename($PROGRAM_NAME);

  my $usage = <<"END_OF_USAGE";
Usage: $prog [OPTION...] [FILE] [KEY=VALUE]...
OPTIONS

  -c, --config=DIR          - configuration directory (default: /usr/lib/bedrock/config)
  -r, --rc=FILE             - resource file (default: ~/.bedrock_rc)
  -d, --db=NAME             - default database connection to name from .bedrock_rc (default 'database')
  -h, --help                - help this
  -i, --infile              - input file (default: STDIN)
  -o, --outfile             - output file (default: STDOUT)
  -l, --logfile=FILE        - log file (default: /tmp/bedrock-shell.log)
  -L, --loglevel=LEVEL      - debug, info, warn, error (default: info)
  -m, --mime-type=MIME-TYPE - set the content header (default: text/plain)
  -V, --version             - report Bedrock version

Report bugs to <bugs\@openbedrock.net>
END_OF_USAGE

  die $usage;
}

1;

__END__
