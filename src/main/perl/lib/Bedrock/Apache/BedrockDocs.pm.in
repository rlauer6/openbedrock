#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::BedrockDocs;

# TODO:
# [ ] option to disable traversing all sub-directories
# [ ] collapsible directories

use strict;
use warnings;

use Bedrock qw{:booleans slurp_file};
use Bedrock::Apache::Constants qw{:http};
use Bedrock::BedrockConfig;
use Bedrock::Constants qw{:regexp :chars :booleans :defaults};
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::Template;
use Bedrock::VERSION qw{version};
use bedrock_handler_common;

use Carp;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Temp;
use File::Find;
use Markdown::Render;
use Pod::Html;
use Scalar::Util qw{ reftype blessed};
use List::Util qw{ any pairs none};
use Text::URLEncode;

use Readonly;

Readonly our $DEFAULT_IMAGE_URL => '/bedrock/img';
Readonly our $POD_MIN_SIZE      => 600;

our @TAG_LIST;

if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
  @TAG_LIST = sort split /[|]/xsm, $1;
  @TAG_LIST = grep { !/[#]|else|else[?]if|blm|[?]/xsm } @TAG_LIST;
}

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  my $bedrock_handler = eval { return init_bedrock_handler($r); };

  if ( $EVAL_ERROR || !$bedrock_handler ) {
    $r->log->error(qq{Could not initialize Bedrock's handler\n$EVAL_ERROR});

    return $SERVER_ERROR;
  }

  my $config = $bedrock_handler->config();

  my $bedrock_info = $config->{ALLOW_BEDROCK_INFO} // $EMPTY;

  if ( none { lc $bedrock_info eq $_ } qw{ on 1 yes docs} ) {
    $r->log->error(
      sprintf
        'Bedrock admin directory denied by configuration (ALLOW_BEDROCK_INFO): [%s]',
      $bedrock_info
    );

    return $FORBIDDEN;
  }

  $config->{BEDROCK_IMAGE_URL} //= $DEFAULT_IMAGE_URL;
  $config->{BEDROCK_ADMIN_DIR} //= '/bedrock';

  # used by .inc files that include other files (--file=~/bedrock-docs-header)
  $ENV{DOCUMENT_ROOT} = $config->{BEDROCK_INCLUDE_DIR};

  ####################################################################
  # router
  ####################################################################
  my $uri = $r->uri;
  $uri =~ s/^$config->{BEDROCK_ADMIN_DIR}//xsm;

  for ($uri) {
    /plugins\/?(.*?)$/xsm && do {
      return plugin_docs( $bedrock_handler, $1 );
    };

    /system\/?(.*?)\/?$/xsm && do {
      return system_docs( $bedrock_handler, $1 );
    };

    /pod\/?(.*?)\/?$/xsm && do {
      return pod_docs( $bedrock_handler, $1 );
    };

    /markdown\/?(.*?)\/?$/xsm && do {
      return markdown_docs( $bedrock_handler, $1 );
    };

    /tag\/?(.*?)\/?$/xsm && do {
      return tag_docs( $bedrock_handler, lc $1 );
    };

    /^\/env\/?$/xsm && do {
      return env_docs($bedrock_handler);
    };

    /^\/config\/?$/xsm && do {
      return config_docs($bedrock_handler);
    };
  }

  ####################################################################
  # documentation home page
  ####################################################################

  my $template = fetch_template( $config, 'bedrock-docs-index' );

  my %parameters;

  $parameters{head}
    = listing_head( $bedrock_handler, 'Bedrock Reference Guide' );

  ####################################################################
  # head
  ####################################################################
  $parameters{tags} = ul_links(
    $config,
    tag     => 'Bedrock Tags',
    plugins => 'Bedrock Plugins',
  );

  ####################################################################
  # system modules
  ####################################################################

  $parameters{system_docs} = ul_links( $config, system => 'System Modules' );

  ####################################################################
  # user modules
  ####################################################################
  my $pod_paths = get_pod_paths( $bedrock_handler->config );

  if ($pod_paths) {
    $parameters{user_docs} = ul_links( $config, pod => 'Module Listing' );
  }

  ####################################################################
  # markdown
  ####################################################################
  my $markdown_paths = get_markdown_paths( $bedrock_handler->config );

  if ($markdown_paths) {
    $parameters{markdown_docs}
      = ul_links( $config, markdown => 'Documentation Listing' );
  }

  ####################################################################
  # config & environment
  ####################################################################
  if ( $config->{ALLOW_BEDROCK_INFO} ne 'docs' ) {

    my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;
    $allow_config = $allow_config =~ /^y|1|on/xsmi;

    my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;
    $allow_env = $allow_env =~ /^y|1|on/xsmi;

    $parameters{bedrock_env} = ul_links(
      $config,
      config => $allow_config ? 'Bedrock Configuration' : '(disabled)',
      env    => $allow_env    ? 'Bedrock Environment'   : '(disabled)',
    );
  }

  ####################################################################
  # finalize and output
  ####################################################################
  output( $r, template( $config, $template, %parameters ) );

  return $OK;
}

########################################################################
sub header {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-header' );

  return template( $config, $template, %parameters );
}

########################################################################
sub fetch_template {
########################################################################
  my ( $config, $template ) = @_;

  my $file = sprintf '%s/%s.inc', $config->{BEDROCK_INCLUDE_DIR}, $template;

  return slurp_file($file);
}

########################################################################
sub show_pod {
########################################################################
  my ( $bedrock_handler, $file, $back_url ) = @_;

  my $html = _show_pod( $bedrock_handler->config, $file, $back_url );

  if ( !$html ) {
    my $url = sprintf 'http://%s/%s/%s',
      $ENV{HTTP_HOST},
      $bedrock_handler->get_bedrock_admin_dir,
      $back_url;

    $bedrock_handler->request_handler->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub create_pod_file {
########################################################################
  my ( $file, $css_url ) = @_;

  my $pod = tmpnam;

  my %options = (
    '--infile'   => $file,
    '--outfile'  => $pod,
    '--cachedir' => File::Spec->tmpdir(),
    $css_url ? ( '--css' => $css_url ) : (),
  );

  my $html = eval {
    pod2html( '--backlink', map { "$_=" . $options{$_} } keys %options );

    return slurp_file $pod;
  };

  if ( -e $pod ) {
    unlink $pod;
  }

  return $html;
}

########################################################################
sub _show_pod {
########################################################################
  my ( $config, $file, $back_url ) = @_;

  my $html = create_pod_file( $file, $config->{BEDROCK_POD_CSS_URL} );

  $back_url = sprintf '%s/%s', $config->{BEDROCK_ADMIN_DIR}, $back_url;

  if ( length $html < $POD_MIN_SIZE ) {
    my $message = q{No documentation found for this module.};

    return create_error_page(
      $config,
      back_url => $back_url,
      error    => $message
    );
  }

  my $top_section = header( $config, back_url => $back_url );

  $html =~ s/(<body(.*?)>)/$1\n$top_section/ixsm;

  return $html;
}

########################################################################
sub get_modules {
########################################################################
  my ( $dir, $exclude_blms ) = @_;

  return find_files(
    dir          => $dir,
    exclude_blms => $exclude_blms,
    ext          => 'pm'
  );
}

########################################################################
sub find_markdown_files {
########################################################################
  my ($dir) = @_;

  return find_files(
    dir          => $dir,
    exclude_blms => $TRUE,
    ext          => 'md'
  );
}

########################################################################
sub find_files {
########################################################################
  my (%args) = @_;

  my ( $dir, $no_blms, $ext ) = @args{qw(dir exclude_blms ext)};

  $ext //= 'pm';

  return ()
    if !-d $dir;

  my $fh;

  opendir $fh, $dir;

  my @listing;

  while ( my $file = readdir $fh ) {

    next if $file =~ /\A[.]/xsm;

    next if $no_blms && $file =~ /^BLM/xsm;  #  && any {/$dir/xsm} @INC;

    if ( -d "$dir/$file" ) {
      push @listing,
        find_files(
        dir          => "$dir/$file",
        exclude_blms => $no_blms,
        ext          => $ext
        );
    }
    else {
      if ( $file =~ /^([^.]+)[.]$ext$/xsm ) {
        push @listing, "$dir/$1";
      }
    }
  }

  closedir $fh;

  return @listing;
}

########################################################################
sub get_all_modules {
########################################################################
  my ( $paths, $public_only, $no_blms ) = @_;

  my @module_listing;

  my %module_map;

  foreach my $path ( @{$paths} ) {
    my $dir;

    my $filter;

    if ( is_hash($path) ) {
      $dir = $path->{dir};

      $filter = $path->{filter};
      $filter = qr/$filter/xsm;
    }
    else {
      $dir = $path;
    }

    my @modules = get_modules( $dir, $no_blms );

    foreach my $file (@modules) {
      next if !has_pod("$file.pm");

      my $module = $file;

      $module =~ s/$dir\///xsm;
      $module =~ s/\//::/xsmg;

      next if $filter && $module !~ $filter;

      $module_map{$module} = $file;
    }

    push @module_listing, @modules;
  }

  # delete non-public modules
  if ($public_only) {
    foreach my $module ( keys %module_map ) {
      next if is_public_module( $module, \%module_map );

      delete $module_map{$module};
    }
  }

  return \%module_map;
}

########################################################################
sub has_pod {
########################################################################
  my ($file) = @_;

  my $text = slurp_file $file;

  return $text =~ /^[=]pod\s*$/xsm;
}

########################################################################
sub is_public_module {
########################################################################
  my ( $module, $module_map ) = @_;

  my $file = $module_map->{$module} . '.pm';

  my $source = slurp_file $file;

  return $source =~ /[=]head1\s+public/xsmi;
}

########################################################################
sub get_all_blms {
########################################################################

  my @module_listing;

  my @blm_path = grep { -d "$_/BLM" } @INC;

  # get public only BLMs
  my $modules = get_all_modules( \@blm_path, $TRUE, $FALSE );

  return @{$modules}{ sort keys %{$modules} };
}

# return the standard documentation header

########################################################################
sub listing_index {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

  return template( $config, $template, %parameters );
}

########################################################################
sub ul_links {
########################################################################
  my ( $config, %options ) = @_;

  my $back_url = delete $options{back_url};

  $back_url //= $config->{BEDROCK_ADMIN_DIR};

  my $template = fetch_template( $config, 'bedrock-docs-ul' );

  return template( $config, $template, url => $back_url, links => \%options );
}

########################################################################
sub blm_ul {
########################################################################
  my ( $bedrock_handler, $blms, $h2, @args ) = @_;

  return if !@args;

  my %blm_listing;

  # just the names
  foreach my $blm (@args) {
    $blm_listing{$blm} = $blms->{$blm};
    $blm_listing{$blm} =~ s/^(.*)::(.*)$/$2/xsm;
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-blms' );

  my $uri = '%s/plugins/%s';

  my $list = Bedrock::Hash->new(
    map { $blm_listing{$_} => sprintf $uri, $config->{BEDROCK_ADMIN_DIR}, $_ }
    sort @args
  );

  my %vars = (
    heading => $h2,
    list    => $list,
  );

  return template( $config, $template, %vars );
}

########################################################################
sub template {
########################################################################
  my ( $config, $template, %parameters ) = @_;

  my $logo_url = sprintf '%s/%s',
    @{$config}{qw(BEDROCK_IMAGE_URL BEDROCK_LOGO)};

  %parameters = (
    env        => \%ENV,
    back_url   => $config->{BEDROCK_ADMIN_DIR},
    config     => $config,
    version    => version('full'),
    logo       => $logo_url,
    stylesheet => $config->{BEDROCK_POD_CSS_URL},
    %parameters,
  );

  my $text
    = eval { return Bedrock::Template->new( $template, %parameters )->parse; };

  die sprintf "error processing template: %s\n%s\n", $template, $EVAL_ERROR
    if !$text || $EVAL_ERROR;

  return $text;
}

########################################################################
sub output {
########################################################################
  my ( $r, $content ) = @_;

  $r->content_type('text/html');

  $r->send_http_header;

  return print $content;
}

########################################################################
sub plugin_docs {
########################################################################
  my ( $bedrock_handler, $file ) = @_;

  my $r = $bedrock_handler->request_handler;

  my @blm_listing = get_all_blms();

  $r->log->debug( Dumper( [ 'BLMs:', \@blm_listing ] ) );

  if ($file) {
    my @path_list
      = grep {/(BLM\/$file|BLM\/Startup\/$file)|BLM\/Filter\/$file/ixsm}
      @blm_listing;

    my $path;

    if ( @path_list && -s $path_list[0] . '.pm' ) {
      $path = $path_list[0] . '.pm';
    }

    if ( $path && $path =~ /(BLM\/.*?)[.]pm$/xsm ) {
      my $title = $1;
      $title =~ s/\//::/gxsm;

      return show_pod( $bedrock_handler, $path, 'plugins' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $blms = Bedrock::Hash->new;

  foreach my $blm (@blm_listing) {
    if ( $blm =~ /BLM\/(.*?)$/xsm ) {
      $blms->{$1} = "BLM/$1";
      $blms->{$1} =~ s/\//::/gxsm;
    }
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-plugins' );

  my @blm_names = keys %{$blms};

  my %sections = (
    Plugins               => [ grep { !/^Startup|Filter/xsm } @blm_names ],
    'Application Plugins' => [ grep {/^Startup/xsm} @blm_names ],
    Filters               => [ grep {/^Filter/xsm} @blm_names ],
  );

  my @headings = sort keys %sections;

  my @plugins
    = map { blm_ul( $bedrock_handler, $blms, $_, @{ $sections{$_} } ) }
    @headings;

  my $head = listing_head( $bedrock_handler, 'Bedrock Plugins' );

  my $html = template(
    $config, $template,
    headings => \@headings,
    head     => $head,
    plugins  => \@plugins
  );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub system_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $pod_paths = [$DEFAULT_BEDROCK_PERL5LIBDIR];

  # get non-public modules
  my $module_listing = get_all_modules( $pod_paths, $FALSE );

  return $NOT_FOUND
    if !$module_listing || !keys %{$module_listing};

  if ($module) {

    $module =~ s/\//\:\:/xsmg;
    my $path = $module_listing->{$module} . '.pm';

    return show_pod( $bedrock_handler, $path, 'system' );
  }

  my $modules = get_all_modules( $pod_paths, 0, 1 );

  my $url_prefix = '/bedrock/system';
  my $anchor_tag = '<a href="%s/%s">%s</a>';

  my @system_listing;

  foreach my $module ( sort keys %{$modules} ) {
    next if $module =~ /Bedrock::Text|Filter/xsm;

    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @system_listing, sprintf $anchor_tag, $url_prefix, $path, $module;
  }

  my $html = listing( $bedrock_handler, 'System Documentation Listing',
    @system_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub _show_markdown {
########################################################################
  my ( $config, $markdown ) = @_;

  my $top_section = header($config);

  my $html = eval {
    my $md = Markdown::Render->new(
      infile => $markdown,
      engine => 'text_markdown',
      body   => $FALSE
    );

    $md->render_markdown;

    return $md->get_html;
  };

  if ( $EVAL_ERROR || !length $html ) {
    my $message = "No documentation found for $markdown.";

    $html = create_error_page(
      $config,
      error => $message,
      title => $markdown
    );
  }
  else {
    my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

    my $back_url = sprintf '/%s/markdown', $config->{BEDROCK_ADMIN_DIR};

    $html = template(
      $config,
      $template,
      content  => $html,
      back_url => $back_url,
      title    => $markdown,
    );

  }

  return $html;
}

########################################################################
sub create_error_page {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-error' );

  $parameters{error} //= $EVAL_ERROR;

  return template( $config, $template, %parameters, );
}

########################################################################
sub show_markdown {
########################################################################
  my ( $bedrock_handler, $markdown, $back_url ) = @_;

  my $html = _show_markdown( $bedrock_handler->config, $markdown );

  if ( !$html ) {
    my $url = sprintf 'http://%s/%s/%s',
      $ENV{HTTP_HOST},
      $bedrock_handler->get_bedrock_admin_dir,
      $back_url;

    $bedrock_handler->request_handler->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request_handler, $html );

  return $OK;

}

########################################################################
sub markdown_docs {
########################################################################
  my ( $bedrock_handler, $markdown ) = @_;

  my @markdown_listing;

  my $config = $bedrock_handler->config;

  my $markdown_paths = get_markdown_paths($config);

  if ($markdown_paths) {
    for ( @{$markdown_paths} ) {
      push @markdown_listing, find_markdown_files($_);
    }
  }

  if ($markdown) {
    my $path = "$markdown.md";

    return show_markdown( $bedrock_handler, $path, 'tag' );
  }

  my $title = 'Documentation Listing';

  if ( !@markdown_listing ) {
    my $message
      = !@{$markdown_paths}
      ? 'No markdown paths defined in configuraion.'
      : 'No additional documentation found';

    my $html
      = create_error_page( $config, title => $title, error => $message );

    output( $bedrock_handler->request_handler, $html );

    return $OK;
  }

  my $anchor_tag = '<a href="%s/markdown/%s">%s</a>';

  my @listing;

  foreach my $file ( sort @markdown_listing ) {
    my $uri = Text::URLEncode::Encode $file;

    push @listing, sprintf $anchor_tag,
      $bedrock_handler->get_bedrock_admin_dir, $uri, $file;
  }

  my $html = listing( $bedrock_handler, $title, @listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub pod_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $config = $bedrock_handler->config;

  my $pod_paths = get_pod_paths($config);

  my $module_listing;

  if ( $pod_paths && @{$pod_paths} ) {
    $module_listing = get_all_modules( $pod_paths, 0 );
  }

  if ( $module && $module_listing && keys %{$module_listing} ) {
    $module =~ s/\//\:\:/xsmg;
    my $path = $module_listing->{$module} . '.pm';

    return show_pod( $bedrock_handler, $path );
  }

  my $title = 'User Documentation Listing';

  if ( !$module_listing || !keys %{$module_listing} ) {
    my $message = 'No user documentation found.';

    my $html = create_error_page( $config, error => $message );

    output( $bedrock_handler->request_handler, $html );

    return $OK;
  }

  my $anchor_tag = '<a href="%s/pod/%s">%s</a>';

  my @pod_listing;

  foreach my $module ( sort keys %{$module_listing} ) {
    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @pod_listing, sprintf $anchor_tag,
      $bedrock_handler->get_bedrock_admin_dir, $path, $module;
  }

  my $html = listing( $bedrock_handler, $title, @pod_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub env_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;

  my $env
    = $allow_env =~ /^y/xsmi
    ? \%ENV
    : { ALLOW_BEDROCK_ENV_INFO => $allow_env };

  return hash_docs( $bedrock_handler, 'Environment', $env );
}

########################################################################
sub config_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config       = $bedrock_handler->config;
  my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;

  $config
    = $allow_config =~ /^y/xsmi
    ? $config
    : { ALLOW_BEDROCK_CONFIG_INFO => $allow_config };

  return hash_docs( $bedrock_handler, 'Configuration', $config );
}

########################################################################
sub hash_docs {
########################################################################
  my ( $bedrock_handler, $title, $hash ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-hash-dump' );

  # make sure that all refs can('compact')
  foreach ( %{$hash} ) {
    next if !ref $_ || blessed $_;

    bless $_, 'Bedrock::Dump';
  }

  my $head = listing_head( $bedrock_handler, 'Bedrock ' . $title );

  my $html = template( $config, $template, head => $head, hash => $hash );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub find_tag_file {
########################################################################
  my ($tag) = @_;

  my $tagx = 'Text/TagX/TAG';

  my ($tag_path) = grep { -d "$_/$tagx" } @INC;

  return $EMPTY
    if !$tag_path;

  my @path_stubs
    = map {"$tag_path/$tagx/$_"} qw{  NoBody WithBody WithBody/Loop };

  my @search_paths = map { sprintf '%s/%s.pm', $_, ucfirst $tag } @path_stubs;

  my ($tag_file) = grep {-e} @search_paths;

  return $tag_file
    if $tag_file;

  no warnings 'File::Find';  ## no critic

  find(
    sub {
      my ($name) = split /[.]/xsm, $_;
      return if !$name;

      if ( !$tag_file && $tag eq lc $name ) {
        $tag_file = $File::Find::name;
      }
    },
    @path_stubs
  );

  return $tag_file;
}

########################################################################
sub tag_list {
########################################################################
  my @tags;

  # this will always be true...
  if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
    foreach ( sort split /[|]/xsm, $1 ) {
      next if /[#]|else|else[?]if|blm|[?]/xsm;

      push @tags, $_;
    }
  }

  return @tags;
}

########################################################################
sub tag_docs {
########################################################################
  my ( $bedrock_handler, $tag ) = @_;

  if ($tag) {
    my $tag_file = find_tag_file($tag);

    if ($tag_file) {
      return show_pod( $bedrock_handler, $tag_file, 'tag' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  my $tag_link = q{<a href="%s/tag/%s">%s</a>};

  my @tag_listing
    = map { sprintf $tag_link, $bedrock_admin_dir, $_, $_ } @TAG_LIST;

  my $html = listing( $bedrock_handler, 'Bedrock Tag Listing', @tag_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub listing {
########################################################################
  my ( $bedrock_handler, $title, @listing ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-listing' );

  my $head = listing_head( $bedrock_handler, $title );

  return template(
    $config,
    $template,
    head    => $head,
    listing => \@listing
  );
}

########################################################################
sub listing_head {
########################################################################
  my ( $bedrock_handler, $title ) = @_;

  my $config = $bedrock_handler->config;

  return listing_index( $config, title => $title, );
}

########################################################################
sub validate_paths {
########################################################################
  my (@paths) = @_;

  # only valid paths...
  return [ grep { -d $_ && -r $_ } @paths ];
}

########################################################################
sub get_doc_paths {
########################################################################
  my ( $config, $type ) = @_;

  $type = uc "${type}_PATHS";

  my $path_list = $config->{$type} // $EMPTY;

  if ( !is_array($path_list) ) {
    $path_list = [ split /:/xsm, $path_list // $EMPTY ];
  }

  return validate_paths( @{$path_list} );
}

########################################################################
{
  ## no critic (RequireArgUnpacking)
  sub get_markdown_paths { push @_, 'markdown'; goto &get_doc_paths; }
  sub get_pod_paths      { push @_, 'pod';      goto &get_doc_paths; }
}
########################################################################

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 NAME

Bedrock::Apache::BedrockDocs - Provides Bedrock and user documentation as HTML

=head1 SYNOPSIS

 AllowEncodedSlashes On

 <Directory /var/www/html/bedrock/>
   AcceptPathInfo On
   Options -Indexes
   AllowOverride None
 
   <IfModule mod_perl.c>
     SetHandler perl-script 
     PerlHandler Apache::BedrockDocs 
   </IfModule>
 
   <IfModule !mod_perl.c>
     SetHandler bedrock-docs
   </IfModule>
 
   AuthType Basic
   AuthName Bedrock
   AuthBasicProvider file
   AuthUserFile /usr/lib/bedrock/config/bedrock.users

   require valid-user
 
 </Directory>

=head1 DESCRIPTION

Displays documentation (L<POD|https://perldoc.perl.org/perlpod>)
embedded in Bedrock's Perl modules as HTML.

User documenation contained in the form of POD within Perl modules or
markdown within specified paths can also be displayed (See L</USER
DOCUMENTATION>).

Bedrock documentation availability is controlled by the configuration
variable C<ALLOW_BEDROCK_INFO> in F<tagx.xml>.  Set the configuration
variable to one of the values described below.

=over 5

=item yes/on/1

Allow documentation and possibly other information (configuration, environment).

=item no/off/0

Do not allow documentation.

=item docs

Allow documentation only.

=back

To allow configuration information to be displayed set
C<ALLOW_BEDROCK_CONFIG_INFO> To allow environment information to
be displayed set C<ALLOW_BEDROCK_ENV_INFO> to C<yes>. The default
value for these variables is C<no>.

=head1 USER DOCUMENTATION

Bedrock can also display documentation you have embedded in your own Perl
modules or markdown.

=head2 Pod

Set the configuration variable C<POD_PATHS> to either a colon
separated string of absolute paths to your Perl modules or an array of
paths. You can also set the C<POD_PATHS> environment variable in your
Apache configuration.

 <scalar name="POD_PATHS">/home/fred/git/acmem-pebbles/lib</scalar>

or

 <array name="POD_PATHS">
   <scalar>/home/fred/git/acme-dino</scalar>
   <scalar>/home/fred/git/acme-quarry/lib</scalar>
 </array>

or in your Apache's configuration:

 SetEnv POD_PATHS /home/fred/git/acme-quarry/lib

Bedrock's documentation facility will recurse sub-directories and list
 all modules that end with C<.pm>.

=head2 Markdown

Set the scalar configuration variable C<MARKDOWN_PATHS> to either a colon
separated string of absolute paths to your Perl modules or an array of
paths. You can also set the C<MARKDOWN_PATHS> environment variable in your
Apache configuration.

  <array name="MARKDOWN_PATHS">
    <scalar>/usr/local/share/my-app/docs</scalar>
  </array>

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
