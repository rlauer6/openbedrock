package Apache::BedrockDocs;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2025, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

# TODO:
# [ ] option to disable traversing all sub-directories
# [ ] collapsible directories
# [ ] cache user documentation paths (.md, .pm)

use strict;
use warnings;

use Apache::Bedrock qw(cache);
use Bedrock qw(:booleans slurp_file choose);
use Bedrock::Array;
use Bedrock::Hash;
use Bedrock::PodWriter qw(pod2html);
use Bedrock::Apache::Constants qw(:http);
use Bedrock::BedrockConfig;
use Bedrock::Constants qw(:regexp :chars :booleans :defaults);
use Bedrock::Context qw(init_log4perl_logger);
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::Request;
use Bedrock::Template;
use Bedrock::VERSION qw(version);

use Carp;
use Data::Dumper;
use Digest::MD5 qw(md5_hex);
use English qw(-no_match_vars );
use File::Basename qw(fileparse basename dirname);
use File::Temp qw(tempfile);
use File::Find;
use JSON;
use Markdown::Render;
use Module::Load;
use Scalar::Util qw(reftype blessed);
use List::Util qw(any pairs none);
use Log::Log4perl;
use LWP::UserAgent;
use LWP::Protocol::https;  # force rpmbuild to include
use Text::URLEncode;
use Log::Log4perl;

use Role::Tiny::With;
with 'Bedrock::Logger';
with 'Bedrock::Apache::HandlerUtils';

########################################################################
use Readonly;

Readonly our $DEFAULT_IMAGE_URL => '/bedrock/img';
Readonly our $POD_MIN_SIZE      => 600;
Readonly our $POD_CACHE_TTL     => 15 * 60;        # 15m
########################################################################

our @TAG_LIST;

if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
  @TAG_LIST = sort split /[|]/xsm, $1;
  @TAG_LIST = grep { !/[#]|else|else[?]if|blm|[?]/xsm } @TAG_LIST;
}

# order is important, 'docs' comes last always...
my @routes = (
  plugins  => qr{plugins/?(.*?)$}xsm,
  system   => qr{system/?(.*?)/?$}xsm,
  internal => qr{bedrock-internal/?(.*?)/?$}xsm,
  pod      => qr{pod/?(.*?)/?$}xsm,
  markdown => qr{markdown/?(.*?)/?$}xsm,
  tag      => qr{tag/?(.*?)/?$}xsm,
  env      => qr{env$}xsm,
  config   => qr{config$}xsm,
  session  => qr{session}xsm,
  clear    => qr{clear\-cache$}xsm,
  cache    => qr{list\-cache$}xsm,
  docs     => qr{/bedrock/docs/?(.*?)/?$}xsm,
  index    => qr{/bedrock/$}xsm,
);

my %dispatcher = (
  plugins => \&plugin_docs,
  system  => sub {
    my ( $bedrock_handler, $arg ) = @_;
    return system_docs( $bedrock_handler, module => $arg, type => 'system' );
  },
  internal => sub {
    my ( $bedrock_handler, $arg ) = @_;
    return system_docs( $bedrock_handler, module => $arg, type => 'bedrock-internal' );
  },
  pod => sub {
    my ( $bedrock_handler, $arg ) = @_;
    my $module = $arg;
    if ( !$module ) {
      my $req = Bedrock::Request->new( $bedrock_handler->request );
      $module = $req->param('module');
    }
    return pod_docs( $bedrock_handler, $module );
  },
  markdown => \&markdown_docs,
  tag      => sub {
    my ( $bedrock_handler, $arg ) = @_;
    return tag_docs( $bedrock_handler, lc $arg );
  },
  env     => \&env_docs,
  session => \&session_state,
  config  => \&config_docs,
  cache   => sub {
    my $cache = cache();
    return output( $_[0]->request, $cache->keys );
  },
  clear => sub {
    my ( $bedrock_handler, $arg ) = @_;

    cache() && cache()->clear;

    return $OK;
  },
  docs  => \&generic_docs,
  index => \&index_html,
);

########################################################################
# get_route()
########################################################################
#
# Returns a 2-element array or undef if no route is found in the route table
#     [ route-id, arg ]
#
# Where:
#    'arg' is the first segment after the route suffix
# Example:
#    /bedrock/docs/pod/Foo::Bar -> arg = Foo::Bar
#
# The route table is a list of key/value pairs where the key is a
# route-id and the value is regular expression that should match a
# route.
#
# The route id is used to look up a subroutine reference in the
# dispatch table. The dispatch table is a hash of key/value pairs
# where the key is the route-id which should exist in our route table
# and the value is a subroutine reference that accepts a
# Bedrock::Handler object, 'arg' and the Bedrock::Config object.
#
########################################################################
sub get_route {
########################################################################
  my (%args) = @_;

  my ( $r, $uri, $routes ) = @args{qw(r uri routes)};

  for my $route ( pairs @{$routes} ) {
    my ( $id, $regexp ) = @{$route};

    return [ $id, $1 ]
      if $uri =~ /$regexp/xsm;
  }

  return;
}

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # we really need caching for this to be a pleasant experience for developers
  if ( !$ENV{BEDROCK_CACHE_ENGINE} ) {
    $ENV{BEDROCK_CACHE_ENGINE} = 'Memory';
  }

  my $bedrock_handler = eval { return Bedrock::Handler->new( $r, cache => cache() ); };

  if ( $EVAL_ERROR || !$bedrock_handler ) {
    $r->log->error(qq{Could not initialize Bedrock's handler\n$EVAL_ERROR});

    return internal_server_error( $r, $EVAL_ERROR );
  }

  if ( !Log::Log4perl->initialized ) {
    init_log4perl_logger();
  }

  my %headers = %{ $r->headers_in };

  my $session = get_session($bedrock_handler);
  $bedrock_handler->{session} = $session;

  if ($session) {
    $session->set( 'Referer', $headers{Referer} );
  }
  else {
    $r->log->warn( 'unable to load session manager: ' . $EVAL_ERROR );
  }

  my $status = eval {

    my $config = $bedrock_handler->config();

    my $bedrock_info = $config->{ALLOW_BEDROCK_INFO} // $EMPTY;

    if ( none { lc $bedrock_info eq $_ } qw{ on 1 yes docs} ) {
      $r->log->error( sprintf 'Bedrock admin directory denied by configuration (ALLOW_BEDROCK_INFO): [%s]', $bedrock_info );

      return $FORBIDDEN;
    }

    $config->{BEDROCK_IMAGE_URL} //= $DEFAULT_IMAGE_URL;
    $config->{BEDROCK_ADMIN_DIR} //= '/bedrock';

    if ( $ENV{BEDROCK_INCLUDE_DIR} ) {
      $config->{BEDROCK_INCLUDE_DIR} = $ENV{BEDROCK_INCLUDE_DIR};
    }
    else {
      $config->{BEDROCK_INCLUDE_DIR} = $DEFAULT_BEDROCK_INCLUDE_DIR;
    }

    # used by .inc files that include other files (--file=~/bedrock-docs-header)
    local $ENV{DOCUMENT_ROOT} = $config->{BEDROCK_INCLUDE_DIR};

    ####################################################################
    # router
    ####################################################################
    my $uri = $r->uri;

    get_logger()->debug( 'handling: ' . $uri );

    my ( $route_id, $arg ) = @{ get_route( r => $r, uri => $uri, routes => \@routes ) // [] };

    return $HTTP_BAD_REQUEST
      if !$route_id;

    return $dispatcher{$route_id}->( $bedrock_handler, $arg, $config );
  };

  if ($session) {
    $session->closeBLM();
  }

  return $EVAL_ERROR ? internal_server_error( $r, $EVAL_ERROR ) : $status;
}

########################################################################
sub index_html {
########################################################################
  my ( $bedrock_handler, $arg, $config ) = @_;

  my $r = $bedrock_handler->request;

  return $HTTP_BAD_REQUEST
    if is_api($r);

  ####################################################################
  # documentation home page
  ####################################################################

  my $template = fetch_template( $config, 'bedrock-docs-index' );

  my %parameters;

  $parameters{head} = listing_head( $bedrock_handler, 'Bedrock Reference Guide' );

  ####################################################################
  # head
  ####################################################################
  $parameters{tags} = ul_links(
    $config,
    tag     => 'Bedrock Tags',
    plugins => 'Bedrock Plugins',
  );

  ####################################################################
  # system modules
  ####################################################################
  $parameters{system_docs} = ul_links( $config, system => 'System Modules' );

  ####################################################################
  # Bedrock internal modules
  ####################################################################
  $parameters{bedrock_internal_docs} = ul_links( $config, 'bedrock-internal' => 'Bedrock Internal Documentation' );

  ####################################################################
  # user modules
  ####################################################################
  my $pod_paths = get_pod_paths( $bedrock_handler->config() );

  if ( $pod_paths && @{$pod_paths} ) {
    $parameters{user_docs} = ul_links( $config, pod => 'User Module Listing' );
  }

  ####################################################################
  # markdown
  ####################################################################
  my $markdown_paths = get_markdown_paths( $bedrock_handler->config() );

  if ($markdown_paths) {
    $parameters{markdown_docs} = ul_links( $config, markdown => 'Documentation Listing' );
  }

  ####################################################################
  # config & environment
  ####################################################################
  if ( $config->{ALLOW_BEDROCK_INFO} ne 'docs' ) {

    my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;
    $allow_config = $allow_config =~ /^y|1|on/xsmi;

    my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;
    $allow_env = $allow_env =~ /^y|1|on/xsmi;

    $parameters{bedrock_env} = ul_links(
      $config,
      config => $allow_config ? 'Bedrock Configuration' : '(disabled)',
      env    => $allow_env    ? 'Bedrock Environment'   : '(disabled)',
    );
  }

  if ( $config->{LOG4PERL} && -e $config->{LOG4PERL} ) {
    $parameters{log4perl} = slurp_file $config->{LOG4PERL};
  }

  ####################################################################
  # finalize and output
  ####################################################################
  output( $r, template( $config, $template, %parameters ) );

  return $OK;
}

########################################################################
sub header {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-header' );

  return template( $config, $template, %parameters );
}

########################################################################
sub fetch_template {
########################################################################
  my ( $config, $template ) = @_;

  my $file = sprintf '%s/%s.inc', $config->{BEDROCK_INCLUDE_DIR}, $template;

  return slurp_file($file);
}

########################################################################
sub _render_markdown {
########################################################################
  my ( $bedrock_handler, $file ) = @_;

  my $r = $bedrock_handler->request;

  $r->log->debug( sprintf 'rendering markdown for %s', $file );

  my $html = eval {
    my $md = Markdown::Render->new(
      infile => $file,
      engine => 'text_markdown',
      body   => $FALSE
    );

    $md->render_markdown;

    return $md->get_html;
  };

  if ( !$html || $EVAL_ERROR ) {
    # log this in case we are in eval {}
    my $err_msg = sprintf "could not render markdown: $EVAL_ERROR";
    $r->log->error($err_msg);
    die $err_msg;
  }

  return $html;
}

########################################################################
sub is_available_on_metacpan {
########################################################################
  my ($module) = @_;

  $module =~ s/\//::/xsmg;
  my $ua = LWP::UserAgent->new;

  # do a search
  my $req = HTTP::Request->new( 'GET' => 'https://fastapi.metacpan.org/v1/pod/' . $module . '?content-type=text/x-pod' );

  my $rsp = $ua->request($req);

  return
    if $rsp->code ne $HTTP_OK;

  my $content = $rsp->content;
  my ( $fh, $filename ) = tempfile( 'metacpan-XXXXX', TMPDIR => 1 );

  print {$fh} $content;

  return $filename;
}

########################################################################
sub cache_key {
########################################################################
  my ( $r, $type, $module ) = @_;

  my $call_context = is_api($r) ? 'api' : 'web';

  return sprintf '%s:%s:%s:%s', __PACKAGE__, $type, $call_context, $module;
}

########################################################################
sub show_pod {
########################################################################
  my ( $bedrock_handler, $file, $type, $module ) = @_;

  my $r = $bedrock_handler->request;

  my $cache = cache();

  my $cache_key = cache_key( $r, $type, $module );

  get_logger()->debug(
    Dumper(
      [ type      => $type,
        module    => $module,
        cache_key => $cache_key
      ]
    )
  );

  ######################################################################
  # POD search sequence
  # 1. cache if caching enabled
  # 2. @INC paths
  # 3. MetaCPAN
  ######################################################################

  my ( $source, $html ) = choose {

    ####################################################################
    # 1. look in cache
    ####################################################################
    return ( cache => $cache->get($cache_key) )
      if $cache && $cache->get($cache_key);

    ####################################################################
    # 2. look in @INC
    ####################################################################
    get_logger()->debug('looking in @INC');

    my $html = _show_pod(
      $bedrock_handler,
      file     => $file,
      uri_root => '/bedrock',
      module   => $module,
    );

    get_logger()->debug( 'length: ' . length( $html // q{} ) );

    return ( local => $html )
      if $html;

    ####################################################################
    # 3. look in metacpan
    ####################################################################
    my $file = is_available_on_metacpan($module);

    return
      if !$file;

    $html = eval { _show_pod( $bedrock_handler, file => $file, uri_root => '/bedrock', module => $module, unlink => 1, ); };

    if ( $EVAL_ERROR || -e $file ) {
      unlink $file;
    }

    return ( metacpan => $html )
      if $html;

    return;
  };

  get_logger()->debug( Dumper( [ source => $source, html => length $html ] ) );

  # caches should always be enabled even if we are just using Bedrock::Cache::Memory
  if ( $cache && $html && $source ne 'cache' ) {
    get_logger()->debug( 'updating cache for ' . $file );
    $cache->set( $cache_key, $html, ttl => $POD_CACHE_TTL );
  }

  return $NOT_FOUND
    if !is_api($r) && !$html;

  return output( $r, { html => $html, source => $source } )
    if is_api($r);

  return output( $r, $html );
}

########################################################################
sub _show_pod {
########################################################################
  my ( $bedrock_handler, %args ) = @_;

  my $r = $bedrock_handler->request;

  my ( $file, $back_url, $module, $unlink ) = @args{qw(file back_url module unlink)};

  my $config = $bedrock_handler->config();

  if ( !$file || !-e $file ) {
    $file = $module;
    $file =~ s/::/\//gxsm;

    # see if we can find the file in Perl's @INC
    ($file) = grep { -e $_ } map {"$_/$file.pm"} @INC;
  }

  get_logger()->debug("file: $file\n");

  my $html;

  if ( $file && -e $file ) {
    $html = create_pod_file( $bedrock_handler, $file, $config->{BEDROCK_POD_CSS_URL} );
    if ($unlink) {
      unlink $file;
    }
  }

  return
    if !$html || length($html) < $POD_MIN_SIZE;

  if ( is_api($r) ) {
    # strip body, just want pod
    $html =~ s/^.*<body([^>]*)>(.*?)<\/body>/$2/xsm;

    # fix pod links
    $html =~ s/<a\s+href="\/bedrock\/pod\/([^<"]+)"[^>]*>([^<]+)<\/a>/<span class="pod-link" bedrock-data="$1">$2<\/span>/xsmg;
    return $html;
  }

  $module =~ s/\//::/xsmg;

  $back_url = sprintf '%s/%s', $bedrock_handler->get_bedrock_admin_dir, $back_url // q{};

  my $top_section = header( $config, back_url => $back_url, module => $module );

  $html =~ s/(<body(.*?)>)/$1\n$top_section/ixsm;

  return $html;
}

########################################################################
sub create_pod_file {
########################################################################
  my ( $bedrock_handler, $file, $css_url ) = @_;

  my $pod = File::Temp->new( UNLINK => 1 )->filename;

  my %options = (
    '--infile'   => $file,
    '--outfile'  => $pod,
    '--cachedir' => File::Spec->tmpdir(),
    ( $css_url && !is_api($bedrock_handler) ) ? ( '--css' => $css_url ) : (),
  );

  my $html = eval {
    pod2html( map { $options{$_} ? "$_=" . $options{$_} : $options{$_} } keys %options );

    return slurp_file $pod;
  };

  if ($EVAL_ERROR) {
    get_logger()->error("pod2html error: $EVAL_ERROR");
  }

  return $html;
}

########################################################################
sub get_modules {
########################################################################
  my ( $dir, $exclude_blms ) = @_;

  my @files = find_files(
    dir          => $dir,
    exclude_blms => $exclude_blms,
    ext          => 'pm',
  );

  carp Dumper(
    [ dir          => $dir,
      exclude_blms => $exclude_blms,
      files        => \@files
    ]
  );

  return @files;
}

########################################################################
sub find_markdown_files {
########################################################################
  my ($dir) = @_;

  return find_files(
    dir          => $dir,
    exclude_blms => $TRUE,
    ext          => 'md'
  );
}

########################################################################
sub find_files {
########################################################################
  my (%args) = @_;

  my ( $dir, $no_blms, $ext ) = @args{qw(dir exclude_blms ext)};

  $ext //= 'pm';

  return ()
    if !-d $dir;

  my $fh;

  opendir $fh, $dir;

  my @listing;

  while ( my $file = readdir $fh ) {

    next if $file =~ /\A[.]/xsm;

    next if $no_blms && $file =~ /^BLM/xsm;  #  && any {/$dir/xsm} @INC;

    if ( -d "$dir/$file" ) {
      push @listing,
        find_files(
        dir          => "$dir/$file",
        exclude_blms => $no_blms,
        ext          => $ext
        );
    }
    else {
      if ( $file =~ /^([^.]+)[.]$ext$/xsm ) {
        push @listing, "$dir/$1";
      }
    }
  }

  closedir $fh;

  return @listing;
}

########################################################################
sub fetch_modules {
########################################################################
  my (%args) = @_;

  my ( $paths, $public_only, $blms ) = @args{qw(paths public blms)};

  $blms //= $TRUE;

  $public_only //= $FALSE;

  croak 'ERROR: paths must be an array'
    if !ref $paths || reftype($paths) ne 'ARRAY';

  foreach my $pathspec ( @{$paths} ) {
    next if ref $pathspec;
    $pathspec = { dir => $pathspec };
  }

  return get_all_modules( $paths, $public_only, !$blms );
}

########################################################################
sub get_all_modules {
########################################################################
  my ( $paths, $public_only, $no_blms ) = @_;

  my %module_map;

  foreach my $pathspec ( @{$paths} ) {
    my ( $dir, $filter, $filter_type ) = @{$pathspec}{qw(dir filter filter_type)};

    $filter_type = $filter && $filter_type // 'exclude';

    $filter = $filter && qr/$filter/xsm;

    my @modules = get_modules( $dir, $no_blms );

    foreach my $file (@modules) {
      next
        if !has_pod("$file.pm");

      my $module = get_module_name( $file, $dir );

      next
        if !$module;

      if ($filter) {
        if ( $filter_type eq 'exclude' && $file =~ $filter ) {
          get_logger()->debug("excluding $module based on exclude filter ($filter)");
          next;
        }
        elsif ( $filter_type eq 'include' ) {
          if ( $module =~ $filter ) {
            get_logger()->debug("including $module based on include filter ($filter)");
          }
          else {
            get_logger()->debug("excluding $module based on include filter ($filter)");
            next;
          }
        }
        elsif ( $filter_type !~ /^(?:include|exclude)$/xsm ) {
          croak "ERROR: unknown filter type: $filter_type";
        }
      }

      next if $public_only && !is_public_module($file);

      $module_map{$module} = $file;
    }
  }

  return \%module_map;
}

########################################################################
sub get_module_name {
########################################################################
  my ( $file, $dir ) = @_;

  $dir = "$dir/";

  my $potential_name = $file;
  $potential_name =~ s/$dir//xsm;

  $potential_name =~ s/\//::/xsmg;

  my @package_names;

  open my $fh, '<', "$file.pm"
    or croak "ERROR: Could not open $file.pm for reading. $OS_ERROR";

  while ( my $line = <$fh> ) {
    next if $line !~ /^\s*package\s+([^;]+);/xsm;
    push @package_names, $1;
  }

  close $fh;

  my ($package_name) = grep {/$potential_name/xsm} @package_names;
  $package_name //= $package_names[0];

  return $package_name;
}

########################################################################
sub has_pod {
########################################################################
  my ($file) = @_;

  my $text = slurp_file $file;

  return $text =~ /^[=]pod\s*$/xsm;
}

########################################################################
sub is_public_module {
########################################################################
  my ($file) = @_;

  my $source = slurp_file "$file.pm";

  return $source =~ /^[=]head1\s+public/xsmi;
}

########################################################################
sub get_all_blms {
########################################################################

  my @module_listing;

  my @blm_path = grep { -d "$_/BLM" } @INC;

  # get public only BLMs
  my $modules = fetch_modules(
    paths  => \@blm_path,
    public => $TRUE,
    blms   => $TRUE
  );

  return @{$modules}{ sort keys %{$modules} };
}

# return the standard documentation header

########################################################################
sub listing_index {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

  return template( $config, $template, %parameters );
}

########################################################################
sub ul_links {
########################################################################
  my ( $config, %options ) = @_;

  my $back_url = delete $options{back_url};

  $back_url //= $config->{BEDROCK_ADMIN_DIR};

  my $template = fetch_template( $config, 'bedrock-docs-ul' );

  return template( $config, $template, url => $back_url, links => \%options );
}

########################################################################
sub blm_ul {
########################################################################
  my ( $bedrock_handler, $blms, $h2, @args ) = @_;

  return if !@args;

  my %blm_listing;

  # just the names
  foreach my $blm (@args) {
    $blm_listing{$blm} = $blms->{$blm};
    $blm_listing{$blm} =~ s/^(.*)::(.*)$/$2/xsm;
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-blms' );

  my $uri = '%s/plugins/%s';

  my $list = Bedrock::Hash->new(
    map { $blm_listing{$_} => sprintf $uri, $config->{BEDROCK_ADMIN_DIR}, $_ }
    sort @args
  );

  my %vars = (
    heading => $h2,
    list    => $list,
  );

  return template( $config, $template, %vars );
}

########################################################################
sub template {
########################################################################
  my ( $config, $template, %parameters ) = @_;

  carp 'no template to process'
    if !$template;

  my $logo_url = sprintf '%s/%s', @{$config}{qw(BEDROCK_IMAGE_URL BEDROCK_LOGO)};

  %parameters = (
    env        => \%ENV,
    back_url   => $config->{BEDROCK_ADMIN_DIR},
    config     => $config,
    version    => version('full'),
    logo       => $logo_url,
    stylesheet => $config->{BEDROCK_POD_CSS_URL},
    %parameters,
  );

  my $text = eval { return Bedrock::Template->new( $template, %parameters )->parse; };

  die sprintf "error processing template: %s\n%s\n", $template, $EVAL_ERROR
    if !$text || $EVAL_ERROR;

  return $text;
}

########################################################################
sub output {
########################################################################
  my ( $r, $content ) = @_;
  if ( ref $content ) {
    $r->content_type('application/json');
    $content = JSON->new->allow_blessed->convert_blessed->encode($content);
  }
  else {
    $r->content_type('text/html');
  }

  $r->send_http_header;

  print $content;

  return $OK;
}

########################################################################
sub plugin_docs {
########################################################################
  my ( $bedrock_handler, $file ) = @_;

  my $r = $bedrock_handler->request;

  my $cache     = cache();
  my $cache_key = sprintf '%s:blm_listing', __PACKAGE__;

  my @blm_listing = choose {
    return
      if !$cache;

    my $listing = $cache->get($cache_key);

    return $listing ? @{$listing} : ();
  };

  if ( !@blm_listing ) {
    @blm_listing = get_all_blms();

    if ($cache) {
      $cache->set( $cache_key, \@blm_listing );
    }
  }

  get_logger()->trace( Dumper( [ 'BLMs:', \@blm_listing ] ) );

  if ($file) {
    my @path_list = grep {/(BLM\/$file|BLM\/Startup\/$file)|BLM\/Filter\/$file/ixsm} @blm_listing;

    my $path;

    if ( @path_list && -s $path_list[0] . '.pm' ) {
      $path = $path_list[0] . '.pm';
    }

    if ( $path && $path =~ /(BLM\/.*?)[.]pm$/xsm ) {
      my $title = $1;
      $title =~ s/\//::/gxsm;

      return show_pod( $bedrock_handler, $path, 'plugins', $title );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $blms = Bedrock::Hash->new;

  foreach my $blm (@blm_listing) {
    if ( $blm =~ /BLM\/(.*?)$/xsm ) {
      $blms->{$1} = "BLM/$1";
      $blms->{$1} =~ s/\//::/gxsm;
    }
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-plugins' );

  my @blm_names = keys %{$blms};

  my %sections = (
    Plugins               => [ grep { !/^(?:Startup|Filter)/xsm } @blm_names ],
    'Application Plugins' => [ grep {/^Startup/xsm} @blm_names ],
    Filters               => [ grep {/^Filter/xsm} @blm_names ],
  );

  my @headings = sort keys %sections;

  my @plugins = map { blm_ul( $bedrock_handler, $blms, $_, @{ $sections{$_} } ) } @headings;

  my $head = listing_head( $bedrock_handler, 'Bedrock Plugins' );

  my $html = template(
    $config, $template,
    headings => \@headings,
    head     => $head,
    plugins  => \@plugins
  );

  if ( is_api($r) ) {
    my %plugin_map;

    foreach ( keys %sections ) {
      my $section = $_;
      $section =~ s/\s/-/xsmg;
      $plugin_map{$_} = lc $section;
    }

    my $links = {};
    my $names = {};

    foreach my $s ( keys %sections ) {
      $links->{$s} = { map { $_ => sprintf '/bedrock/plugins/%s', $_ } @{ $sections{$s} } };
      $names->{$s} = { map { $_ => ( split /\//xsm )[-1] } @{ $sections{$s} } };
    }

    output(
      $r,
      { links      => $links,
        names      => $names,
        plugins    => \%sections,
        plugin_map => \%plugin_map,
      }
    );
  }
  else {
    output( $bedrock_handler->request, $html );
  }

  return $OK;
}

########################################################################
sub fetch_module_list {
########################################################################
  my ( $bedrock_handler, $type ) = @_;

  my $cache = cache();

  my $cache_key = sprintf '%s:%s_modules', __PACKAGE__, $type;

  my $module_list = $cache->get($cache_key);

  return $module_list
    if $module_list;

  $module_list = get_all_modules(
    [ { filter      => '([bB]edrock|TagX|::[bB]edrock|BLM)',
        filter_type => $type eq 'system' ? 'exclude' : 'include',
        dir         => $DEFAULT_BEDROCK_PERL5LIBDIR,
      }
    ],
    $FALSE
  );

  $cache->set( $cache_key, $module_list );

  return $module_list;
}

########################################################################
sub system_docs {
########################################################################
  my ( $bedrock_handler, %args ) = @_;

  my $r = $bedrock_handler->request;

  my ( $module, $type ) = @args{qw(module type)};

  my $module_list = fetch_module_list( $bedrock_handler, $type );

  if ($module) {
    $module =~ s/\//\:\:/xsmg;

    my $path = $module_list->{$module};
    $path = $path ? "$path.pm" : $EMPTY;
    return show_pod( $bedrock_handler, $path, 'system', $module );
  }

  return output( $r, { modules => [ sort keys %{$module_list} ] } )
    if is_api($r);

  my $url_prefix = sprintf '/bedrock/%s', $type;

  my $anchor_tag = '<a href="%s/%s">%s</a>';

  my @system_listing = map { sprintf $anchor_tag, $url_prefix, s/::/\//rxsmg, $_ } sort keys %{$module_list};

  my $title = $type eq 'system' ? 'System' : 'Bedrock Internal';

  my $html = listing( $bedrock_handler, "$title Documentation Listing", @system_listing );

  return output( $bedrock_handler->request, $html );
}

########################################################################
sub _show_markdown {
########################################################################
  my ( $config, $markdown ) = @_;

  my $top_section = header($config);

  my $html = eval {
    my $md = Markdown::Render->new(
      infile => $markdown,
      engine => 'text_markdown',
      body   => $FALSE
    );

    $md->render_markdown;

    return $md->get_html;
  };

  if ( $EVAL_ERROR || !length $html ) {
    my $message = "No documentation found for $markdown.";

    $html = create_error_page(
      $config,
      error => $message,
      title => $markdown
    );
  }
  else {
    my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

    my $back_url = sprintf '%s/markdown', $config->{BEDROCK_ADMIN_DIR};

    $html = template(
      $config,
      $template,
      content  => $html,
      back_url => $back_url,
      title    => basename($markdown),
    );

  }

  return $html;
}

########################################################################
sub create_error_page {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-error' );

  $parameters{error} //= $EVAL_ERROR;

  return template( $config, $template, %parameters, );
}

########################################################################
sub show_markdown {
########################################################################
  my ( $bedrock_handler, $markdown, $back_url ) = @_;

  my $html = _show_markdown( $bedrock_handler->config, $markdown );

  if ( !$html ) {
    my $url = sprintf 'http://%s/%s/%s', $ENV{HTTP_HOST}, $bedrock_handler->get_bedrock_admin_dir, $back_url;

    $bedrock_handler->request->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request, $html );

  return $OK;
}

########################################################################
sub markdown_docs {
########################################################################
  my ( $bedrock_handler, $markdown ) = @_;

  my $cache     = cache();
  my $cache_key = __PACKAGE__ . ':markdown_listing';

  my $config = $bedrock_handler->config;

  my $markdown_listing = $cache->get($cache_key);

  if ( $markdown_listing && $markdown ) {
    my %listing = reverse %{$markdown_listing};
    my $file    = $listing{$markdown};

    return show_markdown( $bedrock_handler, "$file.md", 'markdown' )
      if $markdown;
  }

  my $markdown_paths = get_markdown_paths($config);

  if ( !$markdown_listing && $markdown_paths ) {
    my @listing;

    for ( @{$markdown_paths} ) {
      push @listing, map { $_ => md5_hex($_) } find_markdown_files($_);
    }

    $markdown_listing = {@listing};
    $cache->set( $cache_key, $markdown_listing );
  }

  my $title = 'Documentation Listing';

  if ( !keys %{$markdown_listing} ) {
    my $message = !@{$markdown_paths} ? 'No markdown paths defined in configuration.' : 'No additional documentation found';

    my $html = create_error_page( $config, title => $title, error => $message );

    return output( $bedrock_handler->request, $html );
  }

  my $anchor_tag = '<a href="%s/markdown/%s">%s</a>';

  my @listing;

  foreach my $file ( sort keys %{$markdown_listing} ) {
    my $uri = $markdown_listing->{$file};

    push @listing, sprintf $anchor_tag, $bedrock_handler->get_bedrock_admin_dir, $uri, $file;
  }

  my $html = listing( $bedrock_handler, $title, @listing );

  return output( $bedrock_handler->request, $html );
}

########################################################################
sub pod_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $config = $bedrock_handler->config;

  my $pod_paths = get_pod_paths($bedrock_handler);

  my $module_listing = fetch_module_list( $bedrock_handler, 'pod' );

  if ( !$module_listing ) {
    get_logger()->trace('no listing in cache');

    if ( $pod_paths && @{$pod_paths} ) {
      $module_listing = fetch_modules(
        paths  => $pod_paths,
        public => $FALSE,
        blms   => $FALSE
      );
    }
  }
  else {
    get_logger()->trace('retrieved pod listing from cache');
  }

  if ( $module && $module_listing && keys %{$module_listing} ) {
    $module =~ s/\//\:\:/xsmg;

    my $path = $module_listing->{$module};

    $path = $path ? "$path.pm" : $EMPTY;

    return show_pod( $bedrock_handler, $path, 'pod', $module );
  }
  elsif ($module) {
    return show_pod( $bedrock_handler, $EMPTY, 'pod', $module );
  }

  my $title = 'User Documentation Listing';

  if ( !$module_listing || !keys %{$module_listing} ) {
    my $message = 'No user documentation found.';

    my $html = create_error_page( $config, error => $message );

    return output( $bedrock_handler->request, $html );
  }

  my $anchor_tag = '<a href="%s/pod/%s">%s</a>';

  my @pod_listing;

  foreach my $module ( sort { lc $a cmp lc $b } keys %{$module_listing} ) {
    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @pod_listing, sprintf $anchor_tag, $bedrock_handler->get_bedrock_admin_dir, $path, $module;
  }

  my $html = listing( $bedrock_handler, $title, @pod_listing );

  return output( $bedrock_handler->request, $html );
}

########################################################################
sub env_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;

  my $env = $allow_env =~ /^y/xsmi ? \%ENV : { ALLOW_BEDROCK_ENV_INFO => $allow_env };

  return dump_hash( $bedrock_handler, $env )
    if is_api($bedrock_handler);

  return hash_docs( $bedrock_handler, 'Environment', $env );
}

########################################################################
sub session_state {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $session = get_session($bedrock_handler) // {};

  return dump_hash( $bedrock_handler, $session )
    if is_api($bedrock_handler);

  return hash_docs( $bedrock_handler, 'Environment', $session );
}

########################################################################
sub is_api {
########################################################################
  my ($bedrock_handler) = @_;

  my $r = ref($bedrock_handler) =~ /Bedrock::Handler/xsm ? $bedrock_handler->request : $bedrock_handler;

  my $accept = $r->header_in('Accept');

  return $accept && $accept =~ /json/xsm;
}

########################################################################
sub dump_hash {
########################################################################
  my ( $bedrock_handler, $hash ) = @_;

  $hash = blessed $hash && $hash->isa('Bedrock::Hash') ? $hash->devolve : $hash;

  my $config = $bedrock_handler->config;

  bless_all($hash);

  my $template = fetch_template( $config, 'bedrock-docs-hash-dump-body' );

  my $html = template( $config, $template, hash => $hash );

  output( $bedrock_handler->request, { html => $html } );

  return $OK;
}

########################################################################
sub config_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;

  $config = $allow_config =~ /^y/xsmi ? $config : { ALLOW_BEDROCK_CONFIG_INFO => $allow_config };

  return dump_hash( $bedrock_handler, $config )
    if is_api($bedrock_handler);

  return hash_docs( $bedrock_handler, 'Configuration', $config );
}

########################################################################
sub bless_all {
########################################################################
  my ($hash) = @_;

  # make sure that all refs can('compact')
  foreach ( keys %{$hash} ) {
    next if !defined $hash->{$_} || !ref $hash->{$_} || blessed $hash->{$_};

    bless $hash->{$_}, 'Bedrock::Dump';
  }

  return;
}

########################################################################
sub hash_docs {
########################################################################
  my ( $bedrock_handler, $title, $hash ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-hash-dump' );

  bless_all($hash);

  my $head = listing_head( $bedrock_handler, 'Bedrock ' . $title );

  my $html = template( $config, $template, head => $head, hash => $hash );

  return output( $bedrock_handler->request, $html );
}

########################################################################
sub find_tag_file {
########################################################################
  my ($tag) = @_;

  my $tagx = 'Text/TagX/TAG';

  my ($tag_path) = grep { -d "$_/$tagx" } @INC;

  return $EMPTY
    if !$tag_path;

  my @path_stubs = map {"$tag_path/$tagx/$_"} qw{  NoBody WithBody WithBody/Loop };

  my @search_paths = map { sprintf '%s/%s.pm', $_, ucfirst $tag } @path_stubs;

  my ($tag_file) = grep {-e} @search_paths;

  return $tag_file
    if $tag_file;

  no warnings 'File::Find';  ## no critic

  find(
    sub {
      my ($name) = split /[.]/xsm, $_;
      return if !$name;

      if ( !$tag_file && $tag eq lc $name ) {
        $tag_file = $File::Find::name;
      }
    },
    @path_stubs
  );

  return $tag_file;
}

########################################################################
sub tag_list {
########################################################################
  my @tags;

  # this will always be true...
  if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
    foreach ( sort split /[|]/xsm, $1 ) {
      next if /[#]|else|else[?]if|blm|[?]/xsm;

      push @tags, $_;
    }
  }

  return @tags;
}

########################################################################
sub generic_docs {
########################################################################
  my ( $bedrock_handler, $document_name ) = @_;

  my $r = $bedrock_handler->request;

  # this endpoint for Ajax only...(for now)
  return $NOT_FOUND
    if !is_api($r);

  my $config = $bedrock_handler->config;

  my $bedrock_documentation = $config->{BEDROCK_DOCUMENTATION};

  if ( !$bedrock_documentation ) {
    $r->log->error('no BEDROCK_DOCUMENTATION section found in config');
    return $NOT_FOUND;
  }

  my $files = $bedrock_documentation->{file_list};

  if ( !$files || !ref $files ) {
    $r->log->error('no "file_list" object found in BEDROCK_DOCUMENTATION section of config');
    return $NOT_FOUND;
  }

  if ( !$files->{$document_name} ) {
    $r->log->error( $document_name . ' not found in file_list section of BEDROCK_DOCUMENTATION' );
    return $NOT_FOUND;
  }

  my $filename = $files->{$document_name}->{path};

  return $NOT_FOUND
    if !-e $filename;

  my ( $name, $path, $ext ) = fileparse( $filename, qr/[.][^.]+$/xsm );

  my $html = eval {
    return _show_pod( $bedrock_handler, file => $filename )
      if $ext =~ /pl|pm|cgi/xsm;

    return _render_markdown( $bedrock_handler, $filename );
  };

  if ( !$html || $EVAL_ERROR ) {
    $r->log->error( sprintf 'could not render %s %s', $filename, $EVAL_ERROR );
    return $NOT_FOUND;
  }

  return output(
    $r,
    { uri_root => $bedrock_handler->get_bedrock_admin_dir,
      html     => $html,
    }
  );
}

########################################################################
sub tag_docs {
########################################################################
  my ( $bedrock_handler, $tag ) = @_;

  my $r = $bedrock_handler->request;

  if ($tag) {
    my $tag_file = find_tag_file($tag);

    if ($tag_file) {
      return show_pod( $bedrock_handler, $tag_file, 'tag' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  return output( $r, { uri_root => $bedrock_admin_dir, tags => \@TAG_LIST } )
    if is_api($r);

  my $tag_link = q{<a href="%s/tag/%s">%s</a>};

  my @tag_listing = map { sprintf $tag_link, $bedrock_admin_dir, $_, $_ } @TAG_LIST;

  my $html = listing( $bedrock_handler, 'Bedrock Tag Listing', @tag_listing );

  return output( $r, $html );
}

########################################################################
sub listing {
########################################################################
  my ( $bedrock_handler, $title, @listing ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-listing' );

  my $head = listing_head( $bedrock_handler, $title );

  return template(
    $config,
    $template,
    head    => $head,
    listing => \@listing
  );
}

########################################################################
sub listing_head {
########################################################################
  my ( $bedrock_handler, $title ) = @_;

  my $config = $bedrock_handler->config;

  return listing_index( $config, title => $title, );
}

########################################################################
sub validate_paths {
########################################################################
  my (@paths) = @_;

  # only valid paths...
  my %valid_paths = map { $_ => -d $_ && -r $_ } @paths;

  if ( any { !$_ } values %valid_paths ) {
    get_logger()->warn( 'found invalid valid paths: ', Dumper( [ grep { !$valid_paths{$_} } keys %valid_paths ] ) );
  }

  return grep { $valid_paths{$_} } keys %valid_paths;
}

########################################################################
sub get_doc_paths {
########################################################################
  my ( $config, $type ) = @_;

  $type = uc "${type}_PATHS";

  my @doc_paths;

  foreach my $path_list ( grep {defined} ( $ENV{$type}, $config->{$type} ) ) {

    next
      if !$path_list;

    if ( !is_array($path_list) ) {
      $path_list = [ split /:/xsm, $path_list // $EMPTY ];
    }

    push @doc_paths, validate_paths( @{$path_list} );
  }

  get_logger()->debug(
    sub {
      return Dumper(
        [ type  => $type,
          paths => \@doc_paths
        ]
      );
    }
  );

  return \@doc_paths;
}

########################################################################
sub get_markdown_paths { push @_, 'markdown'; goto &get_doc_paths; }
sub get_pod_paths      { push @_, 'pod';      goto &get_doc_paths; }
########################################################################

########################################################################
sub internal_server_error {
########################################################################
  my ( $r, $error ) = @_;

  $error = Text::URLEncode::Htmlencode $error;

  if ( is_api($r) ) {
    output( $r, { error => $error } );
    return $OK;
  }

  my $html = <<"END_OF_HTML";
<html>
 <body>
  <h2>An internal error has occurred. Documentation not available at this time.</h2>

  <hr/>

  <pre style="color:red;">
  $error
  </pre>

 </body>
</html>

END_OF_HTML

  $r->content_type('text/html');

  $r->send_http_header;

  print $html;

  return $OK;
}

########################################################################
sub get_session {
########################################################################
  my ($bedrock_handler) = @_;

  return $bedrock_handler->{session}
    if $bedrock_handler->{session};

  my $session = eval { return bind_session( $bedrock_handler, $FALSE ); };
  $bedrock_handler->{session} = $session;

  return $session;
}

########################################################################
# get_logger
########################################################################
{
  my $logger;

  sub get_logger {
    return $logger
      if $logger;

    $logger = Log::Log4perl->get_logger(__PACKAGE__);

    return $logger;
  }
}

1;

## no critic

__END__

=pod

=head1 NAME

Bedrock::Apache::BedrockDocs - Provides Bedrock and user documentation
as HTML

=head1 SYNOPSIS

 AllowEncodedSlashes On

 <Directory /var/www/html/bedrock/>
   AcceptPathInfo On
   Options -Indexes
   AllowOverride None
 
   <IfModule mod_perl.c>
     SetHandler perl-script 
     PerlHandler Apache::BedrockDocs 
   </IfModule>
 
   <IfModule !mod_perl.c>
     SetHandler bedrock-docs
   </IfModule>
 
   AuthType Basic
   AuthName Bedrock
   AuthBasicProvider file
   AuthUserFile /usr/local/share/bedrock/config/bedrock.users

   require valid-user
 
 </Directory>

=head1 DESCRIPTION

Displays Bedrock documentation for tags and Bedrock internals. Renders
L<pod|https://perldoc.perl.org/perlpod> embedded in Bedrock's Perl
modules as HTML.

Your own documentation contained in the form of embedded I<pod> and I<markdown>
can  also be rendered by this module (See L</USER
DOCUMENTATION>).

=head1 ENABLING BEDROCK DOCUMENTATION

Bedrock documentation availability is controlled by the configuration
variable C<ALLOW_BEDROCK_INFO> in F<tagx.xml>.  Set the configuration
variable to one of the values described below.

=over 5

=item yes/on/1

Allow documentation and possibly other information (configuration,
environment).

=item no/off/0

Do not allow documentation.

=item docs

Allow documentation only.

=back

To allow configuration information to be displayed set
C<ALLOW_BEDROCK_CONFIG_INFO> To allow environment information to
be displayed set C<ALLOW_BEDROCK_ENV_INFO> to C<yes>. The default
value for these variables is C<no>.

=head1 USER DOCUMENTATION

Bedrock can also display documentation you have embedded in your own Perl
modules or found in files that contain markdown.

=head2 Pod

Set the configuration variable C<POD_PATHS> in your F<tagx.xml> to
either a colon separated string of absolute paths to your Perl modules
(accessible to the webserver running this module) or an array of
paths. You can also set the C<POD_PATHS> environment variable in your
Apache configuration.

 <scalar name="POD_PATHS">/home/fred/git/acme-pebbles/lib</scalar>

or

 <array name="POD_PATHS">
   <scalar>/home/fred/git/acme-dino</scalar>
   <scalar>/home/fred/git/acme-quarry/lib</scalar>
 </array>

or in your Apache's configuration:

 SetEnv POD_PATHS /home/fred/git/acme-quarry/lib

Bedrock's documentation facility will recurse sub-directories and list
all modules that end with C<.pm>.

I<HINT: Create a separate F<markdown_paths.xml> file that contains the
paths and drop that in Bedrock's config directory.>

=head2 Markdown

Set the scalar configuration variable C<MARKDOWN_PATHS> to either a
colon separated string of absolute paths to your paths or an array of
paths that may include C<.md> files. You can also set the
C<MARKDOWN_PATHS> environment variable in your Apache configuration.

 <array name="MARKDOWN_PATHS">
   <scalar>/usr/local/share/my-app/docs</scalar>
 </array>

=head1 SEE ALSO

L<perlpod|https://perldoc.perl.org/perlpod>

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=cut
