#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::BedrockDocs;

use strict;
use warnings;

BEGIN {
  if ( $ENV{MOD_PERL} ) {
    require Apache2::compat;
  }
}

use Apache2::Const -compile =>
  qw{ HTTP_UNAUTHORIZED NOT_FOUND OK SERVER_ERROR FORBIDDEN DECLINED REDIRECT :log};

use Apache2::Log;
use APR::Const -compile => qw(:error SUCCESS);

use Bedrock qw{:utils};
use Bedrock::BedrockConfig;
use Bedrock::Constants qw{:regexp :chars :booleans :defaults};
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::VERSION qw{version};
use Bedrock::Template;

use Text::TagX;

use Carp;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Temp;
use File::Find;
use Pod::Html;
use Time::HiRes qw{ gettimeofday };
use Scalar::Util qw{ reftype blessed};
use List::Util qw{ any pairs none};

use bedrock_handler_common;
use Readonly;

Readonly our $NOT_FOUND    => Apache2::Const::NOT_FOUND;
Readonly our $SERVER_ERROR => Apache2::Const::SERVER_ERROR;
Readonly our $FORBIDDEN    => Apache2::Const::FORBIDDEN;
Readonly our $OK           => Apache2::Const::OK;
Readonly our $DECLINED     => Apache2::Const::DECLINED;
Readonly our $REDIRECT     => Apache2::Const::REDIRECT;

Readonly our $DEFAULT_IMAGE_URL => '/bedrock/img';
Readonly our $POD_MIN_SIZE      => 600;

########################################################################
sub show_pod {
########################################################################
  my ( $bedrock_handler, $file, $return_url ) = @_;

  my $html = _show_pod( $file, $bedrock_handler->config );

  if ( !$html ) {
    my $url = sprintf 'http://%s/%s/%s',
      $ENV{HTTP_HOST},
      $bedrock_handler->get_bedrock_admin_dir,
      $return_url;

    $bedrock_handler->request_handler->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub _logo_url {
########################################################################
  my ($conf) = @_;

  my $image_url = $conf->{BEDROCK_IMAGE_URL} || $DEFAULT_IMAGE_URL;

  return sprintf '%s/%s', $image_url, $conf->{BEDROCK_LOGO};
}

# show_pod(file, config-object);
########################################################################
sub _show_pod {
########################################################################
  my ( $file, $conf ) = @_;

  my $bedrock_admin_dir = $conf->{BEDROCK_ADMIN_DIR} || '/bedrock';

  my $pod = tmpnam;

  my $pod_css_url = $conf->{BEDROCK_POD_CSS_URL};

  my %options = (
    '--infile'   => $file,
    '--outfile'  => $pod,
    '--cachedir' => File::Spec->tmpdir(),
  );

  if ($pod_css_url) {
    $options{'--css'} = $pod_css_url;
  }

  pod2html( '--backlink', map { "$_=" . $options{$_} } keys %options );

  my $bedrock_logo = _logo_url($conf);

  my $top_section = <<'END_OF_HTML';
<table width="100%">

<tr>
  <td align="left">
    <a href="<var $back>"><img src="<var $logo>" border="0"></a>
  </td>
  <td align="right" valign="bottom" width="9999">
    <i>Bedrock Version: <var $version></i>
  </td>
</tr>

<tr>
  <td colspan="2"><hr></td>
</tr>
</table>
END_OF_HTML

  $top_section = template(
    $top_section,
    back    => $bedrock_admin_dir,
    logo    => $bedrock_logo,
    version => version('full')
  );

  my $data;

  # little or no pod?
  if ( -s $pod > $POD_MIN_SIZE ) {

    open my $fh, '<', $pod
      or croak "Unable to open $pod: $OS_ERROR\n";

    local $RS = undef;

    $data = <$fh>;

    close $fh
      or croak "could not close file\n";

    $data =~ s/(<body(.*?)>)/$1\n$top_section/ixsm;
  }

  unlink $pod;

  return $data;
}

########################################################################
sub get_modules {
########################################################################
  my ( $dir, $no_blms ) = @_;

  return ()
    if !-d $dir;

  my $fh;

  opendir $fh, $dir;

  my @listing;

  while ( my $file = readdir $fh ) {

    next if $file =~ /\A[.]/xsm;

    next if $no_blms && $file =~ /^BLM/xsm;  #  && any {/$dir/xsm} @INC;

    if ( -d "$dir/$file" ) {
      push @listing, get_modules("$dir/$file");
    }
    else {
      if ( $file =~ /^([^.]+)[.]pm$/xsm ) {
        push @listing, "$dir/$1";
      }
    }
  }

  closedir $fh;

  return @listing;
}

########################################################################
sub get_all_modules {
########################################################################
  my ( $paths, $public_only, $no_blms ) = @_;

  my @module_listing;
  my %module_map;

  foreach my $path ( @{$paths} ) {
    my $dir;

    my $filter;

    if ( is_hash($path) ) {
      $dir = $path->{dir};

      $filter = $path->{filter};
      $filter = qr/$filter/xsm;
    }
    else {
      $dir = $path;
    }

    my @modules = get_modules( $dir, $no_blms );

    foreach my $file (@modules) {
      my $module = $file;

      $module =~ s/$dir\///xsm;
      $module =~ s/\//::/xsmg;

      next if $filter && $module !~ $filter;

      $module_map{$module} = $file;
    }

    push @module_listing, @modules;
  }

  # delete non-public modules
  if ($public_only) {
    foreach my $module ( keys %module_map ) {
      next if is_public_module( $module, \%module_map );

      delete $module_map{$module};
    }
  }

  return \%module_map;
}

########################################################################
sub is_public_module {
########################################################################
  my ( $module, $module_map ) = @_;

  local $RS = undef;

  open my $fh, '<', $module_map->{$module} . '.pm'  ## no critic (RequireBriefOpen)
    or return $FALSE;

  my $source = <$fh>;

  close $fh;

  return $source =~ /[=]head1\s+public/xsmi;
}

########################################################################
sub get_all_blms {
########################################################################

  my @module_listing;

  my @blm_path = grep { -d "$_/BLM" } @INC;

  # get public only BLMs
  my $modules = get_all_modules( \@blm_path, $TRUE, $FALSE );

  return @{$modules}{ sort keys %{$modules} };
}

# return the standard documentation header

########################################################################
sub head {
########################################################################
  my (%attributes) = @_;

  $attributes{version} = sprintf '%s - %s', $Bedrock::VERSION::ID,
    $Bedrock::VERSION::BUILD_DATE;

  my $html = <<'END_OF_HTML';
<html>
  <head>
    <title><var $attributes.title></title>
    <link rel="stylesheet" href="<var $attributes.stylesheet>" type="text/css" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  </head>

  <body>
    <table width="100%">
      <tr>
        <td align="left"><a href="<var $attributes.home>"><img src="<var $attributes.image>" border="0"></a></td>
        <td align="right" valign="bottom" width="9999"><i>Bedrock Version: <var $attributes.version></i></td>
      </tr>
      <tr>
        <td colspan="2"><hr></td>
      </tr>
    </table>

    <h1><var $attributes.title></h1>
END_OF_HTML

  return template( $html, attributes => \%attributes );
}

########################################################################
sub ul_links {
########################################################################
  my ( $url, %links ) = @_;

  my $html = <<'END_OF_HTML';
<ul>
 <foreach $links>
 <if $value --re '/disabled/' >
   <li><var $label></li>
 <else>
   <li><a href="<var $url>/<var $key>"><var $value></a></li>
 </if>
 </foreach>
</ul>
END_OF_HTML

  return template( $html, url => $url, links => \%links );
}

########################################################################
sub blm_ul {
########################################################################
  my ( $bedrock_admin_dir, $blms, $h2, @args ) = @_;

  return if !@args;

  my %blm_listing;

  # just the names
  foreach my $blm (@args) {
    $blm_listing{$blm} = $blms->{$blm};
    $blm_listing{$blm} =~ s/^(.*)::(.*)$/$2/xsm;
  }

  my $html = <<'END_OF_HTML';
<h2><var $heading></h2>
<ul>
  <foreach $args>
  <li><a href="<var $bedrock_admin_dir>/plugins/<var $_>"><var $blm_listing.get($_)></a></li>
  </foreach>
</ul>
END_OF_HTML

  my %vars = (
    bedrock_admin_dir => $bedrock_admin_dir,
    args              => \@args,
    blm_listing       => \%blm_listing,
  );

  return template( $html, %vars );

  return $html;
}

########################################################################
sub template {
########################################################################
  my ( $template, %vars ) = @_;

  if ( !exists $vars{env} ) {
    $vars{env} = \%ENV;
  }

  my $text
    = eval { return Bedrock::Template->new( $template, %vars )->parse; };

  die sprintf "error processing template: %s\n%s\n", $template, $EVAL_ERROR
    if !$text || $EVAL_ERROR;

  return $text;
}

########################################################################
sub output {
########################################################################
  my ( $r, $content ) = @_;

  $r->send_http_header;

  return print $content;
}

########################################################################
sub plugin_docs {
########################################################################
  my ( $bedrock_handler, $file ) = @_;

  my $r = $bedrock_handler->request_handler;

  my @blm_listing = get_all_blms();

  $r->log->debug( Dumper( [ 'BLMs:', \@blm_listing ] ) );

  if ($file) {
    my @path_list
      = grep {/(BLM\/$file|BLM\/Startup\/$file)|BLM\/Filter\/$file/ixsm}
      @blm_listing;

    my $path;

    if ( @path_list && -s $path_list[0] . '.pm' ) {
      $path = $path_list[0] . '.pm';
    }

    if ( $path && $path =~ /(BLM\/.*?)[.]pm$/xsm ) {
      my $title = $1;
      $title =~ s/\//::/gxsm;

      return show_pod( $bedrock_handler, $path, 'plugins' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $blms = Bedrock::Hash->new;

  foreach my $blm (@blm_listing) {
    if ( $blm =~ /BLM\/(.*?)$/xsm ) {
      $blms->{$1} = "BLM/$1";
      $blms->{$1} =~ s/\//::/gxsm;
    }
  }

  my $html = <<'END_OF_HTML';
<var $head>
<var $plugins.[0]>
    <hr/>
<var $plugins.[1]>
    <hr/>
<var $plugins.[2]>
  </body>
</html>
END_OF_HTML

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  my @blm_names = keys %{$blms};

  my %sections = (
    Plugins               => [ grep { !/^Startup|Filter/xsm } @blm_names ],
    'Application Plugins' => [ grep {/^Startup/xsm} @blm_names ],
    Filters               => [ grep {/^Filter/xsm} @blm_names ],
  );

  my @plugins
    = map { blm_ul( $bedrock_admin_dir, $blms, $_, @{ $sections{$_} } ) }
    sort keys %sections;

  my $head = listing_head( $bedrock_handler, 'Bedrock Plugins' );

  $html = template( $html, head => $head, plugins => \@plugins );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub system_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $pod_paths = [$DEFAULT_BEDROCK_PERL5LIBDIR];

  # get non-public modules
  my $module_listing = get_all_modules( $pod_paths, $FALSE );

  return $NOT_FOUND
    if !$module_listing || !keys %{$module_listing};

  if ($module) {

    $module =~ s/\//\:\:/xsmg;
    my $path = $module_listing->{$module} . '.pm';

    return show_pod( $bedrock_handler, $path, 'system' );
  }

  my $modules = get_all_modules( $pod_paths, 0, 1 );

  my $url_prefix = '/bedrock/system';
  my $anchor_tag = '<a href="%s/%s">%s</a>';

  my @system_listing;

  foreach my $module ( sort keys %{$modules} ) {
    next if $module =~ /Bedrock::Text|Filter/xsm;

    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @system_listing, sprintf $anchor_tag, $url_prefix, $path, $module;
  }

  my $html = listing( $bedrock_handler, 'System Documention Listing',
    @system_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub pod_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $module_listing;

  my $pod_paths = $bedrock_handler->config->{POD_PATHS};

  if ( $pod_paths && @{$pod_paths} ) {
    $module_listing = get_all_modules( $pod_paths, 0 );
  }

  if ( $module && $module_listing && keys %{$module_listing} ) {
    $module =~ s/\//\:\:/xsmg;
    my $path = $module_listing->{$module} . '.pm';

    return show_pod( $bedrock_handler, $path, 'tag' );
  }

  my $title = 'User Documentation Listing';

  if ( !$module_listing || !keys %{$module_listing} ) {
    my $html = <<'END_OF_HTML';
%s
 No user documentation found.
  </body>
</html>
END_OF_HTML
    $html = sprintf listing_head( $bedrock_handler, $title );
    output( $bedrock_handler->request_handler, $html );

    return $OK;
  }

  my $anchor_tag = '<a href="%s/pod/%s/%s">%s</a>';

  my @pod_listing;

  foreach my $module ( sort keys %{$module_listing} ) {
    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @pod_listing, sprintf $anchor_tag,
      $bedrock_handler->get_bedrock_admin_dir, $path, $module;
  }

  my $html = listing( $bedrock_handler, $title, @pod_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub env_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;

  my $env
    = $allow_env =~ /^y/xsmi
    ? \%ENV
    : { ALLOW_BEDROCK_ENV_INFO => $allow_env };

  return hash_docs( $bedrock_handler, 'Environment', $env );
}

########################################################################
sub config_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config       = $bedrock_handler->config;
  my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;

  $config
    = $allow_config =~ /^y/xsmi
    ? $config
    : { ALLOW_BEDROCK_CONFIG_INFO => $allow_config };

  return hash_docs( $bedrock_handler, 'Configuration', $config );
}

########################################################################
sub hash_docs {
########################################################################
  my ( $bedrock_handler, $title, $hash ) = @_;

  my $html = <<'END_OF_HTML';
<var $head>
    <table cellpadding="0" cellspacing="0" border="0">
    <foreach $hash>
      <tr>
        <th valign="middle" align="right"><code><var $key></code>&nbsp;</th>
        <if --ref $value>
        <td valign="bottom"><pre style="margin:0;padding:0;" class="configref"><var $value.compact()></pre></td>
        <else>
        <td valign="bottom"><pre style="margin:0;padding:0;" class="configvar"><var $value></pre></td>
        </if>
      </tr>
    </foreach>
    </table>
  </body>
</html>
END_OF_HTML

  # make sure that all refs can('compact')
  foreach ( %{$hash} ) {
    next if !ref $_ || blessed $_;

    bless $_, 'Bedrock::Dump';
  }

  my $head = listing_head( $bedrock_handler, 'Bedrock ' . $title );

  $html = template( $html, head => $head, hash => $hash );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub find_tag_file {
########################################################################
  my ($tag) = @_;

  my $tagx = 'Text/TagX/TAG';

  my ($tag_path) = grep { -d "$_/$tagx" } @INC;

  return $EMPTY
    if !$tag_path;

  my @path_stubs
    = map {"$tag_path/$tagx/$_"} qw{  NoBody WithBody WithBody/Loop };

  my @search_paths = map { sprintf '%s/%s.pm', $_, ucfirst $tag } @path_stubs;

  my ($tag_file) = grep {-e} @search_paths;

  return $tag_file
    if $tag_file;

  no warnings 'File::Find';  ## no critic

  find(
    sub {
      my ($name) = split /[.]/xsm, $_;
      return if !$name;

      print {*STDERR} "name: $name\n";

      if ( !$tag_file && $tag eq lc $name ) {
        $tag_file = $File::Find::name;
      }
    },
    @path_stubs
  );

  return $tag_file;
}

########################################################################
sub tag_list {
########################################################################
  my @tags;

  # this will always be true...
  if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
    foreach ( sort split /[|]/xsm, $1 ) {
      next if /[#]|else|else[?]if|blm|[?]/xsm;

      push @tags, $_;
    }
  }

  return @tags;
}

########################################################################
sub tag_docs {
########################################################################
  my ( $bedrock_handler, $tag ) = @_;

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  if ($tag) {
    my $tag_file = find_tag_file($tag);

    if ($tag_file) {
      return show_pod( $bedrock_handler, $tag_file, 'tag' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my @tag_listing
    = map { sprintf q{<a href="%s/tag/%s">%s</a>}, $bedrock_admin_dir, $_, $_ }
    tag_list();

  my $html = listing( $bedrock_handler, 'Bedrock Tag Listing', @tag_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub listing {
########################################################################
  my ( $bedrock_handler, $title, @listing ) = @_;

  my $html = <<'END_OF_HTML';
<var $head>
    <ul>
    <foreach $listing>
      <li><var $_></li>
    </foreach>
    </ul>
  </body>
</html>
END_OF_HTML

  my $head = listing_head( $bedrock_handler, $title );

  return template(
    $html,
    head    => $head,
    listing => \@listing
  );
}

########################################################################
sub listing_head {
########################################################################
  my ( $bedrock_handler, $title ) = @_;

  return head(
    title      => $title,
    stylesheet => $bedrock_handler->config->{BEDROCK_POD_CSS_URL},
    home       => $bedrock_handler->get_bedrock_admin_dir,
    image      => _logo_url( $bedrock_handler->config ),
  );

}

# +------------------------------+
# | mod_perl HANDLER STARTS HERE |
# +------------------------------+

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # start HiRes timer
  my ( $start_seconds, $start_microseconds );

  if ( get_loglevel($r) eq 'debug' ) {
    ( $start_seconds, $start_microseconds ) = gettimeofday();
  }

  my $bedrock_handler = init_bedrock_handler($r);

  if ( !$bedrock_handler ) {
    $r->log->error(q{Could not initialize Bedrock's handler});

    return $SERVER_ERROR;
  }

  my $conf = $bedrock_handler->config();

  my $bedrock_info = lc( $conf->{ALLOW_BEDROCK_INFO} // $EMPTY );

  if ( none { $bedrock_info eq $_ } qw{ yes docs} ) {
    $r->log->error(
      sprintf
        'Bedrock admin directory request denied by configuration (ALLOW_BEDROCK_INFO): [%s]',
      $bedrock_info
    );

    return $FORBIDDEN;
  }

  $r->content_type('text/html');

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  my $uri = $r->uri;
  $uri =~ s/^$bedrock_admin_dir//xsm;

  my $html;

  my $bedrock_logo_url = _logo_url($conf);

  for ($uri) {
    /plugins\/?(.*?)$/xsm && do {
      return plugin_docs( $bedrock_handler, $1 );
    };

    /system\/?(.*?)\/?$/xsm && do {
      return system_docs( $bedrock_handler, $1 );
    };

    /pod\/?(.*?)\/?$/xsm && do {
      return pod_docs( $bedrock_handler, $1 );
    };

    /tag\/?(.*?)\/?$/xsm && do {
      return tag_docs( $bedrock_handler, lc $1 );
    };

    /^\/env\/?$/xsm && do {
      return env_docs($bedrock_handler);
    };

    /^\/config\/?$/xsm && do {
      return config_docs($bedrock_handler);
    };

    my $html = <<'END_OF_HTML';
<var $head>
  <hr/>
  <var $tags>
  <hr/>

  <h1>System Documentation</h1>
  <var $system_docs>

  <hr/>
  <h1>User Documentation</h1>
  <var $user_docs>

  <hr/>
  <h1>Bedrock Environment</h1>
  <var $bedrock_env>

  <hr/>
  <h1>Bedrock Log Configuration</h1>

  <ul>
    <li><var $config.LOG4PERL></li>
  </ul>
  </body>
</html>
END_OF_HTML

    my %vars = ( config => $bedrock_handler->config );

    $vars{head} = listing_head( $bedrock_handler, 'Bedrock Reference Guide' );

    $vars{tags} = ul_links(
      $bedrock_admin_dir,
      tag     => 'Bedrock Tags',
      plugins => 'Bedrock Plugins',
    );

    $vars{system_docs}
      = ul_links( $bedrock_admin_dir, system => 'System Modules' );

    my $modules;

    if ( $conf->{POD_PATHS} && @{ $conf->{POD_PATHS} } ) {
      $vars{modules}
        = ul_links( $bedrock_admin_dir, pod => 'Module Listing' );
    }

    if ( $conf->{ALLOW_BEDROCK_INFO} ne 'docs' ) {

      my $allow_config = $conf->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;
      $allow_config
        = $allow_config =~ /^y/xsmi ? 'Bedrock Configuration' : '(disabled)';

      my $allow_env = $conf->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;
      $allow_env
        = $allow_env =~ /^y/xsmi ? 'Bedrock Environment' : '(disabled)';

      $vars{bedrock_env} = ul_links(
        $bedrock_admin_dir,
        config => $allow_config,
        env    => $allow_env,
      );
    }

    output( $r, template( $html, %vars ) );

    return $OK;
  }
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 NAME

Bedrock::Apache::BedrockDocs - Provide Bedrock documentation as HTML

=head1 SYNOPSIS

 <Directory /var/www/html/bedrock/>
   AcceptPathInfo On
   Options -Indexes
   AllowOverride None
 
   <IfModule mod_perl.c>
     SetHandler perl-script 
     PerlHandler Apache::BedrockDocs 
   </IfModule>
 
   <IfModule !mod_perl.c>
     SetHandler bedrock-docs
   </IfModule>
 
   AuthType Basic
   AuthName Bedrock
   AuthBasicProvider file
   AuthUserFile /usr/lib/bedrock/config/bedrock.users
   require valid-user
 
 </Directory>

=head1 DESCRIPTION

Displays documentation (pod) embedded in Bedrock's Perl modules as
HTML. Bedrock documentation availability is controlled by the
configuration variable C<ALLOW_BEDROCK_INFO> in F<tagx.xml>.  Set the
configuration variable to one of the values described below.

=over 5

=item yes

Allow documentation and possibly other information (configuration, environment).

=item no

Do not allow documentation.

=item docs

Allow documentation only.

=back

To allow configuration information to be displayed set
C<ALLOW_BEDROCK_CONFIG_INFO To allow environment information to
be displayed set C<ALLOW_BEDROCK_ENV_INFO> to C<yes>. The default
value for these variables is C<no>.

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
