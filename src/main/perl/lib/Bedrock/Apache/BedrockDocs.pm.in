package Apache::BedrockDocs;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2024, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

# TODO:
# [ ] option to disable traversing all sub-directories
# [ ] collapsible directories
# [ ] cache user documentation paths (.md, .pm)

use strict;
use warnings;

use Bedrock qw(:booleans slurp_file);
use Bedrock::PodWriter qw(pod2html);
use Bedrock::Apache::Constants qw(:http);
use Bedrock::BedrockConfig;
use Bedrock::Constants qw(:regexp :chars :booleans :defaults);
use Bedrock::Context qw(init_log4perl_logger);
use Bedrock::Dump;
use Bedrock::Handler qw(%BEDROCK_CONFIG_CACHE);
use Bedrock::Template;
use Bedrock::VERSION qw(version);
use BLM::Startup::UserSession;

use Carp;
use CGI;
use Data::Dumper;
use English qw(-no_match_vars );
use File::Basename;
use File::Temp;
use File::Find;
use Markdown::Render;
use Scalar::Util qw(reftype blessed);
use List::Util qw(any pairs none);
use LWP::UserAgent;
use LWP::Protocol::https;  # force rpmbuild to include
use Text::URLEncode;
use Log::Log4perl;

use Role::Tiny::With;
with 'Bedrock::Logger';
use Readonly;

Readonly our $DEFAULT_IMAGE_URL => '/bedrock/img';
Readonly our $POD_MIN_SIZE      => 600;

our @TAG_LIST;

if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
  @TAG_LIST = sort split /[|]/xsm, $1;
  @TAG_LIST = grep { !/[#]|else|else[?]if|blm|[?]/xsm } @TAG_LIST;
}

our $LOGGER;
our $SESSION;

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  my $bedrock_handler = eval { return Bedrock::Handler->new($r); };

  if ( $EVAL_ERROR || !$bedrock_handler ) {
    $r->log->error(qq{Could not initialize Bedrock's handler\n$EVAL_ERROR});

    return internal_server_error( $r, $EVAL_ERROR );
  }

  if ( !Log::Log4perl->initialized ) {
    init_log4perl_logger();
  }

  $LOGGER = get_logger(__PACKAGE__);

  $SESSION = eval { return get_session($bedrock_handler); };

  if ($SESSION) {
    my %headers = %{ $r->headers_in };

    $SESSION->set( 'Referer', $headers{Referer} );
  }

  my $status = eval {

    my $config = $bedrock_handler->config();

    my $bedrock_info = $config->{ALLOW_BEDROCK_INFO} // $EMPTY;

    if ( none { lc $bedrock_info eq $_ } qw{ on 1 yes docs} ) {
      $r->log->error( sprintf 'Bedrock admin directory denied by configuration (ALLOW_BEDROCK_INFO): [%s]',
        $bedrock_info );

      return $FORBIDDEN;
    }

    $config->{BEDROCK_IMAGE_URL}   //= $DEFAULT_IMAGE_URL;
    $config->{BEDROCK_ADMIN_DIR}   //= '/bedrock';
    $config->{BEDROCK_INCLUDE_DIR} //= $DEFAULT_BEDROCK_INCLUDE_DIR;

    # used by .inc files that include other files (--file=~/bedrock-docs-header)
    local $ENV{DOCUMENT_ROOT} = $config->{BEDROCK_INCLUDE_DIR};

    ####################################################################
    # router
    ####################################################################
    my $uri = $r->uri;
    $uri =~ s/^$config->{BEDROCK_ADMIN_DIR}//xsm;

    $LOGGER->debug("handling: $uri");

    for ($uri) {
      /plugins\/?(.*?)$/xsm && do {
        return plugin_docs( $bedrock_handler, $1 );
      };

      /system\/?(.*?)\/?$/xsm && do {
        return system_docs( $bedrock_handler, $1 );
      };

      /pod\/?(.*?)\/?$/xsm && do {
        my $module = $1 ? $1 : CGI->new->param('module');
        return pod_docs( $bedrock_handler, $module );
      };

      /markdown\/?(.*?)\/?$/xsm && do {
        return markdown_docs( $bedrock_handler, $1 );
      };

      /tag\/?(.*?)\/?$/xsm && do {
        return tag_docs( $bedrock_handler, lc $1 );
      };

      /^\/env\/?$/xsm && do {
        return env_docs($bedrock_handler);
      };

      /^\/config\/?$/xsm && do {
        return config_docs($bedrock_handler);
      };

      /^\/clear\-cache/xsm && do {
        %BEDROCK_CONFIG_CACHE = ();
      };
    }

    ####################################################################
    # documentation home page
    ####################################################################

    my $template = fetch_template( $config, 'bedrock-docs-index' );

    my %parameters;

    $parameters{head} = listing_head( $bedrock_handler, 'Bedrock Reference Guide' );

    ####################################################################
    # head
    ####################################################################
    $parameters{tags} = ul_links(
      $config,
      tag     => 'Bedrock Tags',
      plugins => 'Bedrock Plugins',
    );

    ####################################################################
    # system modules
    ####################################################################

    $parameters{system_docs} = ul_links( $config, system => 'System Modules' );

    ####################################################################
    # user modules
    ####################################################################
    my $pod_paths = get_pod_paths($bedrock_handler);

    if ($pod_paths) {
      $parameters{user_docs} = ul_links( $config, pod => 'Module Listing' );
    }

    ####################################################################
    # markdown
    ####################################################################
    my $markdown_paths = get_markdown_paths($bedrock_handler);

    if ($markdown_paths) {
      $parameters{markdown_docs} = ul_links( $config, markdown => 'Documentation Listing' );
    }

    ####################################################################
    # config & environment
    ####################################################################
    if ( $config->{ALLOW_BEDROCK_INFO} ne 'docs' ) {

      my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;
      $allow_config = $allow_config =~ /^y|1|on/xsmi;

      my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;
      $allow_env = $allow_env =~ /^y|1|on/xsmi;

      $parameters{bedrock_env} = ul_links(
        $config,
        config => $allow_config ? 'Bedrock Configuration' : '(disabled)',
        env    => $allow_env    ? 'Bedrock Environment'   : '(disabled)',
      );
    }

    if ( $config->{LOG4PERL} && -e $config->{LOG4PERL} ) {
      $parameters{log4perl} = slurp_file $config->{LOG4PERL};
    }

    ####################################################################
    # finalize and output
    ####################################################################
    output( $r, template( $config, $template, %parameters ) );

    return $OK;
  };

  if ($SESSION) {
    $SESSION->closeBLM();
  }

  return $EVAL_ERROR ? internal_server_error( $r, $EVAL_ERROR ) : $status;
}

########################################################################
sub header {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-header' );

  return template( $config, $template, %parameters );
}

########################################################################
sub fetch_template {
########################################################################
  my ( $config, $template ) = @_;

  my $file = sprintf '%s/%s.inc', $config->{BEDROCK_INCLUDE_DIR}, $template;

  return slurp_file($file);
}

########################################################################
sub is_available_on_metacpan {
########################################################################
  my ($module) = @_;

  my $ua = LWP::UserAgent->new;

  my $url = 'https://metacpan.org/pod/' . $module;

  my $res = $ua->head($url);

  return $res->code eq $HTTP_OK ? $url : $EMPTY;
}

########################################################################
sub show_pod {
########################################################################
  my ( $bedrock_handler, $file, $back_url, $module ) = @_;

  my $request = $bedrock_handler->request_handler;

  my %headers = %{ $request->headers_in };

  my $html = _show_pod( $bedrock_handler, $file, '/bedrock', $module );

  # most of the time the module we are looking for is in our path or
  # inside the webserver hosting this application...occassionally
  # we'll be following a link within the pod itself...and those
  # modules may not be installed on our server, thus we might not be
  # able to show pod...but wait! Let's see if we can find some pod on Metacpan!

  if ( !$html ) {
    # see if this is on metacpan
    my $module_listing = $BEDROCK_CONFIG_CACHE{METACPAN};

    if ( !$module_listing ) {
      $module_listing = {};
      $BEDROCK_CONFIG_CACHE{METACPAN} = $module_listing;
    }

    # cache availability...no need checking for this more than once
    if ( !exists $module_listing->{$module} ) {
      $module_listing->{$module} = is_available_on_metacpan($module);
    }

    my $url = $module_listing->{$module};

    if ( !$url ) {

      $url = $headers{Referer} || sprintf 'http://%s/%s/%s',
        $ENV{HTTP_HOST},
        $bedrock_handler->get_bedrock_admin_dir,
        $back_url;
    }

    $bedrock_handler->request_handler->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub _show_pod {
########################################################################
  my ( $bedrock_handler, $file, $back_url, $module ) = @_;

  my $config = $bedrock_handler->config();

  if ( !$file || !-e $file ) {
    $file = $module;
    $file =~ s/::/\//gxsm;
    # see if we can find the file in Perl's @INC
    ($file) = grep { -e $_ } map {"$_/$file.pm"} @INC;

    if ( !$file ) {

    }
    # TODO: cache this...
  }

  my $html;

  if ( $file && -e $file ) {
    $html = create_pod_file( $bedrock_handler, $file, $config->{BEDROCK_POD_CSS_URL} );

    $back_url = sprintf '%s/%s', $config->{BEDROCK_ADMIN_DIR}, $back_url;
  }

  return
    if !$html || length($html) < $POD_MIN_SIZE;

  $module =~ s/\//::/xsmg;

  my $top_section = header( $config, back_url => $back_url, module => $module );

  $html =~ s/(<body(.*?)>)/$1\n$top_section/ixsm;

  return $html;
}

########################################################################
sub create_pod_file {
########################################################################
  my ( $bedrock_handler, $file, $css_url ) = @_;

  my $pod = tmpnam;

  my %options = (
    '--infile'   => $file,
    '--outfile'  => $pod,
    '--cachedir' => File::Spec->tmpdir(),
    $css_url ? ( '--css' => $css_url ) : (),
  );

  my $html = eval {
    pod2html( '--backlink', map { "$_=" . $options{$_} } keys %options );

    return slurp_file $pod;
  };

  if ($EVAL_ERROR) {
    $LOGGER->error("pod2html error: $EVAL_ERROR");
  }

  if ( -e $pod ) {
    unlink $pod;
  }

  return $html;
}

########################################################################
sub get_modules {
########################################################################
  my ( $dir, $exclude_blms ) = @_;

  return find_files(
    dir          => $dir,
    exclude_blms => $exclude_blms,
    ext          => 'pm'
  );
}

########################################################################
sub find_markdown_files {
########################################################################
  my ($dir) = @_;

  return find_files(
    dir          => $dir,
    exclude_blms => $TRUE,
    ext          => 'md'
  );
}

########################################################################
sub find_files {
########################################################################
  my (%args) = @_;

  my ( $dir, $no_blms, $ext ) = @args{qw(dir exclude_blms ext)};

  $ext //= 'pm';

  return ()
    if !-d $dir;

  my $fh;

  opendir $fh, $dir;

  my @listing;

  while ( my $file = readdir $fh ) {

    next if $file =~ /\A[.]/xsm;

    next if $no_blms && $file =~ /^BLM/xsm;  #  && any {/$dir/xsm} @INC;

    if ( -d "$dir/$file" ) {
      push @listing,
        find_files(
        dir          => "$dir/$file",
        exclude_blms => $no_blms,
        ext          => $ext
        );
    }
    else {
      if ( $file =~ /^([^.]+)[.]$ext$/xsm ) {
        push @listing, "$dir/$1";
      }
    }
  }

  closedir $fh;

  return @listing;
}

########################################################################
sub get_all_modules {
########################################################################
  my ( $paths, $public_only, $no_blms ) = @_;

  my @module_listing;

  my %module_map;

  foreach my $path ( @{$paths} ) {
    my $dir;

    my $filter;

    if ( is_hash($path) ) {
      $dir = $path->{dir};

      $filter = $path->{filter};
      $filter = qr/$filter/xsm;
    }
    else {
      $dir = $path;
    }

    my @modules = get_modules( $dir, $no_blms );

    foreach my $file (@modules) {
      next if !has_pod("$file.pm");

      my $module = get_module_name( $file, $dir );

      next if $filter && $module !~ $filter;

      $module_map{$module} = $file;
    }

    push @module_listing, @modules;
  }

  # delete non-public modules
  if ($public_only) {
    foreach my $module ( keys %module_map ) {
      next if is_public_module( $module, \%module_map );

      delete $module_map{$module};
    }
  }

  return \%module_map;
}

########################################################################
sub get_module_name {
########################################################################
  my ( $file, $dir ) = @_;

  $dir = "$dir/";

  my $potential_name = $file;
  $potential_name =~ s/$dir//xsm;

  $potential_name =~ s/\//::/xsmg;

  my @package_names;

  open my $fh, '<', "$file.pm"
    or die "could not open $file.pm for reading. $OS_ERROR";

  while ( my $line = <$fh> ) {
    next if $line !~ /^\s*package\s+([^;]+);/xsm;
    push @package_names, $1;
  }

  close $fh;

  my ($package_name) = grep {/$potential_name/xsm} @package_names;
  $package_name //= $package_names[0];

  return $package_name;
}

########################################################################
sub has_pod {
########################################################################
  my ($file) = @_;

  my $text = slurp_file $file;

  return $text =~ /^[=]pod\s*$/xsm;
}

########################################################################
sub is_public_module {
########################################################################
  my ( $module, $module_map ) = @_;

  my $file = $module_map->{$module} . '.pm';

  my $source = slurp_file $file;

  return $source =~ /[=]head1\s+public/xsmi;
}

########################################################################
sub get_all_blms {
########################################################################

  my @module_listing;

  my @blm_path = grep { -d "$_/BLM" } @INC;

  # get public only BLMs
  my $modules = get_all_modules( \@blm_path, $TRUE, $FALSE );

  return @{$modules}{ sort keys %{$modules} };
}

# return the standard documentation header

########################################################################
sub listing_index {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

  return template( $config, $template, %parameters );
}

########################################################################
sub ul_links {
########################################################################
  my ( $config, %options ) = @_;

  my $back_url = delete $options{back_url};

  $back_url //= $config->{BEDROCK_ADMIN_DIR};

  my $template = fetch_template( $config, 'bedrock-docs-ul' );

  return template( $config, $template, url => $back_url, links => \%options );
}

########################################################################
sub blm_ul {
########################################################################
  my ( $bedrock_handler, $blms, $h2, @args ) = @_;

  return if !@args;

  my %blm_listing;

  # just the names
  foreach my $blm (@args) {
    $blm_listing{$blm} = $blms->{$blm};
    $blm_listing{$blm} =~ s/^(.*)::(.*)$/$2/xsm;
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-blms' );

  my $uri = '%s/plugins/%s';

  my $list = Bedrock::Hash->new(
    map { $blm_listing{$_} => sprintf $uri, $config->{BEDROCK_ADMIN_DIR}, $_ }
    sort @args
  );

  my %vars = (
    heading => $h2,
    list    => $list,
  );

  return template( $config, $template, %vars );
}

########################################################################
sub template {
########################################################################
  my ( $config, $template, %parameters ) = @_;

  carp 'no template to process'
    if !$template;

  my $logo_url = sprintf '%s/%s', @{$config}{qw(BEDROCK_IMAGE_URL BEDROCK_LOGO)};

  %parameters = (
    env        => \%ENV,
    back_url   => $config->{BEDROCK_ADMIN_DIR},
    config     => $config,
    version    => version('full'),
    logo       => $logo_url,
    stylesheet => $config->{BEDROCK_POD_CSS_URL},
    %parameters,
  );

  my $text = eval { return Bedrock::Template->new( $template, %parameters )->parse; };

  die sprintf "error processing template: %s\n%s\n", $template, $EVAL_ERROR
    if !$text || $EVAL_ERROR;

  return $text;
}

########################################################################
sub output {
########################################################################
  my ( $r, $content ) = @_;

  $r->content_type('text/html');

  $r->send_http_header;

  return print $content;
}

########################################################################
sub plugin_docs {
########################################################################
  my ( $bedrock_handler, $file ) = @_;

  my $r = $bedrock_handler->request_handler;

  my @blm_listing = get_all_blms();

  $LOGGER->trace( Dumper( [ 'BLMs:', \@blm_listing ] ) );

  if ($file) {
    my @path_list = grep {/(BLM\/$file|BLM\/Startup\/$file)|BLM\/Filter\/$file/ixsm} @blm_listing;

    my $path;

    if ( @path_list && -s $path_list[0] . '.pm' ) {
      $path = $path_list[0] . '.pm';
    }

    if ( $path && $path =~ /(BLM\/.*?)[.]pm$/xsm ) {
      my $title = $1;
      $title =~ s/\//::/gxsm;

      return show_pod( $bedrock_handler, $path, 'plugins', $title );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $blms = Bedrock::Hash->new;

  foreach my $blm (@blm_listing) {
    if ( $blm =~ /BLM\/(.*?)$/xsm ) {
      $blms->{$1} = "BLM/$1";
      $blms->{$1} =~ s/\//::/gxsm;
    }
  }

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-plugins' );

  my @blm_names = keys %{$blms};

  my %sections = (
    Plugins               => [ grep { !/^Startup|Filter/xsm } @blm_names ],
    'Application Plugins' => [ grep {/^Startup/xsm} @blm_names ],
    Filters               => [ grep {/^Filter/xsm} @blm_names ],
  );

  my @headings = sort keys %sections;

  my @plugins = map { blm_ul( $bedrock_handler, $blms, $_, @{ $sections{$_} } ) } @headings;

  my $head = listing_head( $bedrock_handler, 'Bedrock Plugins' );

  my $html = template(
    $config, $template,
    headings => \@headings,
    head     => $head,
    plugins  => \@plugins
  );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub system_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $pod_paths = [$DEFAULT_BEDROCK_PERL5LIBDIR];

  # get non-public modules
  my $module_listing = $BEDROCK_CONFIG_CACHE{SYSTEM_POD_LISTING};

  if ( !$module_listing ) {
    $LOGGER->trace('no system listing in cache');

    $module_listing = get_all_modules( $pod_paths, $FALSE );
    $BEDROCK_CONFIG_CACHE{SYSTEM_POD_LISTING} = $module_listing;
  }
  else {
    $LOGGER->trace('retrieving system pod listing from cache');
  }

  return $NOT_FOUND
    if !$module_listing || !keys %{$module_listing};

  if ($module) {

    $module =~ s/\//\:\:/xsmg;

    my $path = $module_listing->{$module};
    $path = $path ? "$path.pm" : $EMPTY;

    return show_pod( $bedrock_handler, $path, 'system', $module );
  }

  my $modules = get_all_modules( $pod_paths, 0, 1 );

  my $url_prefix = '/bedrock/system';
  my $anchor_tag = '<a href="%s/%s">%s</a>';

  my @system_listing;

  foreach my $module ( sort keys %{$modules} ) {
    next if $module =~ /Bedrock::Text|Filter/xsm;

    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @system_listing, sprintf $anchor_tag, $url_prefix, $path, $module;
  }

  my $html = listing( $bedrock_handler, 'System Documentation Listing', @system_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub _show_markdown {
########################################################################
  my ( $config, $markdown ) = @_;

  my $top_section = header($config);

  my $html = eval {
    my $md = Markdown::Render->new(
      infile => $markdown,
      engine => 'text_markdown',
      body   => $FALSE
    );

    $md->render_markdown;

    return $md->get_html;
  };

  if ( $EVAL_ERROR || !length $html ) {
    my $message = "No documentation found for $markdown.";

    $html = create_error_page(
      $config,
      error => $message,
      title => $markdown
    );
  }
  else {
    my $template = fetch_template( $config, 'bedrock-docs-listing-index' );

    my $back_url = sprintf '%s/markdown', $config->{BEDROCK_ADMIN_DIR};

    $html = template(
      $config,
      $template,
      content  => $html,
      back_url => $back_url,
      title    => $markdown,
    );

  }

  return $html;
}

########################################################################
sub create_error_page {
########################################################################
  my ( $config, %parameters ) = @_;

  my $template = fetch_template( $config, 'bedrock-docs-error' );

  $parameters{error} //= $EVAL_ERROR;

  return template( $config, $template, %parameters, );
}

########################################################################
sub show_markdown {
########################################################################
  my ( $bedrock_handler, $markdown, $back_url ) = @_;

  my $html = _show_markdown( $bedrock_handler->config, $markdown );

  if ( !$html ) {
    my $url = sprintf 'http://%s/%s/%s', $ENV{HTTP_HOST}, $bedrock_handler->get_bedrock_admin_dir, $back_url;

    $bedrock_handler->request_handler->header_out( 'Location', $url );

    return $REDIRECT;
  }

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub markdown_docs {
########################################################################
  my ( $bedrock_handler, $markdown ) = @_;

  return show_markdown( $bedrock_handler, "$markdown.md", 'markdown' )
    if $markdown;

  my $markdown_listing = $BEDROCK_CONFIG_CACHE{MARKDOWN_LISTING};

  if ($markdown_listing) {
    $LOGGER->trace('retrieving listing from cache');
  }

  my $config         = $bedrock_handler->config;
  my $markdown_paths = get_markdown_paths($bedrock_handler);

  if ( !$markdown_listing ) {
    $markdown_listing = [];

    if ($markdown_paths) {
      for ( @{$markdown_paths} ) {
        push @{$markdown_listing}, find_markdown_files($_);
      }
    }

    $BEDROCK_CONFIG_CACHE{MARKDOWN_LISTING} = $markdown_listing;
  }

  my $title = 'Documentation Listing';

  if ( !@{$markdown_listing} ) {
    my $message
      = !@{$markdown_paths}
      ? 'No markdown paths defined in configuraion.'
      : 'No additional documentation found';

    my $html = create_error_page( $config, title => $title, error => $message );

    output( $bedrock_handler->request_handler, $html );

    return $OK;
  }

  my $anchor_tag = '<a href="%s/markdown/%s">%s</a>';

  my @listing;

  foreach my $file ( sort @{$markdown_listing} ) {
    my $uri = Text::URLEncode::Encode $file;

    push @listing, sprintf $anchor_tag, $bedrock_handler->get_bedrock_admin_dir, $uri, $file;
  }

  my $html = listing( $bedrock_handler, $title, @listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub pod_docs {
########################################################################
  my ( $bedrock_handler, $module ) = @_;

  my $config = $bedrock_handler->config;

  my $pod_paths = get_pod_paths($bedrock_handler);

  my $module_listing = $BEDROCK_CONFIG_CACHE{POD_LISTING};

  if ( !$module_listing ) {
    $LOGGER->trace('no listing in cache');

    if ( $pod_paths && @{$pod_paths} ) {
      $module_listing = get_all_modules( $pod_paths, 0 );

      $BEDROCK_CONFIG_CACHE{POD_LISTING} = $module_listing;
    }
  }
  else {
    $LOGGER->trace('retrieved pod listing from cache');
  }

  if ( $module && $module_listing && keys %{$module_listing} ) {
    $module =~ s/\//\:\:/xsmg;

    my $path = $module_listing->{$module};

    $path = $path ? "$path.pm" : $EMPTY;

    return show_pod( $bedrock_handler, $path, 'pod', $module );
  }
  elsif ($module) {
    return show_pod( $bedrock_handler, $EMPTY, 'pod', $module );
  }

  my $title = 'User Documentation Listing';

  if ( !$module_listing || !keys %{$module_listing} ) {
    my $message = 'No user documentation found.';

    my $html = create_error_page( $config, error => $message );

    output( $bedrock_handler->request_handler, $html );

    return $OK;
  }

  my $anchor_tag = '<a href="%s/pod/%s">%s</a>';

  my @pod_listing;

  foreach my $module ( sort { lc $a cmp lc $b } keys %{$module_listing} ) {
    my $path = $module;
    $path =~ s/\:\:/\//xsmg;

    push @pod_listing, sprintf $anchor_tag, $bedrock_handler->get_bedrock_admin_dir, $path, $module;
  }

  my $html = listing( $bedrock_handler, $title, @pod_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub env_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config = $bedrock_handler->config;

  my $allow_env = $config->{ALLOW_BEDROCK_ENV_INFO} // $EMPTY;

  my $env
    = $allow_env =~ /^y/xsmi
    ? \%ENV
    : { ALLOW_BEDROCK_ENV_INFO => $allow_env };

  return hash_docs( $bedrock_handler, 'Environment', $env );
}

########################################################################
sub config_docs {
########################################################################
  my ($bedrock_handler) = @_;

  my $config       = $bedrock_handler->config;
  my $allow_config = $config->{ALLOW_BEDROCK_CONFIG_INFO} // $EMPTY;

  $config
    = $allow_config =~ /^y/xsmi
    ? $config
    : { ALLOW_BEDROCK_CONFIG_INFO => $allow_config };

  return hash_docs( $bedrock_handler, 'Configuration', $config );
}

########################################################################
sub hash_docs {
########################################################################
  my ( $bedrock_handler, $title, $hash ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-hash-dump' );

  # make sure that all refs can('compact')
  foreach ( %{$hash} ) {
    next if !ref $_ || blessed $_;

    bless $_, 'Bedrock::Dump';
  }

  my $head = listing_head( $bedrock_handler, 'Bedrock ' . $title );

  my $html = template( $config, $template, head => $head, hash => $hash );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub find_tag_file {
########################################################################
  my ($tag) = @_;

  my $tagx = 'Text/TagX/TAG';

  my ($tag_path) = grep { -d "$_/$tagx" } @INC;

  return $EMPTY
    if !$tag_path;

  my @path_stubs = map {"$tag_path/$tagx/$_"} qw{  NoBody WithBody WithBody/Loop };

  my @search_paths = map { sprintf '%s/%s.pm', $_, ucfirst $tag } @path_stubs;

  my ($tag_file) = grep {-e} @search_paths;

  return $tag_file
    if $tag_file;

  no warnings 'File::Find';  ## no critic

  find(
    sub {
      my ($name) = split /[.]/xsm, $_;
      return if !$name;

      if ( !$tag_file && $tag eq lc $name ) {
        $tag_file = $File::Find::name;
      }
    },
    @path_stubs
  );

  return $tag_file;
}

########################################################################
sub tag_list {
########################################################################
  my @tags;

  # this will always be true...
  if ( $OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
    foreach ( sort split /[|]/xsm, $1 ) {
      next if /[#]|else|else[?]if|blm|[?]/xsm;

      push @tags, $_;
    }
  }

  return @tags;
}

########################################################################
sub tag_docs {
########################################################################
  my ( $bedrock_handler, $tag ) = @_;

  if ($tag) {
    my $tag_file = find_tag_file($tag);

    if ($tag_file) {
      return show_pod( $bedrock_handler, $tag_file, 'tag' );
    }
    else {
      return $NOT_FOUND;
    }
  }

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;

  my $tag_link = q{<a href="%s/tag/%s">%s</a>};

  my @tag_listing = map { sprintf $tag_link, $bedrock_admin_dir, $_, $_ } @TAG_LIST;

  my $html = listing( $bedrock_handler, 'Bedrock Tag Listing', @tag_listing );

  output( $bedrock_handler->request_handler, $html );

  return $OK;
}

########################################################################
sub listing {
########################################################################
  my ( $bedrock_handler, $title, @listing ) = @_;

  my $config = $bedrock_handler->config;

  my $template = fetch_template( $config, 'bedrock-docs-listing' );

  my $head = listing_head( $bedrock_handler, $title );

  return template(
    $config,
    $template,
    head    => $head,
    listing => \@listing
  );
}

########################################################################
sub listing_head {
########################################################################
  my ( $bedrock_handler, $title ) = @_;

  my $config = $bedrock_handler->config;

  return listing_index( $config, title => $title, );
}

########################################################################
sub validate_paths {
########################################################################
  my (@paths) = @_;

  # only valid paths...
  my %valid_paths = map { $_ => -d $_ && -r $_ } @paths;

  if ( any { !$_ } values %valid_paths ) {
    $LOGGER->warn( 'found invalid valid paths: ', Dumper( [ grep { !$valid_paths{$_} } keys %valid_paths ] ) );
  }

  return [ grep { $valid_paths{$_} } keys %valid_paths ];
}

########################################################################
sub get_doc_paths {
########################################################################
  my ( $bedrock_handler, $type ) = @_;

  my $config = $bedrock_handler->config();

  $type = uc "${type}_PATHS";

  if ( exists $BEDROCK_CONFIG_CACHE{$type} ) {
    $LOGGER->trace('reading from cache!');

    return $BEDROCK_CONFIG_CACHE{$type};
  }
  else {
    $LOGGER->trace( Dumper \%BEDROCK_CONFIG_CACHE );
  }

  $LOGGER->trace('nothing in cache!');

  my $path_list = $config->{$type} // $EMPTY;

  $LOGGER->trace(
    sub {
      return 'documentation paths: ' . Dumper( [ 'type:', $type, 'paths: ', $path_list ] );
    }
  );

  if ( !is_array($path_list) ) {
    $path_list = [ split /:/xsm, $path_list // $EMPTY ];
  }

  my $valid_paths = validate_paths( @{$path_list} );
  $BEDROCK_CONFIG_CACHE{$type} = $valid_paths;

  return $valid_paths;
}

########################################################################
{
  ## no critic (RequireArgUnpacking)
  sub get_markdown_paths { push @_, 'markdown'; goto &get_doc_paths; }
  sub get_pod_paths      { push @_, 'pod';      goto &get_doc_paths; }
}
########################################################################

########################################################################
sub internal_server_error {
########################################################################
  my ( $r, $error ) = @_;

  $error = Text::URLEncode::Htmlencode $error;

  my $html = <<"END_OF_HTML";
<html>
 <body>
  <h2>An internal error has occurred. Documentation not available at this time.</h2>

  <hr/>

  <pre style="color:red;">
  $error
  </pre>

 </body>
</html>

END_OF_HTML

  $r->content_type('text/html');

  $r->send_http_header;

  print $html;

  return $OK;
}

########################################################################
sub get_session {
########################################################################
  my ($bedrock_handler) = @_;

  my $r = $bedrock_handler->apache_handler;

  my $ctx = Bedrock::Context->new(
    REQUEST_HANDLER => $r,
    CONFIG          => $bedrock_handler->get_config
  );

  my $module_config = $bedrock_handler->get_config->get_module_config('UserSession');

  return BLM::Startup::UserSession->new( $ctx, $module_config );
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 NAME

Bedrock::Apache::BedrockDocs - Provides Bedrock and user documentation as HTML

=head1 SYNOPSIS

 AllowEncodedSlashes On

 <Directory /var/www/html/bedrock/>
   AcceptPathInfo On
   Options -Indexes
   AllowOverride None
 
   <IfModule mod_perl.c>
     SetHandler perl-script 
     PerlHandler Apache::BedrockDocs 
   </IfModule>
 
   <IfModule !mod_perl.c>
     SetHandler bedrock-docs
   </IfModule>
 
   AuthType Basic
   AuthName Bedrock
   AuthBasicProvider file
   AuthUserFile @configdir@/bedrock.users

   require valid-user
 
 </Directory>

=head1 DESCRIPTION

Displays Bedrock documentation for tags and Bedrock internals. Renders
L<pod|https://perldoc.perl.org/perlpod> embedded in Bedrock's Perl
modules as HTML.

Your own documentation contained in the form of embedded I<pod> and I<markdown>
can  also be rendered by this module (See L</USER
DOCUMENTATION>).

=head1 ENABLING BEDROCK DOCUMENTATION

Bedrock documentation availability is controlled by the configuration
variable C<ALLOW_BEDROCK_INFO> in F<tagx.xml>.  Set the configuration
variable to one of the values described below.

=over 5

=item yes/on/1

Allow documentation and possibly other information (configuration, environment).

=item no/off/0

Do not allow documentation.

=item docs

Allow documentation only.

=back

To allow configuration information to be displayed set
C<ALLOW_BEDROCK_CONFIG_INFO> To allow environment information to
be displayed set C<ALLOW_BEDROCK_ENV_INFO> to C<yes>. The default
value for these variables is C<no>.

=head1 USER DOCUMENTATION

Bedrock can also display documentation you have embedded in your own Perl
modules or found in files that contain markdown.

=head2 Pod

Set the configuration variable C<POD_PATHS> in your F<tagx.xml> to
either a colon separated string of absolute paths to your Perl modules
(accessible to the webserver running this module) or an array of
paths. You can also set the C<POD_PATHS> environment variable in your
Apache configuration.

 <scalar name="POD_PATHS">/home/fred/git/acme-pebbles/lib</scalar>

or

 <array name="POD_PATHS">
   <scalar>/home/fred/git/acme-dino</scalar>
   <scalar>/home/fred/git/acme-quarry/lib</scalar>
 </array>

or in your Apache's configuration:

 SetEnv POD_PATHS /home/fred/git/acme-quarry/lib

Bedrock's documentation facility will recurse sub-directories and list
all modules that end with C<.pm>.

I<HINT: Create a separate F<markdown_paths.xml> file that contains the
paths and drop that in Bedrock's config directory.>

=head2 Markdown

Set the scalar configuration variable C<MARKDOWN_PATHS> to either a colon
separated string of absolute paths to your Perl modules or an array of
paths. You can also set the C<MARKDOWN_PATHS> environment variable in your
Apache configuration.

 <array name="MARKDOWN_PATHS">
   <scalar>/usr/local/share/my-app/docs</scalar>
 </array>

=head1 SEE ALSO

L<perlpod|https://perldoc.perl.org/perlpod>

=head1 AUTHOR

BIGFOOT  - <bigfoot@cpan.org>

=cut
