package Apache::Bedrock; ## no critic

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2026, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

BEGIN {
  if ( $ENV{MOD_PERL} ) {
    eval {
      require Apache2::ServerRec;
      Apache2::ServerRec->import;

      require Apache2::ServerUtil;
      Apache2::ServerUtil->import;
    };
  }
}

use Bedrock qw(cache is_mod_perl is_bedrock_shell);
use Bedrock::Apache::Constants qw(:http %APACHE_LOG_LEVELS);
use Bedrock::Bootstrap;
use Bedrock::Constants qw(:chars :defaults :booleans);
use Bedrock::Error qw(handle_error);
use Bedrock::Handler qw(:mlogger);
use Bedrock::Router;

use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename;
use List::Util qw(any);
use Scalar::Util qw(reftype);

use Role::Tiny::With;
with 'Bedrock::Logger';

our $VERSION = '@PACKAGE_VERSION@'; ## no critic

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # ====================================================================
  # HTTP-SPECIFIC: ETag caching
  # ====================================================================
  my $cache = cache();

  if ($cache) {
    my $etag = $r->headers_in->{'If-None-Match'} // q{};

    if ( $etag && $cache->exists($etag) ) {
      $r->log->info('Cache hit (ETag)...serving 304 Not Modified');
      $r->send_http_header;
      $r->status($NOT_MODIFIED);

      return $OK;
    }
  }

  # ====================================================================
  # HTTP-SPECIFIC: Apache log level configuration
  # ====================================================================
  if ( is_mod_perl() ) {
    my $s = $r->server;

    my $bedrock_log_level = $ENV{BedrockLogLevel} // 'info';

    $s->loglevel( $APACHE_LOG_LEVELS{ uc $bedrock_log_level } );
    mlogger_notice( $r, 'Resetting Apache log level: %s', $bedrock_log_level );
  }

  # ====================================================================
  # BOOTSTRAP: Initialize Bedrock environment
  # ====================================================================
  my $bootstrap = eval {
    return Bedrock::Bootstrap->new(
      request              => $r,
      cache                => $cache,
      benchmarking_enabled => $ENV{BEDROCK_BENCHMARK},
    );
  };

  if ( !$bootstrap ) {
    handle_error( $r, "could not initialize bootstrap\n$EVAL_ERROR" );
    return $OK;
  }

  eval { $bootstrap->initialize(); };

  if ($EVAL_ERROR) {
    handle_error( $r, "bootstrap initialization failed\n$EVAL_ERROR" );
    return $OK;
  }

  my $benchmarking = $bootstrap->benchmarking_enabled;
  $benchmarking && $bootstrap->log_benchmark('Bedrock::Bootstrap->initialize() complete');

  # Get configuration
  my $conf = $bootstrap->config;

  # ====================================================================
  # SHELL-SPECIFIC: Configuration overrides
  # ====================================================================
  if ( $r->can('config_var') ) {
    foreach my $override ( @{ $r->config_var || [] } ) {
      my ( $k, $v ) = split /[:=]/xsm, $override;
      $r->log->warn("overriding $k => $v");
      $conf->{$k} = $v;
    }
  }

  # Validate configuration
  if ( !$conf || ref $conf ne 'Bedrock::Config' ) {
    $r->log->error('unable to create Bedrock::Config object');
    return $SERVER_ERROR;
  }

  my $file = $bootstrap->file;

  # ====================================================================
  # HTTP-SPECIFIC: Content type and file validation
  # ====================================================================
  my $content_type = $r->content_type;

  if ( !$content_type ) {
    $r->log->warn('content type not set, defaulting to text/html');
    $content_type = 'text/html';
  }

  # Validate we're serving a file (not directory)
  if ( !$file ) {
    $r->log->error( sprintf 'attempt to serve directory: [%s]', $r->uri );
    return $FORBIDDEN;
  }

  # Validate content type
  if ( !any { $content_type eq $_ } qw(text/html application/json text/plain) ) {
    $r->log->error( sprintf 'content type: [%s] not supported', $content_type );
    return $UNSUPPORTED;
  }

  # Validate file exists and is readable
  if ( !-e $file ) {
    $r->log->error( sprintf 'file does not exist: [%s]', $file );
    return $NOT_FOUND;
  }

  if ( !-r $file ) {
    $r->log->error( sprintf 'file permissions deny access: [%s]', $file );
    return $FORBIDDEN;
  }

  # ====================================================================
  # HTTP-SPECIFIC: Change to application directory
  # ====================================================================
  my $app_dir = $bootstrap->path;

  if ( $app_dir && !chdir $app_dir ) {
    return $r->log->error( sprintf 'chdir(%s) failed: [%s]', $app_dir, $OS_ERROR );
  }

  $benchmarking && $bootstrap->log_benchmark('environment setup complete');

  # ====================================================================
  # HTTP-SPECIFIC: URL Routing
  # ====================================================================
  my $route_params = {};

  if ( exists $conf->{routes} && reftype( $conf->{routes} ) eq 'ARRAY' ) {
    my $router = Bedrock::Router->new($conf);

    if ( my $match = $router->match( $r->uri ) ) {
      # Override the file to be processed based on route
      my $new_file = sprintf '%s/%s', $conf->{PEBBLE_DIR}, $match->{template};

      if ( -e $new_file ) {
        $file = $new_file;

        # Update Bootstrap state for relative includes
        $bootstrap->file($file);
        $bootstrap->path( dirname($file) );
        $bootstrap->filename( basename($file) );

        # Capture route parameters
        $route_params = $match->{params};

        $r->log->info( sprintf 'Route matched: %s->%s', $r->uri, $match->{template} );
      }
    }
  }

  # ====================================================================
  # BOOTSTRAP: Create context, TagX, and load modules
  # ====================================================================
  my ( $ctx, $tx );
  my $final_status = $OK;

  eval {
    # Create Bedrock context
    $ctx = $bootstrap->create_context( route_params => $route_params, );

    $benchmarking && $bootstrap->log_benchmark('context object created');

    # Initialize TagX parser
    $tx = $bootstrap->init_tagx( context => $ctx, );

    $benchmarking && $bootstrap->log_benchmark('TagX object creation complete');

    # Load startup modules (BLMs)
    my $pre_bound = $bootstrap->load_startup_modules( $ctx, $tx );

    if ( !$pre_bound->{HEADER} ) {
      die 'error in config file: No header module';
    }

    $benchmarking && $bootstrap->log_benchmark('startup modules loaded');

    # ====================================================================
    # EXECUTE: Parse and execute template
    # ====================================================================
    $tx->output;

    $benchmarking && $bootstrap->log_benchmark('Bedrock tag processing complete');

    1;
  } or do {
    my $err = $EVAL_ERROR;
    handle_error( $r, $err, $tx );

    # Return OK so Apache serves the error page content we generated
    $final_status = $OK;
  };

  # ====================================================================
  # CLEANUP
  # ====================================================================
  if ($tx) {
    $tx->close;
  }

  if ( $ctx && $ctx->can('cleanup') ) {
    $ctx->cleanup;
  }

  $benchmarking && $bootstrap->log_benchmark( 'request complete', 1 );

  # Restore original working directory
  if ( $bootstrap->pwd ) {
    chdir $bootstrap->pwd;
  }

  # ====================================================================
  # SHELL/CGI: Early return (no HTTP redirect handling needed)
  # ====================================================================
  return $final_status
    if is_bedrock_shell($r) || !is_mod_perl();

  # ====================================================================
  # HTTP-SPECIFIC: Handle redirects
  # ====================================================================
  my $location;
  my $status = $r->headers_out->{Status} // $r->err_headers_out->{Status};

  foreach my $headers ( $r->err_headers_out, $r->headers_out ) {
    ($location) = grep {$_} $headers->{Location}, $headers->{location};

    last if $location;
  }

  if ($location) {
    $r->status($REDIRECT);
  }

  if ( defined $status && $status =~ /\A\s*(\d+)/xsm ) {
    $r->status($1);
  }

  return $final_status;
}

1;

__END__

=pod

=head1 NAME

Apache::Bedrock - Apache handler for serving Bedrock pages

=head1 SYNOPSIS

 <IfModule mod_perl.c>
   PerlRequire @configdir@/startup.pl
   AddHandler    perl-script .roc .jroc
   PerlHandler   Apache::Bedrock
 </IfModule>

 use Apache::Bedrock;

 Apache::Bedrock::handler( Apache::Request::CGI->new );

 Apache::Bedrock::handler( Apache::Request::Shell->new );

I<See F<bedrock.cgi> if want to see how this module can be used stand alone.>

=head1 DESCRIPTION

Handler for parsing Bedrock files. Can be used with Apache as a
C<mod_perl> handler or in other configurations including a shell
interpreter.

This module now delegates most initialization work to L<Bedrock::Bootstrap>,
focusing exclusively on HTTP-specific request handling, routing, caching,
and output delivery.

=head1 METHODS AND SUBROUTINES

=head2 handler

 Apache::Bedrock::handler($r);

Main request handler. Handles HTTP-specific logic including:

=over 4

=item * ETag-based caching

=item * Apache log level configuration

=item * Content type validation

=item * File permission checking

=item * URL routing

=item * Template execution

=item * HTTP response handling

=back

Delegates initialization to L<Bedrock::Bootstrap>.

=head1 ROUTING

Bedrock includes a configuration-driven router that allows you to map
application URIs to specific Bedrock templates.

=head2 Configuration

Routes are defined in your Bedrock configuration (typically F<routes.xml>)
using Bedrock's typed XML format. You must define a C<routes> object
containing an array of route objects.

 <object name="routes">
   <array>
     <object>
       <scalar name="pattern">/user/:id</scalar>
       <scalar name="template">user_profile.roc</scalar>
     </object>

     <object>
       <scalar name="pattern">/api/search</scalar>
       <scalar name="template">api/search.jroc</scalar>
     </object>
   </array>
 </object>

=head2 Template Resolution (PEBBLE_DIR vs DOCUMENT_ROOT)

When a request matches a route, Bedrock resolves the target C<template>
relative to the configured B<PEBBLE_DIR>, not the web server's
B<DOCUMENT_ROOT>.

This distinction is intentional:

=over 4

=item *

B<DOCUMENT_ROOT>: Intended for public, static assets (images, CSS, JS) and
legacy scripts that map directly to the file system.

=item *

B<PEBBLE_DIR>: Intended for application templates that are accessed via
routes, not direct URLs.

=back

=head2 Pattern Syntax

Route patterns support:

=over 4

=item * B<Static paths>: C</about>, C</contact>

=item * B<Named parameters>: C</user/:id>, C</blog/:year/:month/:slug>

=item * B<Wildcards>: C</files/*path>

=back

See L<Bedrock::Router> for complete pattern syntax.

=head2 Route Parameters

Captured route parameters are available in templates via C<$input>:

 # Route: /user/:id
 # URL: /user/123
 # Template: user_profile.roc

 <var $input.id>  <!-- prints: 123 -->

=head1 ARCHITECTURE

This module has been refactored to use L<Bedrock::Bootstrap> for
initialization. The separation is:

=head2 Apache::Bedrock (HTTP-specific)

=over 4

=item * ETag-based caching

=item * Apache log level configuration

=item * Content type validation

=item * File permission checking

=item * URL routing

=item * HTTP redirect handling

=item * Response delivery

=back

=head2 Bedrock::Bootstrap (Generic)

=over 4

=item * Configuration loading

=item * File path parsing

=item * Environment setup

=item * Context creation

=item * TagX initialization

=item * BLM loading

=back

This separation enables:

=over 4

=item * Code reuse across environments (web, shell, miniserver)

=item * Independent testing of initialization logic

=item * Clearer responsibilities

=item * Easier maintenance

=back

=head1 MIGRATION FROM OLD CODE

If you have code that directly uses C<init_tagx()>, C<load_startup_modules()>,
or C<pre_bind_module()>, these functions are deprecated but still work.

However, for new code, use L<Bedrock::Bootstrap> directly:

 # Old way (deprecated)
 my $tx = Apache::Bedrock::init_tagx(...);

 # New way
 my $bootstrap = Bedrock::Bootstrap->new(request => $r);
 $bootstrap->initialize();
 my $tx = $bootstrap->init_tagx(context => $ctx);

=head1 SEE ALSO

L<Bedrock::Bootstrap>, L<Bedrock::Handler>, L<Bedrock::Context>,
L<Bedrock::Router>, L<Text::TagX>

=head1 AUTHOR

TBC Development Group, LLC.

=cut
