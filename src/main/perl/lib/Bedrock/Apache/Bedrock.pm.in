#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Bedrock;

BEGIN {
  require Apache2::compat if $ENV{MOD_PERL};
}

use Apache2::Const -compile => qw( NOT_FOUND OK SERVER_ERROR FORBIDDEN DECLINED REDIRECT );

use strict;
#
# Define the following mod_perl constants since we could be using
# this module both as a mod_perl module and in a CGI
#
use constant	NOT_FOUND	=> Apache2::Const::NOT_FOUND;
use constant	SERVER_ERROR 	=> Apache2::Const::SERVER_ERROR;
use constant	FORBIDDEN 	=> Apache2::Const::FORBIDDEN;
use constant	OK		=> Apache2::Const::OK;
use constant	DECLINED 	=> Apache2::Const::DECLINED;
use constant	REDIRECT 	=> Apache2::Const::REDIRECT;

use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Hash;
use Bedrock::VERSION;
use Text::TagX;

use Cwd;
use File::Basename;
use File::Temp;
use File::Spec;
use Symbol;
use Pod::Html;
use IO::Scalar;

my $PWD;

sub build_body_tag {
  my $controller = shift;
  my $page = shift;

  my $page_def = $controller->{pages}->{$page};

  $controller->{body} = {} unless $controller->{body};

  my $body = $page_def->{body} || $controller->{body};
  my $body_tag;

  $body_tag = "<body";

  foreach (keys %{$body}) {
    $body_tag .= sprintf(q{ %s="%s"}, $_, $body->{$_});
  }

  $body_tag .= ">\n";

  $body_tag;
}

sub build_body_section {
  my ($controller, $page, $action) = @_;

  my $page_def = $controller->{pages}->{$page};
  my $body_section;

  if ($page_def->{actions}->{$action}) {
    $body_section = include(page_name($page_def->{actions}->{$action}));
  } else {
    $body_section = sprintf("<b>bedrock controller: </b>Page Under Construction - no action for '%s'", $action)
  }

  $body_section;
}

sub build_head_section {
  my $controller = shift;
  my $page = shift;

  my $head_section;

  my $page_def = $controller->{pages}->{$page};

  # if a framework defines it's own complete HEAD section we call that a "header" and include that 
  if ($page_def->{header}) {
    $head_section = include(page_name($page_def->{header}));
  } else {
    $head_section = "<head>\n";
    if (ref($page_def->{head}->{style}) =~/array/i) {
      $head_section .= join("\n", map { sprintf(q{<link rel="stylesheet" type="text/css" href="%s">}, $_) } @{$page_def->{head}->{style}}) . "\n";
    } else {
      my $style = $page_def->{head}->{style} || $page_def->{style} || $controller->{style};
      $head_section .= sprintf(q{<link rel="stylesheet" type="text/css" href="%s">%s}, $style, "\n") if $style;
    }
    
    if (ref($page_def->{head}->{javascript}) =~/array/i) {
      $head_section .= join("\n", map { sprintf(q{<script language="javascript" src="%s"></script>%s}, $_, "\n") } @{$page_def->{head}->{javascript}});
    } else {
      my $javascript = $page_def->{head}->{javascript} || $page_def->{javascript} || $controller->{javascript};
      $head_section .= sprintf(q{<script language="javascript" src="%s"></script>%s}, $javascript, "\n")  if $javascript;
    }
    
    # -- construct meta tags if present
    my $meta = $page_def->{head}->{meta} || $page_def->{meta} || $controller->{meta};
    
    if ($meta) {
      if (ref($meta->{name}) =~/array/i) {
	$head_section .= join("\n", map { sprintf(q{<meta name="%s" content="%s">}, $_->{name}, $_->{content}) } @{$meta->{name}}) . "\n";
      }
      
      if (ref($meta->{'http-equiv'}) =~/array/i) {
	$head_section .= join("\n", map { sprintf(q{<meta http-equiv="%s" content="%s">}, $_->{'http-equiv'}, $_->{content}) } @{$meta->{'http-equiv'}}) . "\n";
      }
    }
    
    my $title = $page_def->{head}->{title} || $page_def->{title} || $controller->{title};
    $head_section .= sprintf("<title>%s</title>\n", $title) if $title;
    $head_section .= "</head>\n";
  }

  $head_section;
}

sub config {
  my $dir = shift;
  $dir =~ s!/$!!;
  
  my $conf = Bedrock::Config->new( 'tagx.xml' );
  my @app_conf_files;
  
  # Look for application config
  push @app_conf_files, $conf->{'APP_CONFIG'} if $conf->{'APP_CONFIG'};
  my $framework_conf = sprintf("%s/framework%s.xml", $ENV{BEDROCK_CONFIG_PATH} || $ENV{CONFIG_PATH}, $dir);

  push @app_conf_files, $framework_conf if -s $framework_conf;
  
  foreach my $dir_conffile (@app_conf_files) {
    # Load the directory config
    my $dir_conf = Bedrock::Config->new( $dir_conffile );
    
    # Look up the app config, based on directory of current request
    my $app_conf = $dir_conf->{$dir} || $dir_conf->{$dir . '/'};
    
    # Extract startup modules from app config
    my $app_modules = delete $app_conf->{'MODULES'};
    
    # merge generic bedrock conf with app config. Note that app config
    # overrides default config
    for my $key (keys %{$app_conf}) {
      $conf->{$key} = $app_conf->{$key};
    }
    
    # Append app startup modules to master startup module list
    push @{$conf->{'MODULES'}}, @{$app_modules} if $app_modules;
  }
  
  # And voila! we have the merged config
  $conf;
}

sub error
  {
    my $r = shift;
    my $mesg = shift;
    my $code = shift || SERVER_ERROR;

    $r->log_error( $mesg );
    chdir $PWD;
    return $code;
  }

# show_pod(file, config-object, "tag|plugins");
sub show_pod {
  my $file = shift;
  my $conf = shift;
  my $return_to = shift;

  my $outfile = tmpnam;
  
  &pod2html('--infile', $file,
	    '--outfile', $outfile, 
	    '--cachedir', File::Spec->tmpdir(), 
	    $conf->{BEDROCK_POD_CSS_URL} ? "--css=".$conf->{BEDROCK_POD_CSS_URL} : ()
	   );

  # in the off chance somebody puts the stupid Bedrock images some place else
  my $image_url = $conf->{IMAGE_URL} || "/bedrock/img";

  my $snippet =<<html;
<table width="100%">
<tr>
  <td align="left"><a href="/bedrock"><img src="$image_url/bedrock.jpg" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>
html

  # little or no pod?
  if (-s $outfile > 600) {
    open(FILE, $outfile) or die "Unable to open $outfile: $!\n";
    local $/ = undef;
    my $data = <FILE>;
    close FILE;
    
    $data =~s/(<body(.*?)>)/$1\n$snippet/is;
    
    print "Content-type: text/html\n\n";
    print $data;
  } else {
    print sprintf("Location: http://%s/bedrock/%s\n\n", $ENV{HTTP_HOST}, $return_to);
  }
  
  unlink $outfile;

  return OK;
}

sub blm_listing {
  my $dir = shift;
  my @listing;

  return () unless -d $dir;
  local *BLMDIR;
  opendir BLMDIR, $dir;
  while (my $file = readdir BLMDIR) {
    next if ($file =~/^\./);
    if (-d $dir . "/". $file) {
      push @listing, blm_listing($dir . "/" . $file);
    } else {
      push @listing, $dir . "/" . $1 if ($file =~/^(.*?)\.pm$/);
    }
  }

  closedir BLMDIR;

  return @listing;
}

sub get_all_blms {

  my @blm_listing;

  my @blm_path = grep { -d $_ ."/BLM" } @INC;

  foreach (@blm_path) {
    push @blm_listing, blm_listing($_ . "/BLM");
  }

  local *BLM;

  my @public_blms;

  foreach my $file (@blm_listing) {
    open BLM, "<" . $file . ".pm" or next;
    local $/;
    my $source = <BLM>;

    if ($source =~/\=pod/si && $source =~/\=head1\s+public/si) {
      push @public_blms, $file;
    }
    close BLM;
  }
  

  return sort @public_blms;
}

# return the standard documentation header
sub doc_head {
  my %attributes = @_;
  my $head;
  $head = "Content-type: text/html\n\n" unless exists $attributes{header};

  $head .=<<eot;
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%s</title>
<link rel="stylesheet" href="%s" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>
<body>
<table width="100%">
<tr>
  <td align="left"><a href="%s"><img src="%s" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>

<h1>%s</h1>
eot
  
  $head = sprintf($head, $attributes{title}, $attributes{stylesheet}, $attributes{home}, $attributes{image}, $attributes{title});

  return $head;
}


sub page_name {  $_[0] .= ".inc" unless $_[0]=~/\.inc$/; $_[0]; }

sub include {
  my @pages = split ";", $_[0];
  my $include;

  foreach (@pages) {
    $include .= sprintf(q{<include --file="%s">}, page_name($_));
  }
  
  $include;
}

sub blm_ul {
  my $blms = shift;
  my $h2 = shift;

  return unless @_;

  printf("<h2>%s</h2>\n", $h2);
  return sprintf("<ul>\n%s\n</ul>\n", join("\n", map { sprintf(q{<li><a href="/bedrock/plugins/%s">%s</a>}, $_, $blms->{$_}) } @_));
}


# +------------------------------+
# | mod_perl HANDLER STARTS HERE |
# +------------------------------+

sub handler {
  my $r = shift;

  my $file;

  $r->log->info("[Apache::Bedrock] started");

  # - under mod_perl naked directory requests, intended for the bedrock controller
  #   are passed along prior to file checking.  Thus the content_type is directory
  if ($r->content_type =~/directory/) {
    $r->log->info(sprintf("[Apache::Bedrock] Directory requested: [%s]", $r->filename));
    $file = "";
    $ENV{PATH_TRANSLATED} = $r->filename;
    $r->content_type('text/html');
  }
  # - under mod_cgi those same requests come through via the "virtual" modifier on the Action directive
  #   8< 
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual
  #   8<
  else {
    $file = $r->filename;
    $r->log->info(sprintf("[Apache::Bedrock] File requested: [%s]", $r->filename));
  }

  my $path_info = $ENV{PATH_INFO};
  $path_info =~s/(.*?)\/$/$1/;

  $r->log->info(sprintf("[Apache::Bedrock] request file: [%s],  PATH_INFO: [%s],  PATH_TRANSLATED: [%s]",
			$file,
			$path_info,
			$ENV{PATH_TRANSLATED}
		       )
	       );

  # Parse for the URI components
  my ($uri_name, $uri_dir) = &fileparse( $r->uri );

  my $conf = &config($uri_dir);
  my $ctx = Bedrock::Context->new (
				   'APACHE_HANDLER' => $r,
				   'CONFIG'         => $conf
				  );
  my $html;

  if ($file) {
    unless ($r->content_type eq 'text/html') {
      &error($r, "[Apache Bedrock] content type: Content-type not text/html");
      return DECLINED ;
    }

    unless ( -e $r->filename ) {
      &error($r, "[Apache Bedrock] File does not exist: $file");
      return NOT_FOUND;
    }

    unless ( -r $r->filename ) {
      &error($r, "[Apache Bedrock] File permissions deny access: $file");
      return FORBIDDEN;
    }
  } elsif ($path_info =~/\/bedrock\/?(.*?)$/) {
    $ENV{BEDROCK_REQUEST_DOC} = $1;

    $r->log->info(sprintf("[Apache Bedrock] Bedrock admin directory request denied by configuration.\n")) unless ($conf->{ALLOW_BEDROCK_INFO} =~/yes/i);
    return FORBIDDEN unless $conf->{ALLOW_BEDROCK_INFO} =~/yes/i;

    $r->log->info(sprintf("[Apache Bedrock] Bedrock admin directory request [%s]\n", $ENV{BEDROCK_REQUEST_DOC}));

    my $doc = $ENV{BEDROCK_REQUEST_DOC};

    if ($doc =~/^plugins\/?(.*?)$/) {
      my $file = "$1";
      my $path;
      if ($file) {
	my @blm_listing = get_all_blms();
	my @path_list = grep {/(BLM\/$file|BLM\/Startup\/$file)/i } @blm_listing;

	$path = $path_list[0] . ".pm" if @path_list && -s $path_list[0] . ".pm";
	if ($path) {
	  $path =~/(BLM\/.*?)\.pm$/;
	  my $title = $1;
	  $title =~s/\//::/g;
	  return show_pod($path, $conf, "plugins");
	} else {
	  return NOT_FOUND;
	}
      } else {			# blm listing
	my @blm_listing = get_all_blms();
	my $blms = Bedrock::Hash->new;
	  
	foreach (@blm_listing) {
	  /BLM\/(.*?)$/;
	  $blms->{$1} = "BLM/$1";
	  $blms->{$1} =~s/\//::/g;
	}
	  
	my $html = doc_head(title => "Bedrock Plugins", 
			    stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			    home => "/bedrock",
			    image => $conf->{IMAGE_URL} . "/bedrock.jpg"
			   );
	print $html;
	print blm_ul($blms, "Plugins", grep (!/^Startup/, keys %$blms));
	print blm_ul($blms, "Application Plugins", grep (/^Startup/, keys %$blms));
	print "</body>\n</html>\n";

	return OK;
      }
    } elsif ($doc =~/tag\/?(.*?)$/) {
      my $tag = lc($1);

      if ($tag) {
	my $path;
	my $tag_file;

	foreach my $inc (@INC) {
	  foreach ("NoBody","WithBody","WithBody/Loop") {
	    my $dir = sprintf("%s/Text/TagX/TAG/%s", $inc, $_);
	    $r->log->info(sprintf("Looking in %s for %s\n", $dir, $tag));
	    opendir TAGS, $dir;
	    while (my $file = readdir TAGS) {
	      next unless $file =~/$tag\.pm$/i;
	      $tag_file = $dir . "/" . $file if (-s $dir . "/" . $file);
	      last;
	    }
	    closedir TAGS;
	    last if $tag_file;
	  }
	  last if $tag_file;
	}
	  
	if ($tag_file) {
	  return show_pod($tag_file, $conf, "tag");
	} else {
	  return NOT_FOUND;
	}
      } else {			# tag listing
	my $html = doc_head(title => "Bedrock Tag Listing", 
			    stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			    home => "/bedrock",
			    image => $conf->{IMAGE_URL} . "/bedrock.jpg"
			   );

	$Text::TagX::Opentag_expr =~/^\^\((.*?)\)/;
	my @tag_listing = split /\|/, $1;
	@tag_listing = map { !/(else|else\?if|blm)/ ? sprintf(q{<a href="/bedrock/tag/%s">%s</a>}, $_, $_) : ()} sort @tag_listing;
	print $html."<ul>\n";
	map { print "<li>$_\n"; } @tag_listing;
	print <<eot;
</ul>
</body>
</html>
eot

	return OK;
      }
    } elsif ($doc eq "env") {

      my $env = join("\n", map { sprintf("%s = (%s)", $_, $ENV{$_}); } keys %ENV);
      my $html = doc_head(title => "Bedrock Environment",
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home => "/bedrock",
			  image => $conf->{IMAGE_URL} . "/bedrock.jpg"
			 );
      print <<eot;
$html
<pre>
$env
</pre>
</body>
</html>
eot
      return OK;
    } elsif ($doc eq "config") {
      $html = doc_head(title => "Bedrock Configuration",
		       stylesheet => $conf->{BEDROCK_POD_CSS_URL},
		       home => "/bedrock",
		       image => $conf->{IMAGE_URL} . "/bedrock.jpg",
		       header => undef
		      );
      $html .=<<eot;
<pre>
<trace --output \$config>
</pre>
</body>
</html>
eot
    } else {
      my $html = doc_head(title => "Bedrock Info",
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home => "/bedrock",
			  image => $conf->{IMAGE_URL} . "/bedrock.jpg"
			 );
	
      print $html . "<ul>\n";
      my %links = ("tag" => "Bedrock Tags",
		   "plugins" => "Bedrock Plugins",
		   "config" => "Bedrock Configuration",
		   "env" => "Bedrock Environment"
		  );
	   
      while (my ($key, $value) = each %links) {
	printf(q{<li><a href="/bedrock/%s">%s</a>} . "\n", $key, $value);
      }

      print <<eot;
</body>
</html>
eot
      return OK;
    }
  }

  $r->log->info("[Apache::Bedrock]:$html\n");

  $PWD = &fastcwd unless defined($PWD);

  local($SIG{__DIE__}, $SIG{__WARN__});

  my $controller;
  my $page;

  unless ($file || $html) {
    $controller = $conf->{framework};

    unless ($controller) {
      &error($r, "[Apache Bedrock] no framework object defined in 'tagx_apps.xml' for this directory.");
      return NOT_FOUND;
    }
    # set some defaults
    $controller->{meta} = {'http-equiv' => [ {'http-equiv' => "Content-Type", content => "text/html; charset=iso-8859-1"}] } unless $controller->{meta};
    $page = $ctx->getInputValue("page") || $controller->{pages}->{default};
    $page = $controller->{pages}->{default} if $page eq "default";
    $controller->{title} = ucfirst($page) unless $controller->{title};
  }

  # Shove the URI params in environment.
  local($ENV{'BEDROCK_URI'}) = $r->uri;
  $uri_dir =~ s!/$!!;
  local($ENV{'BEDROCK_URIDIR'}) = $uri_dir;
  local($ENV{'BEDROCK_URINAME'}) = $uri_name;


  # Parse the file components
  my $app_dir;
  my ($file_name, $file_dir);

  ($file_name, $file_dir) = &fileparse( $r->filename ) if $file;

  # And the file params too.
  local($ENV{'BEDROCK_FILE'})            = $r->filename;
  local($ENV{'BEDROCK_FILEDIR'})         = $file_dir;
  local($ENV{'BEDROCK_FILENAME'})        = $file_name;
  local($ENV{'BEDROCK_INCLUDE_DIR'} )    = $conf->{INCLUDE_DIR};
  local($ENV{'BEDROCK_PEBBLE_DIR'})      = $conf->{BEDROCK_PEBBLE_DIR};
  local($ENV{'BEDROCK_USER_PEBBLE_DIR'}) = $conf->{BEDROCK_USER_PEBBLE_DIR};
  local($ENV{'BEDROCK_SESSION_DIR'})     = $conf->{SESSION_DIR};
  local($ENV{'BEDROCK_CONFIG_PATH'})     = $conf->{BEDROCK_CONFIG_PATH} || $conf->{CONFIG_PATH} || $ENV{CONFIG_PATH};
  local($ENV{'BEDROCK_LOG_DIR'})         = $conf->{LOGDIR};
  local($ENV{'BEDROCK_HTML_LOG_DIR'})    = $conf->{HTML_LOGDIR};
  local($ENV{'BEDROCK_LOG_FILE'})        = $conf->{LOGFILE};
  local($ENV{'BEDROCK_IMAGE_DIR'})       = $conf->{BEDROCK_IMAGE_DIR};
  local($ENV{'BEDROCK_IMAGE_URL'})       = $conf->{IMAGE_URL};

  # - if file is null, then this is probably Bedrock Framework since $ENV{PATH_TRANSLATED} refers to a directory
  $app_dir = $file ? $file_dir : $ENV{PATH_TRANSLATED};

  unless ($html) {
    unless ( chdir $app_dir ) {
      return &error($r, "[Apache Bedrock] chdir($app_dir) failed: $!" );
    }
  }

  # - either we'll be implementing Bedrock Framework or just serving a .roc[k] file
  my $tx;
  my $html_fd;

  if ($controller) {
    $r->log->info("[Apache Bedrock] Bedrock framework found in 'tagx_apps.xml', assuming this is a framework application ;-)");

    unless ($controller->{pages}) {
      return &error($r, "[Apache Bedrock] Misconfigured Bedrock framework - no 'pages' object found!");
    }


    unless ($page) {
      &error($r, "[Apache Bedrock] No page specified or no default 'page' set in Bedrock framework.");
    }

    my $action = $ctx->getInputValue("action") || "default";
    $r->log->info(sprintf("[Apache Bedrock] bedrock framework page: [%s] action: [%s]", $page, $action));

    my $page_def = $controller->{pages}->{$page};
 
    unless ($page_def) {
      $r->warn ("[Apache Bedrock] No Bedrock framework definition for [$page] using defaults...");
      $html = sprintf("<html>\n<body>\n<b>Bedrock framework: </b>Page Under Construction - no controller for '%s'</b></body></html>", $page);
    } else {
      $html .= "<html>\n".build_head_section($controller, $page);
      $html .= build_body_tag($controller, $page);
      $html .= build_body_section($controller, $page, $action);


      # - an optional page footer which can be defined by page or application globally 
      my $footer = $page_def->{footer} || $controller->{footer};
      $html .= include(page_name($footer)) if $footer;
      $html .= "</body>\n</html>\n";
    }

    # once a page is loaded, the page becomes the current page and
    # the action is set to NULL, if the developer needs to know how
    # they got here they can use the 'referrer' and 'referrer_action'
    # CGI vars 
    #
    # Note: setting the $ctx->input object as done below is
    # valid at this point ONLY because $ctx->getInputValue was invoked
    # at least once before these references to $ctx->input (see
    # Bedrock::Context if you really want to see the gory details)
    #
    unless ($action eq "default") {
      my @pages = split ";", $page_def->{actions}->{$action};
      my $current_page = $pages[$#pages];
      $current_page =~s/\.inc$//;
      $ctx->input->{page} = $current_page;
      $ctx->input->{referrer} = $page;
      $ctx->input->{referrer_action} = $ctx->input->{action};
      $ctx->input->{action} = undef;
    }

    $html_fd = IO::Scalar->new(\$html);
    $tx = Text::TagX->new ($html_fd, $ctx);
  } elsif ($html) {
    $html_fd = IO::Scalar->new(\$html);
    $tx = Text::TagX->new ($html_fd, $ctx);
  } else {
    $tx = Text::TagX->new ($file, $ctx);
  }

  #
  # Set logging parameters, let's make the default Bedrock Framework
  # log file bedrock-framework
  #
  my $default_framework_log = $uri_dir;
  $default_framework_log =~s/\/$//;
  $default_framework_log = sprintf("%s.bedrock-framework", $default_framework_log);

  my $f = ($conf->{'HTML_LOGDIR'} || $conf->{'LOGDIR'} || '/tmp') . '/' . ($uri_name || $default_framework_log);
  my $sz = $conf->{'HTML_LOGMAXSIZE'} || $conf->{'LOG_MAXSIZE'} || 200000;

  $tx->options(
	       BEDROCK_PEBBLE_DIR => $conf->{'BEDROCK_PEBBLE_DIR'},
	       LOG_MAXSIZE        => $sz,
	       INCLUDE_DIR        => $conf->{INCLUDE_DIR} || ".",
	       LOG_PREFIX         => $f,
	       PEBBLE_DIR         => $conf->{'PEBBLE_DIR'},
	       ALLOW_SNIPPET_TAG  => $conf->{'ALLOW_SNIPPET_TAG'}
	      );

  #
  # Load Generic startup BLMs
  #
  my $modules = $conf->{'MODULES'};
  unless ( $modules ) {
    return &error( $r, "Error in config file: MODULES is not defined." );
  }

  my @startup = @{$modules};
  my $i = 0; my $header;
  for my $modconf (@startup) {

    unless ( defined( $modconf->{'binding'} ) ) {
      return &error( $r, "PID [$$]: Error in config: `binding' not defined for MODULES->[$i]" );
    }

    my $type = $modconf->{'type'} || 'hash';
    unless ( $type =~ /^(hash|array|handle|object)$/ ) {
      return &error( $r, "PID [$$]: Error in config: MODULES->[$i] defined with invalid `type'($type)" );
    }

    # BLM specific configuration
    my $config = $modconf->{'config'};

    # Special handling for header module. We create the object immediately
    # and bind it
    if ( exists $modconf->{'header'} ) {
      # Croak if more than one module tries to become header module
      if ( $header ) {
	return &error( $r, "PID [$$]: Error in config: Multiple modules defined with `header': ($header, $modconf->{'binding'})" );
      }
	  
      # Bind the header
      $header = $modconf->{'binding'};

      my $modfile = $modconf->{'module'};
      $modfile =~ s!::!/!g;
      $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
      require $modfile;

      my $obj;
      if ( $type eq 'hash' or $type eq 'object' ) {
	$obj = bless {}, $modconf->{'module'};
	tie %{$obj}, $modconf->{'module'}, $ctx, $config;
      } elsif ( $type eq 'array' ) {
	$obj = bless [], $modconf->{'module'};
	tie @{$obj}, $modconf->{'module'}, $ctx, $config;
      } elsif ( $type eq 'handle' ) {
	$obj = bless gensym, $modconf->{'module'};
	tie *{$obj}, $modconf->{'module'}, $ctx, $config;
      }
      $tx->param($header => $obj);
      $tx->options('HEADER' => $obj);
      next;
    }

    # bind a subroutine to the names so the constructor gets
    # invoked ONLY if the variable is accessed from the script.
    $tx->param( $modconf->{'binding'}, sub {
		  my $obj;
		  my $modfile = $modconf->{'module'};
		  $modfile =~ s!::!/!g;
		  $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
		  require $modfile;
		  if ( $type eq 'hash' or $type eq 'object' ) {
		    $obj = bless {}, $modconf->{'module'};
		    tie %{$obj}, $modconf->{'module'}, $ctx, $config;
		  } elsif ( $type eq 'array' ) {
		    $obj = bless [], $modconf->{'module'};
		    tie @{$obj}, $modconf->{'module'}, $ctx, $config;
		  } elsif ( $type eq 'handle' ) {
		    $obj = bless gensym, $modconf->{'module'};
		    tie *{$obj}, $modconf->{'module'}, $ctx, $config;
		  }
		  $obj;
		});
  } continue {
    $i++;
  }

  # Croak if no header module
  unless ( $header ) {
    return &error( $r, "PID [$$]: Error in config file: No header module" );
  }

  eval { $tx->output };

  if ( $@ ) {
    $r->log_error( "PID [$$]: Script $file encountered the following error\n    $@" );
    my $error_location = $conf->{BEDROCK_ERROR_LOCATION} ? $conf->{BEDROCK_ERROR_LOCATION} : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};
    $tx->show_error( $error_location );
  }

  chdir $PWD;
  $tx->close;

  # Apache 2 hack for redirection (mod_perl?)
  $r->status(Apache2::Const::REDIRECT) 
    if $ENV{MOD_PERL} && exists ${$r->err_headers_out}{Location} || exists ${$r->err_headers_out}{location};

  return OK;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.22  2010/11/23 00:06:12  rlauer
# - use BEDROCK_POD_CSS_URL instead of POD_CSS_URL
#
# Revision 1.21  2010/11/16 00:20:12  rlauer
# - add BUILD_DATE to header of documentation
#
# Revision 1.20  2010/11/15 02:08:27  rlauer
# - prevent non-PUBLIC BLMs from being shown in Plugin listing
#
# Revision 1.19  2010/11/14 21:11:21  rlauer
# - removed 'exec' from the list of hidden tags - ok to get docs on this
#   as the docs indicate that it is deprecated in favor of <pebble>
#
# Revision 1.18  2010/11/08 03:20:02  rlauer
# - added subroutine show_pod, add <img> tag to plugin/tag documentation
# - pass ALLOW_SNIPPET_TAG in option hash to TagX
#
# Revision 1.17  2010/10/30 21:45:51  rlauer
# - deprecate ERROR_LOCATION (relative to document root), in favor of
#   BEDROCK_ERROR_LOCATION which is an absolute path
#
# Revision 1.16  2010/06/24 21:36:25  rlauer
# rename the Bedrock/Config.pm file to Bedrock/BedrockConfig.pm to avoid Config.pm conflict
#
# Revision 1.15  2009/12/31 18:33:53  rlauer
# exclude blm from tag listing
#
# Revision 1.14  2009/12/30 00:19:01  rlauer
# split up plugins/application plugins, stream pod to disk first before displaying
#
# Revision 1.13  2009/12/28 23:31:31  rlauer
# fixed pod2html call to use temp file so removed comment, use plugins, not BLM
#
# Revision 1.12  2009/12/28 19:29:48  rlauer
# removing traces of BLM, replacing with plugin moniker
#
# Revision 1.11  2009/12/26 15:38:38  rlauer
# remove BLM::OrderedObject, all objects now ordered
#
# Revision 1.10  2009/01/14 13:38:15  rlauer
# - use Apache2::Const for return status
#
# Revision 1.9  2009/01/13 20:16:29  rlauer
# - hack to make sure internal redirects work under mod_perl/Apache2
#
# Revision 1.8  2008/12/02 15:14:51  rlauer
# $doc incorrectly assigned to re-initialized $1
#
# Revision 1.7  2008/11/26 19:25:38  rlauer
# return FORBIDDEN if ALLOW_BEDROCK_INFO ne yes
#
# Revision 1.6  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.5  2008/02/28 18:14:38  rlauer
# Applying Rob's patches to make Bedrock work on Apache 2.x
# (plus a few other obvious bug fixes).
#
# Revision 1.4  2001/02/14 15:35:42  sridhar
# Added copyright and GPL notice
#
# Revision 1.3  2000/12/18 18:05:01  sridhar
# Using Bedrock::Context instead of SIS::Base
#
# Revision 1.2  2000/12/15 16:22:26  sridhar
# Kicked out BLM::Startup::Modules -- all modules are `require'ed rather
# than `use'd for faster startup.
#
# Revision 1.1  2000/12/12 18:58:56  sridhar
# 1. Bedrock.pm, the main bedrock request handler now lives inside
# Bedrock
# 2. Same handler is used by the bedrock CGI too, by just mimicking the
# apache request handler object
# 3. Not using Apache::Constants since this module will now be used by
# the CGI too. Have the required constants hardcoded instead.
# 4. SIS::Base::Apache no longer used. Replaced by SIS::Base.
#
# Revision 1.13  2000/11/29 20:49:55  sridhar
# Can specify PEBBLE_DIR in the config
#
# Revision 1.12  2000/11/16 20:14:10  sridhar
# 1. chdir's to script directory and changes back on return from
# handler.
# 2. Uses `fastcwd' to find current dir for changing back.
# 3. Have a generic `error' function which changes back dir on return.
# 4. If script has an error, invokes `$tx->show_error()' with an error
# page.
#
# Revision 1.11  2000/11/13 14:51:50  sridhar
# Kicked out config cacheing till things stabilize a bit.
#
# Revision 1.10  2000/11/07 21:26:29  sridhar
# 1. Load configuration from disk for every request only if `RELOAD' set
# to `yes'
# 2. Defines a bunch of environment vars `BEDROCK_*' to contain the
# current script name, file, dir, etc.
# 3. Log message includes PID
#
# Revision 1.9  2000/11/07 14:16:51  sridhar
# 1. Major changes implementing directory-specific configuration, including
# Startup modules per directory.
# 2. Module takes care of loading config file `tagx.cfg' and creating
# the config object for each request based on the request directory, and
# merging the startup module list for each directory with the site-wide
# startup module list
# 3. Creates a subroutine for as the binding for each startup object
# which gets invoked for constructing the object only if needed. So one
# could have 100 startup modules for a directory, but use only 3 of them
# in a script; the other 97 wouldn't be constructed at all. All this
# magic happens behind the scenes so nobody is any the wiser.
#
# Revision 1.8  2000/11/01 21:02:17  sridhar
# Using XML file for Configuration
#
# Revision 1.7  2000/08/11 17:56:47  sridhar
# Catch unhandled exceptions and log an error.
#
# Revision 1.6  2000/07/19 19:41:59  sridhar
# Using BLM::Startup::Modules instead of BLM::Modules since dynamic BLMs
# no longer need to be pre-declared.
#
# Revision 1.5  2000/07/11 20:58:50  sridhar
# Localized $SIG{__DIE__} and __WARN__ so that state is restored on exit
# from handler.
#
# Revision 1.4  2000/07/06 18:36:15  sridhar
# Pass the SIS::Base::Apache object directly as the output handle to
# TagX since all necessary methods are supported in it (done for uniform
# header handling between mod_perl and CGI environments).
#
# Revision 1.3  2000/07/06 17:23:09  sridhar
# 1. MODULES config variable is now expected to have startup modules
# under MODULES->STARTUP.
# 2. MODULES->HEADER can be the name of a startup module object which
# generates HTTP headers.
#
# Revision 1.2  2000/06/15 19:35:29  sridhar
# New version with support for BLMs
#
# Revision 1.1  2000/06/07 19:53:41  sridhar
# Added mod_perl module for bedrock
#
#
