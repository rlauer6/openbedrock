#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Bedrock;

BEGIN {
  require Apache2::compat if $ENV{MOD_PERL};
}

use Apache2::Const -compile =>
qw( HTTP_UNAUTHORIZED NOT_FOUND OK SERVER_ERROR FORBIDDEN DECLINED REDIRECT :log);
use Apache2::Log;
use APR::Const -compile => qw(:error SUCCESS);

use strict;
use Data::Dumper;

use warnings;
no warnings qw/uninitialized/;

#
# Define the following mod_perl constants since we could be using
# this module both as a mod_perl module and in a CGI
#
use constant NOT_FOUND    => Apache2::Const::NOT_FOUND;
use constant SERVER_ERROR => Apache2::Const::SERVER_ERROR;
use constant FORBIDDEN    => Apache2::Const::FORBIDDEN;
use constant OK           => Apache2::Const::OK;
use constant DECLINED     => Apache2::Const::DECLINED;
use constant REDIRECT     => Apache2::Const::REDIRECT;

use Bedrock;
use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Hash;
use Bedrock::Text::URLEncode;
use Bedrock::VERSION;
use Text::TagX;

use Cwd;
use File::Basename;
use File::Spec;
use File::Temp;
use IO::File;
use IO::Scalar;
use Pod::Html;
use Symbol;

use Time::HiRes qw/gettimeofday/;

# +-------------------------+
# | Bedrock Config Cacheing |
# +-------------------------+
#
# Basics:
#
# - cacheing Bedrock's config object avoids a lot of config file
#   mashing which includes, file I/O, XML parsing, and merging of hash
#   objects
# 
# - could be employed with either mod_perl or CGIs
#
# - The shared memory segment is created by the Apache parent process
#   when a `startup.pl' script is invoked.  It creates the segment
#   thusly:
#
#     tie %X, 'IPC::Shareable', { key => 'BCFG', create => 1, destroy => 1 };
#   
#   For a non-mod_perl environment (Bedrock running as a perl CGI
#   script) you would need to run the `startup.pl' script at boot time
#   or before your Apache server was started.  Also, you would NOT
#   want the shared memory destroyed when the process terminates, thus
#   you would set `destroy => 0', but would need to provide for some
#   other way to clean up the shared memory segment (if you were
#   concerned about such things).
#
# - in this module (Apache::Bedrock) we tie the hash object
#   (%BEDROCK_CONFIG_CACHE) to the shared memory.  We do this in an
#   eval block in the event that the shared memory is not available.
#   If an error occurs during the tie, we simply will have an empty
#   hash object and thus cacheing is disabled.
#  
#   The absence of the shared memory key is essentially then our
#   trigger to cache or not to cache.
#
# - when the Bedrock handler() method is invoked, we check the cache
#   before creating a config object.
#
#     $conf = $BEDROCK_CONFIG_CACHE{$key};
#
#   If an object exists, great, if not, we do the config dance and
#   create a config object.  We then store the config object back in
#   the hash used to cache the configs.  If we're not cacheing, we do
#   it anyway, no harm, no foul here.
#
# - the "key" used as the hash index in the cache (not to be confused
#   with the shared memory "key" that allows multiple processes to
#   access the same block of shared memory) is composed of the server
#   name from SERVER_NAME environment variable and the absolute path
#   to the file being processed through the handler.
#
#   Keeping in mind that the mod_perl handler servers many virtual
#   hosts we need to make sure that the correct config object is
#   accessed.  Using the key as described above to store and fetch the
#   config object will (should) insure that the correct config object
#   is being used for the correct virtual host and for the correct
#   directory within that virtual host.  Recall that Bedrock allows
#   per directory configuration via `tagx_apps.xml'.
#
# - the shared memory object is destroyed when the Apache parent is
#   gracefully terminated, since we set the `destroy' flag to 1 in our
#   `startup.pl' script which is invoked by the Apache parent process.
#   Again, note that in this module (Apache::Bedrock) we neither
#   create, nor destroy the shared memory segment, but we use it if it
#   is available.
#
# - flushing the config cache is a simple matter of executing this
#   code:
#
#     tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
#     %FOO = ();
#
#   We can (will) provide an external utility for this trivial process
#   as well as add something to the Bedrock Admin pages that
#   accomplishes this task.
#
# - examing the cache is equally trivial
#
#     use IPC::Shareable;
#     use Data::Dumper;
#
#     tie %FOO, 'IPC::Shareable', { key => 'BCFG', create => 0 };
#     print Dumper( \%FOO );
#
# - Are there other opportunities to speed up Bedrock using cacheing?
#   At first blush, no.  The whole point of a templating package is to
#   merge dynamic data with templates, so we never know what dynamic
#   data is being merged.
#
#   Cacheing processed pages then it seems, is a non-starter, however
#   we could conceivably cache the raw Bedrock page, avoiding the disk
#   access associated with reading the .roc file into memory.  Given
#   the advances in the way the O/S handles cacheing of disk objects
#   itself, it seems like this might not be a place where a great deal
#   of additional benefit might be derived with optmizations efforts.

use vars qw/%BEDROCK_CONFIG_CACHE/;

if ( $ENV{BEDROCK_CONFIG_CACHE} ) {
  eval {
    require IPC::Shareable;

    tie %BEDROCK_CONFIG_CACHE, 'IPC::Shareable', { key => 'BCFG', create => 0 }; 
  };
}

my $PWD;
my @config_files_processed;

sub build_body_tag {
  my $controller = shift;
  my $page       = shift;

  my $page_def = $controller->{pages}->{$page};

  $controller->{body} = {} unless $controller->{body};

  my $body = $page_def->{body} || $controller->{body};
  my $body_tag;

  $body_tag = "<body";

  foreach ( keys %{$body} ) {
    $body_tag .= sprintf( q{ %s="%s"}, $_, $body->{$_} );
  }

  $body_tag .= ">\n";

  $body_tag;
}

sub build_body_section {
  my ( $controller, $page, $action ) = @_;

  my $page_def = $controller->{pages}->{$page};
  my $body_section;

  if ( $page_def->{actions}->{$action} ) {
    $body_section = include( page_name( $page_def->{actions}->{$action} ) );
  }
  else {
    $body_section = sprintf(
      "<b>bedrock controller: </b>Page Under Construction - no action for '%s'",
      $action );
  }

  $body_section;
}

sub build_head_section {
  my $controller = shift;
  my $page       = shift;

  my $head_section;

  my $page_def = $controller->{pages}->{$page};

# if a framework defines it's own complete HEAD section we call that a "header" and include that
  if ( $page_def->{header} ) {
    $head_section = include( page_name( $page_def->{header} ) );
  }
  else {
    $head_section = "<head>\n";
    if ( ref( $page_def->{head}->{style} ) =~ /array/i ) {
      $head_section .= join(
        "\n",
        map {
          sprintf( q{<link rel="stylesheet" type="text/css" href="%s">}, $_ )
        } @{ $page_def->{head}->{style} }
      ) . "\n";
    }
    else {
      my $style =
         $page_def->{head}->{style}
      || $page_def->{style}
      || $controller->{style};
      $head_section .=
      sprintf( q{<link rel="stylesheet" type="text/css" href="%s">%s},
               $style, "\n" )
      if $style;
    }

    if ( ref( $page_def->{head}->{javascript} ) =~ /array/i ) {
      $head_section .= join(
        "\n",
        map {
          sprintf( q{<script language="javascript" src="%s"></script>%s},
                   $_, "\n" )
        } @{ $page_def->{head}->{javascript} }
      );
    }
    else {
      my $javascript =
         $page_def->{head}->{javascript}
      || $page_def->{javascript}
      || $controller->{javascript};
      $head_section .=
      sprintf( q{<script language="javascript" src="%s"></script>%s},
               $javascript, "\n" )
      if $javascript;
    }

    # -- construct meta tags if present
    my $meta =
       $page_def->{head}->{meta}
    || $page_def->{meta}
    || $controller->{meta};

    if ($meta) {
      if ( ref( $meta->{name} ) =~ /array/i ) {
        $head_section .= join(
          "\n",
          map {
            sprintf( q{<meta name="%s" content="%s">},
                     $_->{name}, $_->{content} )
          } @{ $meta->{name} }
        ) . "\n";
      }

      if ( ref( $meta->{'http-equiv'} ) =~ /array/i ) {
        $head_section .= join(
          "\n",
          map {
            sprintf( q{<meta http-equiv="%s" content="%s">},
                     $_->{'http-equiv'}, $_->{content} )
          } @{ $meta->{'http-equiv'} }
        ) . "\n";
      }
    }

    my $title =
       $page_def->{head}->{title}
    || $page_def->{title}
    || $controller->{title};
    $head_section .= sprintf( "<title>%s</title>\n", $title ) if $title;
    $head_section .= "</head>\n";
  }

  $head_section;
}

sub merge_modules {
  my $r = shift;
  my ( $dest_config, $src_config ) = @_;

  my $src_modules = $src_config->{'MODULES'};

  return unless $src_modules && @$src_modules;

  my %dest_modules;

  map { $dest_modules{ $_->{'binding'} } = $_; } @{ $dest_config->{'MODULES'} };

  if ( $src_modules && @$src_modules ) {
    foreach ( @$src_modules ) {

      $r && $r->log->debug( sprintf(
				    "[%s]: overriding MODULE binding %s",
				    (caller(0))[3],
				    $_->{'binding'}
				   )
			  )
	if exists $dest_modules{ $_->{'binding'} };

      $r && $r->log->debug(
			   sprintf( 
				   "[%s]: merging module: [%s]", 
				   (caller(0))[3],
				   Bedrock::Dump::compact( $_ )
				  )
			  );
      
      $dest_modules{ $_->{'binding'} } = $_;
    }

    my @modules = values %dest_modules;
    $dest_config->{'MODULES'} = \@modules;
  }
}

sub merge_config {
  my $r = shift;

  # bedrock master config, local config
  my ( $dest_config, $src_config ) = @_;

  $r && $r->log->debug(
		       sprintf(
			       "[%s]: merging configs: [%s]",
			       (caller(0))[3],
			       Bedrock::Dump::compact($dest_config)
			      )
		      );

  $r && $r->log->debug(
		       sprintf( 
			       "[%s]: merging configs: [%s]", 
			       (caller(0))[3],
			       Bedrock::Dump::compact($src_config)
			      )
		      );
 
  # merge source-config with dest-config (override)
  map { $dest_config->{$_} = $src_config->{$_} unless $_ eq 'MODULES'; }
  keys %$src_config;

  # merge modules
  merge_modules( $r, $dest_config, $src_config );

  $dest_config;
}

# config( apache-request, uri-dir )
sub config {
  my $r   = shift;
  my $dir = shift;

  $dir =~ s!/$!!;

  $r && $r->log->debug( 
		       sprintf( 
			       "[%s]: env: %s", 
			       (caller(0))[3], 
			       Bedrock::Dump::compact( \%ENV )
			      )
		      );

  $r && $r->log->debug( 
		       sprintf( 
			       "[%s]: uri-dir: %s DOCUMENT_ROOT: %s", 
			       (caller(0))[3], 
			       $dir || '/',
			       $ENV{DOCUMENT_ROOT}
			      )
		      );
  
  $dir =~ s/^$ENV{DOCUMENT_ROOT}//;    # Bedrock shell

  $r && $r->log->debug( 
		       sprintf( 
			       "[%s]: uri-dir: %s CONFIG_PATH: %s", 
			       (caller(0))[3], 
			       $dir || '/',
			       $ENV{CONFIG_PATH}
			      )
		      );

  # Bedrock 2 wants the master tagx.xml in $ENV{BEDROCK_CONFIG_PATH}
  # it can be overridden or merged with local configuration files.  To
  # override the master, add this to the master tagx.xml file
  #
  #  <scalar name="REPLACE_CONFIG">yes</scalar>
  #
  my $conf;
  eval { $conf = Bedrock::Config->new('tagx.xml'); };

  if ( $@ ) {
    $r && $r->log->warn( $@ );
    $r && $r->log->warn( 
			sprintf( 
				"[%s]: error reading %s/tagx.xml" , 
				(caller(0))[3], 
				$ENV{BEDROCK_CONFIG_PATH}
			       )
		       );
  }

  push @config_files_processed, $ENV{BEDROCK_CONFIG_PATH} . "/tagx.xml";

  # look for data-sources.xml which defines database connection strings
  my $db_conf;

  foreach my $dir (qw(BEDROCK_CONFIG_PATH CONFIG_PATH)) {

    my $xml_file = $ENV{$dir}    . "/data-sources.xml";
    if ( -s $xml_file ) {
      push @config_files_processed, $xml_file;

      my $conf = Bedrock::Config->new( $xml_file );

      $db_conf = merge_config( $r, $conf, $db_conf || Bedrock::Hash->new() );
    }
  }

  $conf->{'_dbnames'} = $db_conf 
    if $db_conf;

  # look for a tagx.xml that will be used with or instead of Bedrock's tagx.xml
  if ( -r $ENV{CONFIG_PATH} . '/tagx.xml' ) {
    if ( !$conf || $conf->{REPLACE_CONFIG} =~ /^y/i ) {
      $r && $r->log->debug( 
			   sprintf( 
				   "[%s]: [%s/tagx.xml] replaces system [%s/tagx.xml].",
				   (caller(0))[3],
				   $ENV{CONFIG_PATH}, 
				   $ENV{BEDROCK_CONFIG_PATH}
				  )
			  );

      $conf = Bedrock::Config->new( $ENV{CONFIG_PATH} . '/tagx.xml' );
      push @config_files_processed, $ENV{CONFIG_PATH} . '/tagx.xml';
    }
    else {
      my $local_conf = Bedrock::Config->new( $ENV{CONFIG_PATH} . '/tagx.xml' );

      $conf = ( $local_conf->{REPLACE_CONFIG} =~ /^y/i ) ? $local_conf : merge_config( 
										      $r, 
										      $conf, 
										      $local_conf
										     );
      push @config_files_processed, $ENV{CONFIG_PATH} . '/tagx.xml';
    }
  }

  $r && $r->log->debug( "config: " . Bedrock::Dump::compact($conf) );

  die sprintf( "No or empty 'tagx.xml' found.\n" .
	       "BEDROCK_CONFIG_PATH: [%s]\n" .
	       "CONFIG_PATH: [%s]\n",
	       $ENV{BEDROCK_CONFIG_PATH}, 
	       $ENV{CONFIG_PATH} )
    unless $conf && keys %$conf;

# Look for auxillary application configurations and merge with (or replace)  master

  my @app_conf_files;

  my ( $dummy, $framework_dir ) = split /\//, $dir;

  my $framework_conf = sprintf( 
			       "%s/framework/%s.xml", 
			       $ENV{CONFIG_PATH}, 
			       $framework_dir
			      );

  $r && $r->log->debug(
		       sprintf(
			       "[%s]: reading framework config file: [%s.xml]...%s",
			       (caller(0))[3],
			       $framework_dir,
			       ( -s $framework_conf ) ? "FOUND" : "NOT FOUND" 
			      )
		      );

  push @app_conf_files, $framework_conf if -s $framework_conf;


  # look for more config files to merge
  foreach my $path ( ( $ENV{BEDROCK_CONFIG_PATH} . ".d",
                       $ENV{CONFIG_PATH},
                       $ENV{CONFIG_PATH} . ".d"
                     )
                   ) {

    $r && $r->log->debug( 
			 sprintf( "[%s]: reading config files: [%s]", 
				  (caller(0))[3], 
				  $path 
				)
			);

    next unless -d $path;

    local (*CONFIG_FILES);
    opendir CONFIG_FILES, "$path";

    while ( my $file = readdir CONFIG_FILES ) {
      next unless $file =~ /\.xml$/ && $file !~ /^(tagx|tagx_apps)\.xml$/;

      $r && $r->log->debug( 
			   sprintf(
				   "[%s]: merging config file: [%s]",
				   (caller(0))[3],
				   $file
				  )
			  );

      $conf = merge_config( $r, 
			    $conf,
			    Bedrock::Config->newFromXML( $path . '/' . $file )
			  );

      push @config_files_processed, $path . '/' . $file;
    }
    closedir CONFIG_FILES;
  }

  # look for module configs
  my @module_paths;

  foreach (qw/startup plugin/) {

    push @module_paths, $ENV{CONFIG_PATH} . ".d/" . $_
      if -d $ENV{CONFIG_PATH} . ".d/" . $_;

    push @module_paths, $ENV{BEDROCK_CONFIG_PATH} . ".d/" . $_
      if -d $ENV{BEDROCK_CONFIG_PATH} . ".d/" . $_;
  }

  foreach my $path (@module_paths) {
    local (*CONFIG_FILES);
    opendir CONFIG_FILES, "$path";

    while ( my $file = readdir CONFIG_FILES ) {
      next unless $file =~ /\.xml$/;

      $r && $r->log->debug(
			   sprintf(
				   "[%s]: loading config file: [%s]", 
				   (caller(0))[3], 
				   $file
				  )
			  );

      merge_modules( $r, $conf,
                     { MODULES =>
                       [ Bedrock::Config->newFromXML( $path . '/' . $file ) ]
                     }
                   );

      push @config_files_processed, $path . '/' . $file;
    }

    closedir CONFIG_FILES;
  }

  # note that configurations above could have overridden APP_CONFIG
  # These are directory level configurations (tagx_apps.xml)
  push @app_conf_files, $conf->{'APP_CONFIG'} if $conf->{'APP_CONFIG'};

  foreach my $dir_conffile (@app_conf_files) {
    $r && $r->log->debug(
			 sprintf( 
				 "[%s]: loading app config file: [%s]", 
				 (caller(0))[3],
				 $dir_conffile
				)
			);
    
    # Load the config file
    my $dir_conf = Bedrock::Config->new($dir_conffile);
    push @config_files_processed, $dir_conffile;

    my $dir_path = '/';
    my %dirconfs;

    foreach my $dir_part ( undef, split /\//, $dir ) {
      $dir_path .= $dir_part;

      next if $dirconfs{$dir_path};

      $dirconfs{$dir_path} = $dir_path;
      
      # Look up the app config, based on directory of current request
      my $app_conf = $dir_conf->{$dir_path} || $dir_conf->{ $dir_path . '/' };

      $r && $r->log->debug(
			   sprintf(
				   "[%s]: reading directory config [%s]...%s",
				   (caller(0))[3],
				   $dir_path,
				   $app_conf ? 'FOUND' : 'NOT FOUND'
				  )
			  );


      $conf = merge_config( $r, $conf, $app_conf ) 
	if $app_conf;

      $dir_path .= '/'
	unless $dir_path eq '/';
    }
  }

  $conf->{CONFIG_PATH} = $ENV{CONFIG_PATH};

  # And voila! we have the merged config
  $conf;
}

sub error {
  my $r    = shift;
  my $mesg = shift;
  my $code = shift || SERVER_ERROR;

  $r && $r->log_error( $mesg );

  chdir $PWD;
  return $code;
}

# show_pod(file, config-object, "tag|plugins");
sub show_pod {
  my $file              = shift;
  my $conf              = shift;
  my $return_to         = shift;
  my $bedrock_admin_dir = $conf->{BEDROCK_ADMIN_DIR} || '/bedrock';
  my $outfile           = tmpnam;

  &pod2html( '--infile', $file,
	     '--outfile', $outfile,
	     '--cachedir', File::Spec->tmpdir(),
	     $conf->{BEDROCK_POD_CSS_URL} ? "--css=" . $conf->{BEDROCK_POD_CSS_URL} : ()
	   );

  # in the off chance somebody puts the stupid Bedrock images some place else
  my $image_url = $conf->{BEDROCK_IMAGE_URL} || "/bedrock/img";
  my $bedrock_logo = $image_url . '/' . $conf->{BEDROCK_LOGO};

  my $snippet = <<html;
<table width="100%">
<tr>
  <td align="left"><a href="$bedrock_admin_dir"><img src="$bedrock_logo" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>
html

  # little or no pod?
  if ( -s $outfile > 600 ) {
    open( FILE, $outfile ) or die "Unable to open $outfile: $!\n";
    local $/ = undef;
    my $data = <FILE>;
    close FILE;

    $data =~ s/(<body(.*?)>)/$1\n$snippet/is;

    print "Content-type: text/html\n\n";
    print $data;
  }
  else {
    print sprintf( "Location: http://%s/%s/%s\n\n",
                   $bedrock_admin_dir, $ENV{HTTP_HOST}, $return_to );
  }

  unlink $outfile;

  return OK;
}

sub module_listing {
  my $dir = shift;
  my $no_blms = shift;

  my @listing;

  return () unless -d $dir;

  local *POD_DIR;
  opendir POD_DIR, $dir;

  while ( my $file = readdir POD_DIR ) {
    next if ( $file =~ /^\./ );

    next if $no_blms && $file =~/blm/i && grep { /$dir/ } @INC;

    if ( -d $dir . "/" . $file ) {
      push @listing, module_listing( $dir . "/" . $file );
    }
    else {
      push @listing, $dir . "/" . $1 if ( $file =~ /^(.*?)\.pm$/ );
    }
  }

  closedir POD_DIR;

  return @listing;
}

=pod

=head2 get_all_modules

 get_all_modules( paths, public-only, blms)

Returns a hash reference containing perl module names and their paths.

=over 5

=item paths

Array reference of paths to search for perl modules.  If the array
element is a hash instead of a scalar representing a path, then the
hash object should contain two keys (C<dir> and C<filter>).  The
C<dir> key should contain the directory to search for perl modules and
the C<filter> key should contain a regular expression that will be
used to filter modules in that directory.

=item public-only

Boolean flag that indicates whether only modules with a C<head1> tag
of C<PUBLIC> should be returned.

=item blms

Boolean flag that indicates C<BLM> modules should be ignored.

=back

=cut

sub get_all_modules {
  my $paths = shift;
  my $public_only = shift;
  my $no_blms = shift;

  my @module_listing;
  my %module_map;

  foreach my $path ( @$paths ) {
    my $dir;
    my $filter;

    if ( UNIVERSAL::isa( $path, 'HASH') ) {
      $dir = $path->{dir};
      $filter = $path->{filter};
    }
    else {
      $dir = $path;
    }

    my @modules = module_listing( $dir, $no_blms );

    foreach my $file ( @modules ) {
      
      my $module = $file;
      $module =~s/$dir\///;
      $module =~s/\//::/g;

      $filter = qr/$filter/ 
	if $filter;

      next if $filter && $module !~ $filter;
      
      $module_map{$module} = $file;
    }

    push @module_listing, @modules;
  }
  
  local *POD;

  foreach my $module ( keys %module_map) {
    open POD, "<" . $module_map{$module} . ".pm" or next;
    local $/;

    my $source = <POD>;

    if ( $source =~ /\=(pod|head1)/si ) {
      delete $module_map{$module}
	unless ($source =~ /\=head1\s+public/si || ! $public_only );
    }
    else {
      delete $module_map{$module};
    }

    close POD;
  }

  return \%module_map;
}

=pod

=head2 get_all_blms

=cut

sub get_all_blms {

  my @module_listing;

  my @blm_path = grep { -d $_ . "/BLM" } @INC;

  my $modules = get_all_modules( \@blm_path, 1 );

  @{$modules}{sort keys %$modules};
}

=pod

=head2 doc_head

=cut

# return the standard documentation header

sub doc_head {
  my %attributes = @_;
  my $head;
  $head = "Content-type: text/html\n\n" unless exists $attributes{header};

  $head .= <<eot;
<html>
<head>
<title>%s</title>
<link rel="stylesheet" href="%s" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>
<body>
<table width="100%">
<tr>
  <td align="left"><a href="%s"><img src="%s" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>

<h1>%s</h1>
eot

  $head = sprintf( $head,
                   $attributes{title}, $attributes{stylesheet},
                   $attributes{home},  $attributes{image},
                   $attributes{title} );

  return $head;
}

sub ul_links {
  my $bedrock_admin_dir = shift;
  my $links             = Bedrock::Hash->new(@_);
  my $ul                = "<ul>\n";

  while ( my ( $key, $value ) = each %{$links} ) {
    $ul .= sprintf( q{<li><a href="%s/%s">%s</a>} . "\n",
                    $bedrock_admin_dir, $key, $value );
  }

  $ul .= "</ul>\n";

  return $ul;
}

sub page_name { $_[0] .= ".inc" unless $_[0] =~ /\.inc$/; $_[0]; }

=pod

=head2 include

=cut

sub include {
  my @pages = split ";", $_[0];
  my $include;

  foreach (@pages) {
    $include .= sprintf( q{<include --file="%s">}, page_name($_) );
  }

  $include;
}

=pod

=head2 blm_ul

=cut

sub blm_ul {
  my $bedrock_admin_dir = shift;
  my $blms = shift;
  my $h2 = shift;

  return unless @_;
  my $html;

  my %blm_listing;

  # just the names
  foreach (@_) {
    $blm_listing{$_} = $blms->{$_};
    $blm_listing{$_} =~ s/^(.*)::(.*)$/$2/;
  }

  $html = sprintf( "<h2>%s</h2>\n", $h2 );

  my $li = '<li><a href="%s/plugins/%s">%s</a>';
  $html .= sprintf( 
		   "<ul>\n%s\n</ul>\n",
		    join("\n", map {  sprintf( $li, $bedrock_admin_dir, $_, $blm_listing{$_} ) } @_)
		  );


  return $html;
}

=pod

=head2 require_module

=cut

sub require_module {
  my $modfile = shift;
  
  $modfile =~ s!::!/!g;
  $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
  
  require $modfile;
}

sub bind_module {
  my %args = @_;

  require_module( $args{module} );
      
  my $obj;

  if ( $args{type} eq 'hash' or $args{type} eq 'object' ) {
    $obj = bless {}, $args{module};
    tie %{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'array' ) {
    $obj = bless [], $args{module};
    tie @{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'handle' ) {
    $obj = bless gensym, $args{module};
    tie *{$obj}, $args{module}, $args{context}, $args{config};
  }

  return $obj;
}


# +------------------------------+
# | mod_perl HANDLER STARTS HERE |
# +------------------------------+

sub handler {
  my $r = shift;

  # start HiRes timer
  my ($start_seconds, $start_microseconds) = gettimeofday();

  $r && $r->log->info(
		       sprintf(
			       "[%s]: Apache::Bedrock started.", 
			       (caller(0))[3]
			       )
		      );

  $r && $r->log->debug(
		       sprintf(
			       "[%s]: request object: [%s]",
			       (caller(0))[3],
			       ref( $r )
			      )
		      );

  my $file = "";

# - under mod_perl naked directory requests, intended for the bedrock controller
#   are passed along prior to file checking.  Thus the content_type is directory
  if ( $r->content_type =~ /directory/ ) {
    $r && $r->log->debug(
			 sprintf( 
				 "[%s]: directory requested: [%s]", 
				 (caller(0))[3],
				 $r->filename
				)
			);

    $ENV{PATH_TRANSLATED} = $r->filename;
    $r->content_type('text/html');
  }

# - under mod_cgi those same requests come through via the "virtual" modifier on the Action directive
#   8<
#     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual
#   8<
  else {
    $file = $r->filename;

    $r && $r->log->debug( sprintf( 
				  "[%s]: file requested: [%s]", 
				  (caller(0))[3],
				  $r->filename
				 )
			);
  }

  my $path_info = $ENV{PATH_INFO};
  $path_info =~ s/(.*?)\/$/$1/;

  $r && $r->log->debug( sprintf( "[%s]: request file.....[%s] " , (caller(0))[3], $file ) );
  $r && $r->log->debug( sprintf( "[%s]: URI..............[%s] " , (caller(0))[3], $r->uri ) );
  $r && $r->log->debug( sprintf( "[%s]: PATH_INFO........[%s] " , (caller(0))[3], $path_info ) );
  $r && $r->log->debug( sprintf( "[%s]: PATH_TRANSLATED..[%s] " , (caller(0))[3], $ENV{PATH_TRANSLATED} ) );

  # Parse for the URI components
  my ( $uri_name, $uri_dir ) = &fileparse( $r->uri );

  my $conf;

  if ( $file && $ENV{BEDROCK_CACHE_CONFIG} && $ENV{BEDROCK_CACHE_CONFIG} =~/^y/i ) {
    my ( $name, $path ) = &fileparse( $file );
    my $key = $ENV{SERVER_NAME} . ':' . $path;

    $r->log->debug(
		   sprintf(
			   "[%s]: cache contents: [%s]",
			   (caller(0))[3],
			   Bedrock::Dump::compact( [ keys %BEDROCK_CONFIG_CACHE ] )
			  )
		  );
		    
    $r->log->debug( sprintf(
			    "[%s]: checking config cache: [%s]",
			    (caller(0))[3],
			    $key
			   )
		  );
    
    $conf = $BEDROCK_CONFIG_CACHE{$key};

    unless ( $conf ) {
      eval { $conf = &config( $r, $uri_dir ); };
      $BEDROCK_CONFIG_CACHE{$key} = $conf;
    }
    else {
      $r->log->debug( sprintf(
			      "[%s]: using config from cache: [%s]",
			      (caller(0))[3],
			      $key
			     )
		    );
    }
  }
  else {
    eval { $conf = &config( $r, $uri_dir ); };
  };


  my ($seconds, $microseconds) = gettimeofday();

  $r->log->debug(
		 sprintf("[%s]: config processing complete: %s", 
 			 (caller(0))[3], 
			 ($seconds - $start_seconds) + 
			 ($microseconds - $start_microseconds)/1000000,
			)
		);

  if ( $@ ) {
    &error( $r, sprintf("[%s]: Could not read config file. $@", (caller(0))[3]) );
    my $config_files_listing = join( "\n", @config_files_processed );

    unless ( ref($r) =~ /shell/i ) {
      print <<eot;
Content-type: text/html

<html>
<head>
<title>Bedrock Configuration Error</title>
</head>
<body>
<div style="color:red;">An error was encountered while trying to read Bedrock&#39; configuration file:</div>
<pre>
You most likely have a malformed .xml file somewhere in your configuration path.
While reading the configuration directories, Bedrock has thrown the following exception:

$@

Bedrock has successfully processed the configuration files listed below:

$config_files_listing

Check the log file for more information.
</pre>
</body>
</html>
eot
      return OK;
    }
    else {
      print <<eom;

Bedrock shell could not process one or more of your configuration files.

You most likely have a malformed .xml file somewhere in your configuration path.
While reading the configuration directories, Bedrock has thrown the following exception:

\t$@
Bedrock has successfully processed the configuration files listed below:

\t$config_files_listing

Check the log file for more information.\n
eom
      return 0;
    }
  }

  $conf->{BEDROCK_IMAGE_URL} = $conf->{IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

# make sure that the LOG directories are present and writable, otherwise try /tmp
  foreach (qw(LOGDIR HTML_LOGDIR)) {
    unless ( -d $conf->{$_} && -w $conf->{$_} ) {
      $conf->{$_} = '/tmp';
    }
  }

  my $ctx = Bedrock::Context->new( 'APACHE_HANDLER' => $r,
                                   'CONFIG'         => $conf );
  my $html;

  my $bedrock_admin_dir = $conf->{BEDROCK_ADMIN_DIR} || '/bedrock';

  if ( $file ) {
    unless ( $r->content_type eq 'text/html' ) {
      &error( $r, sprintf("[%s]: content type: Content-type not text/html", (caller(0))[3]) );
      return DECLINED;
    }

    unless ( -e $r->filename ) {
      &error( $r, sprintf("[%s]: file does not exist: [%s]", (caller(0))[3], $file) );
      return NOT_FOUND;
    }

    unless ( -r $r->filename ) {
      &error( $r, sprintf("[%s]: file permissions deny access: [%s]", (caller(0))[3], $file) );
      return FORBIDDEN;
    }
  }
  elsif ( $path_info =~ /$bedrock_admin_dir\/?(.*?)$/ ) {
    $ENV{BEDROCK_REQUEST_DOC} = $1;

    unless ( $conf->{ALLOW_BEDROCK_INFO} =~ /(yes|docs)/i ) {
      
      $r && $r->log->error(  sprintf( 
				     "[%s]: bedrock admin directory request denied by configuration!",
				     (caller(0))[3]
				    )
			  );
      return FORBIDDEN;
    }
    
    
    $r && $r->log->debug(
			 sprintf( "[%s]: bedrock admin directory request: [%s]",
				  (caller(0))[3],
				  $ENV{BEDROCK_REQUEST_DOC} )
			);

    my $doc = $ENV{BEDROCK_REQUEST_DOC};

    if ( $doc =~ /plugins\/?(.*?)$/ ) {
      my $file = "$1";
      my $path;

      if ( $file ) {
        my @blm_listing = get_all_blms();
        my @path_list =
	  grep { /(BLM\/$file|BLM\/Startup\/$file)|BLM\/Filter\/$file/i } @blm_listing;

        $path = $path_list[0] . ".pm" if @path_list && -s $path_list[0] . ".pm";

        if ( $path ) {
          $path =~ /(BLM\/.*?)\.pm$/;
          my $title = $1;
          $title =~ s/\//::/g;
          return show_pod( $path, $conf, "plugins" );
        }
        else {
          return NOT_FOUND;
        }
      }
      else {    # blm listing
        my @blm_listing = get_all_blms();
        my $blms = Bedrock::Hash->new;

        foreach (  @blm_listing ) {
          /BLM\/(.*?)$/;
          $blms->{$1} = "BLM/$1";
          $blms->{$1} =~ s/\//::/g;
        }

        my $html = doc_head(title      => "Bedrock Plugins",
                            stylesheet => $conf->{BEDROCK_POD_CSS_URL},
                            home       => $bedrock_admin_dir,
                            image      => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO}
                           );

        $html .= blm_ul( $bedrock_admin_dir, $blms, "Plugins",
                         grep ( !/^(Startup|Filter)/, keys %$blms ) );
        $html .= "<hr>\n";
        $html .= blm_ul( $bedrock_admin_dir, $blms,
                         "Application Plugins",
                         grep ( /^Startup/, keys %$blms ) );
        $html .= "<hr>\n";
        $html .= blm_ul( $bedrock_admin_dir, $blms,
                         "Filters",
                         grep ( /^Filter/, keys %$blms ) );
        $html .= "</body>\n</html>\n";

        print $html;

        return OK;
      }
    }
    elsif ( $doc =~/system\/?(.*?)$/ ) {
      my $module = $1;

      my $module_listing;
      my $pod_paths = [ '@libdir@/bedrock/perl5' ];
      $module_listing = get_all_modules( $pod_paths, 0 );

      my $html = doc_head(
			  title      => "System Documentation Listing",
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home       => $bedrock_admin_dir,
			  image      => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO} 
			 );

      if ( $module && $module_listing && keys %$module_listing ) {
	$module =~s/\//\:\:/g;
	my $path = $module_listing->{$module} . '.pm';

	return show_pod( $path, $conf, "tag" );
      }
      elsif ( $module_listing && keys %$module_listing ) {

	my $modules = get_all_modules( $pod_paths, 0, 1 );
	
	print $html. "<ul>\n";
	
	foreach my $module ( sort keys %$modules ) {
	  my $path = $module;
	  $path =~s/\:\:/\//g;
	  
	  my $href = sprintf('<a href="/bedrock/system/%s">%s</a>', $path, $module ); 
	  print "<li>$href</li>\n"
	    unless $module =~/Bedrock::(Text|Filter)/;
	}
	print <<eot;
</ul>
</body>
</html>
eot
	return OK;
      }
    }
    elsif ( $doc =~/pod\/?(.*?)$/ ) {
      my $module = $1;

      my $module_listing;

      my $pod_paths = $conf->{POD_PATHS};

      if ( $pod_paths && @$pod_paths ) {
	$module_listing = get_all_modules( $pod_paths, 0 );
      }

      my $html = doc_head(title      => "User Documentation Listing",
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home       => $bedrock_admin_dir,
			  image      => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO} 
			 );

      if ( $module && $module_listing && keys %$module_listing ) {
	$module =~s/\//\:\:/g;
	my $path = $module_listing->{$module} . '.pm';

	return show_pod( $path, $conf, "tag" );
      }
      elsif ( $module_listing && keys %$module_listing ) {
	my $pod_paths = $conf->{POD_PATHS};

	if ( $pod_paths && @$pod_paths ) {
	  my $modules = get_all_modules( $pod_paths, 0, 1 );

	  print $html. "<ul>\n";

	  foreach my $module ( sort keys %$modules ) {
	    my $path = $module;
	    $path =~s/\:\:/\//g;

	    my $href = sprintf('<a href="/bedrock/pod/%s">%s</a>', $path, $module ); 
	    print "<li>$href</li>\n";
	  }
	  print <<eot;
</ul>
</body>
</html>
eot
	  return OK;
	}
      }
      else {
	print $html;
	print "No user documentation found.";
	print "</body></html>";

	return OK;
      }
    }
    elsif ( $doc =~/tag\/?(.*?)$/ ) {
      my $tag = lc($1);

      if ($tag) {
        my $path;
        my $tag_file;

        foreach my $inc (@INC) {

          foreach ( "NoBody", "WithBody", "WithBody/Loop" ) {
            my $dir = sprintf( "%s/Text/TagX/TAG/%s", $inc, $_ );

            opendir TAGS, $dir;

            while ( my $file = readdir TAGS ) {
              next unless $file =~ /$tag\.pm$/i;
              $tag_file = $dir . "/" . $file if ( -s $dir . "/" . $file );
              last;
            }
            closedir TAGS;
            last if $tag_file;
          }
          last if $tag_file;
        }

        if ($tag_file) {
          return show_pod( $tag_file, $conf, "tag" );
        }
        else {
          return NOT_FOUND;
        }
      }
      else {    # tag listing
        my $html = doc_head(title      => "Bedrock Tag Listing",
                            stylesheet => $conf->{BEDROCK_POD_CSS_URL},
                            home       => $bedrock_admin_dir,
                            image      => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO} 
                           );

        $Text::TagX::Opentag_expr =~ /^\^\((.*?)\)/;
        my @tag_listing = split /\|/, $1;
        @tag_listing = map {
          !/(else|else\?if|blm|\?)/
          ? sprintf( q{<a href="%s/tag/%s">%s</a>}, $bedrock_admin_dir, $_, $_ )
          : ()
        } sort @tag_listing;
        print $html. "<ul>\n";
        map { print "<li>$_\n"; } @tag_listing;
        print <<eot;
</ul>
</body>
</html>
eot

        return OK;
      }
    }
    elsif ( $doc =~ /^(env|config)$/ ) {

      my %vars = ( env    => [ 'Environment',   \%ENV ],
                   config => [ 'Configuration', $conf ] );

      my $html = doc_head( title      => "Bedrock " . $vars{$doc}->[0],
                           stylesheet => $conf->{BEDROCK_POD_CSS_URL},
                           home       => $bedrock_admin_dir,
                           image => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO}
                         );
      $html .= q{<table cellpadding="0" cellspacing="0" border="0">} . "\n";
      foreach ( sort keys %{ $vars{$doc}->[1] } ) {
        my $val = $vars{$doc}->[1]->{$_};
        my $string_val =
        ref($val)
        ? '<pre class="configref">' . Bedrock::Dump::compact($val) . '</pre>'
        : '<code class="configvar">' . $val . '</code>';
        $html .= <<eot;
<tr>
  <th valign="top" align="right"><code>$_</code>&nbsp;</th>
  <td valign="top">$string_val</td>
</tr>
eot
      }

      $html .= "</table>\n</body>\n</html>\n";

      print $html;

      return OK;
    }
    else {
      my $html = doc_head( title      => "Bedrock Reference Guide",
                           stylesheet => $conf->{BEDROCK_POD_CSS_URL},
                           home       => $bedrock_admin_dir,
                           image      => $conf->{BEDROCK_IMAGE_URL} . '/' . $conf->{BEDROCK_LOGO}
                         );

      $html .= ul_links( $bedrock_admin_dir,
                         "tag"     => "Bedrock Tags",
                         "plugins" => "Bedrock Plugins",
                       );

      $html .= "<hr>\n";



      $html .= "<h1>System Documentation</h1>\n";
      $html .= ul_links ( $bedrock_admin_dir,
			  "system" => "System Modules"
			);
      
      $html .= "<hr>\n";

      if ( $conf->{POD_PATHS} && @{$conf->{POD_PATHS}} ) {
        $html .= "<h1>User Documentation</h1>\n";
	$html .= ul_links ( $bedrock_admin_dir,
			    "pod" => "Module Listing"
			  );
	
	$html .= "<hr>\n";
      }

      unless ( $conf->{ALLOW_BEDROCK_INFO} eq 'docs' ) {
        $html .= "<h1>Bedrock Environment</h1>\n";
        $html .= ul_links( $bedrock_admin_dir,
                           "config" => "Bedrock Configuration",
                           "env"    => "Bedrock Environment"
                         );

        # See if logs are working...
        $html .= "<hr>\n";
        $html .= "<h1>Bedrock Logs</h1>\n";

        my $logfile = sprintf( "%s/%s", @$conf{qw(LOGDIR LOGFILE)} );

        unless ( $conf->{LOGDIR} && $conf->{LOGFILE} ) {

          # no LOGDIR specified
          $html .=
q{<span class="error">No log directory or log file specified in <strong>tagx.xml</strong>.  Set <strong>LOGDIR and LOGFILE</strong></span> }
          . "\n";
        }
        elsif ( -d $conf->{LOGDIR} && !-s $logfile ) {

          # directory defined
          $html .=
            q{<span class="error">Directory specified but no <strong>} 
          . $logfile
          . "</strong> can be found.  Check permissions.</span>\n";
        }
        elsif ( !-d $conf->{LOGDIR} ) {

          # directory not defined
          $html .=
            q{<span class="error">Log directory is specified but <strong>}
          . $conf->{LOGDIR}
          . "</strong> does not exist.  Create the directory.  Make sure the Apache user can write to this directory.\n";
        }
        elsif ( !-d $conf->{HTML_LOGDIR} ) {

          # directory not defined
          $html .=
            q{<span class="error">HTML log directory is specified but <strong>}
          . $conf->{HTML_LOGDIR}
          . "</strong> does not exists.  Create the directory. Make sure the Apache user can write to this directory.\n";
        }
        else {

          # defined and present
          $html .= "<ul>\n";
          $html .=
            q{<li><span class="code">LOGDIR:</span>&nbsp;<strong>}
          . $conf->{LOGDIR}
          . "</strong></li>\n";
          $html .=
            q{<li><span class="code">LOGFILE:</span>&nbsp;<strong>}
          . $conf->{LOGFILE}
          . "</strong></li>\n";
          $html .=
            q{<li><span class="code">HTML_LOGDIR:</span>&nbsp;<strong>}
          . $conf->{HTML_LOGDIR}
          . "</strong></li>\n";
          $html .=
            q{<li><span class="code">LOGLEVEL:</span>&nbsp;<strong>}
          . $conf->{LOGLEVEL}
          . "</strong></li>\n";
          $html .= "</ul>\n";
          $html .= "<hr>\n";
          $html .= "<h3>Bedrock Log Tail</h3>\n";
          $html .=
          q{<pre class="codeframe" style="height:150px; width:600px;">} . "\n";

          my $fd = IO::File->new( $logfile, "r" );
          my $pos = ( -s $fd > 4000 ) ? -s $fd - 4000 : 0;

          $fd->setpos($pos);
          while (<$fd>) {
            $html .= Text::URLEncode::Htmlencode($_);
          }
          $html .= "</pre>\n";
          $fd->close;
        }
      }

      $html .= <<eot;
</body>
</html>
eot
      print $html;

      return OK;
    }
  }

  $PWD = &fastcwd unless defined($PWD);

  local ( $SIG{__DIE__}, $SIG{__WARN__} );

  my $controller;
  my $page;

  unless ( $file || $html ) {
    $controller = $conf->{framework};

    unless ($controller) {
      &error(
	     $r,
	     sprintf(
		     "[%s]: no framework object defined in 'tagx_apps.xml' for this directory.",
		     (caller(0))[3]
		    )
	    );
      return NOT_FOUND;
    }

    # set some defaults
    $controller->{meta} = { 'http-equiv' => [
                                    { 'http-equiv' => "Content-Type",
                                      content => "text/html; charset=iso-8859-1"
                                    }
                            ]
                          }
    unless $controller->{meta};
    $page = $ctx->getInputValue("page") || $controller->{pages}->{default};
    $page = $controller->{pages}->{default} if $page eq "default";
    $controller->{title} = ucfirst($page) unless $controller->{title};
  }

  # Shove the URI params in environment.
  local ( $ENV{'BEDROCK_URI'} ) = $r->uri;
  $uri_dir =~ s!/$!!;
  local ( $ENV{'BEDROCK_URIDIR'} )  = $uri_dir;
  local ( $ENV{'BEDROCK_URINAME'} ) = $uri_name;

  # Parse the file components
  my $app_dir;
  my ( $file_name, $file_dir );

  ( $file_name, $file_dir ) = &fileparse( $r->filename ) if $file;

  # And the file params too.
  local ( $ENV{'BEDROCK_FILE'} )            = $r->filename;
  local ( $ENV{'BEDROCK_FILEDIR'} )         = $file_dir;
  local ( $ENV{'BEDROCK_FILENAME'} )        = $file_name;
  local ( $ENV{'BEDROCK_INCLUDE_DIR'} )     = $conf->{INCLUDE_DIR};
  local ( $ENV{'BEDROCK_PEBBLE_DIR'} )      = $conf->{BEDROCK_PEBBLE_DIR};
  local ( $ENV{'PEBBLE_DIR'} )              = $conf->{PEBBLE_DIR};
  local ( $ENV{'BEDROCK_SESSION_DIR'} )     = $conf->{SESSION_DIR};
  local ( $ENV{'BEDROCK_CONFIG_PATH'} ) =
     $conf->{BEDROCK_CONFIG_PATH}
  || $conf->{CONFIG_PATH}
  || $ENV{CONFIG_PATH};
  local ( $ENV{'BEDROCK_LOG_DIR'} )      = $conf->{LOGDIR};
  local ( $ENV{'BEDROCK_HTML_LOG_DIR'} ) = $conf->{HTML_LOGDIR};
  local ( $ENV{'BEDROCK_LOG_FILE'} )     = $conf->{LOGFILE};
  local ( $ENV{'BEDROCK_IMAGE_DIR'} )    = $conf->{BEDROCK_IMAGE_DIR};
  local ( $ENV{'BEDROCK_IMAGE_URL'} )    = $conf->{BEDROCK_IMAGE_URL};

# - if file is null, then this is probably Bedrock Framework since $ENV{PATH_TRANSLATED} refers to a directory
  $app_dir = $file ? $file_dir : $ENV{PATH_TRANSLATED};

  unless ($html) {
    unless ( chdir $app_dir ) {
      return &error( $r, sprintf("[%s] chdir($app_dir) failed: [%s]", (caller(0))[3], $!) );
    }
  }

# - either we'll be implementing Bedrock Framework or just serving a .roc[k] file
  my $tx;
  my $html_fd;

  if ( $controller ) {
    $r && $r->log->debug( sprintf(
				  "[%s]: Bedrock framework found in 'tagx_apps.xml'" .
				  " assuming this is a framework application ;-)", 
				  (caller(0))[3]
				 )
			);

    unless ( $controller->{pages} ) {
      return
	&error( $r,
		sprintf("[%s]: misconfigured Bedrock framework - no 'pages' object found!", (caller(0))[3])
	      );
    }

    unless ($page) {
      &error(
	     $r,
	     sprintf("[%s]: no page specified or no default 'page' set in Bedrock framework.", (caller(0))[3])
	    );
    }

    my $action = $ctx->getInputValue("action") || "default";

    $r && $r->log->debug(
			 sprintf( 
				 "[%s]: bedrock framework page: [%s] action: [%s]",
				 (caller(0))[3],
				 $page, 
				 $action
				)
			);

    my $page_def = $controller->{pages}->{$page};

    unless ($page_def) {

      $r && $r->log->warn(
			  sprintf(
				  "[%s]: no Bedrock framework definition for [%s] using defaults.",
				  (caller(0))[3],
				  $page
				 )
			 );

      $html =<<end_of_html;
<html>
<head>
<title>Bedrock Framework</title>
</head>

<body>
<b>Bedrock framework:</b> Page Under Construction - no controller for '$page'
</body>

</html>
end_of_html

    }
    else {
      $html .= "<html>\n" . build_head_section( $controller, $page );
      $html .= build_body_tag( $controller, $page );
      $html .= build_body_section( $controller, $page, $action );

# - an optional page footer which can be defined by page or application globally
      my $footer = $page_def->{footer} || $controller->{footer};
      $html .= include( page_name($footer) ) if $footer;
      $html .= "</body>\n</html>\n";
    }

    # once a page is loaded, the page becomes the current page and
    # the action is set to NULL, if the developer needs to know how
    # they got here they can use the 'referrer' and 'referrer_action'
    # CGI vars
    #
    # Note: setting the $ctx->input object as done below is
    # valid at this point ONLY because $ctx->getInputValue was invoked
    # at least once before these references to $ctx->input (see
    # Bedrock::Context if you really want to see the gory details)
    #
    unless ( $action eq "default" ) {
      my @pages = split ";", $page_def->{actions}->{$action};
      my $current_page = $pages[$#pages];
      $current_page =~ s/\.inc$//;
      $ctx->input->{page}            = $current_page;
      $ctx->input->{referrer}        = $page;
      $ctx->input->{referrer_action} = $ctx->input->{action};
      $ctx->input->{action}          = undef;
    }

    $html_fd = IO::Scalar->new( \$html );
    $tx = Text::TagX->new( $html_fd, $ctx );
  }
  elsif ( $html ) {
    $html_fd = IO::Scalar->new( \$html );
    $tx = Text::TagX->new( $html_fd, $ctx );
  }
  else {
    $tx = Text::TagX->new( $file, $ctx );
  }

  #
  # Set logging parameters, let's make the default Bedrock Framework
  # log file bedrock-framework
  #
  my $default_framework_log = $uri_dir;
  $default_framework_log =~ s/\/$//;
  $default_framework_log =
  sprintf( "%s.bedrock-framework", $default_framework_log );

  my $f;

  # the default is to create HTML page logs...
  unless ( $conf->{HTML_LOG} && $conf->{HTML_LOG} !~/^y/i ) {
    $f = sprintf(
		 "%s/%s", 
		 $conf->{'HTML_LOGDIR'} || $conf->{'LOGDIR'} || '/tmp',
		 $uri_name || $default_framework_log
		);
  }

  my $sz = $conf->{'HTML_LOGMAXSIZE'} || $conf->{'LOG_MAXSIZE'} || 200000;

  $tx->options( BEDROCK_PEBBLE_DIR => $conf->{'BEDROCK_PEBBLE_DIR'},
                LOG_MAXSIZE        => $sz,
                INCLUDE_DIR        => $conf->{INCLUDE_DIR} || ".",
                LOG_PREFIX         => $f,
		LOGFORMAT          => $conf->{LOGFORMAT} || '%t [%p] [%a]: %L ',
                PEBBLE_DIR         => $conf->{'PEBBLE_DIR'},
                ALLOW_SNIPPET_TAG  => $conf->{'ALLOW_SNIPPET_TAG'}
              );

  #
  # Load Generic startup BLMs
  #
  my $modules = $conf->{'MODULES'};

  unless ( $modules ) {
    return &error( $r, sprintf(
			       "[%s]: error in config file: MODULES is not defined.",
			       (caller(0))[3]
			      )
		 );
  }

  # Custom plugins
  if ( $conf->{PLUGIN_PATH} ) {
    my @plugin_inc = split /:/, $conf->{PLUGIN_PATH};

    foreach my $path (@plugin_inc) {
      push @INC, $path
      unless grep { /$path/ } @INC;
    }
  }

  my @startup = @{$modules};
  my $i = 0;

  my %pre_bound = ( HEADER  => undef,
		    SESSION => undef
		  );

  for my $modconf (@startup) {

    unless ( defined( $modconf->{'binding'} ) ) {
      return
      &error( $r,
	      sprintf(
		      "[%s]: error in config: `binding' not defined for MODULES->[%s]",
		      (caller(0))[3],
		      $i
		     )
	    );
    }

    my $type = $modconf->{'type'} || 'hash';

    unless ( $type =~ /^(hash|array|handle|object)$/ ) {
      return &error(
		    $r,
		    sprintf(
			    "[%s]: error in config: MODULES->[%s] defined with invalid `type'($type)",
			    (caller(0))[3],
			    $i
			   )
		   );
    }
    
    # BLM specific configuration
    my $config = $modconf->{'config'};

    if ( $modconf->{'header'} =~/^y/i || $modconf->{session} =~/^y/i ) {
      my $binding = (exists $modconf->{'header'}) ? 'HEADER' : 'SESSION';
      
      # Croak if more than one module tries to become pre-bound with same name
      if ( $pre_bound{$binding} ) {
	unless ( ref($r) =~/shell/i ) {
	  return &error( $r,
			 sprintf("[%s]: error in config: Multiple modules defined: (%s, %s)",
				 (caller(0))[3],
				 $pre_bound{$binding},
				 $modconf->{'binding'}
				)
		     );
	}
	else {
	  print sprintf("[%s]: error in config: Multiple modules defined: (%s, %s)",
			(caller(0))[3],
			$pre_bound{$binding},
			$modconf->{'binding'}
		       );
	  exit -1;
	}
      }
      
      # Bind the module
      $pre_bound{$binding} = $modconf->{'binding'};

      my $obj;

      eval {
	$obj = bind_module( module  => $modconf->{'module'},
			    type    => $type,
			    context => $ctx,
			    config  => $config
			  );
      };

      if ( $@ ) {
	unless ( ref($r) =~/shell/i ) {
	  &error( $r, sprintf("[%s]: could not bind %s ($@)",
			      (caller(0))[3],
			      $pre_bound{$binding},
			      $modconf->{'binding'}
			     )
		);
	  print <<eom;
Content-type: text/html

<html>
<head>
<title>Bedrock Initialization Error</title>
</head>
<body>
<div style="color:red;">An error was encountered while trying to initialize Bedrock</div>
<pre>
$@
</pre>
</body>
</html>
eom
	  return OK;
	}
	else {
	  print sprintf("[%s]: could not bind %s ($@)",
			(caller(0))[3],
			$pre_bound{$binding},
			$modconf->{'binding'}
		       );
	  exit -1;
	}
      }

      $tx->param( $modconf->{'binding'} => $obj );
      $tx->options( $binding => $obj );

      $ctx->{$binding} = $obj;

      next;
    }

    # bind a subroutine to the names so the constructor gets
    # invoked ONLY if the variable is accessed from the script.
    $tx->param( $modconf->{'binding'},
		sub {
		  my $obj;
		  my $modfile = $modconf->{'module'};
		  $modfile =~ s!::!/!g;
		  $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
		  require $modfile;
		  
		  if ( $type eq 'hash' or $type eq 'object' ) {
		    $obj = bless {}, $modconf->{'module'};
		    tie %{$obj}, $modconf->{'module'}, $ctx, $config;
		  }
		  elsif ( $type eq 'array' ) {
		    $obj = bless [], $modconf->{'module'};
		    tie @{$obj}, $modconf->{'module'}, $ctx, $config;
		  }
		  elsif ( $type eq 'handle' ) {
		    $obj = bless gensym, $modconf->{'module'};
		    tie *{$obj}, $modconf->{'module'}, $ctx, $config;
		  }
		  
		  $obj;
		}
	      );
  }

  continue {
    $i++;
  }

  # Croak if no header module
  unless ( $pre_bound{HEADER} ) {
    return &error( $r,
		   sprintf(
			   "[%s]: error in config file: No header module",
			   (caller(0))[3]
			  )
		 );
  }

  eval { $tx->output };

  if ( $@ ) {
    if ( $ENV{SERVER_SIGNATURE} =~ /apache/i ) {

      $r && $r->log_error(
			  sprintf(
				  "[%s]: script [%s] encountered the following error:",
				  (caller(0))[3],
				  $file
				 )
			 );

      $r && $r->log_error( "$@" );

      my $error_location =  $conf->{BEDROCK_ERROR_LOCATION} ? $conf->{BEDROCK_ERROR_LOCATION} : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};

      $tx->show_error($error_location);
    }
    else {
      $r && $r->log_error( sprintf(
				   "[%s]: script [%s] encountered the following error:",
				   (caller(0))[3],
				   $file
				  )
			   );
      
      $r && $r->log_error( "$@" );
      
      # output error to STDERR
      my $line = $tx->{'error'}->line;
      my $file = $tx->{'error'}->file;
      my $source;

      if ( ref($file) ) {
        $source = tied( *{$file} );
        $line--;
        $file = $tx->pebble($file);
      }
      else {
        open FILE, "<$file";

        die "Could not open source file " . $file
        unless $file;
        {
          local $/;
          $source = <FILE>;
        }

        close FILE;
      }

      my @lines = split /\n/, $source;
      print STDERR sprintf( "Error on line [%d] (%s) - %s", $line, $file, $@ );

      # print the lines surrounding error
      print STDERR sprintf( "  [%3d] %s\n", $line - 1, $lines[ $line - 2 ] ) unless $line <= 1;
      print STDERR sprintf( ">>[%3d] %s\n", $line,     $lines[ $line - 1 ] );
      print STDERR sprintf( "  [%3d] %s\n", $line + 1, $lines[ $line ] ) unless $line == @lines;

      exit -1;
    }

  }

  chdir $PWD;

  # unfortunately since Bedrock error handling is finished now, if
  # errors occur now you will only see them in the error log
  $tx->close;

  # Apache 2 hack for redirection (mod_perl?)
  if ( $ENV{SERVER_SIGNATURE} =~ /apache/i ) {
    if ( $ENV{MOD_PERL} ) {
      if ( exists ${ $r->err_headers_out }{Location} ||
	   exists ${ $r->err_headers_out }{location} ) {
	$r->status( Apache2::Const::REDIRECT )
      }

      if ( exists ${ $r->err_headers_out }{Status} ||
	   exists ${ $r->err_headers_out }{status} ) {
	
	my $status = ${ $r->err_headers_out }{status} || ${ $r->err_headers_out }{Status};
	$r->status( $1 ) if $status =~/^\s*(\d+)/;
      }
    }
  }

  ($seconds, $microseconds) = gettimeofday();

  $r->log->info(
		 sprintf("[%s]: processing completed in %s seconds.", 
 			 (caller(0))[3],
			 ($seconds - $start_seconds) + 
			 ($microseconds - $start_microseconds)/1000000,
			)
	       );

  return $ENV{SERVER_SIGNATURE} =~ /apache/i ? OK : 0;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.71  2012/07/31 20:19:03  lauerrc
# - remove warn debug message
#
# Revision 1.70  2012/07/29 16:44:37  lauerrc
# - filter modules in get_all_modules() based on regexp
# - look for =pod or =head1 when deciding if module has pod since some modules are sloppy
#
# Revision 1.69  2012/07/18 13:39:58  lauerrc
# - if config() method CONFIG_PATH should be BEDROCK_CONFIG_PATH - we weren't checking both locations since we were pushing the same
#   directory twice
#
# Revision 1.68  2012/06/13 13:37:02  eutl420
# - we now expose some additional pod for Bedrock modules (/bedrock/system)
# - output an error page when the session object bind fails on startup instead of just giving a 500 error
# - minor typo Ctag should have been tag in show_pod() method call in the handler()
#
# Revision 1.67  2012/05/11 17:29:46  eutl420
# - check to see if the POD_PATHS object is defined first before trying to access it
#
# Revision 1.66  2012/05/09 19:27:27  eutl420
# - don't show BLM modules that are in @INC path when showing files in POD_PATHS
#
# Revision 1.65  2012/05/09 19:02:09  eutl420
# - reworked the get_all_blms(), blm_listing() methods into get_all_modules() and module_listing() methods to support user
#   documentation.  Add an array object to tagx.xml named POD_PATHS and Bedrock will add look for perl modules in these paths
#   and make their documentation available on the /bedrock/pod page.
#
# Revision 1.64  2012/05/08 16:50:42  eutl420
# - use run-time module inclusion (require IPC::Shareable) if environment variable set
#
# Revision 1.63  2012/04/13 17:09:48  eutl420
# - avoid tie of %BEDROCK_CONFIG_CACHE unless the environment variable is set, thus avoiding an unsightly error message from
#   the tie, even though it is in an eval block
#
# Revision 1.62  2012/03/05 20:28:46  eutl420
# - check for header/session=yes when pre-binding the header and session objects. Previously the code looked for existence of
#   the object 'header' only and did not test value.  Seeing 'yes' in tagx.xml might mislead someone into believing that 'no'
#   turned off the feature.  It does now...
# - trap errors when binding the session object
# - output errors to STDOUT for Bedrock shell if we can get started for some reason
#
# Revision 1.61  2012/03/05 16:33:15  eutl420
# - added new require_module, bind_module to generalize process of "pre-binding" startup BLMs
# - pre-bind 'session' manager and expose this to BLMs via the context object
#
# Revision 1.60  2012/02/27 14:33:48  eutl420
# - should not have been escaping the double quotes
#
# Revision 1.59  2012/02/24 19:31:23  eutl420
# - log messages are now in a more standard format that includes the subroutine name first
# - some log messages have been made clearer and shorter, some moved from info to debug or debug to info
# - we now try to tie the config cache shared memory variable and try to do config file cacheing
#
# Revision 1.58  2012/02/20 16:39:04  eutl420
# - BEDROCK_USER_PEBBLE_DIR changed to PEBBLE_DIR
#
# Revision 1.57  2012/02/08 19:49:41  eutl420
# - omit \? from list of tags
#
# Revision 1.56  2012/02/08 13:55:04  eutl420
# - add filters to "plugins" documentation page
#
# Revision 1.55  2012/01/17 22:45:49  eutl420
# - use BEDROCK_LOGO instead of hard-code 'bedrock.jpg'
#
# Revision 1.54  2011/12/28 16:53:01  eutl420
# - set status for mod_perl
#
# Revision 1.53  2011/11/30 18:50:54  eutl420
# - formatting, comment about error handling
#
# Revision 1.52  2011/11/28 21:43:17  eutl420
# - error in Bedrock shell was indicated on wrong line when error on line 1
#
# Revision 1.51  2011/11/16 14:37:15  eutl420
# - pass the context object the header object
#
# Revision 1.50  2011/11/14 14:16:27  eutl420
# - -compile appended to previous string by tidy
#
# Revision 1.49  2011/09/15 16:05:32  eutl420
# - perl tidy
#
# Revision 1.48  2011/09/14 18:55:20  eutl420
# - Bedrock shell errors now need to lookup pebble names if the error occurred in a pebble rather than a file
#
# Revision 1.47  2011/09/10 15:51:13  eutl420
# - use PLUGIN_PATH to find Application Plugins
#
# Revision 1.46  2011/08/24 22:34:39  eutl420
# - support for BEDROCK_ADMIN_DIR to allow for installing Bedrock without root
#   privileges for example.
#
# Revision 1.45  2011/08/18 22:00:08  eutl420
# - added support for --dns= in <sqlconnect> tag by reading dbnames.xml into config object
#
# Revision 1.44  2011/08/16 20:40:09  eutl420
# - delay looking up APP_CONFIG file until all .xmls merged to allow override
#
# Revision 1.43  2011/08/13 14:43:39  eutl420
# - look in Bedrock's config directory for startup modules (config.d/startup)
#
# Revision 1.42  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.41  2011/07/13 18:07:52  eutl420
# - collect a list of config files that are loaded so we can output the list if an error occurs
# - output a better error message for shell and web when config files are malformed
#
# Revision 1.40  2011/07/12 18:21:53  eutl420
# - report $@ in log file if an error occurs
#
# Revision 1.39  2011/07/11 18:03:23  eutl420
# - in all methods, use Apache request object for logging as $r && $r->log ...) this allows some methods
#   to be called without the ARO.  Of course, you'll get no logging, but nothing in life is free.
# - root directory "/" object form tagx_apps.xml like files was not being loaded because: split /\//, $dir is empty when
#   $dir = "/" or "" - see perldoc -f split
# - look for files in Bedrock's config.d directory (was missing .)
#
# Revision 1.38  2011/07/06 16:21:01  eutl420
# - read config files from ${BEDROCK_CONFIG_PATH}.d
# - remove ${DOCUMENT_ROOT} from start of uri-dir to support bedrock shell
#
# Revision 1.37  2011/07/05 20:34:26  eutl420
# - tagx_apps.xml style files loaded from  the framework directory should be named for the root directory for which
#   the configuration applies
# - directory level configuration info in the tagx_apps style configs cascades
#
# Revision 1.36  2011/07/05 17:54:19  eutl420
# - moved the order in which config (.xml) files are loaded so that the
#   tagx_apps.xml-ish files in the ~CONFIG/framework directory are loaded last
#   thus overriding any other values with the same keys.
#
# Revision 1.35  2011/03/30 18:05:33  eutl420
# - for shell users, show a useful error message with line number and offending
#   line of the Bedrock file
# - for shell users, return 0 not 200
#
# Revision 1.34  2011/03/29 14:16:26  eutl420
# - do not test for redirects unless running under Apache
#
# Revision 1.33  2011/03/25 17:15:29  eutl420
# - create method merge_modules() which does a true merge or the modules instead
#   of just replacing or appending
# - die if the tagx.xml file is empty
# - call merge_modules() when merging configs from config.d/startup directory
# - output error page when config problem instead of just logging message and
#   issuing a status 500
#
# Revision 1.32  2011/01/12 19:15:50  eutl420
# - use exact regexp to see if trying to reload tagx.xml
#
# Revision 1.31  2010/12/20 21:29:24  eutl420
# - closedir
# - config.d directory was not being scanned and files were not loaded properly
# - allow use of either yes or docs to ALLOW_BEDROCK_INFO
# - set CONFIG_PATH in configuration object from enviroment
#
# Revision 1.30  2010/12/18 16:31:50  eutl420
# - make sure that LOGDIR is writeable and set config if we use /tmp
#
# Revision 1.29  2010/12/17 21:31:56  eutl420
# - $conf =
#
# Revision 1.28  2010/12/17 18:59:40  eutl420
# - use $path not $_ in loop
#
# Revision 1.27  2010/12/17 18:52:35  eutl420
# - exclude tagx_apps from list of files to look for
#
# Revision 1.26  2010/12/17 16:52:51  eutl420
# - remove the BLM::Startup/BLM:: from plugin titles on the Bedrock doc pages
# - move the implementation of config.d merging into this module since it
#   really is a Bedrock system behavior that is independent of config file
#   reading and processing.  Now any .xml file on the config directory is
#   merged with the config object and one can override the default
#   tagx.xml configuration settings using REPLACE_CONFIG in tagx.xml
#
# Revision 1.25  2010/12/12 21:27:44  eutl420
# - added Apache log modules
#
# Revision 1.24  2010/12/12 17:14:00  eutl420
# - use Bedrock::Text::URLEncode
#
# Revision 1.23  2010/12/06 14:14:43  rlauer
# - use BEDROCK_IMAGE_URL primarily, deprecate IMAGE_URL
# - status page changes
#   + prettification
#   + log configuration checking and display
#   + bedrock.log dump of tail
#
# Revision 1.22  2010/11/23 00:06:12  rlauer
# - use BEDROCK_POD_CSS_URL instead of POD_CSS_URL
#
# Revision 1.21  2010/11/16 00:20:12  rlauer
# - add BUILD_DATE to header of documentation
#
# Revision 1.20  2010/11/15 02:08:27  rlauer
# - prevent non-PUBLIC BLMs from being shown in Plugin listing
#
# Revision 1.19  2010/11/14 21:11:21  rlauer
# - removed 'exec' from the list of hidden tags - ok to get docs on this
#   as the docs indicate that it is deprecated in favor of <pebble>
#
# Revision 1.18  2010/11/08 03:20:02  rlauer
# - added subroutine show_pod, add <img> tag to plugin/tag documentation
# - pass ALLOW_SNIPPET_TAG in option hash to TagX
#
# Revision 1.17  2010/10/30 21:45:51  rlauer
# - deprecate ERROR_LOCATION (relative to document root), in favor of
#   BEDROCK_ERROR_LOCATION which is an absolute path
#
# Revision 1.16  2010/06/24 21:36:25  rlauer
# rename the Bedrock/Config.pm file to Bedrock/BedrockConfig.pm to avoid Config.pm conflict
#
# Revision 1.15  2009/12/31 18:33:53  rlauer
# exclude blm from tag listing
#
# Revision 1.14  2009/12/30 00:19:01  rlauer
# split up plugins/application plugins, stream pod to disk first before displaying
#
# Revision 1.13  2009/12/28 23:31:31  rlauer
# fixed pod2html call to use temp file so removed comment, use plugins, not BLM
#
# Revision 1.12  2009/12/28 19:29:48  rlauer
# removing traces of BLM, replacing with plugin moniker
#
# Revision 1.11  2009/12/26 15:38:38  rlauer
# remove BLM::OrderedObject, all objects now ordered
#
# Revision 1.10  2009/01/14 13:38:15  rlauer
# - use Apache2::Const for return status
#
# Revision 1.9  2009/01/13 20:16:29  rlauer
# - hack to make sure internal redirects work under mod_perl/Apache2
#
# Revision 1.8  2008/12/02 15:14:51  rlauer
# $doc incorrectly assigned to re-initialized $1
#
# Revision 1.7  2008/11/26 19:25:38  rlauer
# return FORBIDDEN if ALLOW_BEDROCK_INFO ne yes
#
# Revision 1.6  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.5  2008/02/28 18:14:38  rlauer
# Applying Rob's patches to make Bedrock work on Apache 2.x
# (plus a few other obvious bug fixes).
#
# Revision 1.4  2001/02/14 15:35:42  sridhar
# Added copyright and GPL notice
#
# Revision 1.3  2000/12/18 18:05:01  sridhar
# Using Bedrock::Context instead of SIS::Base
#
# Revision 1.2  2000/12/15 16:22:26  sridhar
# Kicked out BLM::Startup::Modules -- all modules are `require'ed rather
# than `use'd for faster startup.
#
# Revision 1.1  2000/12/12 18:58:56  sridhar
# 1. Bedrock.pm, the main bedrock request handler now lives inside
# Bedrock
# 2. Same handler is used by the bedrock CGI too, by just mimicking the
# apache request handler object
# 3. Not using Apache::Constants since this module will now be used by
# the CGI too. Have the required constants hardcoded instead.
# 4. SIS::Base::Apache no longer used. Replaced by SIS::Base.
#
# Revision 1.13  2000/11/29 20:49:55  sridhar
# Can specify PEBBLE_DIR in the config
#
# Revision 1.12  2000/11/16 20:14:10  sridhar
# 1. chdir's to script directory and changes back on return from
# handler.
# 2. Uses `fastcwd' to find current dir for changing back.
# 3. Have a generic `error' function which changes back dir on return.
# 4. If script has an error, invokes `$tx->show_error()' with an error
# page.
#
# Revision 1.11  2000/11/13 14:51:50  sridhar
# Kicked out config cacheing till things stabilize a bit.
#
# Revision 1.10  2000/11/07 21:26:29  sridhar
# 1. Load configuration from disk for every request only if `RELOAD' set
# to `yes'
# 2. Defines a bunch of environment vars `BEDROCK_*' to contain the
# current script name, file, dir, etc.
# 3. Log message includes PID
#
# Revision 1.9  2000/11/07 14:16:51  sridhar
# 1. Major changes implementing directory-specific configuration, including
# Startup modules per directory.
# 2. Module takes care of loading config file `tagx.cfg' and creating
# the config object for each request based on the request directory, and
# merging the startup module list for each directory with the site-wide
# startup module list
# 3. Creates a subroutine for as the binding for each startup object
# which gets invoked for constructing the object only if needed. So one
# could have 100 startup modules for a directory, but use only 3 of them
# in a script; the other 97 wouldn't be constructed at all. All this
# magic happens behind the scenes so nobody is any the wiser.
#
# Revision 1.8  2000/11/01 21:02:17  sridhar
# Using XML file for Configuration
#
# Revision 1.7  2000/08/11 17:56:47  sridhar
# Catch unhandled exceptions and log an error.
#
# Revision 1.6  2000/07/19 19:41:59  sridhar
# Using BLM::Startup::Modules instead of BLM::Modules since dynamic BLMs
# no longer need to be pre-declared.
#
# Revision 1.5  2000/07/11 20:58:50  sridhar
# Localized $SIG{__DIE__} and __WARN__ so that state is restored on exit
# from handler.
#
# Revision 1.4  2000/07/06 18:36:15  sridhar
# Pass the SIS::Base::Apache object directly as the output handle to
# TagX since all necessary methods are supported in it (done for uniform
# header handling between mod_perl and CGI environments).
#
# Revision 1.3  2000/07/06 17:23:09  sridhar
# 1. MODULES config variable is now expected to have startup modules
# under MODULES->STARTUP.
# 2. MODULES->HEADER can be the name of a startup module object which
# generates HTTP headers.
#
# Revision 1.2  2000/06/15 19:35:29  sridhar
# New version with support for BLMs
#
# Revision 1.1  2000/06/07 19:53:41  sridhar
# Added mod_perl module for bedrock
#
#
