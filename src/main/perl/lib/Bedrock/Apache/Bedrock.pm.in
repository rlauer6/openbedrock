package Apache::Bedrock;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

BEGIN {
  if ( defined $ENV{MOD_PERL} ) {
    require Apache2::compat;
  }
}

use Apache2::Const -compile => qw(
  HTTP_UNSUPPORTED_MEDIA_TYPE
  HTTP_UNAUTHORIZED
  NOT_FOUND
  OK
  SERVER_ERROR
  FORBIDDEN
  DECLINED REDIRECT :log
);

use Apache2::Log;

use APR::Const -compile => qw(:error SUCCESS);

#
# Define the following mod_perl constants since we could be using
# this module both as a mod_perl module and in a CGI
#
use constant {  ## no critic (ValuesAndExpressions::ProhibitConstantPragma)
  NOT_FOUND    => Apache2::Const::NOT_FOUND,
  SERVER_ERROR => Apache2::Const::SERVER_ERROR,
  FORBIDDEN    => Apache2::Const::FORBIDDEN,
  OK           => Apache2::Const::OK,
  DECLINED     => Apache2::Const::DECLINED,
  REDIRECT     => Apache2::Const::REDIRECT,
  UNSUPPORTED  => Apache2::Const::HTTP_UNSUPPORTED_MEDIA_TYPE,
  EMPTY        => q{},
  SLASH        => q{/},
};

use Bedrock;
use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::Hash;
use Bedrock::Log;
use Bedrock::VERSION;
use bedrock_handler_common;

use Text::TagX;
use Text::URLEncode;

use Benchmark qw/:all/;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Spec;
use File::Temp;
use IO::File;
use IO::Scalar;
use List::Util qw{ any };
use Log::Log4perl;
use Symbol;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)

{
  my $logger;

  # try to initialize Log::Log4perl
  foreach my $path ( $ENV{CONFIG_PATH}, $ENV{BEDROCK_CONFIG_PATH} ) {
    next if !$path;

    my $conf = "$path/log4perl.conf";

    if ( -e $conf ) {
      $logger = eval { Log::Log4perl->init_once($conf); };
    }

    last if $EVAL_ERROR || $logger;
  } ## end foreach my $path ( $ENV{CONFIG_PATH...})

  if ( !$logger && $EVAL_ERROR ) {
    print {*STDERR} "ERROR: [$EVAL_ERROR]\n";

    my $log4perl_conf = <<'EOT';
log4perl.rootLogger=DEBUG, Bedrock
log4perl.appender.Bedrock=Log::Log4perl::Appender::Screen
log4perl.appender.Bedrock.mode=append
log4perl.appender.Bedrock.layout=PatternLayout
log4perl.appender.Bedrock.layout.ConversionPattern=%d (%r) (%p) [%P] [%l] %c - %m%n
EOT
    Log::Log4perl->init( \$log4perl_conf );
  } ## end if ( !$logger && $EVAL_ERROR)
}

########################################################################
sub require_module {
########################################################################
  my ($modfile) = @_;

  $modfile =~ s/::/\//xsmg;

  if ( $modfile !~ /[.]pm\z/xsm ) {
    $modfile =~ s/\z/\.pm/xsm;
  }

  return require $modfile;
} ## end sub require_module

########################################################################
sub bind_module {
########################################################################
  my (%args) = @_;

  require_module $args{module};

  my $obj;

  ## no critic (Miscellanea::ProhibitTies)
  if ( $args{type} eq 'hash' or $args{type} eq 'object' ) {
    $obj = bless {}, $args{module};
    tie %{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'array' ) {
    $obj = bless [], $args{module};
    tie @{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'handle' ) {
    $obj = bless gensym, $args{module};
    tie *{$obj}, $args{module}, $args{context}, $args{config};
  }

  my $func = tied %{$obj};

  $func->can('init_plugin')
    && $func->init_plugin( $args{context}, $args{config} );

  return $obj;
} ## end sub bind_module

########################################################################
sub is_bedrock_shell {
########################################################################
  my ($ref) = @_;

  return Scalar::Util::blessed($ref) eq 'Apache::Request_shell';
} ## end sub is_bedrock_shell

########################################################################
sub is_mod_perl {
########################################################################
  return defined $ENV{MOD_PERL};
}

# +---------------------+
# | HANDLER STARTS HERE |
# +---------------------+

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # start HiRes timer
  my $t0;

  if ( get_loglevel($r) eq 'debug' ) {
    $t0 = Benchmark->new;
  }

  my $bedrock_handler = init_bedrock_handler($r);

  # errors are handled in the init_bedrock_handler() subroutine
  return OK if !$bedrock_handler;

  # get the Bedrock config object
  my $conf = $bedrock_handler->config;

  # make sure that the LOG directories are present and writable, otherwise try /tmp
  foreach my $k (qw{LOGDIR HTML_LOGDIR}) {
    my $dir = $conf->{$k};

    if ( -d $dir && !-w $dir ) {
      $bedrock_handler->log_error("$dir is not writeable, using /tmp");
      $conf->{$k} = '/tmp';
    }
    elsif ( !-d $dir ) {
      eval { return mkdir $dir };

      if ($EVAL_ERROR) {
        $bedrock_handler->log_error(
          "could not create $dir:[$OS_ERROR] - using [/tmp]");
        $conf->{$k} = '/tmp';
      }
    } ## end elsif ( !-d $dir )
  } ## end foreach my $k (qw{LOGDIR HTML_LOGDIR})

  $bedrock_handler->log_info(
    sprintf 'Bedrock log directory is ..........[%s]',
    $conf->{LOGDIR} );

  $bedrock_handler->log_info(
    sprintf q{Bedrock's HTML log directory is ...[%s]},
    $conf->{HTML_LOGDIR} );

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;  # typically /bedrock

  my $file = $bedrock_handler->{file};

  if ($file) {

    # check mime-type
    if ( $r->content_type !~ /text\/html|application\/json|text\/plain/xsm ) {
      $bedrock_handler->error( sprintf 'content type: [%s] not supported',
        $r->content_type );

      return UNSUPPORTED;
    } ## end if ( $r->content_type ...)

    if ( !-e $r->filename ) {
      $bedrock_handler->error( sprintf 'file does not exist: [%s]', $file );

      return NOT_FOUND;
    }

    if ( !-r $r->filename ) {
      $bedrock_handler->error( sprintf 'file permissions deny access: [%s]',
        $file );

      return FORBIDDEN;
    } ## end if ( !-r $r->filename )
  } ## end if ($file)
  else {
    $bedrock_handler->error( sprintf 'attempt to serve directory: [%s]',
      $r->uri );

    return FORBIDDEN;
  } ## end else [ if ($file) ]

  local $SIG{__DIE__}  = undef;
  local $SIG{__WARN__} = undef;

  # Shove the URI params in environment.
  local $ENV{'BEDROCK_URI'}     = $r->uri;
  local $ENV{'BEDROCK_URIDIR'}  = $bedrock_handler->{uri_dir};
  local $ENV{'BEDROCK_URINAME'} = $bedrock_handler->{uri_name};

  # And the file params too.
  local $ENV{'BEDROCK_FILE'}     = $r->filename;
  local $ENV{'BEDROCK_FILEDIR'}  = $bedrock_handler->{path};
  local $ENV{'BEDROCK_FILENAME'} = $bedrock_handler->{filename};

  # TODO: cleanup this mess...scour code and use consistent
  # environment variables and configuration values with BEDROCK prefix
  local ( $ENV{'BEDROCK_INCLUDE_DIR'} )
    = $ENV{BEDROCK_INCLUDE_DIR} || $conf->{INCLUDE_DIR};
  local ( $ENV{'BEDROCK_PEBBLE_DIR'} )
    = $ENV{BEDROCK_PEBBLE_DIR} || $conf->{BEDROCK_PEBBLE_DIR};
  local ( $ENV{'PEBBLE_DIR'} ) = $ENV{PEBBLE_DIR} || $conf->{PEBBLE_DIR};
  local ( $ENV{'BEDROCK_SESSION_DIR'} )
    = $ENV{BEDROCK_SESSION_DIR} || $conf->{SESSION_DIR};
  local ( $ENV{'BEDROCK_CONFIG_PATH'} )
    = $ENV{BEDROCK_CONFIG_PATH}
    || $conf->{BEDROCK_CONFIG_PATH}
    || $conf->{CONFIG_PATH}
    || $ENV{CONFIG_PATH};
  local ( $ENV{'BEDROCK_LOG_DIR'} )
    = $ENV{BEDROCK_LOG_DIR} || $conf->{LOGDIR};
  local ( $ENV{'BEDROCK_HTML_LOG_DIR'} )
    = $ENV{BEDROCK_HTML_LOG_DIR} || $conf->{HTML_LOGDIR};
  local ( $ENV{'BEDROCK_LOG_FILE'} )
    = $ENV{BEDROCK_LOG_FILE} || $conf->{LOGFILE};
  local ( $ENV{'BEDROCK_IMAGE_DIR'} )
    = $ENV{BEDROCK_IMAGE_DIR} || $conf->{BEDROCK_IMAGE_DIR};
  local ( $ENV{'BEDROCK_IMAGE_URL'} )
    = $ENV{BEDROCK_IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  my $app_dir = $bedrock_handler->{path};

  if ( !chdir $app_dir ) {
    return $bedrock_handler->error( sprintf 'chdir(%s) failed: [%s]',
      $app_dir, $OS_ERROR );
  }

  my $ctx
    = Bedrock::Context->new( 'APACHE_HANDLER' => $r, 'CONFIG' => $conf );

  my $tx = Text::TagX->new( $file, $ctx );

  # -- setup logging

  # TODO: this is an example of TODO above...
  # use BEDROCK_HTML_LOGFILE...BEDROCK_HTML_LOG_DIR from %ENV now or we
  # always take values from the configuration object
  my $page_log;
  my $html_logdir = $conf->{HTML_LOGDIR} || '/tmp';

  # if we have HTML_LOGFILE, then we log each page separately
  if ( $conf->{HTML_LOGFILE} ) {
    $page_log = $conf->{HTML_LOGFILE};
  }
  else {
    $page_log = $bedrock_handler->{filename};
    $page_log =~ s/[.](.*)\z//xsm;
  }

  # not sure this should ever happen, however if we've parsed the
  # URI incorrectly (Bedrock CGI mainly) then let's do some belt &
  # suspenders mitigation...
  if ( !$page_log ) {
    $page_log = 'bedrock-page-' . time;
  }

  if ( $page_log ne 'STDERR' ) {
    $page_log = $html_logdir . q{/} . $page_log;
  }

  # the TagX::Log start_logger() method redirects STDERR to the page
  # log after this call has been executed
  $tx->options(
    BEDROCK_PEBBLE_DIR => $ENV{BEDROCK_PEBBLE_DIR},
    INCLUDE_DIR        => $ENV{BEDROCK_INCLUDE_DIR},
    PEBBLE_DIR         => $ENV{BEDROCK_PEBBLE_DIR},
    ALLOW_SNIPPET_TAG  => $conf->{ALLOW_SNIPPET_TAG},
    LOGFORMAT          => $conf->{LOGFORMAT}       || '%t [%p] [%a]: %L ',
    LOG_MAXSIZE        => $conf->{HTML_LOGMAXSIZE} || $conf->{'LOG_MAXSIZE'},
    LOG_SPOOLER        => $conf->{HTML_LOGSPOOLER},
    LOG_PREFIX         => $page_log,
  );

  if ( get_loglevel($r) eq 'debug' ) {
    {
      $bedrock_handler->log_debug( sprintf 'HTML_LOGDIR.......[%s]',
        $conf->{HTML_LOGDIR} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'HTML_LOGFILE......[%s]',
        $conf->{HTML_LOGFILE} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'INCLUDE_DIR.......[%s]',
        $conf->{INCLUDE_DIR} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'PEBBLE_DIR........[%s]',
        $conf->{PEBBLE_DIR} // EMPTY );
      $bedrock_handler->log_debug(
        sprintf 'ALLOW_SNIPPET_TAG.[%s]',
        $conf->{ALLOW_SNIPPET_TAG} // EMPTY
      );
      $bedrock_handler->log_debug( sprintf 'LOGFORMAT.........[%s]',
        $conf->{LOGFORMAT} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'LOG_MAXSIZE.......[%s]',
        $conf->{LOG_MAXSIZE} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'LOG_SPOOLER.......[%s]',
        $conf->{LOG_SPOOLER} // EMPTY );
      $bedrock_handler->log_debug( sprintf 'LOG_PREFIX........[%s]',
        $conf->{LOG_PREFIX} // EMPTY );
    }
  } ## end if ( get_loglevel($r) ...)

  # load generic startup BLMs
  my $modules = $conf->get_module_config();

  if ( !$modules ) {
    return $bedrock_handler->error(
      'error in config file: MODULES is not defined.');
  }

  # custom plugins
  if ( exists $conf->{PLUGIN_PATH} && defined $conf->{PLUGIN_PATH} ) {
    my @plugin_inc = split /:/xsm, $conf->{PLUGIN_PATH};

    foreach my $path (@plugin_inc) {
      if ( !any {/$path/xsm} @INC ) {
        push @INC, $path;
      }
    }
  } ## end if ( exists $conf->{PLUGIN_PATH...})

  # this simply allows us to record if we have encountered a HEADER or
  # SESSION module yet in order to avoid loading duplicate copies of
  # these
  my %pre_bound = ( HEADER => undef, SESSION => undef );

  my @startup = @{$modules};

  foreach my $idx ( 0 .. $#startup ) {
    my $modconf = $startup[$idx];

    my ( $config, $binding, $module, $header, $session, $type,
      $abort_if_error )
      = @{$modconf}
      {qw/config binding module header session type abort_if_error/};

    $type = $type || 'hash';

    if ( !$binding ) {
      return $bedrock_handler->error(
        sprintf q{'binding' not defined for module (%s)}, $idx );
    }

    if ( !any {/$type/xsm} qw{ hash array handle object} ) {
      return $bedrock_handler->error(
        sprintf 'invalid type (%s) in module (%s)',
        $type, $idx );
    }

    # BLM specific configuration
    # <scalar name="header"></scalar>
    if ( $header || $session ) {

      # must be either header or session
      my $pre_bound_module = $header ? 'HEADER' : 'SESSION';

      # Croak if more than one module tries to become pre-bound with same name
      if ( $pre_bound{$pre_bound_module} ) {
        my $errstr = "multiple modules defined for $pre_bound_module module";

        if ( is_bedrock_shell($r) ) {
          print {*STDERR} $errstr;
          exit -1;
        }
        else {
          return $bedrock_handler->error($errstr);
        }
      } ## end if ( $pre_bound{$pre_bound_module...})

      # Bind the module
      $pre_bound{$pre_bound_module} = $pre_bound_module;

      my $obj = eval {
        bind_module(
          module  => $module,
          type    => $type,
          context => $ctx,
          config  => $config
        );
      };

      my $bind_error = $EVAL_ERROR;
      my $errstr;

      if ($bind_error) {

        $errstr = sprintf q{could not bind module (%s) as '%s'}, $module,
          $binding;

        $bedrock_handler->log_error($errstr);
        $bedrock_handler->log_error($bind_error);

        if ($abort_if_error) {

          if ( is_bedrock_shell($r) ) {
            print {*STDERR} $errstr;

            exit -1;
          }
          else {
            $r->content_type('text/html');
            $r->send_http_header;

            print <<"EOM";
<html>
<head>
<title>Bedrock Initialization Error</title>
</head>
<body>
<div style="color:red;">An error was encountered while trying to initialize Bedrock</div>
<pre>
$errstr
----
<p>$bind_error</p>
</pre>
</body>
</html>
EOM
            return OK;
          } ## end else [ if ( is_bedrock_shell(...))]
        } ## end if ($abort_if_error)
      } ## end if ($bind_error)

      if ($obj) {

        # add the object to Bedrock' top frame (symbol table)
        $tx->param( $binding => $obj );

        # tagX wants to know who the header and session object are
        $tx->options( $pre_bound_module => $obj );

        # ...so does the context object which can be used by Bedrock::CGI
        $ctx->{$pre_bound_module} = $obj;
      } ## end if ($obj)
      else {
        $tx->param( 'error' => $bind_error );
      }
    } ## end if ( $header || $session)
    else {
      $tx->param(
        $binding,
        sub {
          require_module($module);

          return bind_module(
            type    => $type,
            module  => $module,
            context => $ctx,
            config  => $config
          );

        }
      );
    } ## end else [ if ( $header || $session)]
  } ## end foreach my $idx ( 0 .. $#startup)

  # Croak if no header module
  if ( !$pre_bound{HEADER} ) {
    return $bedrock_handler->error(
      sprintf 'error in config file: No header module' );
  }

  $tx->param( '_version' => '@VERSION@-@BEDROCK_RELEASE@' );  ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)

  # this is where Bedrock starts parsing the template
  eval { $tx->output };

  my $err = $EVAL_ERROR;

  if ($err) {
    if ( is_bedrock_shell($r) ) {

      # output error to STDERR
      my $line = $tx->{'error'}->line;
      my $file = $tx->{'error'}->file;
      my $source;

      if ( ref $file ) {
        $source = tied *{$file};
        $line--;
        $file = $tx->pebble($file);
      }

      open my $fh, '<', $file
        or die 'Could not open source file ' . $file;  ## no critic (ErrorHandling::RequireCarping)

      {
        local $RS = undef;
        $source = <$fh>;
      }

      close $fh;

      my @lines;

      {
        require IO::Scalar;

        my $fd = IO::Scalar->new( \$source );

        while ( defined( $_ = $fd->getline ) ) {
          chomp;
          push @lines, $_;
        }

        $fd->close;
      }

      if ( $err !~ /\Asnippet/xsm ) {
        $r->log_error( sprintf 'Error on line [%d] (%s) - %s',
          $line, $file, $err );

        # print the lines surrounding error
        if ( $line > 1 ) {
          $r->log_error( sprintf "  [%3d] %s\n",
            $line - 1, $lines[ $line - 2 ] );
        }

        $r->log_error( sprintf ">>[%3d] %s\n", $line, $lines[ $line - 1 ] );

        if ( $line != @lines ) {
          $r->log_error( sprintf "  [%3d] %s\n", $line + 1, $lines[$line] );
        }
      } ## end if ( $err !~ /\Asnippet/xsm)
      else {
        $r->log_error("$err");
      }
    } ## end if ( is_bedrock_shell(...))
    else {
      $bedrock_handler->log_error(
        sprintf
          'script [%s] with mime-type [%s] encountered the following error:',
        $bedrock_handler->{file}, $r->content_type
      );

      $bedrock_handler->log_error("$err");

      my $error_location
        = $conf->{BEDROCK_ERROR_LOCATION}
        ? $conf->{BEDROCK_ERROR_LOCATION}
        : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};

      # if we are serving up JSON content, then we need to return a
      # proper error code, not 200
      if ( $r->content_type =~ /json/xsm ) {
        $bedrock_handler->restore_dir;

        if ( is_mod_perl() ) {
          $r->status(SERVER_ERROR);
        }
        else {
          $r->content_type('application/json');
          $r->cgi_header_out( 'Status', '500' );
          $r->send_http_header;
        }

        chomp $err;

        print <<"EOM";
{ error : "$err" }
EOM
        return OK;
      } ## end if ( $r->content_type ...)
      else {
        $tx->show_error($error_location);
      }
    } ## end else [ if ( is_bedrock_shell(...))]
  } ## end if ($err)

  $bedrock_handler->restore_dir;

  # unfortunately since Bedrock error handling is finished now, if
  # errors occur now you will only see them in the error log
  $tx->close;

  # Apache 2 hack for redirection...let's not send unnecessary content
  # to the browser if a redirect header has been set.
  if ( !is_bedrock_shell($r) ) {

    if ( is_mod_perl() ) {

      if ( exists ${ $r->err_headers_out }{Location}
        || exists ${ $r->err_headers_out }{location} ) {
        $r->status(Apache2::Const::REDIRECT);
      }

      if ( exists ${ $r->err_headers_out }{Status}
        || exists ${ $r->err_headers_out }{status} ) {

        my $status = ${ $r->err_headers_out }{status}
          || ${ $r->err_headers_out }{Status};

        if ( $status =~ /\A\s*(\d+)/xsm ) {
          $r->status($1);
        }
      } ## end if ( exists ${ $r->err_headers_out...})
    } ## end if ( is_mod_perl() )
  } ## end if ( !is_bedrock_shell...)

  # benchmark
  my $t1 = Benchmark->new;

  if ( get_loglevel($r) eq 'debug' ) {

    $bedrock_handler->log_debug( 'log level ' . get_loglevel($r) );

    $bedrock_handler->log_debug(
      'processing complete: ' . timestr( timediff( $t1, $t0 ), 'all' ) );
  } ## end if ( get_loglevel($r) ...)

  return OK;
} ## end sub handler

1;

__END__

=pod

=head1 NAME

Apache::Bedrock - Apache handler for serving Bedrock pages

=head1 SYNOPSIS

 <IfModule mod_perl.c>
   PerlRequire /usr/lib/bedrock/config/startup.pl
   AddHandler    perl-script .roc .jroc
   PerlHandler   Apache::Bedrock
 </IfModule>

 use Apache::Bedrock;

 Apache::Bedrock::handler->new( Apache::Request_cgi->new );

 Apache::Bedrock::handler->new( Apache::Request_shell->new );

I<See F<bedrock.cgi> or F<bedrock.pl> if you want to see how this module
can be used stand alone.>

=head1 DESCRIPTION

Handler for parsing Bedrock files.  Can be used with Apache as a
C<mod_perl> handler or in other configurations including a shell
interpreter.

=head1 METHODS AND SUBROUTINES

=head2 require_module

Parse a module name and 'require' it.  Used to load BLMs.

=head2 bind_module

Binds a Bedrock variable to a loadable module.

=head2 is_bedrock_shell

Returns true if running as bedrock shell.

=head2 is_mod_perl

Returns true if running under mod_perl.

=head1 AUTHOR

Jay Sridhar
Rob Lauer - <rlauer6@comcast.net>

=cut
