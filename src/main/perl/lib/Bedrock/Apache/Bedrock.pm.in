package Apache::Bedrock;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock qw{slurp_file};

use Bedrock::Apache::Constants qw{:http};
use Bedrock::BedrockConfig;
use Bedrock::Constants qw{:chars :defaults};
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::Hash;
use Bedrock::Log;
use Bedrock::VERSION;
use bedrock_handler_common;

use Text::TagX;
use Text::URLEncode;

use Benchmark qw/:all/;
use Data::Dumper;
use English qw{-no_match_vars};
use File::Basename;
use File::Spec;
use File::Temp;
use IO::File;
use IO::Scalar;
use List::Util qw{ any uniq };

use Role::Tiny::With;
with 'Bedrock::Logger';

use Symbol;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  my $t0 = Benchmark->new;

  my $bedrock_handler = init_bedrock_handler($r);

  # errors are handled in the init_bedrock_handler() subroutine
  return $OK if !$bedrock_handler;

  # get the Bedrock config object
  my $conf = $bedrock_handler->config;

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;  # typically /bedrock

  my $file = $bedrock_handler->{file};

  if ($file) {

    # check mime-type
    if ( $r->content_type !~ /text\/html|application\/json|text\/plain/xsm ) {
      $r->log->error( sprintf 'content type: [%s] not supported',
        $r->content_type );

      return $UNSUPPORTED;
    }

    if ( !-e $r->filename ) {
      $r->log->error( sprintf 'file does not exist: [%s]', $file );

      return $NOT_FOUND;
    }

    if ( !-r $r->filename ) {
      $r->log->error( sprintf 'file permissions deny access: [%s]', $file );

      return $FORBIDDEN;
    }
  }
  else {
    $r->log->error( sprintf 'attempt to serve directory: [%s]', $r->uri );

    return $FORBIDDEN;
  }

  local $SIG{__DIE__}  = undef;
  local $SIG{__WARN__} = undef;

  # Shove the URI params in environment.
  local $ENV{'BEDROCK_URI'}     = $r->uri;
  local $ENV{'BEDROCK_URIDIR'}  = $bedrock_handler->{uri_dir};
  local $ENV{'BEDROCK_URINAME'} = $bedrock_handler->{uri_name};

  # And the file params too.
  local $ENV{'BEDROCK_FILE'}     = $r->filename;
  local $ENV{'BEDROCK_FILEDIR'}  = $bedrock_handler->{path};
  local $ENV{'BEDROCK_FILENAME'} = $bedrock_handler->{filename};

  local ( $ENV{'BEDROCK_INCLUDE_DIR'} )
    = $ENV{BEDROCK_INCLUDE_DIR} || $conf->{INCLUDE_DIR};

  local ( $ENV{'BEDROCK_PEBBLE_DIR'} )
    = $ENV{BEDROCK_PEBBLE_DIR} || $conf->{BEDROCK_PEBBLE_DIR};

  local ( $ENV{'PEBBLE_DIR'} ) = $ENV{PEBBLE_DIR} || $conf->{PEBBLE_DIR};

  local ( $ENV{'BEDROCK_SESSION_DIR'} )
    = $ENV{BEDROCK_SESSION_DIR} || $conf->{SESSION_DIR};

  local ( $ENV{'BEDROCK_CONFIG_PATH'} )
    = $ENV{BEDROCK_CONFIG_PATH}
    || $conf->{BEDROCK_CONFIG_PATH}
    || $conf->{CONFIG_PATH}
    || $ENV{CONFIG_PATH};

  local ( $ENV{'BEDROCK_IMAGE_DIR'} )
    = $ENV{BEDROCK_IMAGE_DIR} || $conf->{BEDROCK_IMAGE_DIR};

  local ( $ENV{'BEDROCK_IMAGE_URL'} )
    = $ENV{BEDROCK_IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  my $app_dir = $bedrock_handler->{path};

  if ( !chdir $app_dir ) {
    return $r->log->error( sprintf 'chdir(%s) failed: [%s]',
      $app_dir, $OS_ERROR );
  }

  my $ctx = Bedrock::Context->new(
    REQUEST_HANDLER => $r,
    CONFIG          => $conf
  );

  my $tx = Text::TagX->new( $file, $ctx );

  $tx->options(
    BEDROCK_PEBBLE_DIR => $ENV{BEDROCK_PEBBLE_DIR},
    INCLUDE_DIR        => get_include_dir($conf),
    PEBBLE_DIR         => $ENV{BEDROCK_PEBBLE_DIR},
    ALLOW_SNIPPET_TAG  => $conf->{ALLOW_SNIPPET_TAG},
    CONFIG             => $conf,
  );

  $r->log->info( sprintf 'INCLUDE_DIR.......[%s]',
    $conf->{INCLUDE_DIR} // $EMPTY );
  $r->log->info( sprintf 'PEBBLE_DIR........[%s]',
    $conf->{PEBBLE_DIR} // $EMPTY );
  $r->log->info(
    sprintf 'ALLOW_SNIPPET_TAG.[%s]',
    $conf->{ALLOW_SNIPPET_TAG} // $EMPTY
  );

  # load generic startup BLMs
  my $modules = $conf->get_module_config();

  if ( !$modules ) {
    return $r->log->error('error in config file: MODULES is not defined.');
  }

  # custom plugins
  if ( exists $conf->{PLUGIN_PATH} && defined $conf->{PLUGIN_PATH} ) {
    my @plugin_inc = split /:/xsm, $conf->{PLUGIN_PATH};

    foreach my $path (@plugin_inc) {
      if ( !any {/$path/xsm} @INC ) {
        push @INC, $path;
      }
    }
  }

  # this simply allows us to record if we have encountered a HEADER or
  # SESSION module yet in order to avoid loading duplicate copies of
  # these
  my %pre_bound = ( HEADER => undef, SESSION => undef );

  my @startup = @{$modules};

  foreach my $idx ( 0 .. $#startup ) {
    my $modconf = $startup[$idx];

    my ( $config, $binding, $module, $header, $session, $type,
      $abort_if_error )
      = @{$modconf}
      {qw/config binding module header session type abort_if_error/};

    $type = $type || 'hash';

    if ( !$binding ) {
      return $r->log->error( sprintf q{'binding' not defined for module (%s)},
        $idx );
    }

    if ( !any {/$type/xsm} qw{ hash array handle object} ) {
      return $r->log->error( sprintf 'invalid type (%s) in module (%s)',
        $type, $idx );
    }

    # BLM specific configuration
    # <scalar name="header"></scalar>
    if ( $header || $session ) {

      # must be either header or session
      my $pre_bound_module = $header ? 'HEADER' : 'SESSION';

      # Croak if more than one module tries to become pre-bound with same name
      if ( $pre_bound{$pre_bound_module} ) {
        my $errstr = "multiple modules defined for $pre_bound_module module";

        if ( is_bedrock_shell($r) ) {
          print {*STDERR} $errstr;
          exit -1;
        }
        else {
          return $r->log->error($errstr);
        }
      }

      # Bind the module
      $pre_bound{$pre_bound_module} = $pre_bound_module;

      my $obj = eval {
        bind_module(
          module  => $module,
          type    => $type,
          context => $ctx,
          config  => $config
        );
      };

      my $bind_error = $EVAL_ERROR;
      my $errstr;

      if ($bind_error) {

        $errstr = sprintf q{could not bind module (%s) as '%s'}, $module,
          $binding;

        $r->log->error($errstr);
        $r->log->error($bind_error);

        if ($abort_if_error) {

          if ( is_bedrock_shell($r) ) {
            print {*STDERR} $errstr;

            exit -1;
          }
          else {
            send_init_error( $r, $errstr, $bind_error );

            return $OK;
          }
        }
      }

      if ($obj) {

        # add the object to Bedrock' top frame (symbol table)
        $tx->param( $binding => $obj );

        # tagX wants to know who the header and session object are
        $tx->options( $pre_bound_module => $obj );

        # ...so does the context object which can be used by Bedrock::CGI
        $ctx->{$pre_bound_module} = $obj;
      }
      else {
        $tx->param( 'error' => $bind_error );
      }
    }
    else {
      $tx->param(
        $binding,
        sub {
          require_module($module);

          return bind_module(
            type    => $type,
            module  => $module,
            context => $ctx,
            config  => $config
          );

        }
      );
    }
  }

  # Croak if no header module
  if ( !$pre_bound{HEADER} ) {
    return $r->log->error( sprintf 'error in config file: No header module' );
  }

  $tx->param( '_version' => '@VERSION@-@BEDROCK_RELEASE@' );  ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)

  # benchmark
  my $t97 = Benchmark->new;

  $r->log->info(
    sprintf 'initialization complete: %s',
    timestr( timediff( $t97, $t0 ), 'all' )
  );

  # this is where Bedrock starts parsing the template
  eval { $tx->output };

  my $err = $EVAL_ERROR;

  # benchmark
  my $t98 = Benchmark->new;

  $r->log->info(
    sprintf 'bedrock processing complete: %s',
    timestr( timediff( $t98, $t97 ), 'all' )
  );

  # benchmark
  my $t99 = Benchmark->new;

  $r->log->info(
    sprintf 'request complete: %s %s',
    timestr( timediff( $t99, $t0 ), 'all' ),
    $err ? 'with error' : 'no errors'
  );

  if ($err) {
    if ( is_bedrock_shell($r) ) {

      # output error to STDERR
      my $line = $tx->{'error'}->line;
      my $file = $tx->{'error'}->file;
      my $source;

      if ( ref $file ) {
        $source = tied *{$file};
        $line--;
        $file = $tx->pebble($file);
      }

      $source = slurp_file $file;

      my @lines;

      {
        require IO::Scalar;

        my $fd = IO::Scalar->new( \$source );

        while ( defined( $_ = $fd->getline ) ) {
          chomp;
          push @lines, $_;
        }

        $fd->close;
      }

      if ( $err !~ /\Asnippet/xsm ) {

        print {*STDERR} sprintf 'Error on line [%d] (%s) - %s',
          $line, $file, $err;

        # print the lines surrounding error
        if ( $line > 1 ) {
          print {*STDERR} sprintf "  [%3d] %s\n",
            $line - 1, $lines[ $line - 2 ];
        }

        print {*STDERR} sprintf ">>[%3d] %s\n", $line, $lines[ $line - 1 ];

        if ( $line != @lines ) {
          print {*STDERR} sprintf "  [%3d] %s\n", $line + 1, $lines[$line];
        }
      }
      else {
        print {*STDERR} "$err";
      }
    }
    else {
      $r->log->error(
        sprintf
          'script [%s] with mime-type [%s] encountered the following error:',
        $bedrock_handler->{file}, $r->content_type
      );

      $r->log->error("$err");

      my $error_location
        = $conf->{BEDROCK_ERROR_LOCATION}
        ? $conf->{BEDROCK_ERROR_LOCATION}
        : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};

      # if we are serving up JSON content, then we need to return a
      # proper error code, not 200
      if ( $r->content_type =~ /json/xsm ) {
        $bedrock_handler->restore_dir;

        if ( is_mod_perl() ) {
          $r->status($SERVER_ERROR);
        }
        else {
          $r->content_type('application/json');
          $r->cgi_header_out( 'Status', '500' );
          $r->send_http_header;
        }

        chomp $err;

        print <<"EOM";
{ error : "$err" }
EOM
        return $OK;
      }
      else {
        $tx->show_error($error_location);
      }
    }
  }

  $bedrock_handler->restore_dir;

  # unfortunately since Bedrock error handling is finished now, if
  # errors occur now you will only see them in the error log
  $tx->close;

  # Apache 2 hack for redirection...let's not send unnecessary content
  # to the browser if a redirect header has been set.
  if ( !is_bedrock_shell($r) ) {

    if ( is_mod_perl() ) {

      if ( exists ${ $r->err_headers_out }{Location}
        || exists ${ $r->err_headers_out }{location} ) {
        $r->status(Apache2::Const::REDIRECT);
      }

      if ( exists ${ $r->err_headers_out }{Status}
        || exists ${ $r->err_headers_out }{status} ) {

        my $status = ${ $r->err_headers_out }{status}
          || ${ $r->err_headers_out }{Status};

        if ( $status =~ /\A\s*(\d+)/xsm ) {
          $r->status($1);
        }
      }
    }
  }

  return $OK;
}

########################################################################
sub get_include_dir {
########################################################################
  my ($conf) = @_;

  my @include_dir = @{$conf}{qw(INCLUDE_DIR BEDROCK_INCLUDE_DIR)};

  push @include_dir, @ENV{qw(INCLUDE_DIR BEDROCK_INCLUDE_DIR)};

  push @include_dir, $DEFAULT_BEDROCK_INCLUDE_DIR;

  @include_dir = uniq grep {defined} @include_dir;

  return join $COLON, @include_dir;
}

########################################################################
sub require_module {
########################################################################
  my ($modfile) = @_;

  $modfile =~ s/::/\//xsmg;

  if ( $modfile !~ /[.]pm\z/xsm ) {
    $modfile =~ s/\z/\.pm/xsm;
  }

  return require $modfile;
}

########################################################################
sub bind_module {
########################################################################
  my (%args) = @_;

  require_module $args{module};

  my $obj;

  ## no critic (Miscellanea::ProhibitTies)
  if ( $args{type} eq 'hash' or $args{type} eq 'object' ) {
    $obj = bless {}, $args{module};
    tie %{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'array' ) {
    $obj = bless [], $args{module};
    tie @{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'handle' ) {
    $obj = bless gensym, $args{module};
    tie *{$obj}, $args{module}, $args{context}, $args{config};
  }

  my $func = tied %{$obj};

  $func->can('init_plugin')
    && $func->init_plugin( $args{context}, $args{config} );

  return $obj;
}

########################################################################
sub is_bedrock_shell {
########################################################################
  my ($ref) = @_;

  return Scalar::Util::blessed($ref) eq 'Apache::Request_shell';
}

########################################################################
sub is_mod_perl {
########################################################################
  return defined $ENV{MOD_PERL};
}

########################################################################
sub send_init_error {
########################################################################
  my ( $r, $errstr, $bind_error ) = @_;

  $r->content_type('text/html');
  $r->send_http_header;

  print <<"END_OF_HTML";
<html>
  <head>
    <title>Bedrock Initialization Error</title>
  </head>
  <body>
    <div style="color:red;">An error was encountered while trying to initialize Bedrock</div>
    <pre>
$errstr
----
<p>$bind_error</p>
    </pre>
  </body>
</html>
END_OF_HTML

  return;
}

1;

__END__

=pod

=head1 NAME

Apache::Bedrock - Apache handler for serving Bedrock pages

=head1 SYNOPSIS

 <IfModule mod_perl.c>
   PerlRequire /usr/lib/bedrock/config/startup.pl
   AddHandler    perl-script .roc .jroc
   PerlHandler   Apache::Bedrock
 </IfModule>

 use Apache::Bedrock;

 Apache::Bedrock::handler->new( Apache::Request_cgi->new );

 Apache::Bedrock::handler->new( Apache::Request_shell->new );

I<See F<bedrock.cgi> or F<bedrock.pl> if you want to see how this module
can be used stand alone.>

=head1 DESCRIPTION

Handler for parsing Bedrock files.  Can be used with Apache as a
C<mod_perl> handler or in other configurations including a shell
interpreter.

=head1 METHODS AND SUBROUTINES

=head2 require_module

Parse a module name and 'require' it.  Used to load BLMs.

=head2 bind_module

Binds a Bedrock variable to a loadable module.

=head2 is_bedrock_shell

Returns true if running as bedrock shell.

=head2 is_mod_perl

Returns true if running under mod_perl.

=head1 AUTHOR

Jay Sridhar
Rob Lauer - <rlauer6@comcast.net>

=head1 SEE ALSO

L<Apache2::compat>, L<bedrock_handler_common>, L<Bedrock::Context>, L<Bedrock::Handler>

=cut
