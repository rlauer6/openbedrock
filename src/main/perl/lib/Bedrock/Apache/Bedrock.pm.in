#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Bedrock;

BEGIN {
  require Apache2::compat if $ENV{MOD_PERL};
}

use Apache2::Const -compile => qw( NOT_FOUND OK SERVER_ERROR FORBIDDEN DECLINED REDIRECT :log);
use Apache2::Log;
use APR::Const    -compile => qw(:error SUCCESS);

use strict;
#
# Define the following mod_perl constants since we could be using
# this module both as a mod_perl module and in a CGI
#
use constant	NOT_FOUND	=> Apache2::Const::NOT_FOUND;
use constant	SERVER_ERROR 	=> Apache2::Const::SERVER_ERROR;
use constant	FORBIDDEN 	=> Apache2::Const::FORBIDDEN;
use constant	OK		=> Apache2::Const::OK;
use constant	DECLINED 	=> Apache2::Const::DECLINED;
use constant	REDIRECT 	=> Apache2::Const::REDIRECT;

use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Hash;
use Bedrock::Text::URLEncode;
use Bedrock::VERSION;

use Text::TagX;

use Cwd;
use File::Basename;
use File::Temp;
use File::Spec;
use Symbol;
use Pod::Html;
use IO::Scalar;
use IO::File;

my $PWD;

sub build_body_tag {
  my $controller = shift;
  my $page = shift;

  my $page_def = $controller->{pages}->{$page};

  $controller->{body} = {} unless $controller->{body};

  my $body = $page_def->{body} || $controller->{body};
  my $body_tag;

  $body_tag = "<body";

  foreach (keys %{$body}) {
    $body_tag .= sprintf(q{ %s="%s"}, $_, $body->{$_});
  }

  $body_tag .= ">\n";

  $body_tag;
}

sub build_body_section {
  my ($controller, $page, $action) = @_;

  my $page_def = $controller->{pages}->{$page};
  my $body_section;

  if ($page_def->{actions}->{$action}) {
    $body_section = include(page_name($page_def->{actions}->{$action}));
  } else {
    $body_section = sprintf("<b>bedrock controller: </b>Page Under Construction - no action for '%s'", $action)
  }

  $body_section;
}

sub build_head_section {
  my $controller = shift;
  my $page = shift;

  my $head_section;

  my $page_def = $controller->{pages}->{$page};

  # if a framework defines it's own complete HEAD section we call that a "header" and include that 
  if ($page_def->{header}) {
    $head_section = include(page_name($page_def->{header}));
  } else {
    $head_section = "<head>\n";
    if (ref($page_def->{head}->{style}) =~/array/i) {
      $head_section .= join("\n", map { sprintf(q{<link rel="stylesheet" type="text/css" href="%s">}, $_) } @{$page_def->{head}->{style}}) . "\n";
    } else {
      my $style = $page_def->{head}->{style} || $page_def->{style} || $controller->{style};
      $head_section .= sprintf(q{<link rel="stylesheet" type="text/css" href="%s">%s}, $style, "\n") if $style;
    }
    
    if (ref($page_def->{head}->{javascript}) =~/array/i) {
      $head_section .= join("\n", map { sprintf(q{<script language="javascript" src="%s"></script>%s}, $_, "\n") } @{$page_def->{head}->{javascript}});
    } else {
      my $javascript = $page_def->{head}->{javascript} || $page_def->{javascript} || $controller->{javascript};
      $head_section .= sprintf(q{<script language="javascript" src="%s"></script>%s}, $javascript, "\n")  if $javascript;
    }
    
    # -- construct meta tags if present
    my $meta = $page_def->{head}->{meta} || $page_def->{meta} || $controller->{meta};
    
    if ($meta) {
      if (ref($meta->{name}) =~/array/i) {
	$head_section .= join("\n", map { sprintf(q{<meta name="%s" content="%s">}, $_->{name}, $_->{content}) } @{$meta->{name}}) . "\n";
      }
      
      if (ref($meta->{'http-equiv'}) =~/array/i) {
	$head_section .= join("\n", map { sprintf(q{<meta http-equiv="%s" content="%s">}, $_->{'http-equiv'}, $_->{content}) } @{$meta->{'http-equiv'}}) . "\n";
      }
    }
    
    my $title = $page_def->{head}->{title} || $page_def->{title} || $controller->{title};
    $head_section .= sprintf("<title>%s</title>\n", $title) if $title;
    $head_section .= "</head>\n";
  }

  $head_section;
}



sub merge_modules {
  my $r = shift;
  my ($dest_config, $src_config) = @_;

  my $src_modules = $src_config->{'MODULES'};

  return unless $src_modules && @$src_modules;

  my %dest_modules;

  map { $dest_modules{$_->{'binding'}} = $_; } @{$dest_config->{'MODULES'}};
  
  if ( $src_modules && @$src_modules ) {
    foreach ( @$src_modules ) {

      $r && $r->log->warn( "overriding MODULE binding ". $_->{'binding'} ) 
	if exists $dest_modules{$_->{'binding'}};

      $r && $r->log->debug( sprintf(" merging module: %s", Bedrock::Dump::compact($_)));

      $dest_modules{$_->{'binding'}} = $_;
    }
    
    my @modules = values %dest_modules;
    $dest_config->{'MODULES'} = \@modules;
  }
}

sub merge_config {
  my $r = shift;
  # bedrock master config, local config
  my ($dest_config, $src_config) = @_;

  $r && $r->log->debug( sprintf("merging configs: %s", Bedrock::Dump::compact($dest_config)));
  $r && $r->log->debug( sprintf("merging configs: %s", Bedrock::Dump::compact($src_config)));

  # merge source-config with dest-config (override)
  map { $dest_config->{$_} = $src_config->{$_} unless $_ eq 'MODULES'; } keys %$src_config;

  # merge modules
  merge_modules($r, $dest_config, $src_config);

  $dest_config;
}

# config( apache-request, uri-dir )
sub config {
  my $r = shift;
  my $dir = shift;

  $dir =~ s!/$!!;

  $r && $r->log->debug(sprintf("env: %s", Bedrock::Dump::compact(\%ENV)));

  $r && $r->log->debug(sprintf("uri-dir: %s DOCUMENT_ROOT: %s", $dir, $ENV{DOCUMENT_ROOT}));

  $dir =~s/^$ENV{DOCUMENT_ROOT}//; # Bedrock shell

  $r && $r->log->debug(sprintf("uri-dir: %s CONFIG_PATH: %s", $dir, $ENV{CONFIG_PATH}));

  # Bedrock 2 wants the master tagx.xml in $ENV{BEDROCK_CONFIG_PATH}
  # it can be overridden or merged with local configuration files.  To
  # override the master, add this to the master tagx.xml file
  #
  #  <scalar name="REPLACE_CONFIG">yes</scalar>
  #
  my $conf;
  eval {
    $conf = Bedrock::Config->new( 'tagx.xml' );
  };

  if ( $@ ) {
    $r && $r->log->warn( $@ );
    $r && $r->log->warn("Problem reading ". $ENV{BEDROCK_CONFIG_PATH} . "/tagx.xml");
  }
  
  if (-r $ENV{CONFIG_PATH} . '/tagx.xml') {
    if ( ! $conf || $conf->{REPLACE_CONFIG} =~/^y/i )  {

      $r && $r->log->warn(sprintf("%s/tagx.xml replaces system %s/tagx.xml.", 
			    $ENV{CONFIG_PATH}, $ENV{BEDROCK_CONFIG_PATH})
		    );

      $conf = Bedrock::Config->new( $ENV{CONFIG_PATH} . '/tagx.xml' );
    }
    else {
      my $local_conf =  Bedrock::Config->new( $ENV{CONFIG_PATH} . '/tagx.xml' );
      $conf = ($local_conf->{REPLACE_CONFIG} =~/^y/i) ? $local_conf : merge_config($r, $conf, $local_conf);
    }
  }

  $r && $r->log->debug("config: " . Bedrock::Dump::compact( $conf ));

  die sprintf("No or empty 'tagx.xml' found.\n\nBEDROCK_CONFIG_PATH: [%s]\nCONFIG_PATH: [%s]\n",
	      $ENV{BEDROCK_CONFIG_PATH}, $ENV{CONFIG_PATH}
	     )
    unless $conf && keys %$conf;

  # Look for auxillary application configurations and merge with (or replace)  master
  
  my @app_conf_files;
  # These are directory level configurations (tagx_apps.xml)
  push @app_conf_files, $conf->{'APP_CONFIG'} if $conf->{'APP_CONFIG'};

  my ($dummy, $framework_dir) = split /\//, $dir;
  $r && $r->log->debug("Looking for framework config file [${framework_dir}.xml");

  my $framework_conf = sprintf("%s/framework/%s.xml", $ENV{CONFIG_PATH}, $framework_dir);

  $r && $r->log->debug(sprintf("%s %s", (-s $framework_conf) ? "FOUND" : "DID NOT FIND"));
  push @app_conf_files, $framework_conf if -s $framework_conf;
  
  # look for more config files to merge
  foreach my $path ( ($ENV{BEDROCK_CONFIG_PATH} . ".d" , 
		      $ENV{CONFIG_PATH}, 
		      $ENV{CONFIG_PATH} . ".d")  ) {
    $r && $r->log->debug(sprintf("Looking for config files in [%s]\n", $path));

    next unless  -d $path;
    local( *CONFIG_FILES );
    opendir CONFIG_FILES, "$path";
    while (my $file = readdir CONFIG_FILES) {
      next unless $file=~/\.xml$/ && $file !~/^(tagx|tagx_apps)\.xml$/;
      $r && $r->log->info("Merging configuration file: $file");
      $conf = merge_config( $r, $conf, Bedrock::Config->newFromXML( $path . '/' . $file ) );
    }
    closedir CONFIG_FILES;
  }
  
  # look for module configs
  if (-d $ENV{CONFIG_PATH} . ".d/startup") {
    my $path = $ENV{CONFIG_PATH} . ".d/startup";
    local( *CONFIG_FILES );
    opendir CONFIG_FILES, "$path";
    while (my $file = readdir CONFIG_FILES) {
      next unless $file=~/\.xml$/;
      $r && $r->log->warn("Loading configuration file: $file");
      merge_modules($r, $conf, { MODULES => [ Bedrock::Config->newFromXML( $path . '/' . $file )] } );
      $r && $r->log->debug(sprintf("[Apache::Bedrock] Directory requested: [%s]", $r->filename));
    }
    closedir CONFIG_FILES;
  }

  foreach my $dir_conffile ( @app_conf_files ) {
    $r && $r->log->info(sprintf("Loading application configuration file: %s", $dir_conffile));

    # Load the config file
    my $dir_conf = Bedrock::Config->new( $dir_conffile );
    
    my $dir_path = '/';

    foreach my $dir_part ( undef, split /\//, $dir) {
      $dir_path .= $dir_part;

      # Look up the app config, based on directory of current request
      $r && $r->log->debug("Looking up directory configuration [$dir_path] in config object.");
      my $app_conf = $dir_conf->{$dir_path} || $dir_conf->{$dir_path . '/'};

      $conf = merge_config($r, $conf, $app_conf) if $app_conf;
      $dir_path .= '/' unless $dir_path eq '/';
    }
  }
  
  $conf->{CONFIG_PATH} = $ENV{CONFIG_PATH};

  # And voila! we have the merged config
  $conf;
}

sub error
  {
    my $r = shift;
    my $mesg = shift;
    my $code = shift || SERVER_ERROR;

    $r && $r->log_error( $mesg );
    chdir $PWD;
    return $code;
  }

# show_pod(file, config-object, "tag|plugins");
sub show_pod {
  my $file = shift;
  my $conf = shift;
  my $return_to = shift;

  my $outfile = tmpnam;
  
  &pod2html('--infile', $file,
	    '--outfile', $outfile, 
	    '--cachedir', File::Spec->tmpdir(), 
	    $conf->{BEDROCK_POD_CSS_URL} ? "--css=".$conf->{BEDROCK_POD_CSS_URL} : ()
	   );

  # in the off chance somebody puts the stupid Bedrock images some place else
  my $image_url =  $conf->{BEDROCK_IMAGE_URL} || "/bedrock/img";

  my $snippet =<<html;
<table width="100%">
<tr>
  <td align="left"><a href="/bedrock"><img src="$image_url/bedrock.jpg" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>
html

  # little or no pod?
  if (-s $outfile > 600) {
    open(FILE, $outfile) or die "Unable to open $outfile: $!\n";
    local $/ = undef;
    my $data = <FILE>;
    close FILE;
    
    $data =~s/(<body(.*?)>)/$1\n$snippet/is;
    
    print "Content-type: text/html\n\n";
    print $data;
  } else {
    print sprintf("Location: http://%s/bedrock/%s\n\n", $ENV{HTTP_HOST}, $return_to);
  }
  
  unlink $outfile;

  return OK;
}

sub blm_listing {
  my $dir = shift;
  my @listing;

  return () unless -d $dir;
  local *BLMDIR;
  opendir BLMDIR, $dir;
  while (my $file = readdir BLMDIR) {
    next if ($file =~/^\./);
    if (-d $dir . "/". $file) {
      push @listing, blm_listing($dir . "/" . $file);
    } else {
      push @listing, $dir . "/" . $1 if ($file =~/^(.*?)\.pm$/);
    }
  }

  closedir BLMDIR;

  return @listing;
}

sub get_all_blms {

  my @blm_listing;

  my @blm_path = grep { -d $_ ."/BLM" } @INC;

  foreach (@blm_path) {
    push @blm_listing, blm_listing($_ . "/BLM");
  }

  local *BLM;

  my @public_blms;

  foreach my $file (@blm_listing) {
    open BLM, "<" . $file . ".pm" or next;
    local $/;
    my $source = <BLM>;

    if ($source =~/\=pod/si && $source =~/\=head1\s+public/si) {
      push @public_blms, $file;
    }
    close BLM;
  }
  

  return sort @public_blms;
}

# return the standard documentation header
sub doc_head {
  my %attributes = @_;
  my $head;
  $head = "Content-type: text/html\n\n" unless exists $attributes{header};

  $head .=<<eot;
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%s</title>
<link rel="stylesheet" href="%s" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>
<body>
<table width="100%">
<tr>
  <td align="left"><a href="%s"><img src="%s" border="0"></a></td>
  <td align="right" valign="bottom" width="9999"><i>Bedrock Version: $Bedrock::VERSION::ID - $Bedrock::VERSION::BUILD_DATE</i></td>
</tr>
<tr>
  <td colspan="2"><hr></td>
</tr>
</table>

<h1>%s</h1>
eot
  
  $head = sprintf($head, $attributes{title}, $attributes{stylesheet}, $attributes{home}, $attributes{image}, $attributes{title});

  return $head;
}


sub ul_links {
  my $links = Bedrock::Hash->new(@_);
  my $ul = "<ul>\n";
  
  while (my ($key, $value) = each %{$links}) {
    $ul .= sprintf(q{<li><a href="/bedrock/%s">%s</a>} . "\n", $key, $value);
  }
  
  $ul .= "</ul>\n";

  return $ul;
}

sub page_name {  $_[0] .= ".inc" unless $_[0]=~/\.inc$/; $_[0]; }

sub include {
  my @pages = split ";", $_[0];
  my $include;

  foreach (@pages) {
    $include .= sprintf(q{<include --file="%s">}, page_name($_));
  }
  
  $include;
}

sub blm_ul {
  my $blms = shift;
  my $h2 = shift;
  
  return unless @_;
  my $html;

  my %blm_listing;
  # just the names

  foreach (@_) {
    $blm_listing{$_} = $blms->{$_};
    $blm_listing{$_} =~s/^(.*)::(.*)$/$2/;
  }

  $html = sprintf("<h2>%s</h2>\n", $h2);
  return $html . sprintf("<ul>\n%s\n</ul>\n", join("\n", map { sprintf(q{<li><a href="/bedrock/plugins/%s">%s</a>}, $_, $blm_listing{$_}) } @_));
}

# +------------------------------+
# | mod_perl HANDLER STARTS HERE |
# +------------------------------+

sub handler {
  my $r = shift;

  my $file;

  $r && $r->log->info("[Apache::Bedrock] started");

  # - under mod_perl naked directory requests, intended for the bedrock controller
  #   are passed along prior to file checking.  Thus the content_type is directory
  if ($r->content_type =~/directory/) {
    $r && $r->log->info(sprintf("[Apache::Bedrock] Directory requested: [%s]", $r->filename));
    $file = "";
    $ENV{PATH_TRANSLATED} = $r->filename;
    $r->content_type('text/html');
  }
  # - under mod_cgi those same requests come through via the "virtual" modifier on the Action directive
  #   8< 
  #     Action bedrock-cgi /cgi-bin/bedrock.cgi virtual
  #   8<
  else {
    $file = $r->filename;
    $r && $r->log->info(sprintf("[Apache::Bedrock] File requested: [%s]", $r->filename));
  }

  my $path_info = $ENV{PATH_INFO};
  $path_info =~s/(.*?)\/$/$1/;

  $r && $r->log->info(
		sprintf("[Apache::Bedrock] request file: [%s],  PATH_INFO: [%s],  PATH_TRANSLATED: [%s]",
			$file,
			$path_info,
			$ENV{PATH_TRANSLATED}
		       )
	       );

  # Parse for the URI components
  my ($uri_name, $uri_dir) = &fileparse( $r->uri );
  
  my $conf;
  eval {
    $conf = &config( $r, $uri_dir );
  };

  if ( $@ ) {
    &error($r, "[Apache Bedrock] Could not read config file.");
print <<eot;
Content-type: text/html

<html>
<head>
<title>Bedrock Configuration Error</title>
</head>
<body>
<div style="color:red;">An error was encountered while trying to read Bedrock's configuration file:</div>
<pre>$@</pre>
</body>
</html>
eot
    return OK;
  }

  $conf->{BEDROCK_IMAGE_URL} = $conf->{IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  # make sure that the LOG directories are present and writable, otherwise try /tmp
  foreach ( qw(LOGDIR HTML_LOGDIR) ) {
    unless (-d $conf->{$_} && -w $conf->{$_}) {
      $conf->{$_} = '/tmp';
    }
  }

  my $ctx = Bedrock::Context->new (
				   'APACHE_HANDLER' => $r,
				   'CONFIG'         => $conf
				  );
  my $html;

  if ($file) {
    unless ($r->content_type eq 'text/html') {
      &error($r, "[Apache Bedrock] content type: Content-type not text/html");
      return DECLINED ;
    }

    unless ( -e $r->filename ) {
      &error($r, "[Apache Bedrock] File does not exist: $file");
      return NOT_FOUND;
    }

    unless ( -r $r->filename ) {
      &error($r, "[Apache Bedrock] File permissions deny access: $file");
      return FORBIDDEN;
    }
  } elsif ($path_info =~/\/bedrock\/?(.*?)$/) {
    $ENV{BEDROCK_REQUEST_DOC} = $1;

    $r && $r->log->info(sprintf("[Apache Bedrock] Bedrock admin directory request denied by configuration.\n")) unless ($conf->{ALLOW_BEDROCK_INFO} =~/(yes|docs)/i);
    return FORBIDDEN unless $conf->{ALLOW_BEDROCK_INFO} =~/(yes|docs)/i;

    $r && $r->log->info(sprintf("[Apache Bedrock] Bedrock admin directory request [%s]\n", $ENV{BEDROCK_REQUEST_DOC}));

    my $doc = $ENV{BEDROCK_REQUEST_DOC};

    if ($doc =~/^plugins\/?(.*?)$/) {
      my $file = "$1";
      my $path;
      if ($file) {
	my @blm_listing = get_all_blms();
	my @path_list = grep {/(BLM\/$file|BLM\/Startup\/$file)/i } @blm_listing;

	$path = $path_list[0] . ".pm" if @path_list && -s $path_list[0] . ".pm";
	if ($path) {
	  $path =~/(BLM\/.*?)\.pm$/;
	  my $title = $1;
	  $title =~s/\//::/g;
	  return show_pod($path, $conf, "plugins");
	} else {
	  return NOT_FOUND;
	}
      } else {			# blm listing
	my @blm_listing = get_all_blms();
	my $blms = Bedrock::Hash->new;
	  
	foreach (@blm_listing) {
	  /BLM\/(.*?)$/;
	  $blms->{$1} = "BLM/$1";
	  $blms->{$1} =~s/\//::/g;
	}
	  
	my $html = doc_head(title      => "Bedrock Plugins", 
			    stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			    home       => "/bedrock",
			    image      => $conf->{BEDROCK_IMAGE_URL} . "/bedrock.jpg"
			   );
	
	$html .= blm_ul($blms, "Plugins", grep (!/^Startup/, keys %$blms));
	$html .= "<hr>\n";
	$html .= blm_ul($blms, "Application Plugins", grep (/^Startup/, keys %$blms));
	$html .= "</body>\n</html>\n";

	print $html;

	return OK;
      }
    } elsif ($doc =~/tag\/?(.*?)$/) {
      my $tag = lc($1);

      if ($tag) {
	my $path;
	my $tag_file;

	foreach my $inc (@INC) {
	  foreach ("NoBody","WithBody","WithBody/Loop") {
	    my $dir = sprintf("%s/Text/TagX/TAG/%s", $inc, $_);
	    $r && $r->log->info(sprintf("Looking in %s for %s\n", $dir, $tag));
	    opendir TAGS, $dir;
	    while (my $file = readdir TAGS) {
	      next unless $file =~/$tag\.pm$/i;
	      $tag_file = $dir . "/" . $file if (-s $dir . "/" . $file);
	      last;
	    }
	    closedir TAGS;
	    last if $tag_file;
	  }
	  last if $tag_file;
	}
	  
	if ($tag_file) {
	  return show_pod($tag_file, $conf, "tag");
	} else {
	  return NOT_FOUND;
	}
      } else {			# tag listing
	my $html = doc_head(title      => "Bedrock Tag Listing", 
			    stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			    home       => "/bedrock",
			    image      => $conf->{BEDROCK_IMAGE_URL} . "/bedrock.jpg"
			   );

	$Text::TagX::Opentag_expr =~/^\^\((.*?)\)/;
	my @tag_listing = split /\|/, $1;
	@tag_listing = map { !/(else|else\?if|blm)/ ? sprintf(q{<a href="/bedrock/tag/%s">%s</a>}, $_, $_) : ()} sort @tag_listing;
	print $html."<ul>\n";
	map { print "<li>$_\n"; } @tag_listing;
	print <<eot;
</ul>
</body>
</html>
eot

	return OK;
      }
    } elsif ($doc =~/^(env|config)$/) {
      
      my %vars = (
		  env    => ['Environment', \%ENV],
		  config => ['Configuration', $conf]
		 );
      
      my $html = doc_head(title      => "Bedrock " .  $vars{$doc}->[0],
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home       => "/bedrock",
			  image      => $conf->{BEDROCK_IMAGE_URL} . "/bedrock.jpg"
			 );
      $html .= q{<table cellpadding="0" cellspacing="0" border="0">} . "\n";
      foreach (sort keys %{$vars{$doc}->[1]}) {
	my $val = $vars{$doc}->[1]->{$_};
	my $string_val = ref($val) ? '<pre class="configref">' . Bedrock::Dump::compact( $val ) . '</pre>' : '<code class="configvar">' . $val . '</code>';
	$html .=<<eot;
<tr>
  <th valign="top" align="right"><code>$_</code>&nbsp;</th>
  <td valign="top">$string_val</td>
</tr>
eot
      }

      $html .= "</table>\n</body>\n</html>\n";

      print $html;

      return OK;
    }
    else {
      my $html = doc_head(title      => "Bedrock Reference Guide",
			  stylesheet => $conf->{BEDROCK_POD_CSS_URL},
			  home       => "/bedrock",
			  image      => $conf->{BEDROCK_IMAGE_URL} . "/bedrock.jpg"
			 );
	
      

      $html .= ul_links(
			"tag"     => "Bedrock Tags",
			"plugins" => "Bedrock Plugins"
		       );
      
      $html .= "<hr>\n";

      unless ($conf->{ALLOW_BEDROCK_INFO} eq 'docs') {
	$html .= "<h1>Bedrock Environment</h1>\n";
	$html .= ul_links(
			  "config"  => "Bedrock Configuration",
			  "env"     => "Bedrock Environment"
			 );

	# See if logs are working...
	$html .= "<hr>\n";
	$html .= "<h1>Bedrock Logs</h1>\n";

	my $logfile = sprintf("%s/%s", @$conf{qw(LOGDIR LOGFILE)});

	unless ($conf->{LOGDIR} && $conf->{LOGFILE}) {
	  # no LOGDIR specified
	  $html .= q{<span class="error">No log directory or log file specified in <strong>tagx.xml</strong>.  Set <strong>LOGDIR and LOGFILE</strong></span> } . "\n";
	} elsif (-d $conf->{LOGDIR} && ! -s $logfile) {
	  # directory defined
	  $html .= q{<span class="error">Directory specified but no <strong>} . $logfile . "</strong> can be found.  Check permissions.</span>\n";
	} elsif (! -d $conf->{LOGDIR}) {
	  # directory not defined
	  $html .= q{<span class="error">Log directory is specified but <strong>} . $conf->{LOGDIR} . "</strong> does not exist.  Create the directory.  Make sure the Apache user can write to this directory.\n";
	} elsif (! -d $conf->{HTML_LOGDIR}) {
	  # directory not defined
	  $html .= q{<span class="error">HTML log directory is specified but <strong>} . $conf->{HTML_LOGDIR} . "</strong> does not exists.  Create the directory. Make sure the Apache user can write to this directory.\n";
	} else {
	  # defined and present
	  $html .= "<ul>\n";
	  $html .= q{<li><span class="code">LOGDIR:</span>&nbsp;<strong>} . $conf->{LOGDIR} . "</strong></li>\n";
	  $html .= q{<li><span class="code">LOGFILE:</span>&nbsp;<strong>} . $conf->{LOGFILE} . "</strong></li>\n";
	  $html .= q{<li><span class="code">HTML_LOGDIR:</span>&nbsp;<strong>} . $conf->{HTML_LOGDIR} . "</strong></li>\n";
	  $html .= q{<li><span class="code">LOGLEVEL:</span>&nbsp;<strong>} . $conf->{LOGLEVEL} . "</strong></li>\n";
	  $html .= "</ul>\n";
	  $html .= "<hr>\n";
	  $html .= "<h3>Bedrock Log Tail</h3>\n";
	  $html .= q{<pre class="codeframe" style="height:150px; width:600px;">} . "\n";

	  my $fd = IO::File->new($logfile, "r");
	  my $pos = (-s $fd > 4000) ? -s $fd - 4000 : 0;

	  $fd->setpos($pos);
	  while (<$fd>) {
	    $html .= Text::URLEncode::Htmlencode($_);
	  }
	  $html .= "</pre>\n";
	  $fd->close;
	}
      }

      $html .= <<eot;
</body>
</html>
eot
      print $html;

      return OK;
    }
  }

  $r && $r->log->info("[Apache::Bedrock]:$html\n");

  $PWD = &fastcwd unless defined($PWD);

  local($SIG{__DIE__}, $SIG{__WARN__});

  my $controller;
  my $page;

  unless ($file || $html) {
    $controller = $conf->{framework};

    unless ($controller) {
      &error($r, "[Apache Bedrock] no framework object defined in 'tagx_apps.xml' for this directory.");
      return NOT_FOUND;
    }
    # set some defaults
    $controller->{meta} = {'http-equiv' => [ {'http-equiv' => "Content-Type", content => "text/html; charset=iso-8859-1"}] } unless $controller->{meta};
    $page = $ctx->getInputValue("page") || $controller->{pages}->{default};
    $page = $controller->{pages}->{default} if $page eq "default";
    $controller->{title} = ucfirst($page) unless $controller->{title};
  }

  # Shove the URI params in environment.
  local($ENV{'BEDROCK_URI'}) = $r->uri;
  $uri_dir =~ s!/$!!;
  local($ENV{'BEDROCK_URIDIR'}) = $uri_dir;
  local($ENV{'BEDROCK_URINAME'}) = $uri_name;


  # Parse the file components
  my $app_dir;
  my ($file_name, $file_dir);

  ($file_name, $file_dir) = &fileparse( $r->filename ) if $file;

  # And the file params too.
  local($ENV{'BEDROCK_FILE'})            = $r->filename;
  local($ENV{'BEDROCK_FILEDIR'})         = $file_dir;
  local($ENV{'BEDROCK_FILENAME'})        = $file_name;
  local($ENV{'BEDROCK_INCLUDE_DIR'} )    = $conf->{INCLUDE_DIR};
  local($ENV{'BEDROCK_PEBBLE_DIR'})      = $conf->{BEDROCK_PEBBLE_DIR};
  local($ENV{'BEDROCK_USER_PEBBLE_DIR'}) = $conf->{BEDROCK_USER_PEBBLE_DIR};
  local($ENV{'BEDROCK_SESSION_DIR'})     = $conf->{SESSION_DIR};
  local($ENV{'BEDROCK_CONFIG_PATH'})     = $conf->{BEDROCK_CONFIG_PATH} || $conf->{CONFIG_PATH} || $ENV{CONFIG_PATH};
  local($ENV{'BEDROCK_LOG_DIR'})         = $conf->{LOGDIR};
  local($ENV{'BEDROCK_HTML_LOG_DIR'})    = $conf->{HTML_LOGDIR};
  local($ENV{'BEDROCK_LOG_FILE'})        = $conf->{LOGFILE};
  local($ENV{'BEDROCK_IMAGE_DIR'})       = $conf->{BEDROCK_IMAGE_DIR};
  local($ENV{'BEDROCK_IMAGE_URL'})       = $conf->{BEDROCK_IMAGE_URL};

  # - if file is null, then this is probably Bedrock Framework since $ENV{PATH_TRANSLATED} refers to a directory
  $app_dir = $file ? $file_dir : $ENV{PATH_TRANSLATED};

  unless ($html) {
    unless ( chdir $app_dir ) {
      return &error($r, "[Apache Bedrock] chdir($app_dir) failed: $!" );
    }
  }

  # - either we'll be implementing Bedrock Framework or just serving a .roc[k] file
  my $tx;
  my $html_fd;

  if ($controller) {
    $r && $r->log->info("[Apache Bedrock] Bedrock framework found in 'tagx_apps.xml', assuming this is a framework application ;-)");

    unless ($controller->{pages}) {
      return &error($r, "[Apache Bedrock] Misconfigured Bedrock framework - no 'pages' object found!");
    }


    unless ($page) {
      &error($r, "[Apache Bedrock] No page specified or no default 'page' set in Bedrock framework.");
    }

    my $action = $ctx->getInputValue("action") || "default";
    $r && $r->log->info(sprintf("[Apache Bedrock] bedrock framework page: [%s] action: [%s]", $page, $action));

    my $page_def = $controller->{pages}->{$page};
 
    unless ($page_def) {
      $r && $r->log->warn ("[Apache Bedrock] No Bedrock framework definition for [$page] using defaults...");
      $html = sprintf("<html>\n<body>\n<b>Bedrock framework: </b>Page Under Construction - no controller for '%s'</b></body></html>", $page);
    } else {
      $html .= "<html>\n".build_head_section($controller, $page);
      $html .= build_body_tag($controller, $page);
      $html .= build_body_section($controller, $page, $action);


      # - an optional page footer which can be defined by page or application globally 
      my $footer = $page_def->{footer} || $controller->{footer};
      $html .= include(page_name($footer)) if $footer;
      $html .= "</body>\n</html>\n";
    }

    # once a page is loaded, the page becomes the current page and
    # the action is set to NULL, if the developer needs to know how
    # they got here they can use the 'referrer' and 'referrer_action'
    # CGI vars 
    #
    # Note: setting the $ctx->input object as done below is
    # valid at this point ONLY because $ctx->getInputValue was invoked
    # at least once before these references to $ctx->input (see
    # Bedrock::Context if you really want to see the gory details)
    #
    unless ($action eq "default") {
      my @pages = split ";", $page_def->{actions}->{$action};
      my $current_page = $pages[$#pages];
      $current_page =~s/\.inc$//;
      $ctx->input->{page} = $current_page;
      $ctx->input->{referrer} = $page;
      $ctx->input->{referrer_action} = $ctx->input->{action};
      $ctx->input->{action} = undef;
    }

    $html_fd = IO::Scalar->new(\$html);
    $tx = Text::TagX->new ($html_fd, $ctx);
  } elsif ($html) {
    $html_fd = IO::Scalar->new(\$html);
    $tx = Text::TagX->new ($html_fd, $ctx);
  } else {
    $tx = Text::TagX->new ($file, $ctx);
  }

  #
  # Set logging parameters, let's make the default Bedrock Framework
  # log file bedrock-framework
  #
  my $default_framework_log = $uri_dir;
  $default_framework_log =~s/\/$//;
  $default_framework_log = sprintf("%s.bedrock-framework", $default_framework_log);

  my $f = ($conf->{'HTML_LOGDIR'} || $conf->{'LOGDIR'} || '/tmp') . '/' . ($uri_name || $default_framework_log);
  my $sz = $conf->{'HTML_LOGMAXSIZE'} || $conf->{'LOG_MAXSIZE'} || 200000;

  $tx->options(
	       BEDROCK_PEBBLE_DIR => $conf->{'BEDROCK_PEBBLE_DIR'},
	       LOG_MAXSIZE        => $sz,
	       INCLUDE_DIR        => $conf->{INCLUDE_DIR} || ".",
	       LOG_PREFIX         => $f,
	       PEBBLE_DIR         => $conf->{'PEBBLE_DIR'},
	       ALLOW_SNIPPET_TAG  => $conf->{'ALLOW_SNIPPET_TAG'}
	      );

  #
  # Load Generic startup BLMs
  #
  my $modules = $conf->{'MODULES'};
  unless ( $modules ) {
    return &error( $r, "Error in config file: MODULES is not defined." );
  }

  my @startup = @{$modules};
  my $i = 0; my $header;
  for my $modconf (@startup) {

    unless ( defined( $modconf->{'binding'} ) ) {
      return &error( $r, "PID [$$]: Error in config: `binding' not defined for MODULES->[$i]" );
    }

    my $type = $modconf->{'type'} || 'hash';
    unless ( $type =~ /^(hash|array|handle|object)$/ ) {
      return &error( $r, "PID [$$]: Error in config: MODULES->[$i] defined with invalid `type'($type)" );
    }

    # BLM specific configuration
    my $config = $modconf->{'config'};

    # Special handling for header module. We create the object immediately
    # and bind it
    if ( exists $modconf->{'header'} ) {
      # Croak if more than one module tries to become header module
      if ( $header ) {
	return &error( $r, "PID [$$]: Error in config: Multiple modules defined with `header': ($header, $modconf->{'binding'})" );
      }
	  
      # Bind the header
      $header = $modconf->{'binding'};

      my $modfile = $modconf->{'module'};
      $modfile =~ s!::!/!g;
      $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
      require $modfile;

      my $obj;
      if ( $type eq 'hash' or $type eq 'object' ) {
	$obj = bless {}, $modconf->{'module'};
	tie %{$obj}, $modconf->{'module'}, $ctx, $config;
      } elsif ( $type eq 'array' ) {
	$obj = bless [], $modconf->{'module'};
	tie @{$obj}, $modconf->{'module'}, $ctx, $config;
      } elsif ( $type eq 'handle' ) {
	$obj = bless gensym, $modconf->{'module'};
	tie *{$obj}, $modconf->{'module'}, $ctx, $config;
      }
      $tx->param($header => $obj);
      $tx->options('HEADER' => $obj);
      next;
    }

    # bind a subroutine to the names so the constructor gets
    # invoked ONLY if the variable is accessed from the script.
    $tx->param( $modconf->{'binding'}, sub {
		  my $obj;
		  my $modfile = $modconf->{'module'};
		  $modfile =~ s!::!/!g;
		  $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;
		  require $modfile;
		  if ( $type eq 'hash' or $type eq 'object' ) {
		    $obj = bless {}, $modconf->{'module'};
		    tie %{$obj}, $modconf->{'module'}, $ctx, $config;
		  } elsif ( $type eq 'array' ) {
		    $obj = bless [], $modconf->{'module'};
		    tie @{$obj}, $modconf->{'module'}, $ctx, $config;
		  } elsif ( $type eq 'handle' ) {
		    $obj = bless gensym, $modconf->{'module'};
		    tie *{$obj}, $modconf->{'module'}, $ctx, $config;
		  }
		  $obj;
		});
  } continue {
    $i++;
  }

  # Croak if no header module
  unless ( $header ) {
    return &error( $r, "PID [$$]: Error in config file: No header module" );
  }

  eval { $tx->output };

  if ( $@ ) {
    if ( $ENV{SERVER_SIGNATURE} =~/apache/i ) {
      $r && $r->log_error( "PID [$$]: Script $file encountered the following error\n    $@" );
      my $error_location = $conf->{BEDROCK_ERROR_LOCATION} ? $conf->{BEDROCK_ERROR_LOCATION} : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};
      $tx->show_error( $error_location );
    }
    else {
      $r && $r->log_error( "PID [$$]: Script $file encountered the following error\n    $@" );

      # output error to STDERR
      my $line = $tx->{'error'}->line;
      my $file = $tx->{'error'}->file;

      open FILE, "<" . $file or die "Could not open source file " . $file;
      my $source;
      while ( $source = <FILE> ) {
	chomp $source;
	last if --$line == 0;
      }
      close FILE;

      print STDERR sprintf("Error on line [%d] (%s) - %s" , $tx->{'error'}->line, $file, $@);
      print STDERR sprintf("[%d] %s\n", $tx->{'error'}->line, $source);

      exit -1;
    }

  }

  chdir $PWD;
  $tx->close;

  # Apache 2 hack for redirection (mod_perl?)
  if ($ENV{SERVER_SIGNATURE} =~/apache/i ) {
    $r->status(Apache2::Const::REDIRECT) 
      if $ENV{MOD_PERL} && exists ${$r->err_headers_out}{Location} || exists ${$r->err_headers_out}{location};
  }
  
  return $ENV{SERVER_SIGNATURE} =~/apache/i ? OK : 0;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.40  2011/07/12 18:21:53  eutl420
# - report $@ in log file if an error occurs
#
# Revision 1.39  2011/07/11 18:03:23  eutl420
# - in all methods, use Apache request object for logging as $r && $r->log ...) this allows some methods
#   to be called without the ARO.  Of course, you'll get no logging, but nothing in life is free.
# - root directory "/" object form tagx_apps.xml like files was not being loaded because: split /\//, $dir is empty when
#   $dir = "/" or "" - see perldoc -f split
# - look for files in Bedrock's config.d directory (was missing .)
#
# Revision 1.38  2011/07/06 16:21:01  eutl420
# - read config files from ${BEDROCK_CONFIG_PATH}.d
# - remove ${DOCUMENT_ROOT} from start of uri-dir to support bedrock shell
#
# Revision 1.37  2011/07/05 20:34:26  eutl420
# - tagx_apps.xml style files loaded from  the framework directory should be named for the root directory for which
#   the configuration applies
# - directory level configuration info in the tagx_apps style configs cascades
#
# Revision 1.36  2011/07/05 17:54:19  eutl420
# - moved the order in which config (.xml) files are loaded so that the
#   tagx_apps.xml-ish files in the ~CONFIG/framework directory are loaded last
#   thus overriding any other values with the same keys.
#
# Revision 1.35  2011/03/30 18:05:33  eutl420
# - for shell users, show a useful error message with line number and offending
#   line of the Bedrock file
# - for shell users, return 0 not 200
#
# Revision 1.34  2011/03/29 14:16:26  eutl420
# - do not test for redirects unless running under Apache
#
# Revision 1.33  2011/03/25 17:15:29  eutl420
# - create method merge_modules() which does a true merge or the modules instead
#   of just replacing or appending
# - die if the tagx.xml file is empty
# - call merge_modules() when merging configs from config.d/startup directory
# - output error page when config problem instead of just logging message and
#   issuing a status 500
#
# Revision 1.32  2011/01/12 19:15:50  eutl420
# - use exact regexp to see if trying to reload tagx.xml
#
# Revision 1.31  2010/12/20 21:29:24  eutl420
# - closedir
# - config.d directory was not being scanned and files were not loaded properly
# - allow use of either yes or docs to ALLOW_BEDROCK_INFO
# - set CONFIG_PATH in configuration object from enviroment
#
# Revision 1.30  2010/12/18 16:31:50  eutl420
# - make sure that LOGDIR is writeable and set config if we use /tmp
#
# Revision 1.29  2010/12/17 21:31:56  eutl420
# - $conf =
#
# Revision 1.28  2010/12/17 18:59:40  eutl420
# - use $path not $_ in loop
#
# Revision 1.27  2010/12/17 18:52:35  eutl420
# - exclude tagx_apps from list of files to look for
#
# Revision 1.26  2010/12/17 16:52:51  eutl420
# - remove the BLM::Startup/BLM:: from plugin titles on the Bedrock doc pages
# - move the implementation of config.d merging into this module since it
#   really is a Bedrock system behavior that is independent of config file
#   reading and processing.  Now any .xml file on the config directory is
#   merged with the config object and one can override the default
#   tagx.xml configuration settings using REPLACE_CONFIG in tagx.xml
#
# Revision 1.25  2010/12/12 21:27:44  eutl420
# - added Apache log modules
#
# Revision 1.24  2010/12/12 17:14:00  eutl420
# - use Bedrock::Text::URLEncode
#
# Revision 1.23  2010/12/06 14:14:43  rlauer
# - use BEDROCK_IMAGE_URL primarily, deprecate IMAGE_URL
# - status page changes
#   + prettification
#   + log configuration checking and display
#   + bedrock.log dump of tail
#
# Revision 1.22  2010/11/23 00:06:12  rlauer
# - use BEDROCK_POD_CSS_URL instead of POD_CSS_URL
#
# Revision 1.21  2010/11/16 00:20:12  rlauer
# - add BUILD_DATE to header of documentation
#
# Revision 1.20  2010/11/15 02:08:27  rlauer
# - prevent non-PUBLIC BLMs from being shown in Plugin listing
#
# Revision 1.19  2010/11/14 21:11:21  rlauer
# - removed 'exec' from the list of hidden tags - ok to get docs on this
#   as the docs indicate that it is deprecated in favor of <pebble>
#
# Revision 1.18  2010/11/08 03:20:02  rlauer
# - added subroutine show_pod, add <img> tag to plugin/tag documentation
# - pass ALLOW_SNIPPET_TAG in option hash to TagX
#
# Revision 1.17  2010/10/30 21:45:51  rlauer
# - deprecate ERROR_LOCATION (relative to document root), in favor of
#   BEDROCK_ERROR_LOCATION which is an absolute path
#
# Revision 1.16  2010/06/24 21:36:25  rlauer
# rename the Bedrock/Config.pm file to Bedrock/BedrockConfig.pm to avoid Config.pm conflict
#
# Revision 1.15  2009/12/31 18:33:53  rlauer
# exclude blm from tag listing
#
# Revision 1.14  2009/12/30 00:19:01  rlauer
# split up plugins/application plugins, stream pod to disk first before displaying
#
# Revision 1.13  2009/12/28 23:31:31  rlauer
# fixed pod2html call to use temp file so removed comment, use plugins, not BLM
#
# Revision 1.12  2009/12/28 19:29:48  rlauer
# removing traces of BLM, replacing with plugin moniker
#
# Revision 1.11  2009/12/26 15:38:38  rlauer
# remove BLM::OrderedObject, all objects now ordered
#
# Revision 1.10  2009/01/14 13:38:15  rlauer
# - use Apache2::Const for return status
#
# Revision 1.9  2009/01/13 20:16:29  rlauer
# - hack to make sure internal redirects work under mod_perl/Apache2
#
# Revision 1.8  2008/12/02 15:14:51  rlauer
# $doc incorrectly assigned to re-initialized $1
#
# Revision 1.7  2008/11/26 19:25:38  rlauer
# return FORBIDDEN if ALLOW_BEDROCK_INFO ne yes
#
# Revision 1.6  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.5  2008/02/28 18:14:38  rlauer
# Applying Rob's patches to make Bedrock work on Apache 2.x
# (plus a few other obvious bug fixes).
#
# Revision 1.4  2001/02/14 15:35:42  sridhar
# Added copyright and GPL notice
#
# Revision 1.3  2000/12/18 18:05:01  sridhar
# Using Bedrock::Context instead of SIS::Base
#
# Revision 1.2  2000/12/15 16:22:26  sridhar
# Kicked out BLM::Startup::Modules -- all modules are `require'ed rather
# than `use'd for faster startup.
#
# Revision 1.1  2000/12/12 18:58:56  sridhar
# 1. Bedrock.pm, the main bedrock request handler now lives inside
# Bedrock
# 2. Same handler is used by the bedrock CGI too, by just mimicking the
# apache request handler object
# 3. Not using Apache::Constants since this module will now be used by
# the CGI too. Have the required constants hardcoded instead.
# 4. SIS::Base::Apache no longer used. Replaced by SIS::Base.
#
# Revision 1.13  2000/11/29 20:49:55  sridhar
# Can specify PEBBLE_DIR in the config
#
# Revision 1.12  2000/11/16 20:14:10  sridhar
# 1. chdir's to script directory and changes back on return from
# handler.
# 2. Uses `fastcwd' to find current dir for changing back.
# 3. Have a generic `error' function which changes back dir on return.
# 4. If script has an error, invokes `$tx->show_error()' with an error
# page.
#
# Revision 1.11  2000/11/13 14:51:50  sridhar
# Kicked out config cacheing till things stabilize a bit.
#
# Revision 1.10  2000/11/07 21:26:29  sridhar
# 1. Load configuration from disk for every request only if `RELOAD' set
# to `yes'
# 2. Defines a bunch of environment vars `BEDROCK_*' to contain the
# current script name, file, dir, etc.
# 3. Log message includes PID
#
# Revision 1.9  2000/11/07 14:16:51  sridhar
# 1. Major changes implementing directory-specific configuration, including
# Startup modules per directory.
# 2. Module takes care of loading config file `tagx.cfg' and creating
# the config object for each request based on the request directory, and
# merging the startup module list for each directory with the site-wide
# startup module list
# 3. Creates a subroutine for as the binding for each startup object
# which gets invoked for constructing the object only if needed. So one
# could have 100 startup modules for a directory, but use only 3 of them
# in a script; the other 97 wouldn't be constructed at all. All this
# magic happens behind the scenes so nobody is any the wiser.
#
# Revision 1.8  2000/11/01 21:02:17  sridhar
# Using XML file for Configuration
#
# Revision 1.7  2000/08/11 17:56:47  sridhar
# Catch unhandled exceptions and log an error.
#
# Revision 1.6  2000/07/19 19:41:59  sridhar
# Using BLM::Startup::Modules instead of BLM::Modules since dynamic BLMs
# no longer need to be pre-declared.
#
# Revision 1.5  2000/07/11 20:58:50  sridhar
# Localized $SIG{__DIE__} and __WARN__ so that state is restored on exit
# from handler.
#
# Revision 1.4  2000/07/06 18:36:15  sridhar
# Pass the SIS::Base::Apache object directly as the output handle to
# TagX since all necessary methods are supported in it (done for uniform
# header handling between mod_perl and CGI environments).
#
# Revision 1.3  2000/07/06 17:23:09  sridhar
# 1. MODULES config variable is now expected to have startup modules
# under MODULES->STARTUP.
# 2. MODULES->HEADER can be the name of a startup module object which
# generates HTTP headers.
#
# Revision 1.2  2000/06/15 19:35:29  sridhar
# New version with support for BLMs
#
# Revision 1.1  2000/06/07 19:53:41  sridhar
# Added mod_perl module for bedrock
#
#
