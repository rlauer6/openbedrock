package Apache::Bedrock;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

BEGIN {
  require Apache2::compat if defined $ENV{MOD_PERL};
}

use strict;
use warnings;

no warnings qw/uninitialized/;

use Apache2::Const -compile => qw(
  HTTP_UNSUPPORTED_MEDIA_TYPE
  HTTP_UNAUTHORIZED
  NOT_FOUND
  OK
  SERVER_ERROR
  FORBIDDEN
  DECLINED REDIRECT :log
);

use Apache2::Log;

use APR::Const -compile => qw(:error SUCCESS);

#
# Define the following mod_perl constants since we could be using
# this module both as a mod_perl module and in a CGI
#
use constant NOT_FOUND    => Apache2::Const::NOT_FOUND;
use constant SERVER_ERROR => Apache2::Const::SERVER_ERROR;
use constant FORBIDDEN    => Apache2::Const::FORBIDDEN;
use constant OK           => Apache2::Const::OK;
use constant DECLINED     => Apache2::Const::DECLINED;
use constant REDIRECT     => Apache2::Const::REDIRECT;
use constant UNSUPPORTED  => Apache2::Const::HTTP_UNSUPPORTED_MEDIA_TYPE;

use Bedrock;
use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Handler;
use Bedrock::Hash;
use Bedrock::Log;
use Bedrock::VERSION;
use bedrock_handler_common;

use Text::TagX;
use Text::URLEncode;
use Benchmark qw/:all/;
use Data::Dumper;
use English;
use File::Basename;
use File::Spec;
use File::Temp;
use IO::File;
use IO::Scalar;
use Symbol;

=pod

=head1 NAME

C<Apache::Bedrock> - Apache handler for serving Bedrock pages.

=head1 SYNOPSIS

 <IfModule mod_perl.c>
   PerlRequire /usr/lib/bedrock/config/startup.pl
   AddHandler    perl-script .roc .jroc
   PerlHandler   Apache::Bedrock
 </IfModule>

 use Apache::Bedrock;

 &Apache::Bedrock::handler( new Apache::Request_cgi );

 &Apache::Bedrock::handler( new Apache::Request_shell );

I<See bedrock.cgi or bedrock.pl> if you want to see how this module can be used stand alone.>

=head1 DESCRIPTION

Handler for parsing Bedrock files.  Can be used with Apache as a
mod_perl handler or in other configurations including a shell
interpreter.

=head1 METHODS

=head2 require_module

Parse a module name and 'require' it.  Used to load BLMs.

=cut

sub require_module {
  my $modfile = shift;

  $modfile =~ s!::!/!g;
  $modfile =~ s!$!.pm! unless $modfile =~ /\.pm$/;

  require $modfile;
} ## end sub require_module

=pod

=head2 bind_module

=cut

sub bind_module {
  my %args = @_;

  require_module( $args{module} );

  my $obj;

  if ( $args{type} eq 'hash' or $args{type} eq 'object' ) {
    $obj = bless {}, $args{module};
    tie %{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'array' ) {
    $obj = bless [], $args{module};
    tie @{$obj}, $args{module}, $args{context}, $args{config};
  }
  elsif ( $args{type} eq 'handle' ) {
    $obj = bless gensym, $args{module};
    tie *{$obj}, $args{module}, $args{context}, $args{config};
  }

  my $func = tied( %{$obj} );
  $func->can('init_plugin')
    && $func->init_plugin( $args{context}, $args{config} );

  return $obj;
} ## end sub bind_module

=pod

=head2 is_bedrock_shell

=cut

sub is_bedrock_shell {
  return Scalar::Util::blessed( $_[0] ) eq 'Apache::Request_shell';
}

=pod

=head2 is_mod_perl

=cut

sub is_mod_perl {
  return defined $ENV{MOD_PERL};
}

# +---------------------+
# | HANDLER STARTS HERE |
# +---------------------+

sub handler {
  my $r = shift;

  # start HiRes timer
  my $t0 = Benchmark->new
    if get_loglevel($r) eq 'debug';

  # errors are handled in the init_bedrock_handler() subroutine
  my $bedrock_handler = init_bedrock_handler($r) or return OK;

  # get the Bedrock config object
  my $conf = $bedrock_handler->config;

  # make sure that the LOG directories are present and writable, otherwise try /tmp
  foreach my $k (qw(LOGDIR HTML_LOGDIR)) {
    my $dir = $conf->{$k};

    if ( -d $dir && !-w $dir) {
      $bedrock_handler->log_error("$dir is not writeable, using /tmp");
      $conf->{$k} = '/tmp';
    }
    elsif ( !-d $dir) {
      eval { mkdir $dir };
      
      if ($@) {
        $bedrock_handler->log_error(
          "could not create $dir:[$OS_ERROR] - using [/tmp]");
        $conf->{$k} = '/tmp';
      }
    }
  }
  
  $bedrock_handler->log_info(
    sprintf( "Bedrock log directory is ..........[%s]", $conf->{LOGDIR} ) );

  $bedrock_handler->log_info(
    sprintf(
      "Bedrock's HTML log directory is ...[%s]", $conf->{HTML_LOGDIR}
    )
  );

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir; # typically /bedrock

  my $file = $bedrock_handler->{file};

  if ($file) {
    # check mime-type
    unless (
      $r->content_type =~ /(text\/html|application\/json|text\/plain)/ ) {
      $bedrock_handler->error( sprintf "content type: [%s] not supported\n",
        $r->content_type );

      return UNSUPPORTED;
    } ## end unless ( $r->content_type ...)

    unless ( -e $r->filename ) {
      $bedrock_handler->error(
        sprintf( "file does not exist: [%s]", $file ) );

      return NOT_FOUND;
    } ## end unless ( -e $r->filename )

    unless ( -r $r->filename ) {
      $bedrock_handler->error(
        sprintf( "file permissions deny access: [%s]", $file ) );

      return FORBIDDEN;
    } ## end unless ( -r $r->filename )
  } ## end if ($file)
  else {
    $bedrock_handler->error(
      sprintf( "attempt to serve directory: [%s]", $r->uri ) );

    return FORBIDDEN;
  } ## end else [ if ($file) ]

  local ( $SIG{__DIE__}, $SIG{__WARN__} );

  # Shove the URI params in environment.
  local $ENV{'BEDROCK_URI'}     = $r->uri;
  local $ENV{'BEDROCK_URIDIR'}  = $bedrock_handler->{uri_dir};
  local $ENV{'BEDROCK_URINAME'} = $bedrock_handler->{uri_name};

  # And the file params too.
  local $ENV{'BEDROCK_FILE'}     = $r->filename;
  local $ENV{'BEDROCK_FILEDIR'}  = $bedrock_handler->{path};
  local $ENV{'BEDROCK_FILENAME'} = $bedrock_handler->{filename};

  # TODO: cleanup this mess...scour code and use consistent
  # environment variables and configuration values with BEDROCK prefix
  local ( $ENV{'BEDROCK_INCLUDE_DIR'} )
    = $ENV{BEDROCK_INCLUDE_DIR} || $conf->{INCLUDE_DIR};
  local ( $ENV{'BEDROCK_PEBBLE_DIR'} )
    = $ENV{BEDROCK_PEBBLE_DIR} || $conf->{BEDROCK_PEBBLE_DIR};
  local ( $ENV{'PEBBLE_DIR'} ) = $ENV{PEBBLE_DIR} || $conf->{PEBBLE_DIR};
  local ( $ENV{'BEDROCK_SESSION_DIR'} )
    = $ENV{BEDROCK_SESSION_DIR} || $conf->{SESSION_DIR};
  local ( $ENV{'BEDROCK_CONFIG_PATH'} )
    = $ENV{BEDROCK_CONFIG_PATH}
    || $conf->{BEDROCK_CONFIG_PATH}
    || $conf->{CONFIG_PATH}
    || $ENV{CONFIG_PATH};
  local ( $ENV{'BEDROCK_LOG_DIR'} )
    = $ENV{BEDROCK_LOG_DIR} || $conf->{LOGDIR};
  local ( $ENV{'BEDROCK_HTML_LOG_DIR'} )
    = $ENV{BEDROCK_HTML_LOG_DIR} || $conf->{HTML_LOGDIR};
  local ( $ENV{'BEDROCK_LOG_FILE'} )
    = $ENV{BEDROCK_LOG_FILE} || $conf->{LOGFILE};
  local ( $ENV{'BEDROCK_IMAGE_DIR'} )
    = $ENV{BEDROCK_IMAGE_DIR} || $conf->{BEDROCK_IMAGE_DIR};
  local ( $ENV{'BEDROCK_IMAGE_URL'} )
    = $ENV{BEDROCK_IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  my $app_dir = $bedrock_handler->{path};

  if ( !chdir $app_dir ) {
    return $bedrock_handler->error(
      sprintf( " chdir(%s) failed: [%s]", $app_dir, $! ) );
  }

  my $ctx
    = Bedrock::Context->new( 'APACHE_HANDLER' => $r, 'CONFIG' => $conf );
    
  my $tx = Text::TagX->new( $file, $ctx );

  # -- setup logging

  # TODO: this is an example of TODO above...
  # use BEDROCK_HTML_LOGFILE...BEDROCK_HTML_LOG_DIR from %ENV now or we
  # always take values from the configuration object
  my $page_log;
  my $html_logdir = $conf->{HTML_LOGDIR} || '/tmp';

  # if we have HTML_LOGFILE, then we log each page separately
  if ( $conf->{HTML_LOGFILE} ) {
    $page_log = $conf->{HTML_LOGFILE};
  }
  else {
    $page_log = $bedrock_handler->{filename};
    $page_log =~s/\.(.*)$//;
  }

  # not sure this should ever happen, however if we've parsed the
  # URI incorrectly (Bedrock CGI mainly) then let's do some belt &
  # suspenders mitigation...
  if ( !$page_log ) {
    $page_log = 'bedrock-page-' . time;
  }

  if ( $page_log !~/^STDERR$/ ) {
    $page_log = $html_logdir . '/' . $page_log;
  }
  
  # the TagX::Log start_logger() method redirects STDERR to the page
  # log after this call has been executed
  $tx->options(
    BEDROCK_PEBBLE_DIR => $ENV{BEDROCK_PEBBLE_DIR},
    INCLUDE_DIR        => $ENV{BEDROCK_INCLUDE_DIR},
    PEBBLE_DIR         => $ENV{BEDROCK_PEBBLE_DIR},
    ALLOW_SNIPPET_TAG  => $conf->{ALLOW_SNIPPET_TAG},
    LOGFORMAT          => $conf->{LOGFORMAT} || '%t [%p] [%a]: %L ',
    LOG_MAXSIZE        => $conf->{HTML_LOGMAXSIZE} || $conf->{'LOG_MAXSIZE'},
    LOG_SPOOLER        => $conf->{HTML_LOGSPOOLER},
    LOG_PREFIX         => $page_log,
  );

  {
    no warnings 'uninitialized';
    
    $bedrock_handler->log_debug(sprintf("HTML_LOGDIR.......[%s]", $conf->{HTML_LOGDIR}));
    $bedrock_handler->log_debug(sprintf("HTML_LOGFILE......[%s]", $conf->{HTML_LOGFILE}));
    $bedrock_handler->log_debug(sprintf("INCLUDE_DIR.......[%s]", $conf->{INCLUDE_DIR}));
    $bedrock_handler->log_debug(sprintf("PEBBLE_DIR........[%s]", $conf->{PEBBLE_DIR}));
    $bedrock_handler->log_debug(sprintf("ALLOW_SNIPPET_TAG.[%s]", $conf->{ALLOW_SNIPPET_TAG}));
    $bedrock_handler->log_debug(sprintf("LOGFORMAT.........[%s]", $conf->{LOGFORMAT}));
    $bedrock_handler->log_debug(sprintf("LOG_MAXSIZE.......[%s]", $conf->{LOG_MAXSIZE}));
    $bedrock_handler->log_debug(sprintf("LOG_SPOOLER.......[%s]", $conf->{LOG_SPOOLER}));
    $bedrock_handler->log_debug(sprintf("LOG_PREFIX........[%s]", $conf->{LOG_PREFIX}));
  }
  
  # load generic startup BLMs
  my $modules = $conf->get_module_config();

  if ( !$modules ) {
    return $bedrock_handler->error(
      'error in config file: MODULES is not defined.');
  }

  # custom plugins
  if ( exists $conf->{PLUGIN_PATH} && defined $conf->{PLUGIN_PATH} ) {
    my @plugin_inc = split /:/, $conf->{PLUGIN_PATH};

    foreach my $path (@plugin_inc) {
      push @INC, $path
        unless grep {/$path/} @INC;
    }
  } ## end if ( exists $conf->{PLUGIN_PATH...})

  # this simply allows us to record if we have encountered a HEADER or
  # SESSION module yet in order to avoid loading duplicate copies of
  # these
  my %pre_bound = ( HEADER => undef, SESSION => undef );

  my @startup = @{$modules};

  for ( my $idx = 0; $idx < @startup; $idx++ ) {
    my $modconf = $startup[$idx];

    my ( $config, $binding, $module, $header, $session, $type,
      $abort_if_error )
      = @{$modconf}
      {qw/config binding module header session type abort_if_error/};

    $type = $type || 'hash';

    if ( !$binding ) {
      return $bedrock_handler->error(
        "'binding' not defined for module ($idx)");
    }

    if ( $type !~ /^(hash|array|handle|object)$/ ) {
      return $bedrock_handler->error("invalid type ($type) in module ($idx)");
    }

    # BLM specific configuration
    # <scalar name="header"></scalar>
    if ( $header || $session ) {

      # must be either header or session
      my $pre_bound_module = $header ? 'HEADER' : 'SESSION';

      # Croak if more than one module tries to become pre-bound with same name
      if ( $pre_bound{$pre_bound_module} ) {
        my $errstr = "multiple modules defined for $pre_bound_module module";

        if ( is_bedrock_shell($r) ) {
          print STDERR $errstr;
          exit -1;
        }
        else {
          return $bedrock_handler->error($errstr);
        }
      } ## end if ( $pre_bound{$pre_bound_module...})

      # Bind the module
      $pre_bound{$pre_bound_module} = $pre_bound_module;

      my $obj = eval {
        bind_module(
          module  => $module,
          type    => $type,
          context => $ctx,
          config  => $config
        );
      };

      my $bind_error = $EVAL_ERROR;
      my $errstr;

      if ($bind_error) {

        $errstr = "could not bind module ($module) as '$binding'";
        $bedrock_handler->log_error($errstr);
        $bedrock_handler->log_error($bind_error);
        
        if ($abort_if_error) {

          if ( is_bedrock_shell($r) ) {
            print STDERR $errstr;
            exit -1;
          }
          else {
            $r->content_type('text/html');
            $r->send_http_header;

            print <<eom;
<html>
<head>
<title>Bedrock Initialization Error</title>
</head>
<body>
<div style="color:red;">An error was encountered while trying to initialize Bedrock</div>
<pre>
$errstr
----
<p>$bind_error</p>
</pre>
</body>
</html>
eom
            return OK;
          } ## end else [ if ( is_bedrock_shell(...))]
        } ## end if ($abort_if_error)
      } ## end if ($bind_error)

      if ($obj) {

        # add the object to Bedrock' top frame (symbol table)
        $tx->param( $binding => $obj );

        # tagX wants to know who the header and session object are
        $tx->options( $pre_bound_module => $obj );

        # ...so does the context object which can be used by Bedrock::CGI
        $ctx->{$pre_bound_module} = $obj;
      } ## end if ($obj)
      else {
        $tx->param( 'error' => $bind_error );
      }
    } ## end if ( $header || $session)
    else {
      $tx->param(
        $binding,
        sub {
          require_module($module);

          return bind_module(
            type    => $type,
            module  => $module,
            context => $ctx,
            config  => $config
          );

        }
      );
    } ## end else [ if ( $header || $session)]
  } ## end for ( my $idx = 0; $idx...)

  # Croak if no header module
  if ( !$pre_bound{HEADER} ) {
    return $bedrock_handler->error(
      sprintf("error in config file: No header module") );
  }

  $tx->param( '_version' => '@VERSION@-@BEDROCK_RELEASE@' );

  
  # this is where Bedrock starts parsing the template
  eval { $tx->output };

  my $err = $@;

  if ($err) {
    if ( is_bedrock_shell($r) ) {

      # output error to STDERR
      my $line = $tx->{'error'}->line;
      my $file = $tx->{'error'}->file;
      my $source;

      if ( ref($file) ) {
        $source = tied( *{$file} );
        $line--;
        $file = $tx->pebble($file);
      }

      open FILE, '<', $file
        or die "Could not open source file " . $file;

      {
        local $/;
        $source = <FILE>;
      }

      close FILE;

      my @lines;

      {
        require IO::Scalar;

        my $fd = IO::Scalar->new( \$source );

        while ( defined( $_ = $fd->getline ) ) {
          chomp;
          push @lines, $_;
        }

        $fd->close;
      }

      unless ( $err =~ /^snippet/ ) {
        $r->log_error(
          sprintf( "Error on line [%d] (%s) - %s", $line, $file, $err ) );

        # print the lines surrounding error
        $r->log_error(
          sprintf( "  [%3d] %s\n", $line - 1, $lines[ $line - 2 ] ) )
          unless $line <= 1;

        $r->log_error(
          sprintf( ">>[%3d] %s\n", $line, $lines[ $line - 1 ] ) );

        $r->log_error( sprintf( "  [%3d] %s\n", $line + 1, $lines[$line] ) )
          unless $line == @lines;
      } ## end unless ( $err =~ /^snippet/)
      else {
        $r->log_error("$err");
      }
    } ## end if ( is_bedrock_shell(...))
    else {
      $bedrock_handler->log_error(
        sprintf(
          "script [%s] with mime-type [%s] encountered the following error:",
          $bedrock_handler->{file},
          $r->content_type
        )
      );

      $bedrock_handler->log_error("$err");

      my $error_location
        = $conf->{BEDROCK_ERROR_LOCATION}
        ? $conf->{BEDROCK_ERROR_LOCATION}
        : $ENV{DOCUMENT_ROOT} . $conf->{ERROR_LOCATION};

      # if we are serving up JSON content, then we need to return a
      # proper error code, not 200
      if ( $r->content_type =~ /json/ ) {
        $bedrock_handler->restore_dir;

        if ( is_mod_perl() ) {
          $r->status(SERVER_ERROR);
        }
        else {
          $r->content_type('application/json');
          $r->cgi_header_out( 'Status', '500' );
          $r->send_http_header;
        }

        chomp $err;
        print <<eom;
{ error : "$err" }
eom
        return OK;
      } ## end if ( $r->content_type ...)
      else {
        $tx->show_error($error_location);
      }
    } ## end else [ if ( is_bedrock_shell(...))]
  } ## end if ($err)

  $bedrock_handler->restore_dir;

  # unfortunately since Bedrock error handling is finished now, if
  # errors occur now you will only see them in the error log
  $tx->close;

  # Apache 2 hack for redirection...let's not send unnecessary content
  # to the browser if a redirect header has been set.
  unless ( is_bedrock_shell($r) ) {
    if ( is_mod_perl() ) {
      if ( exists ${ $r->err_headers_out }{Location}
        || exists ${ $r->err_headers_out }{location} ) {
        $r->status(Apache2::Const::REDIRECT);
      }
      if ( exists ${ $r->err_headers_out }{Status}
        || exists ${ $r->err_headers_out }{status} ) {
        my $status = ${ $r->err_headers_out }{status}
          || ${ $r->err_headers_out }{Status};
        $r->status($1) if $status =~ /^\s*(\d+)/;
      } ## end if ( exists ${ $r->err_headers_out...})
    } ## end if ( is_mod_perl() )
  } ## end unless ( is_bedrock_shell(...))

  # benchmark
  my $t1 = Benchmark->new;

  if ( get_loglevel($r) eq 'debug' ) {
    $bedrock_handler->log_debug( "log level " . get_loglevel($r) );
    $bedrock_handler->log_debug(
      "processing complete: " . timestr( timediff( $t1, $t0 ), 'all' ) );
  }

  return OK;
} ## end sub handler

1;

=pod

=head1 AUTHOR

Jay Sridhar
Rob Lauer - <rlauer6@comcast.net>

=cut
