package Apache::Bedrock;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2024, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

BEGIN {
  if ( $ENV{MOD_PERL} ) {
    eval {
      require Apache2::ServerRec;
      Apache2::ServerRec->import;

      require Apache2::ServerUtil;
      Apache2::ServerUtil->import;

    };
  }
}

use Bedrock qw(slurp_file);
use Bedrock::Apache::Constants qw(:http %APACHE_LOG_LEVELS);
use Bedrock::Constants qw(:chars :defaults :booleans :regexp);
use Bedrock::BedrockConfig;
use Bedrock::Context;
use Bedrock::Dump;
use Bedrock::Handler qw(mlogger_debug mlogger_info require_module bind_module);
use Text::TagX;

use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename;
use HTML::Entities qw(encode_entities);
use JSON;
use List::Util qw( any uniq );
use Scalar::Util qw(blessed reftype);

use Role::Tiny::With;
with 'Bedrock::Logger';

our $VERSION = '@PACKAGE_VERSION@';  ## no critic

use parent qw(Exporter);

our @EXPORT_OK = qw(
  load_startup_modules
  pre_bind_module
  cache
);

our %EXPORT_TAGS = (
  bind => [
    qw(
      load_startup_modules
      pre_bind_module
    )
  ]
);

{
  my $cache;

########################################################################
  sub cache {
########################################################################
    return $cache
      if $cache;

    return
      if !$ENV{BEDROCK_CACHE_ENGINE};

    require Bedrock::Cache;

    $cache = eval {
      return Bedrock::Cache->new();  # Factory handles discovery of Bedrock::Cache::Redis
    };

    if ( !$cache || $EVAL_ERROR ) {
      warn "WARNING: could not initialize Bedrock::Cache provider:\n$EVAL_ERROR";
    }

    return $cache;
  }
}

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # see if our page is in cache, if so send a 304
  my $cache = cache();

  if ($cache) {
    my $etag = $r->headers_in->{'If-None-Match'} // q{};

    if ( $etag && $cache->exists($etag) ) {
      $r->log->info('Cache hit (ETag)...serving 304 Not Modified');
      $r->send_http_header;
      $r->status($NOT_MODIFIED);

      return $OK;
    }
  }

  # reset Apache log level to match BedrocLogLevel
  if ( is_mod_perl() ) {
    my $s = Apache2::ServerUtil->server;

    my $bedrock_log_level = $ENV{BedrockLogLevel} // 'info';

    $s->loglevel( $APACHE_LOG_LEVELS{ uc $bedrock_log_level } );
    mlogger_info( $r, 'Resetting Apache log level: %s', $bedrock_log_level );
  }

  my $bedrock_handler
    = eval { return Bedrock::Handler->new( $r, cache => $cache, benchmarking_enabled => $ENV{BEDROCK_BENCHMARK} ); };

  if ( !$bedrock_handler ) {
    display_init_error( $r, "could not initialize handler\n$EVAL_ERROR" );

    return $OK;
  }

  my $benchmarking_enabled = $bedrock_handler->benchmarking_enabled;

  # --- benchmark
  $benchmarking_enabled && $bedrock_handler->log_benchmark('Bedrock::Handler->new() complete');

  # get the Bedrock config object
  my $conf = $bedrock_handler->config;

  if ( !$conf || reftype($conf) eq 'Bedrock::Config' ) {
    $r->log->error('unable to create Bedrock::Config object');

    return $SERVER_ERROR;
  }

  my $bedrock_admin_dir = $bedrock_handler->get_bedrock_admin_dir;  # typically /bedrock

  my $file = $bedrock_handler->{file};

  # if mod_perl or Apache::Request::CGI has done their jobs, there
  # should already be a content type set...but just in case?
  my $content_type = $r->content_type;

  if ( !$content_type ) {
    $r->log->warn('somebody forgot to set content type?');
    $content_type = 'text/html';
  }

  # might want to revisit this, but the point is that this handler
  # should only be serving HTML, JSON or plain text files?
  if ($file) {

    # check mime-type
    if ( !any { $content_type eq $_ } qw(text/html application/json text/plain ) ) {
      $r->log->error( sprintf 'content type: [%s] not supported', $content_type );

      return $UNSUPPORTED;
    }

    if ( !-e $file ) {
      $r->log->error( sprintf 'file does not exist: [%s]', $file );
      return $NOT_FOUND;
    }

    if ( !-r $file ) {
      $r->log->error( sprintf 'file permissions deny access: [%s]', $file );

      return $FORBIDDEN;
    }
  }
  else {
    $r->log->error( sprintf 'attempt to serve directory: [%s]', $r->uri );

    return $FORBIDDEN;
  }

  # Shove the URI params in environment.
  local $ENV{BEDROCK_URI}     = $r->uri;
  local $ENV{BEDROCK_URIDIR}  = $bedrock_handler->{uri_dir};
  local $ENV{BEDROCK_URINAME} = $bedrock_handler->{uri_name};

  # And the file params too.
  local $ENV{BEDROCK_FILE}     = $r->filename;
  local $ENV{BEDROCK_FILEDIR}  = $bedrock_handler->{path};
  local $ENV{BEDROCK_FILENAME} = $bedrock_handler->{filename};

  # override configuration file with environment variables
  foreach my $var (qw(PEBBLE INCLUDE SESSION IMAGE)) {
    my $env_var = "BEDROCK_${var}_DIR";

    if ( $ENV{$env_var} ) {
      $conf->{$env_var} = $conf->{"${var}_DIR"} = $ENV{$env_var};
    }
    else {
      $ENV{$env_var} = defined $conf->{$env_var} ? defined $conf->{$env_var} : $EMPTY;
    }
  }

  if ( $ENV{BEDROCK_CONFIG_PATH} || $ENV{CONFIG_PATH} ) {
    $conf->{BEDROCK_CONFIG_PATH} = $ENV{BEDROCK_CONFIG_PATH} // $ENV{CONFIG_PATH};
    $conf->{CONFIG_PATH}         = $conf->{BEDROCK_CONFIG_PATH};
  }
  else {
    $ENV{BEDROCK_CONFIG_PATH} = $ENV{CONFIG_PATH} = $conf->{CONFIG_PATH} // $conf->{BEDROCK_CONFIG_PATH};
  }

  $ENV{BEDROCK_IMAGE_URL} //= $ENV{IMAGE_URL} || $conf->{BEDROCK_IMAGE_URL};

  my $error_page = $conf->{ERROR_LOCATION};

  if ($error_page) {
    $error_page = $ENV{DOCUMENT_ROOT} . $error_page;
  }
  else {
    $error_page = $conf->{BEDROCK_ERROR_LOCATION};
  }

  $ENV{BEDROCK_ERROR_PAGE} = $error_page;

  $r->log->info( sprintf 'INCLUDE_DIR.........[%s]', $conf->{INCLUDE_DIR}       // $EMPTY );
  $r->log->info( sprintf 'PEBBLE_DIR..........[%s]', $conf->{PEBBLE_DIR}        // $EMPTY );
  $r->log->info( sprintf 'ALLOW_SNIPPET_TAG...[%s]', $conf->{ALLOW_SNIPPET_TAG} // $EMPTY );
  $r->log->info( sprintf 'BEDROCK_ERROR_PAGE..[%s]', $ENV{BEDROCK_ERROR_PAGE}   // $EMPTY );

  my $app_dir = $bedrock_handler->{path};

  if ( $app_dir && !chdir $app_dir ) {
    return $r->log->error( sprintf 'chdir(%s) failed: [%s]', $app_dir, $OS_ERROR );
  }

  # --- benchmark
  $benchmarking_enabled && $bedrock_handler->log_benchmark('environment setup complete');

  my $ctx;
  my $tx;
  my $final_status = $OK;

  my $route_params = {};

  if ( exists $conf->{routes} && reftype( $conf->{routes} ) eq 'ARRAY' ) {
    require Bedrock::Router;

    my $router = Bedrock::Router->new($conf);

    if ( my $match = $router->match( $r->uri ) ) {
      # 1. Override the file to be processed
      my $new_file = sprintf '%s/%s', $conf->{PEBBLE_DIR}, $match->{template};

      if ( -e $new_file ) {
        $file = $new_file;  # Override local var used by init_tagx

        # Update Handler state so relative includes works
        @{$bedrock_handler}{qw(file path filename)} = ( $file, dirname($file), basename($file) );

        # 2. Capture Params
        $route_params = $match->{params};

        $r->log->info( sprintf 'Route matched: %s->%s', $r->uri, $match->{template} );
      }
    }
  }

  eval {
    $ctx = Bedrock::Context->new(
      request      => $r,
      config       => $conf,
      cache        => $cache,
      route_params => $route_params,
    );

    # --- benchmark
    $benchmarking_enabled && $bedrock_handler->log_benchmark('context object created');

    # this needs to be done before load_startup_modules()
    $conf->init_plugin_path();

    # load module config
    my $modules = $conf->get_module_config();

    if ( !$modules ) {
      die 'error in config file: MODULES is not defined.';
    }

    $tx = init_tagx(
      file            => $file,
      config          => $conf,
      request_handler => $r,
      context         => $ctx
    );

    # --- benchmark
    $benchmarking_enabled && $bedrock_handler->log_benchmark('TagX object creation complete');

    # load startup modules
    my $pre_bound = load_startup_modules( $modules, $ctx, $tx, $bedrock_handler );

    if ( !$pre_bound->{HEADER} ) {
      die 'error in config file: No header module';
    }

    # --- benchmark
    $benchmarking_enabled && $bedrock_handler->log_benchmark('module_binding_complete');

    # this is where Bedrock starts parsing the template
    $tx->output;

    # --- benchmark
    $benchmarking_enabled && $bedrock_handler->log_benchmark('Bedrock tag processing complete');

    1;
  } or do {
    my $err = $EVAL_ERROR;
    $r->log->error( sprintf 'file:[%s] mime-type:[%s] error: [%s]', $bedrock_handler->{file}, $r->content_type, $err );

    # Distinguish between Startup Panic vs Runtime Error
    if ( $err =~ $PANIC_EXPR ) {
      display_init_error( $r, $err );
    }
    else {
      display_error( $r, $err, $tx );
    }

    # We return OK so Apache serves the error page content we just generated
    $final_status = $OK;
  };

  if ($tx) {
    $tx->close;
  }

  if ( $ctx && $ctx->can('cleanup') ) {
    $ctx->cleanup;
  }

  # --- benchmark
  $benchmarking_enabled && $bedrock_handler->log_benchmark( 'request complete', 1 );

  $bedrock_handler->restore_dir;

  return $final_status
    if is_bedrock_shell($r) || !is_mod_perl();

  # Apache 2 hack for redirection...let's not send unnecessary content
  # to the browser if a redirect header has been set.
  my $location;
  my $status = $r->headers_out->{Status} // $r->err_headers_out->{Status};

  foreach my $headers ( $r->err_headers_out, $r->headers_out ) {
    ($location) = grep {$_} $headers->{Location}, $headers->{location};

    last if $location;
  }

  if ($location) {
    $r->status($REDIRECT);
  }

  if ( defined $status && $status =~ /\A\s*(\d+)/xsm ) {
    $r->status($1);
  }

  return $final_status;
}

########################################################################
sub init_tagx {
########################################################################
  my (%args) = @_;

  my ( $file, $config, $ctx, $r ) = @args{qw(file config context request_handler)};

  my $tx = Text::TagX->new( $file, $ctx );

  $tx->options(
    INCLUDE_DIR       => $config->get_include_dir(),
    ALLOW_SNIPPET_TAG => $config->{ALLOW_SNIPPET_TAG},
    CONFIG            => $config,
  );

  # disable tags?
  if ( is_bedrock_shell($r) && $r->{OPENTAG_EXPR} ) {
    $tx->{OPENTAG_EXPR} = $r->{OPENTAG_EXPR};
  }

  $tx->param( '_request' => $r );
  $tx->param( '_version' => sprintf '%s', $VERSION );

  return $tx;
}

########################################################################
sub load_startup_modules {
########################################################################
  my ( $modules, $context, $tx, $bedrock_handler ) = @_;

  my %pre_bound_modules;

  my $handler = $context->request;

  mlogger_debug( $handler, Dumper( [ startup_modules => $modules ] ) );

  foreach my $idx ( 0 .. $#{$modules} ) {
    my $module = $modules->[$idx];

    mlogger_debug( $handler, Dumper( [ module => $module ] ) );

    $module->{type} //= 'hash';

    my $class = $module->{module};

    die sprintf q{'binding' not defined for module (%s)}, $idx
      if !$module->{binding};

    die sprintf 'invalid type (%s) in module (%s)', $module->{type}, $idx
      if !any { lc $module->{type} eq $_ } qw( hash array handle object);

    if ( any { exists $module->{$_} && $module->{$_} =~ /^y/ixsm } qw( header session ) ) {

      my $type = exists $module->{header} ? 'HEADER' : 'SESSION';

      die "multiple modules defined for $type module"
        if exists $pre_bound_modules{$type};

      $pre_bound_modules{$type} = $type;

      pre_bind_module(
        module         => $module,
        context        => $context,
        tagx           => $tx,
        pre_bound_type => $type,
      );
    }
    else {
      $tx->param(
        $module->{binding},
        sub {
          my ($symbtab) = @_;

          require_module($class);

          return bind_module(
            type    => $module->{type},
            module  => $class,
            context => $context,
            config  => $module->{config},
            tagx    => $tx
          );

        }
      );
    }

    $bedrock_handler && $bedrock_handler->log_benchmark( $module->{binding} );
  }

  return \%pre_bound_modules;
}

########################################################################
sub pre_bind_module {
########################################################################
  my (%args) = @_;

  my ( $module, $pre_bound_type, $context, $tagx ) = @args{qw(module pre_bound_type context tagx)};

  my ( $class, $type, $config, $binding ) = @{$module}{qw(module type config binding)};

  # Bind the module
  my $obj = eval { return bind_module( module => $class, type => $type || 'hash', context => $context, config => $config, ); };

  die sprintf q{could not bind module (%s) as '%s': %s}, $class, $binding, $EVAL_ERROR
    if !$obj || $EVAL_ERROR;

  # add the object to Bedrock' top frame (symbol table)
  $tagx->param( $binding => $obj );

  # tagX wants to know who the header and session object are
  $tagx->options( $pre_bound_type => $obj );

  # ...so does the context object which can be used by Bedrock::CGI
  $context->{$pre_bound_type} = $obj;

  return $TRUE;
}

########################################################################
sub is_bedrock_shell {
########################################################################
  my ($r) = @_;

  return blessed($r) eq 'Apache::Request::Shell';
}

########################################################################
sub is_mod_perl {
########################################################################
  return defined $ENV{MOD_PERL};
}

########################################################################
sub display_init_error {
########################################################################
  my ( $r, $message ) = @_;

  if ( is_bedrock_shell($r) ) {
    print {*STDERR} $message;
    exit 1;
  }

  $r->log->error($message);

  display_html_init_error( $r, $message );

  return;
}

########################################################################
sub display_html_init_error {
########################################################################
  my ( $r, $message ) = @_;

  my $safe_message = encode_entities($message);

  $r->content_type('text/html');
  $r->send_http_header;

  print <<"END_OF_HTML";
<html>
  <head>
    <title>Bedrock Initialization Error</title>
  </head>
  <body>
    <div style="color:red;">An error was encountered while trying to initialize Bedrock</div>
    <pre>
      <p>$safe_message</p>
    </pre>
  </body>
</html>
END_OF_HTML

  return;
}

########################################################################
sub display_error {
########################################################################
  my ( $r, $err, $tx ) = @_;

  if ( is_bedrock_shell($r) ) {
    display_shell_error( $err, $tx );
  }
  elsif ( $r->content_type =~ /json/xsm ) {
    if ( is_mod_perl() ) {
      # NOTE: you can set the header like this:
      #       $header.set('Status', '400 Bad Request')
      # and that will override the 500 Server Error response
      $r->status($SERVER_ERROR);
    }
    else {
      $r->content_type('application/json');
      $r->cgi_header_out( Status => '500' );
      $r->send_http_header;
    }

    chomp $err;

    print {*STDOUT} JSON->new->encode( { error => $err } );
  }
  else {
    $tx->show_error( $ENV{BEDROCK_ERROR_PAGE} );
  }

  return;
}

########################################################################
sub display_shell_error {
########################################################################
  my ( $err, $tx ) = @_;

  my $line = $tx->{error}->line;
  my $file = $tx->{error}->file;

  # error in file or pebble?
  my $source = eval {
    return slurp_file $file
      if !ref $file;

    # first call return pebble name
    my $pebble_name = $tx->pebble($file);
    return $tx->pebble($pebble_name);
  };

  my @lines = split /\n/xsm, $source;

  if ( $err !~ /\Asnippet/xsm ) {

    print {*STDERR} sprintf 'Error on line [%d] (%s) - %s', $line, $file, $err;

    # print the lines surrounding error
    if ( $line > 1 ) {
      print {*STDERR} sprintf "  [%3d] %s\n", $line - 1, $lines[ $line - 2 ];
    }

    print {*STDERR} sprintf ">>[%3d] %s\n", $line, $lines[ $line - 1 ];

    if ( $line != @lines ) {
      print {*STDERR} sprintf "  [%3d] %s\n", $line + 1, $lines[$line];
    }
  }
  else {
    print {*STDERR} $err;
  }

  return;
}

1;

__END__

=pod

=head1 NAME

Apache::Bedrock - Apache handler for serving Bedrock pages

=head1 SYNOPSIS

 <IfModule mod_perl.c>
   PerlRequire @configdir@/startup.pl
   AddHandler    perl-script .roc .jroc
   PerlHandler   Apache::Bedrock
 </IfModule>

 use Apache::Bedrock;

 Apache::Bedrock::handler->new( Apache::Request::CGI->new );

 Apache::Bedrock::handler->new( Apache::Request::Shell->new );

I<See F<bedrock.cgi> if want to see how this module can be used stand
alone.>

=head1 DESCRIPTION

Handler for parsing Bedrock files.  Can be used with Apache as a
C<mod_perl> handler or in other configurations including a shell
interpreter.

=head1 ROUTING

Bedrock includes a configuration-driven router that allows you to map application
URIs to specific Bedrock templates.

=head2 Configuration

Routes are defined in your Bedrock configuration (typically F<routes.xml>) using
Bedrock's typed XML format. You must define a C<routes> object containing an
array of route objects.

 <object name="routes">
   <array>
     <object>
       <scalar name="pattern">/user/:id</scalar>
       <scalar name="template">user_profile.roc</scalar>
     </object>

     <object>
       <scalar name="pattern">/api/search</scalar>
       <scalar name="template">api/search.jroc</scalar>
     </object>
   </array>
 </object>

=head2 Template Resolution (PEBBLE_DIR vs DOCUMENT_ROOT)

When a request matches a route, Bedrock resolves the target C<template> relative
to the configured B<PEBBLE_DIR>, not the web server's B<DOCUMENT_ROOT>.

This distinction is intentional:

=over 4

=item *

B<DOCUMENT_ROOT>: Intended for public, static assets (images, CSS, JS) and
legacy scripts that map directly to the file system.

=item *

B<PEBBLE_DIR>: The repository for your application's logic and templates.
By resolving routes against C<PEBBLE_DIR>, Bedrock keeps your application code
separate from the public web root, improving security and organization.

=back

=head2 Route Parameters

The router supports named parameters defined by a colon prefix (e.g., C<:id>).
When a route matches, these parameters are captured and passed to the
L<Bedrock::Context> object.

=cut

=head1 METHODS AND SUBROUTINES

=head2 is_bedrock_shell

Returns true if running as bedrock shell.

=head2 is_mod_perl

Returns true if running under C<mod_perl>.

=head2 load_startup_modules

 load_startup_modules(modules, context, tagx)

This method installs plugins defined in F<tagx.xml>'s C<MODULES>
section and those with configurations defined in Bedrock's plugin
configuration directories:

 {path-to-config}/config.d/plugin
 {path-to-config}/config.d/startup

Aside from the C<$header> and C<$session> objects these modules are
lazy-loaded and only are instantiated if they are used on a page.

When modules are instantiated they are passed these parameters:

=over 4

=item *

B<context>: The current C<Bedrock::Context> object.

=item *

B<config>: The module-specific configuration hash.

=item *

B<tagx>: The current C<Text::TagX> parser instance.

=back

The module objects are bound to the TagX symbol table, making them available
within your Bedrock templates using the configured binding name.

=head2 pre_bind_module

 pre_bind_module(options)

Internal method used to bind special "pre-bound" modules (specifically
C<HEADER> and C<SESSION> types) that must be available immediately, rather than
lazy-loaded.

=head1 AUTHOR

Jay Sridhar

Rob Lauer - <bigfoot@cpan.org>

=head1 SEE ALSO

L<Apache::Request::CGI>, L<Apache::Request::Shell>, L<Bedrock>,
L<Bedrock::Context>, L<Bedrock::Handler>

=cut
