package Apache::BedrockAutocomplete;

use strict;
use warnings;

use Role::Tiny::With;
with 'Bedrock::Apache::HandlerUtils';

use Apache::Bedrock qw(cache);
use Bedrock qw(slurp_file);
use Bedrock::Constants qw(:booleans :chars);
use Bedrock::Handler;
use Bedrock::Apache::Constants qw(:all);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(basename);
use JSON qw(decode_json);
use Text::URLEncode qw(Encode);

########################################################################
sub init_autocomplete {
########################################################################
  my ($bedrock_handler) = @_;

  # Load config from bedrock.xml / .bedrock_rc
  my $config = $bedrock_handler->config->{autocomplete} // {};

  # Environment overrides configuration file
  my $enabled = $config->{enabled} // $ENV{BEDROCK_AUTOCOMPLETE_ENABLED};
  $config->{enabled} = $ENV{BEDROCK_AUTOCOMPLETE_ENABLED} ? 'yes' : 'no';

  $config->{cache} //= 'yes';
  $config->{cache} = $config->{cache} =~ /^(:?yes|[y1]|true|on|enabled)$/xsmi;

  $config->{root} = $ENV{BEDROCK_AUTOCOMPLETE_ROOT} // $EMPTY;

  my $r = $bedrock_handler->request;
  $r->log->info('autocomplete configuration');
  $r->log->info('--------------------------');
  $r->log->info( sprintf '     enabled: %s', $config->{enabled} );
  $r->log->info( sprintf '        root: %s', $config->{root} );
  $r->log->info( sprintf 'cache enable: %s', $config->{cache} );

  return $config;
}

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  # Initialize Caching
  my $cache     = cache();
  my $cache_key = __PACKAGE__ . ':file_list';

  my $bedrock_handler = Bedrock::Handler->new( $r, cache => $cache );

  my $config              = $bedrock_handler->config;
  my $autocomplete_config = init_autocomplete($bedrock_handler);
  my $caching_enabled     = $autocomplete_config->{cache} && $cache;

  my $file_info;

  # ====================================================================
  # LOOKUP ORDER:
  # 1. Public (Alias/Document Root)
  # 2. Global (System-wide list)
  # 3. Session (User-specific private list)
  # ====================================================================

  # 1. Check Public Document Root
  # This serves files physically located in the directory mapped by the Alias.
  if ( -e $r->filename && !-d $r->filename ) {
    $file_info = {
      filename => $r->filename,
      mtime    => ( stat $r->filename )[9],
    };
    $r->log->debug( sprintf 'serving public file [%s]', $r->filename );
  }

  # 2. Check Global Directory
  if ( !$file_info ) {
    my $global_root = $ENV{BEDROCK_AUTOCOMPLETE_ROOT} // $autocomplete_config->{root};

    if ($global_root) {
      # Security: Use basename to prevent directory traversal
      my $clean_name  = basename( $r->filename );
      my $global_file = sprintf '%s/%s', $global_root, $clean_name;

      if ( -e $global_file ) {
        $file_info = {
          filename => $global_file,
          mtime    => ( stat $global_file )[9],
        };
        $r->log->debug( sprintf 'serving global file [%s]', $global_file );
      }
    }
  }

  # 3. Check Session (Private)
  if ( !$file_info ) {
    # We attempt to resolve the file using the session logic.
    # If the user has no session (or an invalid one), this simply fails
    # to return a file path, resulting in a natural 404.

    $file_info = eval { return get_session_file_info( $r, $TRUE ); };

    if ($file_info) {
      $r->log->debug( sprintf 'serving session file [%s]', $file_info->{filename} );
    }
  }

  # If we still don't have a file, it's a 404.
  if ( !$file_info ) {
    $r->log->error( 'File not found: ' . $r->filename );
    return set_error_status( $r, "file not found\n" );
  }

  # ====================================================================
  # PROCESSING & CACHING
  # ====================================================================

  my ( $filename, $mtime ) = @{$file_info}{qw(filename mtime)};

  my $cache_list = $caching_enabled ? $cache->get($cache_key) : {};

  my ( $list, $modified_time, $etag ) = @{ $cache_list->{$filename} }{qw(list mtime etag)};

  if ( !$list || $modified_time ne $mtime ) {

    $list = eval {
      my $content = slurp_file($filename);
      die "could not open file [$filename] for reading\n" if !$content;
      return decode_json($content);
    };

    if ( !$list || $EVAL_ERROR ) {
      my $error_msg = $EVAL_ERROR || 'Unknown error decoding JSON';
      $r->log->error("Error loading autocomplete file [$filename]: $error_msg");

      if ( defined $ENV{MOD_PERL} ) {
        $r->status($SERVER_ERROR);
      }
      else {
        $r->headers_out( Status => '500' );
      }

      $r->content_type('application/json');
      $r->send_http_header;

      my $safe_error = Encode($error_msg);
      print {*STDOUT} qq({ "error" : "$safe_error" });

      return $OK;
    }

    if ($caching_enabled) {
      $cache_list->{$filename} = {
        list  => $list,
        mtime => $mtime,
        etag  => $etag,
      };

      $cache->set( $cache_key, $cache_list );
      $r->log->debug("cache refreshed for [$filename]");
    }
  }
  else {
    $r->log->debug( sprintf 'read %s from cache', $filename );
  }

  my $result = get_result_set( $list, $autocomplete_config->{search_key} );

  $r->content_type('application/json');
  $r->send_http_header;

  print JSON->new->pretty->encode($result);

  return $OK;
}

########################################################################
sub get_result_set {
########################################################################
  my ( $list, $search_key ) = @_;

  my $query  = $ENV{QUERY_STRING} // q{};
  my ($term) = $query =~ /(?:^|&)term=([^&]*)/xsmi;
  my ($type) = $query =~ /(?:^|&)type=([^&]*)/xsmi;
  $type //= 'word';  # default match mode

  return $list if !defined $term || $term eq q{};

  $term = lc $term;
  $search_key //= 'label';

  my @matches = grep {
    my $label = lc $_->{$search_key};

        $type eq 'exact'    ? $label eq $term
      : $type eq 'prefix'   ? $label =~ /^\Q$term\E/xsm
      : $type eq 'word'     ? $label =~ /\b\Q$term\E/xsm
      : $type eq 'contains' ? index( $label, $term ) >= 0
      : 0
  } @{$list};

  return \@matches;
}

1;

__END__

=pod

=head1 NAME

Apache::BedrockAutocomplete - A handler for creating autocompletion result sets

=head1 SYNOPSIS

 cookie="session=32733cca688df39044832be9928183ed; path=/; expires=Mon, 24-Oct-2022 20:53:58 GMT;"; \
 curl -b "$cookie" http://example.com/autocomplete/clients.json?term=gro

=head1 DESCRIPTION

Implements an Apache handler that serves L<autocomplete
files|/Autocomplete Files> files from a specified directory or from
the user's session directory.  This module is typically used as part
of a web application that requires an autocomplete API.

Autcomplete files are JSON files with strings (terms) that will be
searched for when a query is sent with a term fragment.

The autocomplete API accepts two query parameters: C<term>, C<type>.

=head2 SECURITY AND LOOKUP ORDER

This handler uses a tiered lookup strategy that implicitly handles security.
It looks for the requested autocomplete file in the following order:

1.  B<Public Path:> Checks the physical path mapped to the request URL (Document Root).
2.  B<Global Directory:> If defined via C<BEDROCK_AUTOCOMPLETE_ROOT>, checks this system-wide path.
3.  B<User Session Directory:> Checks if the file exists in the authenticated user's session.

B<Security Note:> Access to session files is inherently secured by the session mechanism.
If a user does not have a valid session cookie, the handler cannot resolve the
path to their private session directory, and the file will simply be "Not Found."

=head2 CONFIGURATION FILE

You can use an optional configuration file to control certain aspects
of the handler. Create a Bedrock XML file that contains an
`autocomplete` key in Bedrock's configuration directory. See below for
allowed values.

I<NOTE: Environment variables will override values in your
configuration file.>

=over 4

=item search_key

The default search key used in your array of hashes.

default: label

=item enabled

Enable or disable the handler. Same as the environment variable
C<BEDROCK_AUTOCOMPLETE_ENABLED>.

=item cache

Set this to a true value to enable caching of the Autocomplete
files. When this is set to a true value, files will be cached using
the selected caching engine. See L<Bedrock::Cache> for more details on
caching.

=back

=over 5

=item term

Search term or term fragment.

=item type

Using the API you can search for terms in one of four modes:

=over 10

=item exact

Only exact matches will be returned.

=item prefix

Terms that begin with the search string are returned.

=item word

Terms that have any word that begins with the search string are returned.

Example:

If the search term is "blu" and you list of terms contains "Bluebird"
and "Eastern Bluebird", then both terms would be returned.

=item contains

Returns any term that matches anywhere in the list of terms.

=back

=back

=head1 INSTALLATION NOTES

Follow these steps to implement an autocompletion service on your
Apache server.

=head2 1. Set Up the Apache Handler

  # if not using mod_perl
  Action bedrock-autocomplete /cgi-bin/bedrock-autocomplete.cgi virtual

  Alias /autocomplete /var/www/autocomplete

  <Directory /var/www/autocomplete>
    AcceptPathInfo On
    Options -Indexes
  
    <IfModule perl_module>
      SetHandler perl-script
      PerlHandler Apache::BedrockAutocomplete
      
      # Optional: Define a global autocomplete directory
      # PerlSetEnv BEDROCK_AUTOCOMPLETE_ROOT /opt/bedrock/global_lists
    </IfModule>
  
    <IfModule !perl_module>
      SetHandler bedrock-autocomplete
    </IfModule>
  
  </Directory>

You can configure the handler for use with C<mod_perl> or as a CGI script.

To use the CGI version, copy the CGI handler to your F</cgi-bin>
directory.

 cp /var/www/cgi-bin/bedrock.cgi /var/www/cgi-bin/bedrock-autocomplete.cgi
 chmod +x /var/www/cgi-bin/bedrock-autocomplete.cgi
 chown apache:apache /var/www/cgi-bin/bedrock-autocomplete.cgi

=head2 2. Create a Session Directory

The C<Apache::BedrockAutocomplete> handler reads a JSON file that is
stored in a user's session directory or in the autocomplete directory.

Assuming you have configured user sessions using something similar to
L<BLM::Startup::UserSession>, user session directories can be created
using the C<$session> object's C<create_session_dir()> method. This
creates a directory (outside of the webserver's C<DOCUMENT_ROOT>)
that is specific to the user's session.

Only the user associated with that session will be able to access files
from that session directory. Recall that to implement persistent
sessions in the first place, users should have cookies enabled.

You place an appropriately formatted file in that directory and then
access the session url (F</autocomplete/filename.jroc>).

You can also used use the C<create_session_file()> method to create the
file.

=head2 3. Create an Autocomplete File

Create a JSON autocomplete file and place it in your user's session
directory.

 <sink:list>
 [ 
  { "label" : "Bedrock", "value" : "1" },
  { "label" : "Perl",    "value" : "2"}
 ]
 </sink>

 <null $session.create_session_file("items.json", $list)>

The autocomplete URL then becomes
C<http://your-host/autocomplete/items.json>.  You do not need to
include the extension if it is a F<.json> file. The handler first
looks in the user's session directory if a session cookie is
available.  If the file is not found in the user's session directory
then the handler will look in the directory specified when configured
the handler.

=head1 Autocomplete Files

The format of file is really up to you based on how you expect to
process the file on the client side. If you use the F<.jroc>
extension, the handler will return the result set with an
I<application/json> content type header.

Typically, an autocomplete file looks some like this if you are using
jQuery's autocomplete facility:

 [
  { "label" : "Bedrock", "value" : "1" },
  { "label" : "Perl",    "value" : "2"}
 ]

I<From jQuery's documentation:>

B<Multiple types supported:>

    * Array: An array can be used for local data. There are two supported formats:

      * An array of strings: [ "Choice1", "Choice2" ]

      * An array of objects with label and value properties: [ { label: "Choice1", value: "value1" }, ... ]

      The label property is displayed in the suggestion menu. The
      value will be inserted into the input element when a user
      selects an item. If just one property is specified, it will be
      used for both, e.g., if you provide only value properties, the
      value will also be used as the label.

=head1 jQuery AUTOCOMPLETE EXAMPLE

   $('#search').autocomplete({
       source: function(request, response) {
           $.ajax({
               url: 'http://localhost:8080/autocomplete/birds',
               dataType: 'json',
               data: {
                   term: request.term,
                   type: getMatchType()
               },
               success: function(data) {
                   console.log(dat);
               },
               error: function(xhr, status, error) {
                   console.error('Autocomplete error:', error);
                   response([]);
               }
           });
       },
       minLength: 1
   });

=head1 SEE ALSO

L<Bedrock::Handler>, L<Bedrock::Apache::Request::CGI>, L<BLM::Startup::UserSession>

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
