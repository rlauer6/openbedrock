#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Request_cgi;

use strict;
use warnings;

use File::Basename;
use Bedrock::Constants qw{:booleans};
use Data::Dumper;

use List::Util qw{pairs};

use Role::Tiny::With;
with 'Bedrock::Logger';

use Readonly;

Readonly::Hash our %LEVELS => (
  'error' => 3,
  'warn'  => 2,
  'info'  => 1,
  'debug' => 0,
);

Readonly::Hash our %MIME_TYPES => (
  htm  => 'text/html',
  jpeg => 'image/jpeg',
  jpg  => 'image/jpeg',
  jroc => 'application/json',
  pdf  => 'application/pdf',
  png  => 'image/png',
  roc  => 'text/html',
  tif  => 'image/tiff',
  txt  => 'text/plain',
);

########################################################################
sub new {
########################################################################
  my ($class) = @_;

  return bless {}, $class;
}

########################################################################
sub get_loglevel {
########################################################################
  return $LEVELS{ get_loglevel_str() };
}

########################################################################
sub get_loglevel_str {
########################################################################
  return $ENV{BedrockLogLevel} || 'info';
}

########################################################################
sub log_message {
########################################################################
  my ( $self, $logmsg, $level ) = @_;

  my %NUMERIC_LEVELS = reverse %LEVELS;
  $level = $NUMERIC_LEVELS{$level};

  return $self->get_logger->$level($logmsg);
}

########################################################################
sub _log {
########################################################################
  my ( $level, $self, @args ) = @_;

  return $self->get_logger->$level(@args);
}

########################################################################
sub log_trace { my (@args) = @_; return _log( 'trace', @args ) }
sub log_debug { my (@args) = @_; return _log( 'debug', @args ) }
sub log_info  { my (@args) = @_; return _log( 'info',  @args ) }
sub log_warn  { my (@args) = @_; return _log( 'warn',  @args ) }
sub log_error { my (@args) = @_; return _log( 'error', @args ) }
sub log_fatal { my (@args) = @_; return _log( 'fatal', @args ) }

sub debug { goto &log_debug; }
sub error { goto &log_error; }
sub info  { goto &log_info; }
sub warn  { goto &log_warn; }  ## no critic (ProhibitBuiltinHomonyms)

########################################################################

########################################################################
sub log {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  return shift->get_logger;
}

# note: we probably don't want to pollute Bedrock with magic mime-type
# checking, so we'll keep it simple
########################################################################
sub content_type {
########################################################################
  my ( $self, $type ) = @_;

  if ( defined $type ) {
    $self->cgi_header_out( 'Content-type', $type );

    return $type;
  }
  else {
    return 'application/octet-stream'
      if !defined $ENV{PATH_TRANSLATED};
  }

  my ( $name, $path, $ext )
    = fileparse( $ENV{PATH_TRANSLATED}, qr/[.][^.]+$/xsm );

  my $mime_type = $MIME_TYPES{$ext} // 'application/octet-stream';

  return $mime_type;
}

########################################################################
sub filename {
########################################################################
  my ( $self, $file ) = @_;

  return $self->finfo($file);
}

########################################################################
sub finfo {
########################################################################
  my ( $self, $file ) = @_;

  my $path_xlated = $file || $ENV{PATH_TRANSLATED};

  # roc[k] file?
  if ( $path_xlated && $path_xlated =~ /[.]j?rock?$/xsm ) {
    return $path_xlated;
  }

  # roc[k] file with path info?
  elsif ( $path_xlated && $path_xlated =~ /^(.*[.]j?rock?)(\/.*?)$/xsm ) {
    my $filename = $1;

    if ($2) {
      $ENV{BEDROCK_PATH_INFO} = $2;
    }

    if ( $ENV{BEDROCK_PATH_INFO} ) {
      $ENV{BEDROCK_PATH_TRANSLATED} = sprintf '%s%s', $ENV{DOCUMENT_ROOT},
        $ENV{BEDROCK_PATH_INFO};
    }

    return $filename;
  }

  # html or other file?
  elsif ( $ENV{PATH_INFO} && $ENV{PATH_INFO} =~ /^(.*)([.][^.]*)$/xsm ) {
    return $path_xlated;
  }

  # Bedrock controller? directory?
  else {
    return;  # could be Bedrock controller
  }
}

########################################################################
sub uri {
########################################################################
  return $ENV{PATH_INFO};
}

########################################################################
sub headers_in {
########################################################################
  use CGI;

  my $cgi = CGI->new;

  my %http_vars = map { $_ => $cgi->http($_) } $cgi->http();

  foreach my $p ( pairs %http_vars ) {
    my ( $key, $value ) = @{$p};
    $key =~ s/^HTTP_//xsm;

    $http_vars{$key} = $value;

    delete $http_vars{ 'HTTP_' . $key };
  }

  return \%http_vars;
}

########################################################################
sub is_cgi          { return $TRUE }
sub header_out      { goto &cgi_header_out; }
sub headers_out     { goto &cgi_header_out; }
sub err_headers_out { goto &cgi_header_out; }
########################################################################

########################################################################
sub cgi_header_out {
########################################################################
  my ( $self, @headers ) = @_;

  if (@headers) {
    foreach my $p ( pairs @headers ) {
      my ( $header, $value ) = @{$p};

      $self->{headers} .= "$header: $value\r\n";
    }
  }

  return $self->{headers};
}

########################################################################
sub send_http_header {
########################################################################
  my ($self) = @_;

  if ( $self->{headers} ) {
    print $self->{headers}, "\r\n";
  }

  $self->{headers} = undef;

  return;
}

########################################################################
sub close {  ## no critic (ProhibitBuiltinHomonyms, ProhibitAmbiguousNames)
########################################################################
  return close STDOUT;
}

########################################################################
sub print {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return print @args;
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 NAME

C<Apache::Bedrock::Request_cgi>

=head1 SYNOPSIS

  # CGI handlers
  Action        bedrock-cgi  /cgi-bin/bedrock.cgi virtual
  
  AddHandler    bedrock-cgi .rock .jrock
  
  # Bedrock - mod-perl for .roc (if mod_perl)
  <IfModule mod_perl.c>
    PerlRequire /usr/lib/bedrock/config/startup.pl
    AddHandler    perl-script .roc .jroc
    PerlHandler   Apache::Bedrock
  </IfModule>
  
  <IfModule !mod_perl.c>
    AddHandler  bedrock-cgi .roc .jroc
  </IfModule>

=head1 DESCRIPTION

Provides a CGI (non mod_perl) version of Bedrock.

=head1 METHODS

=head2  new

=head2  print

=head2  close

=head2  filename

=head2  finfo

=head2  is_cgi

=head2  uri

=head1 HEADER METHODS

=head2  content_type

=head2  cgi_header_out

 cgi_header_out( header, value, ...)

 my $headers = cgi_header_out()

Sets or returns the headers to be sent to client.

=head2  headers_out

See L</cgi_header_out>

=head2  header_out

See L</cgi_header_out>

=head2  err_headers_out

See C</cgi_header_out>

=head2  headers_in

Returns the HTTP headers received from client.

=head2  send_http_header

Outputs the HTTP headers to STDOUT.

=head1 LOGGING METHODS

Logging is done using Log::Log4perl.

By default the L<Bedrock::Context> constructor will initialize logging
by looking for a F<log4perl.conf> file in Bedrock's configuration
path.

See L<Bedrock::Context> for details on how to configure logging.

=head2  get_loglevel

Returns a numberic log level based on the current logging level
defined by the environment variable C<BedrockLogLevel>.

 0 => debug
 1 => info
 2 => warn
 3 => error

default: 1 (info)

=head2  get_loglevel_str

Returns the logging level as a string.

=head2  log

Returns a Log::Log4perl logger.

=head2  debug

 $r->debug('...')

Write log message at C<debug> level.

=head2  info

 $r->info('...')

Write log message at C<info> level.

=head2  warn

 $r->warn('...')

Write log message at C<warn> level.

=head2  error

 $r->error('...')

Write log message at C<error> level.

=head2  log_debug

See L</debug>

=head2  log_error

See L</error>

=head2  log_info

See L</info>

=head2  log_warn

See L</warn>


=cut

1;
