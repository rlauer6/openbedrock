#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Apache::Request_cgi;

use strict;
use warnings;

use File::Basename;
use Bedrock::Constants qw{:booleans};

use List::Util qw{pairs};

use Role::Tiny::With;
with 'Bedrock::Logger';

use Readonly;

Readonly::Hash our %LEVELS => (
  'error' => 3,
  'warn'  => 2,
  'info'  => 1,
  'debug' => 0,
);

Readonly::Hash our %MIME_TYPES => (
  htm  => 'text/html',
  jpeg => 'image/jpeg',
  jpg  => 'image/jpeg',
  jroc => 'application/json',
  pdf  => 'application/pdf',
  png  => 'image/png',
  roc  => 'text/html',
  tif  => 'image/tiff',
  txt  => 'text/plain',
);

########################################################################
sub new {
########################################################################
  my ($class) = @_;

  return bless {}, $class;
}

########################################################################
sub get_loglevel {
########################################################################
  return $LEVELS{ get_loglevel_str() };
}

########################################################################
sub get_loglevel_str {
########################################################################
  return $ENV{BedrockLogLevel} || 'info';
}

########################################################################
sub log_message {
########################################################################
  my ( $self, $logmsg, $level ) = @_;

  my %NUMERIC_LEVELS = reverse %LEVELS;
  $level = $NUMERIC_LEVELS{$level};

  return $self->get_logger->$level($logmsg);
}

########################################################################
sub _log {
########################################################################
  my ( $level, $self, @args ) = @_;

  return $self->get_logger->$level(@args);
}

########################################################################
sub log_trace { my (@args) = @_; return _log( 'trace', @args ) }
sub log_debug { my (@args) = @_; return _log( 'debug', @args ) }
sub log_info  { my (@args) = @_; return _log( 'info',  @args ) }
sub log_warn  { my (@args) = @_; return _log( 'warn',  @args ) }
sub log_error { my (@args) = @_; return _log( 'error', @args ) }
sub log_fatal { my (@args) = @_; return _log( 'fatal', @args ) }

sub debug { goto &log_debug; }
sub error { goto &log_error; }
sub info  { goto &log_info; }
sub warn  { goto &log_warn; }  ## no critic (ProhibitBuiltinHomonyms)

########################################################################

########################################################################
sub log {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ($self) = @_;

  return $self;
}

# note: we probably don't want to pollute Bedrock with magic mime-type
# checking, so we'll keep it simple
########################################################################
sub content_type {
########################################################################
  my ( $self, $type ) = @_;

  if ( defined $type ) {
    $self->cgi_header_out( 'Content-type', $type );

    return $type;
  }
  else {
    return 'application/octet-stream'
      if !defined $ENV{PATH_TRANSLATED};
  }

  my ( $name, $path, $ext )
    = fileparse( $ENV{PATH_TRANSLATED}, qr/[.][^.]+$/xsm );

  my $mime_type = $MIME_TYPES{$ext} // 'application/octet-stream';

  return $mime_type;
}

########################################################################
sub filename {
########################################################################
  my ( $self, $file ) = @_;

  return $self->finfo($file);
}

########################################################################
sub finfo {
########################################################################
  my ( $self, $file ) = @_;

  my $path_xlated = $file || $ENV{PATH_TRANSLATED};

  # roc[k] file?
  if ( $path_xlated && $path_xlated =~ /[.]j?rock?$/xsm ) {
    return $path_xlated;
  }

  # roc[k] file with path info?
  elsif ( $path_xlated && $path_xlated =~ /^(.*[.]j?rock?)(\/.*?)$/xsm ) {
    my $filename = $1;

    if ($2) {
      $ENV{BEDROCK_PATH_INFO} = $2;
    }

    if ( $ENV{BEDROCK_PATH_INFO} ) {
      $ENV{BEDROCK_PATH_TRANSLATED} = sprintf '%s%s', $ENV{DOCUMENT_ROOT},
        $ENV{BEDROCK_PATH_INFO};
    }

    return $filename;
  }

  # html or other file?
  elsif ( $ENV{PATH_INFO} && $ENV{PATH_INFO} =~ /^(.*)([.][^.]*)$/xsm ) {
    return $path_xlated;
  }

  # Bedrock controller? directory?
  else {
    return;  # could be Bedrock controller
  }
}

########################################################################
sub uri {
########################################################################
  return $ENV{PATH_INFO};
}

########################################################################
sub headers_in {
########################################################################
  use CGI;

  my $cgi = new CGI->new;

  my %http_vars = map { $_ => $cgi->http($_) } $cgi->http();

  foreach my $p ( pairs %http_vars ) {
    my ( $key, $value ) = @{$p};
    $key =~ s/^HTTP_//xsm;

    $http_vars{$key} = $value;

    delete $http_vars{ 'HTTP_' . $key };
  }

  return \%http_vars;
}

########################################################################
sub is_cgi {
########################################################################
  return $TRUE;
}

########################################################################
sub header_out {
########################################################################
  return cgi_header_out();
}

########################################################################
sub err_headers_out {
########################################################################
  return {};
}

########################################################################
sub cgi_header_out {
########################################################################
  my ( $self, $header, $value ) = @_;

  return
    if !$header || !$value;

  return $self->{'headers'} .= "$header: $value\r\n";
}

########################################################################
sub send_http_header {
########################################################################
  my ($self) = @_;

  print $self->{'headers'}, "\r\n";

  $self->{'headers'} = undef;

  return;
}

########################################################################
sub close {  ## no critic (ProhibitBuiltinHomonyms, ProhibitAmbiguousNames)
########################################################################
  return close STDOUT;
}

########################################################################
sub print {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return print @args;
}

1;

__END__
  
=pod

=head1 NAME

C<Apache::Bedrock::Request_cgi>

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 METHODS

=head2 filename


=head2 finfo

=cut

1;
