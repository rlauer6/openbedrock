########################################################################
package Bedrock::Service;
########################################################################

use strict;
use warnings;

use Bedrock qw(:booleans resolve_stream choose to_snake_case);
use Bedrock::Constants qw(:chars :booleans :http);
use Bedrock::Context;
use Bedrock::Exception;
use Bedrock::Error qw(handle_error);
use Bedrock::Handler;
use Bedrock::Hash;
use Bedrock::LoadConfig qw(load_config);
use Bedrock::Service::CLI;

use Benchmark;
use Carp;
use Cwd qw(getcwd abs_path);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename;
use FindBin; ## no critic
use Getopt::Long qw(GetOptions);
use JSON;
use List::Util qw(uniq pairs);
use Module::Load;
use Scalar::Util qw(reftype blessed);
use Text::TagX;
use TagX::Output;
use Text::URLEncode qw(Htmlencode);
use Time::HiRes qw(time);
use YAML::Tiny;

use Role::Tiny::With;
with 'Bedrock::Logger';

use Readonly;

Readonly::Scalar our $BOLD      => 'font-weight:800';
Readonly::Scalar our $RED       => 'color:red';
Readonly::Scalar our $FONT_SIZE => 'font-size:125%';
Readonly::Scalar our $MARGIN    => 'margin:10px';
Readonly::Scalar our $PURPLE    => 'color:purple';

our $VERSION = '@PACKAGE_VERSION@';

use parent qw(Exporter Class::Accessor);

our @EXPORT_OK = qw(
  $BOLD $FONT_SIZE $MARGIN $PURPLE $RED
  attribute choose element element_end element_start raise style
);

our %EXPORT_TAGS = ( all => [@EXPORT_OK] );

__PACKAGE__->mk_accessors(
  qw(
    autoflush
    bedrock_handler
    cache
    cgi
    config
    context
    cookieless
    dispatch_action
    dispatch_map
    headers
    output_buffer
    output_handle
    request
    service_config
    session
    tagx
  )
);

########################################################################
sub handler : method {
########################################################################
  my ( $class_or_self, $r ) = @_;

  my $t0 = Benchmark->new;

  # 1. CLI / Testing Mode
  if ( !defined $r && !is_web() ) {
    my $cli_obj = blessed($class_or_self) ? $class_or_self : $class_or_self->new();
    return $cli_obj->handle_cli();
  }

  my $t1 = Benchmark->new;

  # 2. Web Mode
  my $self = choose {

    return $class_or_self
      if blessed($class_or_self) && $class_or_self->isa(__PACKAGE__);

    return $class_or_self->new( request => $r );
  };

  my $t2 = Benchmark->new;
  my $td = timediff( $t2, $t1 );

  # In Miniserver mode, $r is Apache::Request::CGI, which has a hardcoded
  # logger that prints to STDERR in a fixed format. We want to bypass that
  # and use Log4perl directly to maintain formatting consistency.
  my $logger;

  if ( $r && $r->isa('Apache::Request::CGI') && $ENV{SERVER_SOFTWARE} =~ /simple/xmsi ) {
    # Miniserver: Bypass $r->log
    $logger = Log::Log4perl->get_logger( ref($self) || 'Bedrock::Service' );
  }
  else {
    # Apache/mod_perl/mod_cgi: Use the Request logger (wraps Apache logging)
    $logger = $r ? $r->log : $self->request->log;
  }

  $logger->debug( sprintf 'handler setup complete: (%s)', timestr($td) );

  $t1 = $t2;

  # 3. SAFETY NET: Inject Request if Missing
  if ( $r && !$self->request ) {
    $self->request($r);
    $self->content_type('text/html');
    $self->init_request_dependent_objects();
  }

  $t2 = Benchmark->new;
  $td = timediff( $t2, $t1 );
  $t1 = $t2;

  $logger->debug( sprintf 'request setup complete: (%s)', timestr($td) );

  my $status = eval { return $self->dispatch() };
  my $err    = $EVAL_ERROR;

  $t2 = Benchmark->new;
  $td = timediff( $t2, $t1 );
  $logger->notice( sprintf 'dispatch complete: (%s)', timestr($td) );

  if ($err) {
    $self->handle_exception($EVAL_ERROR);
  }

  # Explicit flush ONLY.
  $self->flush_output();

  return 0;
}

########################################################################
sub is_api {
########################################################################
  my ($self) = @_;

  return
    if !$self->request;

  my $accept = $self->request->headers_in('ACCEPT');

  return $accept =~ /json/xsmi;
}

########################################################################
sub init_request_dependent_objects {
########################################################################
  my ($self) = @_;

  return
    if !$self->request;

  if ( !$self->bedrock_handler ) {
    my $bedrock_handler = Bedrock::Handler->new( $self->request, $self->cache ? ( cache => Bedrock::cache() ) : () );

    $self->bedrock_handler($bedrock_handler);

    my $config = $bedrock_handler->get_config;

    # --- SERVICE CONFIG INJECTION ---
    # We inspect the service_config object injected by the miniserver
    # for overrides and merge them directly into the active Bedrock config.
    if ( my $sc = $self->service_config ) {
      if ( my $overrides = is_hash( $sc->{overrides} ) ) {
        @{$config}{ keys %{$overrides} } = values %{$overrides};
      }
    }

    $self->config($config);
  }

  if ( !$self->context ) {
    my $route_params = $self->dispatch_map ? $self->init_route : {};

    $self->context(
      Bedrock::Context->new(
        REQUEST_HANDLER => $self->request,
        CONFIG          => $self->config,
        route_params    => $route_params,
      )
    );
  }

  $self->init_input;

  return;
}

########################################################################
sub new {
########################################################################
  my ( $class, %options ) = @_;

  $options{config}    //= delete $options{CONFIG};
  $options{session}   //= delete $options{SESSION};
  $options{autoflush} //= $FALSE;
  $options{cache}     //= $TRUE;

  foreach ( keys %options ) { $options{ lc $_ } = $options{$_}; }

  my $self = $class->SUPER::new( \%options );

  if ( !$self->request && !$ENV{MOD_PERL} ) {
    require Apache::Request::CGI;
    local @ARGV = ();
    $self->request( Apache::Request::CGI->new( output_handle => $self->output_handle ) );
  }

  if ( $self->request ) {
    $self->init_request_dependent_objects();
  }

  $self->clear;

  return $self
    if !is_web();

  $self->init_headers;

  $self->content_type( $self->is_api ? 'application/json' : 'text/html' );

  return $self;
}

########################################################################
sub param { return shift->context->param(@_); }
########################################################################

########################################################################
sub routes {
########################################################################
  my ($self) = @_;

  # Return a shallow copy to prevent accidental modification
  return { %{ $self->dispatch_map // {} } };
}

########################################################################
sub dispatch {
########################################################################
  my ($self) = @_;

  my $action = $self->dispatch_action;

  if ( !$action ) {
    # this solely for displaying an error message
    if ( $self->dispatch_map ) {
      my $uri = choose {
        return $self->request->uri
          if $self->request && $self->request->can('uri');

        return $ENV{REQUEST_URI} || 'UNKNOWN';
      };

      $self->log->warn( sprintf 'No route matched for URI [%s]', $uri );
      return $self->display_error( 'Not Found', $HTTP_NOT_FOUND );
    }

    # we may want to trap this condition...a service that has no
    # action?
    return;
  }

  return $self->$action()
    if $self->can($action);

  $self->log->error( sprintf 'Route resolved to action [%s] but method not found in %s', $action, ref $self );

  return $self->display_error( 'Method Not Implemented', $HTTP_NOT_IMPLEMENTED );
}

########################################################################
sub init_route {
########################################################################
  my ($self) = @_;

  my $r = $self->request;

  return
    if !$r;

  require Bedrock::Router;

  my $uri = ( $r->can('uri') ? $r->uri : undef ) || $ENV{REQUEST_URI};

  my $path = choose {

    return ( $r->can('path_info') ? $r->path_info : undef ) || $ENV{PATH_INFO}
      if !$uri;

    my $path   = $uri;
    my $script = $ENV{SCRIPT_NAME} // $EMPTY;

    if ( $script && index( $path, $script ) == 0 ) {
      $path = substr $path, length $script;
    }

    return $path;
  };

  $path //= q{/};

  if ( my $base_uri = $ENV{BEDROCK_BASE_URI} // $ENV{REDIRECT_BEDROCK_BASE_URI} ) {
    if ( index( $path, $base_uri ) == 0 ) {
      substr $path, 0, length($base_uri), $EMPTY;
      # Ensure we still have a leading slash if we stripped everything
      if ( $path eq $EMPTY ) {
        $path = $SLASH;
      }
    }
  }

  my $map = $self->dispatch_map;
  my @routes;

  foreach my $p ( pairs %{$map} ) {
    my ( $pattern, $method ) = @{$p};
    push @routes, { pattern => $pattern, method => $method };
    next if $pattern !~ m{^(.+)/:[^/]+$}xsm;

    my $base = $1;

    next
      if exists $map->{$base};

    push @routes, { pattern => $base, method => $method };
  }

  return
    if !@routes;

  my $match = Bedrock::Router->new( { routes => \@routes } )->match($path);

  if ( !$match ) {
    $self->log->warn("No route match for path: [$path]");
    return;
  }

  my ( $pattern, $method, $params ) = @{$match}{qw(pattern method params)};
  $self->dispatch_action("action_$method");

  return $params;
}

########################################################################
sub handle_cli {
########################################################################
  my ($self) = @_;

  return Bedrock::Service::CLI::main();
}

########################################################################
sub parse {
########################################################################
  my ( $self, $thing, %args ) = @_;

  my $on_error = delete $args{on_error};

  my $fh = eval { return resolve_stream($thing); };

  if ($EVAL_ERROR) {
    if ( defined $on_error && $on_error eq 'return' ) {
      $self->log->error("Template Setup Error: $EVAL_ERROR");
      return;
    }

    Bedrock::Exception->new(
      message => "Template Setup Error: $EVAL_ERROR",
      type    => 'template_setup',
      payload => { input => $thing }
    )->throw;
  }

  my $output = $EMPTY;
  open my $output_fh, '>', \$output ## no critic
    or die "could not open scalar ref for writing\n";

  my $tx = Text::TagX->new( $fh, $output_fh );
  $self->tagx($tx);

  my $session = choose {
    return delete $args{session}
      if $args{session};

    return $self->get('session')
      if $self->get('session');

    return $self->context->session
      if $self->context->session;

    return sub { return $self->session };
  };

  $tx->param( session => $session );
  $args{input}   //= $self->context->input;
  $args{config}  //= $self->context->config;
  $args{context} //= $self->context;
  $args{env} = Bedrock::Hash->new(%ENV);

  map { $tx->param( $_ => $args{$_} ) } keys %args;

  eval { $tx->output; };

  my $proc_err = $EVAL_ERROR;

  $tx->close;
  $output_fh->close;

  my $source;
  {
    seek $fh, 0, 0;
    local $RS = undef;
    $source = <$fh>;
  }

  # we should probably close this always...
  if ( $fh && !ref $thing ) {
    close $fh;
  }

  if ($proc_err) {
    my $line_number;
    my $tagx_error_obj;

    if ( $tx->can('error') ) {
      $tagx_error_obj = $tx->error;

      if ( $tagx_error_obj && ref($tagx_error_obj) && @{$tagx_error_obj} ) {
        $line_number = $tagx_error_obj->[0]->{line};
      }
    }

    if ( $line_number && $proc_err !~ /line/xsmi ) {
      $proc_err .= " at line $line_number";
    }

    if ( defined $on_error && $on_error eq 'return' ) {
      $self->log->error("Template Render Error: $proc_err");
      return;
    }

    if ( ref($on_error) eq 'CODE' ) {
      my $ex = Bedrock::Exception->new(
        message => $proc_err,
        type    => 'template_render',
        payload => { input => $thing }
      );

      return $on_error->($ex);
    }

    die Bedrock::Exception->new(
      message => $proc_err,
      type    => 'template_render',
      payload => { input => $source }
    );
  }

  return $output;
}

########################################################################
sub init_headers {
########################################################################
  my ($self) = @_;

  return
    if !$self->request;

  my $headers = $self->headers;

  return $self->set_content_type
    if !$headers || !ref $headers;

  my @header_list = is_hash($headers) ? %{$headers} : @{$headers};

  my $table = $self->request->headers_out;

  foreach my $p ( pairs @header_list ) {
    my ( $k, $v ) = @{$p};
    $table->set( $k => $v );
  }

  return;
}

########################################################################
sub set_content_type {
########################################################################
  my ($self) = @_;

  return
    if !$self->request;

  my $content_type = $self->content_type // 'text/html';
  $self->content_type($content_type);

  if ( $self->request->can('content_type') ) {
    $self->request->content_type($content_type);
  }
  elsif ( $ENV{MOD_PERL} ) {
    my $table = eval { $self->request->headers_out };
    if ( $table && ref $table ) {
      $table->set( 'Content-Type' => $content_type );
    }
  }
  else {
    $self->request->headers_out( 'Content-type', $content_type );
  }
  return $content_type;
}

########################################################################
sub display_error {
########################################################################
  my ( $self, $message, $status ) = @_;

  $status //= $HTTP_INTERNAL_SERVER_ERROR;

  if ( $self->request && $self->request->can('status') ) {
    $self->request->status($status);
  }

  return $self->print_json( { error => $message, status => $status } )
    if $self->content_type && $self->content_type =~ /json/xsm;

  return $self->print($message);
}

########################################################################
sub handle_exception {
########################################################################
  my ( $self, $err ) = @_;

  $self->request->log->error( Dumper( [ error => $err ] ) );

  my $html = choose {
    if ( !blessed $err ) {
      my $message = <<"END_OF_HTML";
<h1>$HTTP_INTERNAL_SERVER_ERROR Internal Server Error</h1>
<p>Unhandled Crash:</p>
<pre>$err</pre>
END_OF_HTML
      return $message;
    }

    return $self->check_error( $err->message, $err->payload->{input} )
      if $err->type eq 'template_render' || $err->type eq 'template_setup';

    return $err->message;
  };

  return $self->display_error( $html, $HTTP_INTERNAL_SERVER_ERROR );
}

########################################################################
sub check_error {
########################################################################
  my ( $self, $eval_error, $source_input ) = @_;

  return
    if !$eval_error;

  $self->clear;

  my $tx = $self->tagx;

  return Bedrock::Error::handle_error( $self->request, $eval_error )
    if !$tx;

  # do some magic to get nice error page when we are parsing Bedrock

  # create a version thingy...
  no strict 'refs'; ## no critic

  my $thingy = bless {}, 'thingy';
  *{'thingy::version'} = sub { return $VERSION };

  my $buffer = $EMPTY;

  my $io = IO::Scalar->new( \$buffer );

  $self->context->output_handler($io);
  $tx->out_handle( TagX::Output->new( $self->context ) );

  $tx->param( bedrock => $thingy, config => $self->config );
  $tx->error->file('template');
  $tx->error->source($source_input);

  Bedrock::Error::handle_error( $self->request, $eval_error, $tx );

  return $buffer;
}

########################################################################
sub session {
########################################################################
  my ( $self, @args ) = @_;

  # $self->session(session-object)
  if ( @args == 1 && ref $args[0] ) {
    if ( !is_array( $args[0] ) ) {
      my $ref = $args[0];
      $self->set( session => $ref );
      return $ref;
    }
  }

  my $session = $self->get('session');

  # initialize session if no session yet
  if ( !$session ) {
    $session = $self->init_session();

    if ($session) {
      $self->set( session => $session );
      $self->context->session($session);
    }
  }

  return
    if !$session;

  return $session
    if !@args;

  return $session->{ $args[0] }
    if @args == 1;

  return $session->{ $args[0] } = $args[1]
    if @args > 1;

  my $ref = $args[0];

  return @{$session}{ @{$ref} }
    if is_array($ref);

  return $session;
}

########################################################################
sub init_session {
########################################################################
  my ($self) = @_;

  my $config = $self->config;  # global config (probably at least tagx.xml)
  my $service_config = $self->service_config;

  # 1. Find a session manager if we can
  my ( $session_config, $session_manager ) = choose {
    if ($service_config) {
      if ( my $session_config = $service_config->{session} ) {
        return $session_config->{config}, $session_config->{module};
      }
    }

    return q{}, $ENV{BEDROCK_SESSION_MANAGER} // $config->{BEDROCK_SESSION_MANAGER};
  };

  # 2. It's ok if we have no session manager, not all services require them
  if ( !$session_manager ) {
    $self->request->log->warn('No session manager defined.');
    return;
  }

  if ( !$session_config ) {
    $session_config = eval { $self->_find_session_config($session_manager); };
  }

  croak "ERROR: error trying to load session configuration file.\n$EVAL_ERROR"
    if !$session_config || $EVAL_ERROR;

  croak "ERROR: You defined a session manager ($session_manager) but I can't find its configuration?\n"
    if !$session_config;

  # the service itself may have told us about cookies
  $session_config->{cookieless_sessions} //= $self->cookieless;

  my $class = $session_manager =~ /\ABLM::Startup::/xsm ? $session_manager : "BLM::Startup::$session_manager";

  load $class;

  my $session = $class->new( $self->context, $session_config );

  $self->context->session($session);

  return $session;
}

########################################################################
sub _find_session_config {
########################################################################
  my ( $self, $session_manager ) = @_;

  my $config = $self->has_bedrock_config;

  ########################################################################
  # 3. All session managers MUST have a configuration
  #   a. See if our global configuration MODULES array has a configuration for us
  #   b. If we don't have a session configuration then we might still find one in Bedrock's
  #      configuration path?
  #   c. If see are using miniserver's default session manager (MemorySession) and no
  #      configuration is found in the miniserver's configuration, make one up, cuz it's not
  #      got a lot of options
  ########################################################################

  my $session_config = $config->get_module_config($session_manager);

  return $session_config
    if $session_config;

  my ($config_name) = $session_manager =~ /::([^:]+)\z/xsm;
  $config_name = to_snake_case($config_name);

  my @paths = grep {defined} ( getcwd, $ENV{CONFIG_PATH}, $ENV{BEDROCK_CONFIG_PATH} );
  my $config_file;

  foreach my $p (@paths) {
    my $candidate = sprintf '%s/%s', $p, $config_name;
    ($config_file) = grep { -e $_ } map {"$candidate/$_"} qw(.xml .yml .yaml .json);
    last if $config_file;
  }

  return load_config($config_file)
    if $config_file;

  if ( $session_manager =~ /MemorySession/xsm ) {
    return {
      table_name          => 'session',
      'expiry_secs'       => 86_400,
      param               => 'session',
      log_level           => 'info',
      persistence_enabled => 'no',
    };
  }

  return;
}

########################################################################
sub has_bedrock_config {
########################################################################
  my ($self) = @_;

  if ( my $config = $self->config ) {
    return $config
      if blessed($config) && $self->config->can('get_module_config');
  }

  return;
}

########################################################################
sub init_input {
########################################################################
  my ($self) = @_;

  my $config = $self->has_bedrock_config;

  my $class = 'BLM::Startup::Input';

  eval { load $class };

  if ($EVAL_ERROR) {
    $self->get_logger->warn("Could not load $class: $EVAL_ERROR");
    return;
  }

  my $input = eval { return $class->new( $self->context, $config->get_module_config('Input') ); };

  if ( $EVAL_ERROR || !$input ) {
    $self->get_logger->error("Failed to instantiate $class: $EVAL_ERROR");
    return;
  }

  $self->context->input($input);

  return $input;
}

########################################################################
sub print { ## no critic
########################################################################
  my ( $self, @args ) = @_;

  return
    if !@args;

  if ( $self->autoflush ) {
    $self->flush_output( join $EMPTY, @args );
  }
  else {
    $self->output_buffer( join $EMPTY, @args );
  }

  return;
}

########################################################################
sub print_json {
########################################################################
  my ( $self, $data ) = @_;

  $self->content_type('application/json');

  return $self->print( JSON->new->encode($data) );
}

########################################################################
sub output_buffer {
########################################################################
  my ( $self, @args ) = @_;

  my $output_buffer = $self->get('output_buffer');

  return $output_buffer
    if !@args;

  $output_buffer .= $args[0];
  $self->set( output_buffer => $output_buffer );

  return $output_buffer;
}

########################################################################
sub log { return shift->get_logger; } ## no critic
########################################################################

########################################################################
sub redirect {
########################################################################
  my ( $self, @headers ) = @_;
  $self->clear;
  return $self->cgi->redirect(@headers);
}

########################################################################
sub clear {
########################################################################
  my ($self) = @_;

  delete $self->{output_buffer};
  delete $self->{content_type};
  delete $self->{headers};

  return $EMPTY;
}

########################################################################
sub flush_output {
########################################################################
  my ( $self, $content ) = @_;

  my $buffer = $self->output_buffer // $EMPTY;
  if ( defined $content ) {
    $buffer .= $content;
  }

  return
    if !length $buffer;

  if ( $self->request ) {
    my $headers_sent = 0;
    eval { $headers_sent = $self->request->bytes_sent; };

    if ( !$headers_sent ) {

      if ( $self->request->can('send_http_header') ) {
        $self->request->send_http_header;
      }
    }

    $self->request->print($buffer);
  }
  else {
    CORE::print $buffer;
  }

  return $self->clear;
}

########################################################################
sub DESTROY {
########################################################################
  my ($self) = @_;

  # we get('session') because ->session() would initialize a session
  my $session = $self->get('session');

  if ( $session && blessed($session) && $session->can('closeBLM') ) {
    $session->closeBLM;
  }

  return;
}

########################################################################
sub config {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args == 1 && ref $args[0] ) {
    $self->set( 'config', shift @args );
  }

  my $config = $self->get('config');

  return $config
    if !@args;

  return @{$config}{@args};
}

########################################################################
sub cgi {
########################################################################
  my ($self) = @_;

  my $cgi = $self->get('cgi');
  return $cgi
    if $cgi;

  $cgi = $self->context->cgi;
  $self->set( 'cgi', $cgi );

  return $cgi;
}

########################################################################
sub attribute {
########################################################################
  my (@args) = @_;
  if ( ref $args[0] ) {
    shift @args;
  }

  my $attribute = shift @args;

  return sprintf '%s="%s"', $attribute, join $SEMICOLON, @args;
}

########################################################################
sub style {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  return attribute( 'style', @args );
}

########################################################################
sub element_start {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  my $element = shift @args;
  my $attributes;

  if (@args) {
    $attributes = $SPACE . join $SPACE, @args;
  }

  return sprintf '<%s%s>', $element, $attributes // $EMPTY;
}

########################################################################
sub element_end {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  return sprintf '</%s>', $args[0];
}

########################################################################
sub element {
########################################################################
  my (@args) = @_;

  if ( ref $args[0] ) {
    shift @args;
  }

  my ( $element_start, $content ) = @args;
  $content //= $EMPTY;

  my $element;

  if ( $element_start !~ /\A</xsm ) {
    $element       = $element_start;
    $element_start = element_start($element_start);
  }
  else {
    $element = $element_start;
    $element =~ s/\A<(\w+)\s+.*\z/$1/xsm;
  }

  return sprintf '%s%s%s', $element_start, $content, element_end($element);
}

########################################################################
sub raise {
########################################################################
  my (@args) = @_;

  if ( @args && blessed( $args[0] ) && $args[0]->isa(__PACKAGE__) ) {
    shift @args;
  }

  if ( @args % 2 == 1 ) {
    my $message = shift @args;
    unshift @args, 'message', $message;
  }

  return Bedrock::Exception->new(@args)->throw;
}

########################################################################
sub content_type {
########################################################################
  my ( $self, $type ) = @_;

  # 1. Delegate strictly to the Request object
  if ( $self->request ) {
    if ( defined $type ) {
      return $self->request->content_type($type);
    }
    return $self->request->content_type;
  }

  # 2. Fallback for CLI/Test modes (no Request object)
  if ( defined $type ) {
    $self->{_fallback_content_type} = $type;
  }
  return $self->{_fallback_content_type};
}

########################################################################
sub run { return shift->handler(@_); }
########################################################################

1;

__END__

=head1 NAME

Bedrock::Service - Base class for creating Bedrock Web Services

=head1 SYNOPSIS

  #!/usr/bin/env perl
  
  package Bedrock::Service::MyService;
  use base qw(Bedrock::Service);
  
  sub new {
      my ($class) = @_;
      # 2. Define Routes
      return $class->SUPER::new(
          autoflush    => 1,
          dispatch_map => {
              '/customer/:id' => 'get_customer',
              '/status'       => 'status',
          }
      );
  }
  
  # 3. Define Actions (prefixed with 'action_')
  sub action_get_customer {
      my ($self) = @_;
      
      # Unified Parameter Access (works for /customer/123 OR ?id=123)
      my $id = $self->context->param('id');
      
      $self->print_json({ id => $id, name => "Barney" });
  }

=head1 DESCRIPTION

C<Bedrock::Service> facilitates the creation of RESTful services you
might use in your web applications. These services can execute in a
C<mod_perl>, C<mod_cgi> or Bedrock's mini HTTP server context.

It is used by C<bedrock-service.cgi> as a CLI tool for service
discovery and as an Apache configuration helper.

Used as a base class for your services, C<Bedrock::Service> is
installed as a C<PerlResponseHandler> or as a CGI script
(C<bedrock-service.cgi>) in your Apache configuration. When used with
Bedrock's miniserver is configured in the miniserver's F<.yml>
configuration file.

=head2 Micro-MVC Routing

Your sub-class defines a dispatch map that maps specific service
routes to the methods that implement that service. You pass a
C<dispatch_map> object to the constructor to enable the internal
routing. The map keys are URI patterns (supported by
L<Bedrock::Router>) and the values are method suffixes. An example map might look like this:

 my $dispatch_map = {
   '/'            => 'index',
   '/status'      => '/status',
   '/product/:id' => 'product',
 };

When a route matches, C<Bedrock::Service> calls the corresponding
method prefixed with C<action_>. You would there implement three methods:

 action_index
 action_status
 action_product

=head2 Unified Parameters

When using the router, captured parameters (like C<:id>) are injected
directly into the Bedrock Context object and are available using the
context object's or service object's C<param()> method.

You should use C<param()> to access all input values. This method
provides a unified view:

=over 4

=item 1. Route Parameters (e.g., C</user/:id>) - I<Highest Priority>

=item 2. Standard CGI Parameters (e.g., C<?sort=desc> or POST body)

=back

=head2 Returning Responses

Services typically return JSON or HTML payloads depending on the
context in which they are invoked. The service instance will interpret
the Accept header and set the output content type to
C<application/json> or C<text/html>.

To return a JSON payload use the C<print_json()> method.

 return $self->print_json({ data => $data });

Use the same method to return HTML snippets or full HTML pages. When
you call C<display_error()> in HTML context, the service will output
the response "as-is" with a content type header of C<text/html>.

=head2 Handling Errors

=head3 API Errors

To return a JSON payload with an error, use C<display_error()>.

 return $self->display_error('No username', $HTTP_BAD_REQUEST);

I<NOTE: C<display_error()> detects the context of the request and will
return a status header and JSON payload that looks like this:>

 { error => 'No username', status => 400 } 

=head3 Exceptions When Rendering Templates

You can use the same method to output a simple error message to the
browser.

 return $self->display_error('No username', $HTTP_BAD_REQUEST);

The service will recognize the context and output a string and content
header of C<text/html>.

When using the C<parse()> method you might encounter parsing
errors. C<Text::TagX> will throw an exception and provide an error
object that is procesed by the C<parse()> method into a
C<Bedrock::Exception> object. This will be caught by the C<handler()>
method will detect that this was a rendering exception and
automatically provide you with an error page that will display the
offending line in your template.

When you throw an exception or your service contains a
bug that causes an exception you can let the C<handler()> handle that
as well. It will at least provide you with an error page that will
assist in debugging the issue.

=head1 METHODS AND SUBROUTINES

=head2 new

 new( %options )

Constructor.

=over 4

=item * B<dispatch_map>: Hash reference mapping URI patterns to method suffixes.

=item * B<autoflush>: Boolean (default 0). If true, prints output immediately.

=item * B<cache>: Boolean (default 1). Enables Bedrock caching.

=back

=head2 handler

 handler()

The main entry point. It detects the execution environment:

=over 4

=item * B<Web Mode>: If C<GATEWAY_INTERFACE> is detected, it
initializes the session, headers, and calls C<dispatch()>.

=item * B<CLI Mode>: If running in a shell, it can process
command-line arguments (like C<install>).

=back

=head2 param

Return query or route parameters.

See L<Bedrock::Context>

=head2 parse

 parse(content, [params]);

Uses Bedrock's Tagx parser to render a template. Returns the rendered
text.

=over 4

=item content

The text, filename or file handle of the template. To pass raw text use a reference.

 my $text = '<var $foo>';
 $service->parse(\$text, foo => 'bar');

=item params

Optional list of key/value pairs (not a reference) of parameters
needed by your template. Keep in mind you are writing a service and
the full weight of Bedrock's engine used when service Bedrock files is
not available to you. However, you do get some things "for free"
depending on how you have configured your service.

=over 8 

=item C<$session>

If you have included a session configuration section in your
configuration or C<Bedrock::Service> can determine a session manager,
you will get a C<$session> object.

=item C<$input>

C<$input> will be available if your configuration object is a
C<Bedrock::Config> object that contains a MODULES section and that
section contains a configuration for a C<BLM::Startup::Input object.

=item C<$config>

The C<$config> object you passed in will always be available.

=item C<$env>

The C<$env> object will always be available as a C<Bedrock::Hash> with
all the rights an privileges blessed upon that class.

=back

=head2 redirect

 redirect( $url )

Sends an HTTP redirect header.

=head2 session

 session()
 session( $key, $value )
 session( $key ) 
 session( \@keys )
 session( $object )

Returns the current Bedrock Session object. If the session has not
been started yet, this method attempts to initialize it using the
active configuration.

B<Usage:>

=over 4

=item * B<Get Session Object:> Call without arguments.

  my $session = $self->session;

=item * B<Set Session Value:> Pass a key and value to store data.

  $self->session( user_id => 42 );

=item * B<Get Data Slice:> Pass an array reference to retrieve a list of values.

  my ($id, $role) = $self->session( [qw(user_id role)] );

=item * B<Inject Session:> Pass a single object (that is not an array
ref) to replace the session manager (useful for testing).

  $self->session( $mock_session_obj );

=item * B<Single Value:> Retrive a single value from the session
object.

  my $foo = $self->session('foo');

=back

B<Configuration:>

The session manager is initialized lazily based on the following
priority:

=over 4

=item 1. B<Miniserver Config:> A C<session> block in
F<bedrock-miniserver.yml>.

=item 2. B<Environment:> The C<BEDROCK_SESSION_MANAGER> environment
variable.

=item 3. B<Global Config:> The C<BEDROCK_SESSION_MANAGER> variable in
F<tagx.xml>.

=back

=head2 Using bedrock-service.cgi (Generic CGI Front Controller)

A Bedrock service does not need to be implemented as an executable CGI
script.  You can deploy services as normal Perl modules
(C<Bedrock::Service::*>), and use a single generic CGI entrypoint
(F<bedrock-service.cgi>) to run them.

When deployed this way, the Apache configuration sets:

  SetEnv BEDROCK_SERVICE_NAME "Bedrock::Service::UserLookup"

The front controller uses that value to load and run the correct
service class.  This keeps your service implementation in a standard
module and avoids one CGI script per service.

To ensure the auto-installation works correctly, follow these
conventions when running your service under C<mod_cgi>.

=over 4

=item 1. Name your script file in kebab-case (e.g., C<customer-lookup.cgi>).

=item 2. The derived Service Name will be C<customer-lookup>.

=item 3. The generated config will use C<SetHandler customer-lookup>.

=back

=head1 FAQs

=head2 Can I use the same user's session when serving Bedrock files
with the full engine?

Yes, services are designed to help you augment the full Bedrock
environment. A Bedrock application is typically a set of Bedrock
templates served by the Bedrock engine that runs under
Apache. Services might be mixed in for example, to provide RESTful
services or other functionality to your front end. As long as the base
configuration (F<tagx.xml>) you are pointing to using the
C<BEDROCK_CONFIG_PATH> variable is the same as that used to serve
pages by the full engine, C<Bedrock::Service> will instantiate the
same configuration object and therefore use the same session
manager.

The session manager will be instantiated by using the
C<BEDROCK_SESSION_MANAGER> environment or configuration value and the
session configuration in your F<tagx.xml> file.

I<NOTE: When running a service using Bedrock's miniserver you should
set the BEDROCK_CONFIG_PATH to in the miniserver configuration
file. You should also know that values in the miniserver configuration
file are added to the configuration object. See man
bedrock-miniserver.pl for additional details.>

=head2 When I run under the full engine I have other BLMs
available. Will I have access to those?

No. In general the use case for services is highly specific and not
designed to give you the full "Bedrock experience". If you want to
instantiate a plugin in your service and pass that to C<parse()>, go
right ahead, nothing is stopping you! The recipe is rather simple:

 1. Make sure you have access to the plugin's configuration.
 2. Load the class
 3. Instantiate the class
 4. Pass the object to the parse using some variable name

The configuration object available via the C<config()> method contains
the fully exploded Bedrock configuration (an instance of
C<Bedrock::Config> used by the Bedrock engine. So, as long as you have
that module configured in your F<tagx.xml> (or a .xml file that was
merged into the configuration object) you can use the
C<get_module_config()> method extract the configuration for your
plugin.

 # load the module
 Module::Load::load 'BLM::Startup::MyPlugin'

 # extract the module configuration form the configuration object
 my $plugin_config = $self->config->get_module_config('MyPlugin');

 # instantiate you plugin
 my $plugin = BLM::Startup::MyPlugin->new($self->context, $plugin_config->{config});

 # pass the plugin to parse()
 my $content = '<var $my_plugin.foo() >';
 $self->parse(\$content, my_plugin => $plugin);

=head2 Can I use Plain Old Bedrock Plugins?

Yes, any plugin that can be loaded using the C<plugin> tag can be used.

=head2 Can I use the C<$header> object?

No, you do not get a C<$header> object! You should use the C<parse()>
method strictly for parsing, not for navigation or setting
headers. You are after all writing a service. You can manipulate
headers, return status and perform whatever other actions your service
dictates.

=head1 AUTHOR

Rob Lauer - <bigfoot@cpan.org>

=head1 SEE ALSO

L<Bedrock::Context>, L<Bedrock::Router>

=cut
