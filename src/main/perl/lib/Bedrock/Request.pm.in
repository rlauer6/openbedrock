package Bedrock::Request::Driver::CGITiny;

use strict;
use warnings;

########################################################################
sub new {
########################################################################
  my $class = shift;

  require CGI::Tiny;
  # Manual instantiation of the framework-less CGI::Tiny object
  my $cgi_tiny_instance = bless {}, 'CGI::Tiny';

  return bless { cgi => $cgi_tiny_instance }, $class;
}

########################################################################
sub param {
########################################################################
  my ( $self, $key ) = @_;

  # FORCE LIST CONTEXT:
  # Explicitly capture names into an array to ensure we return a list,
  # preventing reference leakage from the underlying driver.
  if ( !defined $key ) {
    my @names = $self->{cgi}->param_names();
    return @names;
  }

  return $self->{cgi}->param($key);
}

########################################################################
sub multi_param {
########################################################################
  my ( $self, $key ) = @_;

  # CGI::Tiny uses param_array for multi-value fields
  my $vals = $self->{cgi}->param_array($key);
  return $vals ? @{$vals} : ();
}

########################################################################
sub upload {
########################################################################
  my ( $self, $key ) = @_;
  return $self->{cgi}->upload($key);
}

########################################################################
package Bedrock::Request;
########################################################################

use strict;
use warnings;

use Scalar::Util qw(blessed);
use Carp qw(croak);
use Data::Dumper;
use English qw(-no_match_vars);

########################################################################
sub new {
########################################################################
  my ( $class, $r ) = @_;
  my $self = {};

  if ( $r && blessed($r) && $r->isa('Apache2::RequestRec') ) {
    eval {
      require Apache2::Request;
      require Apache2::Upload;
      1;
    } or croak "mod_perl detected but libapreq2 missing: $EVAL_ERROR";

    $self->{driver} = Apache2::Request->new($r);
    $self->{type}   = 'mod_perl';
  }
  elsif ( eval { require CGI::Tiny; 1; } ) {
    $self->{driver} = Bedrock::Request::Driver::CGITiny->new();
    $self->{type}   = 'cgi_tiny';
  }
  else {
    require CGI;
    $self->{driver} = CGI->new;
    $self->{type}   = 'cgi_legacy';
  }

  return bless $self, $class;
}

# ----------------------------------------------------------------------
# PUBLIC API
# ----------------------------------------------------------------------

########################################################################
sub param {
########################################################################
  my ( $self, $key ) = @_;

  if ( defined $key ) {
    return $self->{driver}->param($key);
  }

  # CONTRACT ENFORCEMENT:
  # The driver MUST return a list of keys. If it returns an array reference
  # (as CGI::Tiny seems to be doing in this environment), we must unwrap it
  # to prevent downstream code (Context.pm/Input.pm) from breaking.

  my @results = $self->{driver}->param();

  # Check if we got a single result that is an ARRAY reference
  if ( @results == 1 && ref( $results[0] ) eq 'ARRAY' ) {
    return @{ $results[0] };
  }

  return @results;
}

########################################################################
sub multi_param {
########################################################################
  my ( $self, $key ) = @_;

  # Polyfill for Apache2::Request which lacks multi_param
  if ( $self->{type} eq 'mod_perl' ) {
    return $self->{driver}->param($key);
  }

  return $self->{driver}->multi_param($key);
}

########################################################################
sub upload {
########################################################################
  my ( $self, $key ) = @_;

  return if !defined $key;

  my $u = $self->{driver}->upload($key);

  return if !$u;

  if ( $self->{type} eq 'cgi_tiny' ) {
    return {
      fh       => $u->{file},
      filename => $u->{filename},
      type     => $u->{content_type},
      size     => $u->{size}
    };
  }
  elsif ( $self->{type} eq 'mod_perl' ) {
    return {
      fh       => $u->fh,
      filename => $u->filename,
      type     => $u->type,
      size     => $u->size,
    };
  }
  else {
    # Legacy CGI.pm
    my $filename = scalar $self->{driver}->param($key);
    my $info_ref = $self->{driver}->uploadInfo($u);
    my $ctype    = $info_ref ? $info_ref->{'Content-Type'} : undef;

    return {
      fh       => $u,
      filename => $filename,
      type     => $ctype,
      size     => -s $u,
    };
  }
}

1;
