package Bedrock::Cache::Shareable;

use strict;
use warnings;

use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use IPC::Shareable;
use Time::HiRes qw(time);

use Role::Tiny::With;
with 'Bedrock::Cache::Engine';

use Readonly;

Readonly::Scalar our $CACHE_KEY            => 'BCFG';
Readonly::Scalar our $CACHE_BLOCK_SIZE     => 1024;
Readonly::Scalar our $DEFAULT_CACHE_BLOCKS => 256;
Readonly::Scalar our $CACHE_MODE           => oct '666';

########################################################################
sub new {
########################################################################
  my ( $class, %options ) = @_;

  my $self = bless \%options, $class;

  $self->_init_memory();

  return $self;
}

########################################################################
sub _init_memory {
########################################################################
  my ($self) = @_;

  # Respect the legacy environment variable for size
  my $cache_blocks = $self->{cache_block};
  $cache_blocks //= $ENV{BEDROCK_CACHE_CONFIG_SIZE} // $DEFAULT_CACHE_BLOCKS;

  my %cache_hash;

  my $create = $self->{create} // ( $ENV{MOD_PERL} ? 0 : 1 );

  my %options = (
    key    => $CACHE_KEY,
    create => $create,
    mode   => $CACHE_MODE,
    size   => $CACHE_BLOCK_SIZE * $cache_blocks,
  );

  # The tie itself
  eval { tie %cache_hash, 'IPC::Shareable', \%options; };  ## no critic

  if ( $EVAL_ERROR || !tied %cache_hash ) {
    confess "Bedrock::Cache::Shareable failed to tie memory segment: $EVAL_ERROR";
  }

  $self->{_cache} = \%cache_hash;

  return;
}

########################################################################
sub set {  ## no critic
########################################################################
  my ( $self, $key, $value, %opts ) = @_;

  my $ttl = $opts{ttl};

  my $expiry = $ttl ? ( time() + $ttl ) : 0;

  # THE ENVELOPE: Wrap the data with its death date
  my $envelope = {
    d => $value,  # Payload
    e => $expiry  # Expiry (0 means never)
  };

  # We rely on the parent class (or caller) to handle serialization,
  # but IPC::Shareable usually handles refs automatically if configured right.
  # If using your wrapper that nfreezes first, $value is already a string.

  $self->{_cache}->{$key} = $envelope;

  return 1;
}

########################################################################
sub get {
########################################################################
  my ( $self, $key ) = @_;

  my $envelope = $self->{_cache}->{$key};
  return
    if !$envelope;

  # Check for Expiration
  if ( $envelope->{e} && time() > $envelope->{e} ) {
    # Lazy Expiration: It's dead, delete it now.
    delete $self->{_cache}->{$key};
    return;
  }

  return $envelope->{d};
}

########################################################################
sub exists {  ## no critic
########################################################################
  my ( $self, $key ) = @_;

  # CRITICAL: We cannot just check exists($hash{$key})
  # We must peek at the envelope to see if it is still alive.

  my $envelope = $self->{_cache}->{$key};
  return 0
    if !$envelope;

  if ( $envelope->{e} && time > $envelope->{e} ) {
    # It exists physically, but logically it is dead.
    # might as well clean it up now.
    delete $self->{_cache}->{$key};
    return 0;
  }

  return 1;
}

########################################################################
sub delete {  ## no critic
########################################################################
  my ( $self, $key ) = @_;
  delete $self->{_cache}->{$key};
  return 1;
}

########################################################################
sub clear {
########################################################################
  my ($self) = @_;

  my $cache = $self->{_cache};

  foreach ( keys %{$cache} ) {
    delete $cache->{$_};
  }

  return $cache;
}

########################################################################
sub keys {  ## no critic
########################################################################
  my ( $self, @args ) = @_;

  my $cache = $self->{_cache};

  return [ grep { $self->exists($_); } CORE::keys %{$cache} ];
}

1;
