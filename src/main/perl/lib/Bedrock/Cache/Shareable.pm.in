package Bedrock::Cache::Shareable;

use strict;
use warnings;

use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use IPC::Shareable;

use Role::Tiny::With;
with 'Bedrock::Cache::Engine';

use constant {
  CACHE_KEY            => 'BCFG',
  CACHE_BLOCK_SIZE     => 1024,
  DEFAULT_CACHE_BLOCKS => 256,
};

########################################################################
sub new {
########################################################################
  my ($class) = @_;

  my $self = bless {}, $class;

  $self->_init_memory();

  return $self;
}

########################################################################
sub _init_memory {
########################################################################
  my ($self) = @_;

  # Respect the legacy environment variable for size
  my $cache_blocks = $ENV{BEDROCK_CACHE_CONFIG_SIZE} || DEFAULT_CACHE_BLOCKS;

  my %cache_hash;
  my %options = (
    key    => CACHE_KEY,
    create => 1,
    mode   => 0666,
    size   => CACHE_BLOCK_SIZE * $cache_blocks,
  );

  # The tie itself
  eval { tie %cache_hash, 'IPC::Shareable', \%options; };  ## no critic

  confess "Bedrock::Cache::Shareable failed to tie memory segment: $EVAL_ERROR"
    if $EVAL_ERROR || !tied %cache_hash;

  $self->{_cache} = \%cache_hash;

  return;
}

########################################################################
sub set {
########################################################################
  my ( $self, $key, $value, %opts ) = @_;

  my $ttl    = $opts{ttl};
  my $expiry = $ttl ? ( time + $ttl ) : 0;

  # THE ENVELOPE: Wrap the data with its death date
  my $envelope = {
    d => $value,  # Payload
    e => $expiry  # Expiry (0 means never)
  };

  # We rely on the parent class (or caller) to handle serialization,
  # but IPC::Shareable usually handles refs automatically if configured right.
  # If using your wrapper that nfreezes first, $value is already a string.

  $self->{_cache}->{$key} = $envelope;

  return 1;
}

########################################################################
sub get {
########################################################################
  my ( $self, $key ) = @_;

  my $envelope = $self->{_cache}->{$key};
  return
    if !$envelope;

  # Check for Expiration
  if ( $envelope->{e} && time > $envelope->{e} ) {
    # Lazy Expiration: It's dead, delete it now.
    delete $self->{_cache}->{$key};
    return;
  }

  return $envelope->{d};
}

########################################################################
sub exists {
########################################################################
  my ( $self, $key ) = @_;

  # CRITICAL: We cannot just check exists($hash{$key})
  # We must peek at the envelope to see if it is still alive.

  my $envelope = $self->{_cache}->{$key};
  return 0
    if !$envelope;

  if ( $envelope->{e} && time > $envelope->{e} ) {
    # It exists physically, but logically it is dead.
    # might as well clean it up now.
    delete $self->{_cache}->{$key};
    return 0;
  }

  return 1;
}

########################################################################
sub delete {
########################################################################
  my ( $self, $key ) = @_;
  delete $self->{_cache}->{$key};
  return 1;
}

1;
