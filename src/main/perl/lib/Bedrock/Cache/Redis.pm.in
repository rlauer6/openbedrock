package Bedrock::Cache::Redis;

use strict;
use warnings;

use Bedrock::XML;
use English qw(-no_match_vars);
use Data::Dumper;
use Redis;
use Role::Tiny::With;

with 'Bedrock::Cache::Engine';

########################################################################
sub new {
########################################################################
  my ($class) = @_;

  # 1. Cloud-Native Priority: Check Environment First
  # This allows secrets to be injected via AWS Secrets Manager / ECS Task Defs
  my $server   = $ENV{BEDROCK_REDIS_SERVER} || $ENV{REDIS_URL};
  my $password = $ENV{BEDROCK_REDIS_PASSWORD};
  my $port     = $ENV{BEDROCK_REDIS_PORT};

  # 2. Legacy Fallback: Check XML if ENV is missing
  if ( !$server ) {
    my $config = _load_redis_config();
    $server = $config->{server};
    $password //= $config->{password};
    $port     //= $config->{port};
  }

  # Default
  $server //= 'localhost';
  $port   //= '6379';

  if ( $server =~ s/:(\d)+$//xsm ) {
    $port = $1;
  }

  # NOTE: No encoding set; we want raw bytes for Storable compatibility.
  my $redis = eval { return Redis->new( server => "$server:$port", password => $password, reconnect => 1, ); };

  die "Could not initialize Redis connection: $EVAL_ERROR"
    if $EVAL_ERROR || !$redis;

  return bless { handle => $redis }, $class;
}

########################################################################
sub _load_redis_config {
########################################################################
  my @paths = split /:/xsm, ( $ENV{CONFIG_PATH} // $ENV{BEDROCK_CONFIG_PATH} // q{} );

  my $xml_file;

  foreach my $path (@paths) {
    my $candidate = "$path/redis.xml";
    if ( -e $candidate ) {
      $xml_file = $candidate;
      last;
    }
  }

  # Default to standard redis configuration if no file found
  return { server => 'localhost:6379' } if !$xml_file;

  # Load specific redis.xml using Bedrock::XML
  my $xml = Bedrock::XML->new($xml_file);

  return $xml;
}

# The Contract Methods
sub get        { my ( $self, $key ) = @_; return $self->{handle}->get($key); }
sub exists     { my ( $self, $key ) = @_; return $self->{handle}->exists($key); }
sub delete     { my ( $self, $key ) = @_; return $self->{handle}->del($key); }
sub get_handle { my ($self) = @_; return $self->{handle}; }

########################################################################
sub set {
########################################################################
  my ( $self, $key, $value, %opts ) = @_;
  if ( my $ttl = $opts{ttl} ) {
    return $self->{handle}->setex( $key, $ttl, $value );
  }
  return $self->{handle}->set( $key, $value );
}

########################################################################
sub keys {  ## no critic
########################################################################
  my ($self) = @_;

  # Redis returns list, wrapper expects array ref
  my @keys = $self->{handle}->keys('*');
  return \@keys;
}

########################################################################
sub clear {
########################################################################
  my ($self) = @_;
  return $self->{handle}->flushdb;
}

########################################################################
sub stats {
########################################################################
  my ($self) = @_;

  # Redis returns statistics as a colon-separated text block via the INFO command.
  # We parse this into a hashref to match the structure expected by the API.
  my $info_text = $self->{handle}->info();
  my %stats;

  foreach my $line ( split /\r\n/, $info_text ) {
    next if $line =~ /^#/;  # Skip comments
    next if $line !~ /:/;   # Skip malformed lines

    my ( $key, $value ) = split /:/, $line, 2;
    $stats{$key} = $value;
  }

  return \%stats;
}

########################################################################
sub touch {
########################################################################
  my ( $self, $key, $ttl ) = @_;

  # 1. Update the TTL
  # If $ttl is 0 (or false), we PERSIST (remove expiry).
  # If $ttl is > 0, we EXPIRE (set new expiry).
  if ($ttl) {
    # EXPIRE returns 1 if successful, 0 if key doesn't exist
    return 0 unless $self->{handle}->expire( $key, $ttl );
  }
  else {
    # PERSIST returns 1 if timeout removed, 0 if key didn't exist or had no timeout
    # We check EXISTS first to ensure we don't return true for a missing key
    return 0 unless $self->{handle}->exists($key);
    $self->{handle}->persist($key);
  }

  # 2. Return the value (Parity with Shareable)
  # This maintains the "Refresh and Retrieve" interface contract.
  return $self->get($key);
}

1;

__END__

=pod

=head1 NAME

Bedrock::Cache::Redis - Redis Backend for Bedrock Caching

=head1 SYNOPSIS

  # Typically instantiated via Bedrock::Cache factory
  # export BEDROCK_CACHE_ENGINE=Redis
  
  my $cache = Bedrock::Cache->new();
  $cache->set('key', 'value', ttl => 3600);

=head1 DESCRIPTION

This module implements the C<Bedrock::Cache::Engine> interface using a
Redis server as the backing store. It is designed to be "Container
Native," preferring environment variables for configuration while
maintaining backward compatibility with legacy XML configuration
files.

=head1 CONFIGURATION

The module determines connection details using the following
precedence order (highest priority first):

=head2 1. Environment Variables (Recommended)

Ideal for AWS Fargate, ECS, or Docker environments.

=over 4

=item * B<BEDROCK_REDIS_SERVER>

The hostname (and optional port) of the Redis server.
Examples: C<redis.internal>, C<10.0.0.5:6379>.

=item * B<REDIS_URL>

A standard connection string often provided by cloud providers.
Example: C<redis://user:pass@host:port>. (Note: Only the host/port is
extracted; password should be set separately if not standard).

=item * B<BEDROCK_REDIS_PASSWORD>

The authentication password (if required).

=item * B<BEDROCK_REDIS_PORT>

The port number. Defaults to C<6379> if not specified in the
environment or the server string.

=back

=head2 2. Legacy XML Configuration

If environment variables are missing, the module searches for
F<redis.xml> in the paths defined by C<BEDROCK_CONFIG_PATH>.

  <object>
    <scalar name="server">localhost</scalar>
    <scalar name="port">6379</scalar>
    <scalar name="password">secret</scalar>
  </object>

=head2 3. Defaults

If no configuration is found, it defaults to:

  Server: C<localhost>
  Port:   C<6379>

=head1 METHODS

This class satisfies the B<Bedrock::Cache::Engine> role.

=over 4

=item * B<get( $key )>

Retrieves the raw bytes from Redis. Deserialization is handled by the
C<Bedrock::Cache> wrapper.

=item * B<set( $key, $value, [ttl => $seconds] )>

Stores the value. If C<ttl> is provided, it uses the Redis C<SETEX>
command to ensure atomic expiration.

=item * B<delete( $key )>

Removes the key from Redis.

=item * B<exists( $key )>

Returns true if the key exists in Redis.

=item * B<keys>

Returns an array reference of all keys in the current database (C<KEYS *>).

=item * B<clear>

Flushes the current database (C<FLUSHDB>).

=item * B<touch( $key, $ttl )>

Updates the TTL for the given key and returns the value (refresh-and-retrieve).
If C<$ttl> is 0, the key is persisted (expiration removed).

=item * B<stats>

Returns a hashref containing the output of the Redis C<INFO> command.

=back

=head1 SERIALIZATION NOTE

This module does B<not> configure the underlying C<Redis> client with
any encoding (e.g., C<utf8>). It treats all data as raw binary
bytes. This is intentional to support C<Storable::nfreeze> data passed
down from the C<Bedrock::Cache> wrapper.

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=cut
