package Bedrock::Cache::Memory;

use strict;
use warnings;

use Time::HiRes qw(time);
use Data::Dumper;

# Shared process-wide cache storage
# Structure: $CACHE{$key} = { d => $data, e => $epoch_time }
my %CACHE;

########################################################################
sub new {
########################################################################
  my ( $class, %options ) = @_;
  return bless \%options, $class;
}

########################################################################
sub get {
########################################################################
  my ( $self, $key ) = @_;

  my $envelope = $CACHE{$key};
  return if !$envelope;

  # Check expiration
  if ( $envelope->{e} && time() > $envelope->{e} ) {
    delete $CACHE{$key};
    return;
  }

  return $envelope->{d};
}

########################################################################
sub keys {  ## no critic
########################################################################
  my ($self) = @_;

  return [ grep { $self->exists($_) } CORE::keys %CACHE ];
}

########################################################################
sub set {  ## no critic
########################################################################
  my ( $self, $key, $value, %opts ) = @_;

  my $ttl    = $opts{ttl};
  my $expiry = $ttl ? ( time() + $ttl ) : 0;

  $CACHE{$key} = {
    d => $value,   # Payload
    e => $expiry,  # Expiry (0 means never)
  };

  return 1;
}

########################################################################
sub exists {  ## no critic
########################################################################
  my ( $self, $key ) = @_;

  my $envelope = $CACHE{$key};
  return 0 if !$envelope;

  if ( $envelope->{e} && time > $envelope->{e} ) {
    delete $CACHE{$key};
    return 0;
  }

  return 1;
}

########################################################################
sub delete {  ## no critic
########################################################################
  my ( $self, $key ) = @_;
  delete $CACHE{$key};
  return 1;
}

########################################################################
sub clear {
########################################################################
  my ($self) = @_;
  %CACHE = ();
  return 1;
}

1;
