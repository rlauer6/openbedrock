package Bedrock::Service::Docs;

use strict;
use warnings;

# Inherit directly from the Application Platform
use Bedrock qw(:booleans slurp_file choose);
use Bedrock::Constants qw(:regexp :chars :booleans :defaults :http);
use Bedrock::PodWriter qw(pod2html);
use Bedrock::Cache;
use Bedrock::Cache::Memory;
use Bedrock::Hash;
use Bedrock::Template;
use Bedrock::VERSION;
use Carp qw(croak confess cluck carp);
use Compress::Zlib qw(memGzip memGunzip);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(fileparse basename dirname);
use File::Temp qw(tempfile);
use File::Find;
use JSON;
use Markdown::Render;
use List::Util qw(any pairs none);
use LWP::UserAgent;
use Digest::MD5 qw(md5_hex);
use Scalar::Util qw(reftype blessed);

use Role::Tiny::With;
with 'Bedrock::Role::DocFinder';

# --- Configuration Constants ---
use Readonly;
Readonly our $DEFAULT_IMAGE_URL => '/bedrock/img';
Readonly our $POD_MIN_SIZE      => 600;
Readonly our $SERVER_CACHE_TTL  => 5 * 60;
Readonly our $BROWSER_CACHE_TTL => 60 * 60;

use parent qw(Bedrock::Service);

our $VERSION = '@PACKAGE_VERSION@';

# "Modulino" Hook: Allows running as a script or loading as a class
caller or __PACKAGE__->new->handler;

########################################################################
sub new {
########################################################################
  my ( $class, %args ) = @_;

  Bedrock::cache( create => 1 );

  my $self = $class->SUPER::new(
    %args,
    dispatch_map => {
      '/'                   => 'index',
      '/cache-stats'        => 'cache_stats',
      '/clear-cache'        => 'clear_cache',
      '/config'             => 'config',
      '/docs/:doc'          => 'generic_docs',
      '/env'                => 'env',
      '/internal/:module'   => 'internal',
      '/list-cache'         => 'list_cache',
      '/markdown/:file'     => 'markdown',
      '/plugins/:file'      => 'plugins',
      '/pod/:module'        => 'pod',
      '/session'            => 'session',
      '/pod-only/:pod_only' => 'pod_only',
      '/system/:module'     => 'system',
      '/tag/:tag'           => 'tag',
    }
  );

  $self->init_cache();

  return $self;
}

########################################################################
sub init_cache {
########################################################################
  my ($self) = @_;

  return;
}

########################################################################
sub dispatch {
########################################################################
  my ($self) = @_;

  # --- Security Gate ---
  my $config = $self->config;

  $self->log->debug( sprintf 'Bedrock documentation server request: [%s] ', $self->request->path_info );

  my $info_setting = $ENV{ALLOW_BEDROCK_INFO} // $config->{ALLOW_BEDROCK_INFO} // $EMPTY;

  if ( none { lc $info_setting eq $_ } qw{ on 1 yes docs } ) {
    $self->log->error("Bedrock docs denied (ALLOW_BEDROCK_INFO='$info_setting')");
    return $self->display_error( 'Forbidden', $HTTP_FORBIDDEN );
  }

  # --- Config Defaults ---
  $config->{BEDROCK_IMAGE_URL} //= $DEFAULT_IMAGE_URL;
  $config->{BEDROCK_ADMIN_DIR} //= '/bedrock';
  $config->{BEDROCK_INCLUDE_DIR} = $ENV{BEDROCK_INCLUDE_DIR} // $DEFAULT_BEDROCK_INCLUDE_DIR;

  my $retval = $self->SUPER::dispatch();

  return $retval;
}

########################################################################
# ACTIONS
########################################################################

########################################################################
sub action_index {
########################################################################
  my ($self) = @_;

  return $HTTP_BAD_REQUEST
    if $self->is_api;

  my $config   = $self->config;
  my $template = $self->fetch_template('bedrock-docs-index');

  my %params;
  $params{head}                  = $self->listing_head('Bedrock Reference Guide');
  $params{tags}                  = $self->ul_links( tag      => 'Bedrock Tags', plugins => 'Bedrock Plugins' );
  $params{system_docs}           = $self->ul_links( system   => 'System Modules' );
  $params{bedrock_internal_docs} = $self->ul_links( internal => 'Bedrock Internal Documentation' );
  $params{logo}                  = $self->get_logo;

  if ( my $paths = $self->get_pod_paths ) {
    if ( @{$paths} ) {
      $params{user_docs} = $self->ul_links( pod => 'User Module Listing' );
    }
  }

  if ( my $paths = $self->get_markdown_paths ) {
    if ( @{$paths} ) {
      $params{markdown_docs} = $self->ul_links( markdown => 'Documentation Listing' );
    }
  }

  if ( $config->{ALLOW_BEDROCK_INFO} ne 'docs' ) {
    my $allow_cfg = to_boolean( $config->{ALLOW_BEDROCK_CONFIG_INFO} );
    my $allow_env = to_boolean( $config->{ALLOW_BEDROCK_ENV_INFO} );

    $params{bedrock_env} = $self->ul_links(
      config => $allow_cfg ? 'Bedrock Configuration' : '(disabled)',
      env    => $allow_env ? 'Bedrock Environment'   : '(disabled)',
    );
  }

  if ( $config->{LOG4PERL} && -e $config->{LOG4PERL} ) {
    $params{log4perl} = slurp_file( $config->{LOG4PERL} );
  }

  return $self->render_page( $template, %params );
}

########################################################################
sub action_cache_stats {
########################################################################
  my ($self) = @_;

  my $cache = $self->cache;
  my @keys  = $cache ? $cache->keys : ();

  # The prefix defined in sub cache_key (Bedrock::Service::Docs)
  my $prefix = __PACKAGE__;

  my %stats = (
    total_keys => scalar(@keys),
    docs_keys  => 0,
    categories => {
      lists       => 0,  # _LIST
      metadata    => 0,  # METADATA
      pod_entries => 0,  # Cached HTML content
    },
    config => { pod_ttl => $SERVER_CACHE_TTL, }
  );

  foreach my $key (@keys) {
    # Filter for keys belonging to this specific service
    # Format matches sub cache_key: Package[KEY_NAME]
    next if $key !~ /^\Q$prefix\E\[(.*)\]$/;

    $stats{docs_keys}++;
    my $inner_key = $1;

    if ( $inner_key =~ /_LIST$/xsm ) {
      $stats{categories}{lists}++;
    }
    elsif ( $inner_key =~ /METADATA/xsm ) {
      $stats{categories}{metadata}++;
    }
    else {
      # Any key not explicitly a List or Metadata is a cached POD Page
      $stats{categories}{pod_entries}++;
    }
  }

  return $self->print_json( \%stats );
}

########################################################################
sub action_plugins {
########################################################################
  my ($self) = @_;

  my $r = $self->request;

  my $plugins = $self->get_module_metadata();

  my $target_name = $self->context->param('file');

  # FIX: Fallback Manual Parsing
  # If the router failed to capture the parameter (e.g. because of '::'),
  # extract it manually from path_info.
  if ( !$target_name ) {
    my $path = $self->request->path_info // $ENV{PATH_INFO} // q{};
    if ( $path =~ m{/plugins/(.+)$} ) {
      $target_name = $1;
    }
  }

  # Handle plugin lookup (Detail View)
  if ($target_name) {
    # STRICT LOOKUP: Client must provide exact name (e.g., BLM::Startup::Bedrock)
    return $self->display_error( "Plugin not found: $target_name", $HTTP_NOT_FOUND )
      if !$plugins->{$target_name};

    return $self->show_pod( $plugins->{$target_name}->{file}, 'plugins', $target_name );
  }

  my $template = $self->fetch_template('bedrock-docs-plugins');

  my @plugin_list = keys %{$plugins};

  my %sections = (
    Plugins               => [ grep { $plugins->{$_}->{plugin} } @plugin_list ],
    'Application Plugins' => [ grep { $plugins->{$_}->{application_plugin} } @plugin_list ],
    Filters               => [ grep { $plugins->{$_}->{filter} } @plugin_list ],
  );

  if ( $self->is_api ) {
    my %plugin_map;
    my %links;
    my %names;

    foreach my $section ( keys %sections ) {
      # 1. Plugin Map (ID generation)
      my $id = lc $section;
      $id =~ s/\s/-/g;
      $plugin_map{$section} = $id;

      # 2. Links & Names
      my @modules = @{ $sections{$section} };

      foreach my $module (@modules) {
        # FIX: Generate authoritative link for JS to use directly
        $links{$section}->{$module} = sprintf '%s/plugins/%s', $self->admin_dir, $module;

        # Names: Simplify display name (strip BLM:: and category)
        my $short = $module;
        $short =~ s/^.*:://;
        $names{$section}->{$module} = $short;
      }
    }

    return $self->print_json(
      { plugins    => \%sections,
        plugin_map => \%plugin_map,
        links      => \%links,
        names      => \%names
      }
    );
  }

  my @headings = sort keys %sections;

  my @plugin_listing = map { $self->blm_ul( metadata => $plugins, title => $_, modules => $sections{$_} ) } @headings;

  return $self->render_page(
    $template,
    headings => \@headings,
    head     => $self->listing_head('Bedrock Plugins'),
    plugins  => \@plugin_listing,
  );
}

########################################################################
sub action_system { return shift->system_docs('system'); }
########################################################################
sub action_internal { return shift->system_docs('bedrock-internal'); }
########################################################################

########################################################################
sub system_docs {
########################################################################
  my ( $self, $type ) = @_;

  my $module = $self->context->param('module');

  # OPTIMIZATION: Fast Path for Single Module
  # If we know the module name, try to render it immediately.
  # We pass 'undef' for the file path and let show_pod's generator find it in @INC.
  return $self->show_pod( undef, $type, $module )
    if $module;

  # SLOW PATH: Full Listing
  # Only NOW do we pay the cost to fetch/deserialize the full metadata index
  my $metadata = $self->get_module_metadata();

  my @modules = sort keys %{$metadata};

  # ... (rest of filtering logic remains the same) ...
  @modules = choose {
    return grep {
      !(   $metadata->{$_}->{bedrock_system}
        || $metadata->{$_}->{plugin}
        || $metadata->{$_}->{filter}
        || $metadata->{$_}->{application_plugin}
        || $metadata->{$_}->{bedrock_public} )
      } @modules
      if $type eq 'system';

    return grep { $metadata->{$_}->{bedrock_system} } @modules
      if $type eq 'bedrock-internal';
  };

  return $self->print_json( { modules => \@modules } )
    if $self->is_api;

  my $prefix = ( $type eq 'system' ) ? 'system' : 'internal';
  my $title  = ( $type eq 'system' ) ? 'System' : 'Bedrock Internal';

  my @links;
  my $session  = $self->session;
  my $pod_only = $session->{pod_only};

  foreach my $module (@modules) {
    if ( $metadata->{$module}->{pod} ) {
      push @links, sprintf '<a href="%s/%s/%s">%s</a>', $self->admin_dir, $prefix, $module, $module;
    }
    elsif ( !$pod_only ) {
      push @links, $module;
    }
  }

  return $self->render_listing( "$title Documentation Listing", @links );
}

########################################################################
sub action_pod {
  my ($self) = @_;
########################################################################

  my $user_metadata = $self->cache->get( cache_key('user_metadata') );
  my $paths         = $self->get_pod_paths;

  if ( !$user_metadata && $paths && @{$paths} ) {

    # [CHANGE 1] Don't abort if we just want a specific module
    if ( !@{$paths} && !$self->context->param('module') ) {
      return $self->display_error('No user docs found');
    }

    # Only attempt scan if we actually have paths
    my $list
      = @{$paths}
      ? $self->find_files_of_type( paths => $paths, type => 'pm' )
      : [];

    # [CHANGE 2] Same check here: Allow empty list if looking for specific module
    return $self->display_error('No user docs found')
      if ( !$list || !@{$list} ) && !$self->context->param('module');

    $user_metadata = $self->module_metadata($list);
    $self->cache->set( cache_key('user_metadata') => $user_metadata );
  }

  if ( my $module = $self->context->param('module') ) {
    my $path = $user_metadata->{$module}->{file};
    return $self->show_pod( $path, 'pod', $module );
  }

  if ( $self->is_api ) {
    return $self->print_json( { modules => [ sort keys %{$user_metadata} ] } );
  }

  my @links;

  foreach my $module ( sort keys %{$user_metadata} ) {
    push @links, sprintf '<a href="%s/pod/%s">%s</a>', $self->admin_dir, $module, $module;
  }

  return $self->render_listing( 'User Documentation Listing', @links );
}

########################################################################
sub action_markdown {
########################################################################
  my ($self) = @_;

  my $file = $self->context->param('file');

  my $listing = $self->get_markdown_listing;

  if ( $self->is_api && !$file ) {
    return $self->print_json( { markdown => $listing } );
  }

  return $self->show_markdown( $listing->{$file} )
    if $file && $listing->{$file};

  my @links;

  foreach my $p ( pairs %{$listing} ) {
    my ( $name, $path ) = @{$p};
    push @links, sprintf '<a href="%s/markdown/%s">%s</a>', $self->admin_dir, $name, $name;
  }

  return $self->render_listing( 'Documentation Listing', sort @links );
}

########################################################################
sub action_tag {
########################################################################
  my ($self) = @_;

  my $tag = $self->context->param('tag');

  my $admin_dir = $self->admin_dir;

  if ($tag) {
    my $file = $self->find_tag_file($tag);

    return $self->display_error( 'Tag not found', $HTTP_NOT_FOUND )
      if !$file;

    return $self->show_pod( $file, 'tag', 'tag_' . $tag );
  }

  my $tags = $self->get_tag_list;

  return $self->print_json( { tags => $tags } )
    if $self->is_api;

  my @links = map { sprintf '<a href="%s/tag/%s">%s</a>', $admin_dir, $_, $_ } @{$tags};

  return $self->render_listing( 'Bedrock Tag Listing', @links );
}

########################################################################
sub action_generic_docs {
########################################################################
  my ($self) = @_;

  return $self->display_error( 'API Only', $HTTP_NOT_FOUND )
    if !$self->is_api;

  my $doc_name   = $self->context->param('doc');
  my $conf       = $self->config->{BEDROCK_DOCUMENTATION} || {};
  my $file_entry = $conf->{file_list}->{$doc_name};

  return $self->display_error( 'Doc not configured', $HTTP_NOT_FOUND )
    if !$file_entry;

  my $path = $file_entry->{path};

  return $self->display_error( 'File not found', $HTTP_NOT_FOUND )
    if !-e $path;

  my ( $name, $dir, $ext ) = fileparse( $path, qr/\.[^.]*$/xsm );

  if ( $ext =~ /pl|pm|cgi/ixsm ) {
    return $self->show_pod( $path, q{}, $path );
  }

  return $self->show_markdown($path);
}

########################################################################
sub action_env {
########################################################################
  my ($self) = @_;

  my $allow = to_boolean( $self->config->{ALLOW_BEDROCK_ENV_INFO} );

  my $data = $allow ? \%ENV : { ALLOW_BEDROCK_ENV_INFO => 'denied' };

  return $self->print_json($data)
    if $self->is_api;

  return $self->render_hash_dump( 'Environment', $data );
}

########################################################################
sub action_config {
########################################################################
  my ($self) = @_;

  my $allow = to_boolean( $self->config->{ALLOW_BEDROCK_CONFIG_INFO} );

  my $data = $allow ? $self->config : { ALLOW_BEDROCK_CONFIG_INFO => 'denied' };

  return $self->print_json($data)
    if $self->is_api;

  return $self->render_hash_dump( 'Configuration', $data );
}

########################################################################
sub action_session {
########################################################################
  my ($self) = @_;

  my $data = $self->session // {};

  return $self->print_json($data)
    if $self->is_api;

  return $self->render_hash_dump( 'Session', $data );
}

########################################################################
sub action_pod_only {
########################################################################
  my ($self) = @_;

  my $data = $self->session // {};

  my $pod_only = $self->context->param('pod_only');

  $data->{pod_only} = $pod_only;

  return $self->print_json( { %{$data} } );
}

########################################################################
sub action_clear_cache {
########################################################################
  my ($self) = @_;

  if ( my $c = $self->cache() ) {
    $c->clear;
  }

  return $self->print_json( { status => 'cleared' } );
}

########################################################################
sub action_list_cache {
########################################################################
  my ($self) = @_;

  my $c = $self->cache();

  my @keys = $c ? $c->keys : ();

  return $self->print_json( { keys => \@keys } );
}

########################################################################
# HELPERS
########################################################################

########################################################################
sub cache {
########################################################################
  my ($self) = @_;

  my $cache = $self->get('cache');

  return $cache
    if $cache && blessed($cache);

  # 1. Try to Attach OR Create (The Pragmatic Approach)
  $cache = Bedrock::cache( create => 1 );

  # 2. Fallback to Memory (Safety Net)
  if ( !$cache ) {
    $self->log->warn("Shared Cache unavailable/creation failed. Falling back to Bedrock::Cache::Memory");

    eval {
      require Bedrock::Cache::Memory;
      $cache = Bedrock::Cache->new( engine_name => 'Memory' );
    };

    if ( $EVAL_ERROR || !$cache ) {
      confess "CRITICAL: Unable to initialize Shared Cache OR Fallback Memory Cache. Aborting.\n$EVAL_ERROR";
    }
  }

  $self->set( cache => $cache );

  return $cache;
}

########################################################################
sub is_api {
########################################################################
  my ($self) = @_;

  my $accept = $self->request->headers_in->{'ACCEPT'} // q{};

  return $accept =~ /json/xsmi;
}

########################################################################
sub admin_dir { return shift->config->{BEDROCK_ADMIN_DIR} }
########################################################################

########################################################################
sub get_logo {
########################################################################
  my ($self) = @_;

  return sprintf '%s/%s', @{ $self->config }{qw(BEDROCK_IMAGE_URL BEDROCK_LOGO)};
}

########################################################################
sub get_version {
########################################################################
  return Bedrock::VERSION::version('full');
}

########################################################################
sub render_page {
########################################################################
  my ( $self, $tpl_source, %params ) = @_;

  my $config = $self->config;

  $params{env}      = \%ENV;
  $params{back_url} = $self->admin_dir;
  $params{config}   = $config;
  $params{logo}     = $self->get_logo;
  $params{version}  = $self->get_version;
  $params{session} //= $self->session;

  $params{stylesheet} = $config->{BEDROCK_POD_CSS_URL};

  local $ENV{DOCUMENT_ROOT} = $config->{BEDROCK_INCLUDE_DIR};

  my $html = eval { Bedrock::Template->new( $tpl_source, %params )->parse };

  my $err = $EVAL_ERROR;

  $html = $err ? $self->check_error( $err, $tpl_source ) : $html;
  $html =~ s/<html>/<!doctype html>/xsm;

  return $self->print($html);
}

########################################################################
sub fix_pod {
########################################################################
  my ( $self, $html, $type, $module ) = @_;

  if ( $self->is_api ) {
    if ( $html =~ /<body[^>]*>(.*?)<\/body>/is ) {
      return $1;
    }
  }

  my $back = sprintf '%s/%s', $self->admin_dir, $type;
  my $head = $self->header_inc( back_url => $back, module => $module );

  $html =~ s/(<body[^>]*>)/$1\n$head/i;

  return $html;
}

########################################################################
sub show_pod {
########################################################################
  my ( $self, $file, $type, $module ) = @_;

  # Append suffix to avoid collision between Full Page (HTML) and Stripped Body (API)
  my $key = cache_key($module) . ( $self->is_api ? ':API' : q{} );

  my $html = $self->_serve_cached_content(
    $key,
    sub {
      if ( ( !$file || !-e $file ) && $module ) {

        my $rel = $module;
        $rel =~ s{::}{/}gxsm;
        $rel .= '.pm';

        foreach my $dir (@INC) {
          if ( -e "$dir/$rel" ) {
            $file = "$dir/$rel";
            last;
          }
        }
      }

      # --- Generator Callback ---
      my $content = $self->_pod2html( $file, $module );

      if ( !$content && $module ) {
        if ( my $remote_file = $self->is_available_on_metacpan($module) ) {
          $content = $self->_pod2html( $remote_file, $module );
          $self->cache->set( cache_key($module) => $content, ttl => $SERVER_CACHE_TTL );
          unlink $remote_file;
        }
      }

      return
        if !$content;

      # Apply headers/footers (Browser) or strip body tags (API)
      # We cache this Final Result.
      return $self->fix_pod( $content, $type, $module );
    }
  );

  return $HTTP_OK
    if $self->request->status eq '304';

  return $self->display_error( "No POD found for $module", $HTTP_NOT_FOUND )
    if !$html;

  # If API, wrap the cached HTML blob in the expected JSON structure
  if ( $self->is_api ) {
    return $self->print_json(
      { html     => $html,
        uri_root => $self->admin_dir,
      }
    );
  }

  return $self->print($html);
}

########################################################################
sub _pod2html {
########################################################################
  my ( $self, $file, $module ) = @_;

  return
    if !$file || !-e $file;

  my $tmp  = File::Temp->new( UNLINK => 1 )->filename;
  my %opts = ( '--infile' => $file, '--outfile' => $tmp, '--cachedir' => File::Spec->tmpdir );

  if ( !$self->is_api && ( my $css = $self->config->{BEDROCK_POD_CSS_URL} ) ) {
    $opts{'--css'} = $css;
  }

  eval {
    my @args = map { $_ . '=' . $opts{$_} } keys %opts;
    pod2html(@args);
  };

  return slurp_file($tmp);
}

########################################################################
sub get_markdown_listing {
########################################################################
  my ($self) = @_;

  my $list = $self->cache->get( cache_key('markdown_list') );

  return $list
    if $list;

  my $paths = $self->get_markdown_paths;

  my @markdown_files = $self->find_files_of_type( paths => $paths, type => 'md' );

  my %markdown_list;

  foreach (@markdown_files) {
    $markdown_list{ basname($_) } = $_;
  }

  $self->cache->set( cache_key('markdown_list') => \%markdown_list );

  return \%markdown_list;
}

########################################################################
sub fetch_module_list {
########################################################################
  my ( $self, $type, $paths ) = @_;

  my $cache_key = sprintf '%s:MODULE_LIST:%s', ref $self, $type;

  my $list = $self->cache->get($cache_key);

  return $list
    if $list;

  if ( !$paths ) {
    $paths = [
      { filter      => '([bB]edrock|TagX|::[bB]edrock|BLM)',
        filter_type => $type eq 'system' ? 'exclude' : 'include',
        dir         => $Bedrock::Constants::DEFAULT_BEDROCK_PERL5LIBDIR,
      }
    ];
  }

  $list = $self->get_all_modules( $paths, 0 );

  $self->cache->set( $cache_key, $list );

  return $list;
}

########################################################################
sub get_all_modules {
########################################################################
  my ( $self, $paths, $public_only, $no_blms ) = @_;

  my %map;

  foreach my $spec ( @{$paths} ) {
    my $dir = ref($spec) ? $spec->{dir} : $spec;

    my $filter = ref($spec) ? $spec->{filter} : undef;

    my $type = ref($spec) ? $spec->{filter_type} : 'exclude';

    my @files = $self->get_modules( $dir, $no_blms );

    foreach my $file (@files) {
      my $pm = "$file.pm";
      next
        if !-e $pm || !$self->has_pod($pm);

      my $name = $self->get_module_name( $file, $dir );

      next
        if !$name;

      if ($filter) {
        next
          if $type eq 'exclude' && $file =~ /$filter/xsm;

        next
          if $type eq 'include' && $name !~ /$filter/xsm;
      }

      next
        if $public_only && !$self->is_public_module($file);

      $map{$name} = $file;
    }
  }

  return \%map;
}

########################################################################
sub get_modules {
########################################################################
  my ( $self, $dir, $exclude_blms ) = @_;

  return $self->find_files(
    dir          => $dir,
    exclude_blms => $exclude_blms,
    ext          => 'pm'
  );
}

########################################################################
sub find_files {
########################################################################
  my ( $self, %args ) = @_;

  my ( $dir, $no_blms, $ext ) = @args{qw(dir exclude_blms ext)};
  $ext //= 'pm';

  return ()
    if !-d $dir;

  opendir( my $fh, $dir );

  my @listing;

  while ( my $file = readdir $fh ) {
    next if $file             =~ /^\./;
    next if $no_blms && $file =~ /^BLM/;

    if ( -d "$dir/$file" ) {
      push @listing,
        $self->find_files(
        dir          => "$dir/$file",
        exclude_blms => $no_blms,
        ext          => $ext
        );
    }
    elsif ( $file =~ /^([^.]+)[.]$ext$/ ) {
      push @listing, "$dir/$1";
    }
  }

  closedir $fh;

  return @listing;
}

########################################################################
sub get_module_name {
########################################################################
  my ( $self, $file, $dir ) = @_;

  $dir = "$dir/";
  my $potential = $file;
  $potential =~ s/\Q$dir\E//;
  $potential =~ s/\//::/g;

  open my $fh, '<', "$file.pm" or return;
  my @pkgs;
  while ( my $line = <$fh> ) {
    if ( $line =~ /^\s*package\s+([^;]+);/xsm ) {
      push @pkgs, $1;
    }
  }
  close $fh;

  my ($name) = grep {/$potential/} @pkgs;

  return $name // $pkgs[0];
}

########################################################################
sub has_pod {
########################################################################
  my ( $self, $file ) = @_;

  my $text = slurp_file($file);

  return $text =~ /^[=]pod\s*$/m;
}

########################################################################
sub is_public_module {
########################################################################
  my ( $self, $file ) = @_;

  my $source = slurp_file("$file.pm");

  return $source =~ /^[=]head1\s+public/mi;
}

########################################################################
sub get_all_blms {
########################################################################
  my ($self) = @_;

  my @blm_path = grep { -d "$_/BLM" } @INC;

  my $modules
    = $self->fetch_module_list( 'blm', [ map { { dir => $_, filter_type => 'include', filter => 'BLM' } } @blm_path ] );

  my @module_list = sort keys %{$modules};

  return @module_list;
}

# --- Tag Helpers ---

########################################################################
sub find_tag_file {
########################################################################
  my ( $self, $tag ) = @_;

  my $tagx_path = 'Text/TagX/TAG';
  my ($root) = grep { -d "$_/$tagx_path" } @INC;
  return
    if !$root;

  my @stubs  = map {"$root/$tagx_path/$_"} qw( NoBody WithBody WithBody/Loop );
  my $uc_tag = ucfirst $tag;

  foreach my $stub (@stubs) {
    my $file = "$stub/$uc_tag.pm";
    return $file if -e $file;
  }

  my $found;

  find( sub { $found = $File::Find::name if lc($_) eq "$tag.pm"; }, @stubs );

  return $found;
}

our @TAG_LIST;

########################################################################
sub get_tag_list {
########################################################################
  return \@TAG_LIST if @TAG_LIST;

  if ( $Bedrock::Constants::OPENTAG_EXPR =~ /^\^[(](.*?)[)]/xsm ) {
    @TAG_LIST = sort split /[|]/xsm, $1;
    @TAG_LIST = grep { !/[#]|else|else[?]if|blm|[?]/xsm } @TAG_LIST;
  }
  return \@TAG_LIST;
}

# --- Path Helpers ---

########################################################################
sub get_markdown_paths { return shift->get_doc_paths('markdown'); }
########################################################################
sub get_pod_paths { return shift->get_doc_paths('pod'); }
########################################################################

########################################################################
sub get_doc_paths {
########################################################################
  my ( $self, $type ) = @_;
  $type = uc "${type}_PATHS";
  my $config = $self->config;
  my @paths;
  foreach my $source ( $ENV{$type}, $config->{$type} ) {
    next unless defined $source;
    my $list = ref($source) eq 'ARRAY' ? $source : [ split /:/, $source ];
    push @paths, $self->validate_paths(@$list);
  }
  return \@paths;
}

########################################################################
sub validate_paths {
########################################################################
  my ( $self, @paths ) = @_;

  return grep { -d $_ && -r $_ } @paths;
}

# --- Presentation Helpers ---

########################################################################
sub fetch_template {
########################################################################
  my ( $self, $name ) = @_;
  my $dir = $self->config->{BEDROCK_INCLUDE_DIR};
  return slurp_file("$dir/$name.inc");
}

########################################################################
sub render_listing {
########################################################################
  my ( $self, $title, @items ) = @_;

  my $template = $self->fetch_template('bedrock-docs-listing');
  my $head     = $self->listing_head($title);

  return $self->render_page( $template, head => $head, listing => \@items );
}

########################################################################
sub listing_head {
########################################################################
  my ( $self, $title ) = @_;

  my $template = $self->fetch_template('bedrock-docs-listing-index');

  local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};

  my %params = (
    title      => $title,
    config     => $self->config,
    back_url   => $self->admin_dir,
    stylesheet => $self->config->{BEDROCK_POD_CSS_URL},
    version    => $self->get_version,
    logo       => $self->get_logo,
    session    => $self->session,
  );

  return Bedrock::Template->new( $template, %params )->parse;
}

########################################################################
sub ul_links {
########################################################################
  my ( $self, %links ) = @_;
  my $template = $self->fetch_template('bedrock-docs-ul');

  local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};

  return Bedrock::Template->new(
    $template,
    url    => $self->admin_dir,
    links  => \%links,
    config => $self->config
  )->parse;
}

########################################################################
sub blm_ul {
########################################################################
  my ( $self, %args ) = @_;

  my ( $metadata, $title, $modules ) = @args{qw(metadata title modules)};

  return
    if !@{$modules};

  my $uri = '%s/plugins/%s';

  my $list = Bedrock::Hash->new( map { $_ => sprintf $uri, $self->admin_dir, $_ } sort @{$modules} );

  my $template = $self->fetch_template('bedrock-docs-blms');
  local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};

  my %params = (
    heading => $title,
    list    => $list,
    config  => $self->config,
    logo    => $self->get_logo,
    version => $self->get_version,
  );

  return Bedrock::Template->new( $template, %params )->parse;
}

########################################################################
sub render_hash_dump {
########################################################################
  my ( $self, $title, $hash ) = @_;

  $self->bless_all($hash);

  my $template = $self->fetch_template('bedrock-docs-hash-dump');

  my $head = $self->listing_head("Bedrock $title");

  return $self->render_page( $template, head => $head, hash => $hash );
}

########################################################################
sub bless_all {
########################################################################
  my ( $self, $hash ) = @_;

  return
    if !ref $hash;

  foreach my $k ( keys %{$hash} ) {
    my $value = $hash->{$k};
    next if !ref $value;

    if ( reftype($value) eq 'HASH' ) {
      $self->bless_all($value);
    }
    elsif ( reftype($value) eq 'ARRAY' ) {
      foreach my $e ( @{$value} ) {
        $self->bless_all($e);
      }
    }
    else {
      next;
    }

    bless $value, 'Bedrock::Dump';
  }

  return;
}

########################################################################
sub header_inc {
########################################################################
  my ( $self, %params ) = @_;

  my $config = $self->config;

  my $template = $self->fetch_template('bedrock-docs-header');

  local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};
  my $session = $self->session;

  %params = (
    %params,
    logo    => $self->get_logo,
    version => $self->get_version(),
    session => $session,
  );

  return Bedrock::Template->new( $template, %params, config => $config )->parse;
}

########################################################################
sub create_error_page {
########################################################################
  my ( $self, %params ) = @_;

  my $template = $self->fetch_template('bedrock-docs-error');

  $params{error} //= 'Unknown Error';

  local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};

  return Bedrock::Template->new( $template, config => $self->config, %params )->parse;
}

########################################################################
sub show_markdown {
########################################################################
  my ( $self, $file ) = @_;

  my $key = cache_key($file) . ( $self->is_api ? ':API' : q{} );

  my $html = $self->_serve_cached_content(
    $key,
    sub {
      # --- Generator Callback ---
      my $raw_html;

      # 1. Render Markdown to HTML Fragment
      eval {
        my $md = Markdown::Render->new(
          infile => $file,
          engine => 'text_markdown',
          body   => $FALSE
        );
        $md->render_markdown;
        $raw_html = $md->get_html;
      };

      # If rendering fails, return undef so we don't cache the failure
      return
        if $EVAL_ERROR || !$raw_html;

      # 2. API: Return Raw Fragment
      if ( $self->is_api ) {
        return $raw_html;
      }

      # 3. Browser: Wrap in Documentation Template
      local $ENV{DOCUMENT_ROOT} = $self->config->{BEDROCK_INCLUDE_DIR};

      my $template = $self->fetch_template('bedrock-docs-listing-index');

      return Bedrock::Template->new(
        $template,
        content  => $raw_html,
        back_url => $self->admin_dir . '/markdown',
        title    => basename($file),
        config   => $self->config
      )->parse;
    }
  );

  # Handle Render Failure (Not Cached)
  if ( !$html ) {
    return $self->print(
      $self->create_error_page(
        error => "Could not render markdown: $EVAL_ERROR",
        title => basename($file)
      )
    );
  }

  if ( $self->is_api ) {
    return $self->print_json(
      { html     => $html,
        uri_root => $self->admin_dir,
      }
    );
  }

  return $self->print($html);
}

########################################################################
sub cache_key {
########################################################################
  my ($key) = @_;

  $key //= q{};

  $key =~ s/[:\/.-]/_/xsmg;
  while ( $key =~ s/__/_/xmsg ) { }
  $key =~ s/\A_//xsm;

  return sprintf '%s[%s]', __PACKAGE__, uc $key;
}

########################################################################
sub get_module_metadata {
########################################################################
  my ( $self, $module ) = @_;

  my $cache    = $self->cache;
  my $metadata = $cache->get( cache_key('metadata') );

  return $metadata
    if $metadata;

  # --- LAZY LOAD LISTS ---
  # If lists are missing (cache cleared or first run), rebuild them now.
  my $plugins = $cache->get( cache_key('plugin_list') );
  if ( !$plugins ) {
    $plugins = $self->find_files_of_type( filter => 'BLM' );
    $cache->set( cache_key('plugin_list') => $plugins );
  }

  my $bedrock_modules = $cache->get( cache_key('bedrock_list') );
  if ( !$bedrock_modules ) {
    $bedrock_modules = $self->find_files_of_type( filter => 'Bedrock' );
    $cache->set( cache_key('bedrock_list') => $bedrock_modules );
  }

  my $system = $cache->get( cache_key('system_list') );
  if ( !$system ) {
    $system = $self->find_files_of_type( filter => [ 'BLM', 'Bedrock' ], filter_type => 'exclude' );
    $cache->set( cache_key('system_list') => $system );
  }

  $metadata = $self->module_metadata( [ @{$plugins}, @{$bedrock_modules}, @{$system} ] );
  $cache->set( cache_key('metadata') => $metadata );

  return $metadata;
}

########################################################################
sub _serve_cached_content {
########################################################################
  my ( $self, $key, $content_generator ) = @_;

  # 1. Try Internal Server Cache
  # The cache engine now handles inflation automatically.
  # We get back a Perl HashRef: { html => "...", etag => "..." }
  my $cached = $self->cache->get($key);

  my ( $html, $etag );

  if ( $cached && ref $cached eq 'HASH' ) {
    # HIT
    $etag = $cached->{etag};

    # 304 Logic (Unchanged)
    if ( !$self->is_api ) {
      my $req_etag = $self->request->headers_in->{'IF-NONE-MATCH'} // q{};
      $req_etag =~ s/["']//xsmg;
      $req_etag =~ s/\-gzip$//xsm;

      if ( $req_etag eq $etag ) {
        $self->request->headers_out->set( 'ETag'          => qq{"$etag"} );
        $self->request->headers_out->set( 'Cache-Control' => "max-age=$BROWSER_CACHE_TTL, public" );
        $self->request->status(304);
        return;
      }
    }

    # No manual decompression needed here
    $html = $cached->{html};
  }
  else {
    # MISS: Generate Fresh Content
    $html = $content_generator->();

    return if !$html;

    $etag = md5_hex($html);

    # Store RAW data.
    # Bedrock::Cache::Shareable will Freeze -> Gzip -> Store.
    $self->cache->set(
      $key,
      { html => $html,  # Raw HTML
        etag => $etag
      },
      ttl => $SERVER_CACHE_TTL
    );
  }

  # 2. Browser Caching Headers (For 200 OK responses)
  if ( !$self->is_api ) {
    $self->request->headers_out->set( 'ETag'          => qq{"$etag"} );
    $self->request->headers_out->set( 'Cache-Control' => "max-age=$BROWSER_CACHE_TTL, public" );

    # We still keep the 304 check here for the "Cache Miss" path
    # (e.g., Cache expired, but we generated the exact same content the user has)
    my $req_etag = $self->request->headers_in->{'IF-NONE-MATCH'} // q{};
    $req_etag =~ s/["']//g;

    if ( $req_etag eq $etag ) {
      $self->request->status(304);
      return;
    }
  }

  return $html;
}

1;
