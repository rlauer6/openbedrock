package Bedrock::Service::Autocomplete;

use strict;
use warnings;

use parent qw(Bedrock::Service);

use Bedrock qw(slurp_file  to_boolean);
use Bedrock::Constants qw(:booleans :chars :http);
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(basename);
use JSON qw(decode_json);
use Text::URLEncode qw(Encode);

# "Modulino" Hook
caller or __PACKAGE__->new->handler;

########################################################################
sub new {
########################################################################
  my ( $class, %args ) = @_;

  my $self = $class->SUPER::new(
    %args,
    dispatch_map => {
      '/'                   => 'status',
      '/autocomplete/:file' => 'lookup',
    }
  );

  return $self;
}

########################################################################
sub action_lookup {
########################################################################
  my ($self) = @_;

  my $r = $self->cgi;  # The adapter for Request/Response

  # 1. Configuration (faithfully ported from init_autocomplete)
  my $config          = $self->config->{autocomplete}   // {};
  my $global_root     = $ENV{BEDROCK_AUTOCOMPLETE_ROOT} // $config->{root};
  my $caching_enabled = to_boolean( $config->{cache} // 'yes' );

  # 2. Resolve the Target File
  # We use the :file parameter from the route (e.g. /autocomplete/clients.json)
  my $requested_file = $self->context->param('file');

  return $self->display_error( 'No file specified', $HTTP_BAD_REQUEST )
    if !$requested_file;

  my $file_info = $self->_resolve_file_path( $requested_file, $global_root );

  if ( !$file_info ) {
    $self->log->error("File not found for autocomplete: $requested_file");
    return $self->display_error( "File not found", $HTTP_NOT_FOUND );
  }

  # 3. Processing & Caching (The logic from your handler)
  my ( $filename, $mtime ) = @{$file_info}{qw(filename mtime)};

  my $cache = Bedrock::cache();

  my $cache_key = __PACKAGE__ . ':file_list';

  # Retrieve current cache state or initialize empty
  my $cache_list = ( $caching_enabled && $cache ) ? ( $cache->get($cache_key) // {} ) : {};

  my $entry = $cache_list->{$filename} // {};
  my ( $list, $cached_mtime ) = @{$entry}{qw(list mtime)};

  # REFRESH LOGIC: If missing or stale (mtime changed), reload from disk
  if ( !$list || $cached_mtime ne $mtime ) {

    $list = eval {
      my $content = slurp_file($filename);
      die "could not open file [$filename]"
        if !$content;
      return decode_json($content);
    };

    if ( !$list || $EVAL_ERROR ) {
      my $error_msg = $EVAL_ERROR || 'Unknown error decoding JSON';
      $self->log->error("Error loading [$filename]: $error_msg");
      return $self->display_error( "Error loading file: $error_msg", $HTTP_INTERNAL_SERVER_ERROR );
    }

    # Update Cache
    if ( $caching_enabled && $cache ) {
      $cache_list->{$filename} = {
        list  => $list,
        mtime => $mtime,
      };
      $cache->set( $cache_key, $cache_list );
      $self->log->debug("Cache refreshed for [$filename]");
    }
  }
  else {
    $self->log->debug("Read [$filename] from cache");
  }

  # 4. Filter Results
  # Uses your exact logic for 'term' and 'type'
  my $term       = $self->context->param('term');
  my $type       = $self->context->param('type');
  my $search_key = $config->{search_key} // 'label';

  my $result = $self->get_result_set( $list, $search_key, $term, $type );

  return $self->print_json($result);
}

########################################################################
sub _resolve_file_path {
########################################################################
  my ( $self, $request_name, $global_root ) = @_;

  my $clean_name = basename($request_name);

  # A. Check Global Directory (Your Tier 2)
  if ($global_root) {
    my $global_file = "$global_root/$clean_name";
    if ( -e $global_file ) {
      $self->log->debug("Serving global file [$global_file]");
      return { filename => $global_file, mtime => ( stat $global_file )[9] };
    }
  }

  # B. Check Session Directory (Your Tier 3)
  # Mimics HandlerUtils logic using the Service's session path
  if ( my $session_dir = $self->context->session->{_session_dir} ) {
    my $session_file = "$session_dir/$clean_name";
    if ( -e $session_file ) {
      $self->log->debug("Serving session file [$session_file]");
      return { filename => $session_file, mtime => ( stat $session_file )[9] };
    }
  }

  return;
}

########################################################################
# EXACT COPY OF YOUR ORIGINAL LOGIC
########################################################################
sub get_result_set {
########################################################################
  my ( $self, $list, $search_key, $term, $type ) = @_;

  $type //= 'word';  # default match mode

  return $list if !defined $term || $term eq q{};

  $term = lc $term;
  $search_key //= 'label';

  my @matches = grep {
    my $label = lc( $_->{$search_key} // q{} );

        $type eq 'exact'    ? $label eq $term
      : $type eq 'prefix'   ? $label =~ /^\Q$term\E/xsm
      : $type eq 'word'     ? $label =~ /\b\Q$term\E/xsm
      : $type eq 'contains' ? index( $label, $term ) >= 0
      : 0
  } @{$list};

  return \@matches;
}

1;
