package Bedrock::Service::CLI;

use strict;
use warnings;

use Bedrock qw(to_snake_case choose);
use Bedrock::Constants qw(:chars);
use Bedrock::Template;
use CLI::Simple::Constants qw(:booleans);
use Carp;
use Cwd qw(abs_path);
use Data::Dumper;
use FindBin; ## no critic
use English qw(-no_match_vars);
use File::Basename;
use List::Util qw(pairs uniq);
use Module::Load;

use parent qw(CLI::Simple);

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  my $service_name = $self->get_service;

  # Determine the script source for comments/mod_cgi
  my $script_path = abs_path($PROGRAM_NAME);

  if ( !$script_path || !-f $script_path ) {
    require FindBin; ## no critic
    $script_path = abs_path( $FindBin::Bin . q{/} . $FindBin::Script ); ## no critic
  }
  my $script_file = basename($script_path);

  $self->set_script_path($script_path);
  $self->set_script_file($script_file);

  my $action_name = $service_name // $script_file;
  $action_name =~ s/^Bedrock::Service:://;
  $action_name = to_snake_case($action_name);
  $action_name =~ tr/_/-/;

  $self->set_action_name($action_name);

  if ($service_name) {
    if ( $service_name !~ /^Bedrock::Service::.*$/xsm ) {
      # 1. Normalize name (customer-lookup -> Bedrock::Service::CustomerLookup)
      $service_name =~ s/(?:^|[-_])(.)/uc($1)/ge;
      $service_name = "Bedrock::Service::$service_name";
    }

    $self->set_service_class($service_name);

    eval {
      load $service_name;

      my $instance = $service_name->new;
      $self->set_service_instance($instance);
    };

    if ($EVAL_ERROR) {
      if ( $EVAL_ERROR =~ /Can[']t\slocate/xsm ) {
        carp "ERROR: Can't load $service_name\n";
        exit 1;
      }
    }
  }

  return;
}

########################################################################
sub cmd_new {
########################################################################
  my ($self) = @_;

  my $class = eval {
    local $RS = undef;

    my $template = <DATA>;
    $template =~ s/^---.*\z//xsm;
    return $template;
  };

  my $routes = $self->get_routes;

  croak "ERROR: you must define at least one route.\n"
    if !keys %{$routes};

  my ($service_name) = $self->get_args;

  croak "ERROR: no service name\nusage: bedrock-service.pl --routes foo=/foo new Foo\n"
    if !$service_name;

  $service_name = ucfirst $service_name;

  my $tpl = Bedrock::Template->new(
    $class,
    routes       => $routes,
    timestamp    => scalar(localtime),
    service_name => $service_name,
  );

  print {*STDOUT} $tpl->parse();

  return $SUCCESS;
}

########################################################################
sub cmd_install {
########################################################################
  my ($self) = @_;

  my $mod_perl = $self->get_mod_perl // $TRUE;

  if ( $self->get_mod_cgi ) {
    $mod_perl = $FALSE;
  }

  my $service     = $self->get_service_instance;
  my $class_name  = $self->get_service_class;
  my $action_name = $self->get_action_name;

  my $script_path = $self->get_script_path;
  my $script_file = $self->get_script_file;

  my $script_url = $self->get_script_url // sprintf "/cgi-bin/$script_file";

  my $base_uri = $self->get_base_uri // $EMPTY;
  $base_uri =~ s{/\z}{}xsmg;

  if ( !$base_uri ) {
    warn "+----------------------------------------------------------+\n";
    warn "| WARNING: You have not provided a --base-uri.             |\n";
    warn "| All routes will be matched relative to the DOCUMENT_ROOT |\n";
    warn "+----------------------------------------------------------+\n";
  }

  my $map = $service->routes;

  my $location_regex = choose {

    return sprintf '^%s/%s', $base_uri, $action_name
      if !$service->dispatch_map;

    my @prefixes;

    my $allow_root = $FALSE;

    foreach my $route ( keys %{ $service->dispatch_map } ) {
      if ( $route eq $SLASH ) {
        $allow_root = $TRUE;
        next;
      }

      next if $route !~ m{^/([^/:]+)}xsm;
      push @prefixes, $1;
    }

    my $union = ( @prefixes == 1 ) ? $prefixes[0] : sprintf '(%s)', join $PIPE, uniq(@prefixes);

    return qq{^$base_uri/?\$}
      if $allow_root && !$union;

    return qq{^$base_uri/?\$|^$base_uri/$union}
      if $allow_root && $union;

    return sprintf '^%s/%s', $base_uri, $union;
  };

  my $timestamp = localtime;

  # 2. Configure Environment Variables (without BEDROCK_SERVICE_NAME)
  my @core_lines;
  my $directive = $mod_perl ? 'PerlSetEnv' : 'SetEnv';

  push @core_lines, qq{$directive BEDROCK_SERVICE_NAME "$class_name"};

  if ($base_uri) {
    push @core_lines, qq{$directive BEDROCK_BASE_URI "$base_uri"};
  }

  foreach my $p ( pairs %{ $self->get_env // {} } ) {
    my ( $key, $val ) = @{$p};
    push @core_lines, qq{$directive $key "$val"};
  }

  my $body_config = join "\n    ", @core_lines;

  my $config_block = choose {

    return <<"END_APACHE" if $mod_perl;
# Bedrock Service: $class_name
# Mode: mod_perl
# Generated: $timestamp
# Source: $script_path
<IfModule mod_perl.c>

    <LocationMatch "$location_regex">
        SetHandler modperl
        PerlResponseHandler $class_name
        $body_config
    </LocationMatch>
</IfModule>
END_APACHE

    return <<"END_APACHE";
# Bedrock Service: $class_name
# Mode: mod_cgi
# Generated: $timestamp
# Source: $script_path
<IfModule mod_alias.c>
    Action $action_name "$script_url" virtual
</IfModule>
<LocationMatch "$location_regex">
    SetHandler $action_name
    $body_config
</LocationMatch>
<Directory "$FindBin::Bin">
    <Files "$script_file">
        Options +ExecCGI +FollowSymLinks
        Require all granted
    </Files>
</Directory>
END_APACHE
  };

  my $dir = $self->get_conf_dir;

  if ( !$dir ) {
    print $config_block;
    return $SUCCESS;
  }

  die "Error: Directory $dir does not exist.\n"
    if !-d $dir;

  my $file = sprintf '%s/%s.conf', $dir, $action_name;

  open my $fh, '>', $file
    or die "Could not write to $file: $OS_ERROR";
  print {$fh} $config_block;
  close $fh;

  print "Configuration installed to $file\n";

  return $SUCCESS;
}

########################################################################
sub cmd_routes {
########################################################################
  my ($self) = @_;

  my $service = $self->get_service_instance;

  # --- 1. Introspection Mode ---
  my $map = $service->routes;

  print "\nRoute Configuration for " . ref($service) . ":\n";
  print q{-} x 60 . "\n";
  printf "%-30s | %-30s\n", 'URL Pattern', 'Action Method';
  print q{-} x 60 . "\n";

  foreach my $pattern ( sort keys %{$map} ) {
    my $action = $map->{$pattern};
    # Handle simple scalar actions or complex references
    my $display_action = ref($action) ? 'CODE(...)' : "action_$action";

    printf "%-30s | %s\n", $pattern, $display_action;
  }

  print "\n";

  return 0;

}

########################################################################
sub main {
########################################################################

  my @option_specs = qw(
    base-uri=s
    conf-dir=s
    env=s%
    mod-cgi
    mod-perl
    routes
    script-url=s
    service=s
    routes=s%
    help|h
  );

  my %commands = (
    install => \&cmd_install,
    routes  => \&cmd_routes,
    new     => \&cmd_new,
    default => \&cmd_install,
  );

  my $cli = Bedrock::Service::CLI->new(
    { commands      => \%commands,
      option_specs  => \@option_specs,
      extra_options => [qw(service_instance service_class action_name script_path script_file)],
    }
  );

  return $cli->run();
}

1;

__DATA__

package Bedrock::Service::<var $service_name>;
# Autogenerated on <var $timestamp>

use strict;
use warnings;

use parent qw(Bedrock::Service);

our $VERSION = '1.0.0';

caller or __PACKAGE__->new->handler();

########################################################################
sub new {
########################################################################
  my ($class, @args) = @_;

  my %dispatch_map = (
<foreach $routes->
   '<var $value>' => '<var $key>',
</foreach->
  );

  my $self = $class->SUPER::new(dispatch_map => \%dispatch_map, @args);

  return $self;
}

<foreach $routes->
########################################################################
sub action_<var $key> { 
########################################################################
  my ($self) = @_;

  return;
}
</foreach>

1;

---

=pod

=head1 NAME

Bedrock::Service::CLI - CLI for scaffolding, introspecting, and
deploying Bedrock services

=head1 SYNOPSIS

 # Scaffold a new service
 bedrock-service.cgi --routes action=/path new ServiceName

 # Generate Apache config (mod_perl, default)
 bedrock-service.cgi --service my-service install

 # Generate Apache config (mod_cgi)
 bedrock-service.cgi --service my-service --mod-cgi install

 # Write config directly to Apache conf directory
 bedrock-service.cgi --service my-service --base-uri /api \
   --conf-dir /etc/apache2/conf-available install

 # Inspect a service's route table
 bedrock-service.cgi --service my-service routes

=head1 DESCRIPTION

C<Bedrock::Service::CLI> provides the command-line interface for
managing L<Bedrock::Service> applications. It supports three
workflows:

=over 4

=item * B<Scaffolding> - Generate a new service module skeleton with
routes and action stubs already wired up.

=item * B<Deployment> - Generate Apache configuration blocks for
C<mod_perl> or C<mod_cgi> environments.

=item * B<Introspection> - Display the dispatch map of an existing
service for debugging or configuring the Miniserver's Route
Translation map.

=back

=head1 USAGE

 bedrock-service.cgi [options] [command] [args]

If no command is given, C<install> is assumed.

=head2 Commands

=over 4

=item B<new> I<ServiceName>

Generates a L<Bedrock::Service> subclass skeleton and prints it to
STDOUT. Requires one or more C<--routes> options to define the
dispatch map. The service name argument is normalized to the
appropriate package name (e.g., C<Foo> becomes
C<Bedrock::Service::Foo>).

 bedrock-service.cgi --routes search=/search \
    --routes details=/details new Foo

 bedrock-service.cgi --routes search=/search \
    --routes details=/details new Foo > lib/Bedrock/Service/Foo.pm

The generated module includes a constructor with the dispatch map
and stub C<action_*> subroutines for each route.

=item B<install>

Generates an Apache configuration block for the service and prints
it to STDOUT, or writes it to the directory specified by
C<--conf-dir>. Requires C<--service> to identify the service class
to introspect.

Generates C<mod_perl> configuration by default. Use C<--mod-cgi>
to generate a C<mod_cgi> configuration instead.

The C<LocationMatch> regex is automatically derived from the
service's dispatch map.

=item B<routes>

Displays the dispatch map (URL Pattern E<rarr> Action Method) for
the service specified by C<--service>. Useful for verifying route
configuration or setting up the Miniserver's Route Translation map.

=item B<help>

Displays the help message.

=back

=head2 Options

=over 4

=item B<--service>=I<name>

The Bedrock Service class to load. Accepts any of these forms:

 my-service                    (kebab-case)
 MyService                     (CamelCase)
 Bedrock::Service::MyService   (fully qualified)

All forms are normalized to C<Bedrock::Service::MyService>.

If you are running from a symlinked copy of
C<bedrock-service.cgi>, the script name is used as the service
name:

 user-lookup.cgi => Bedrock::Service::UserLookup

Required for the C<install> and C<routes> commands.

=item B<--routes> I<action>=I<path>

Define a route mapping for the C<new> command. May be specified
multiple times. The I<action> becomes the C<action_*> method name
and the I<path> becomes the dispatch map key.

 --routes search=/search --routes edit=/edit

=item B<--base-uri>=I<uri>

Base URI prefix for the service. Used by C<install> to construct
the C<LocationMatch> regex. If omitted, routes are matched
relative to the document root and a warning is issued.

=item B<--conf-dir>=I<directory>

Directory where the generated Apache configuration file should be
written. The file is named C<{action-name}.conf>. If omitted, the
configuration is printed to STDOUT.

=item B<--script-url>=I<url>

The absolute URL to the CGI script for C<mod_cgi> deployments.
Defaults to F</cgi-bin/{script-file-name}>.

=item B<--env> I<KEY>=I<VALUE>

Define additional environment variables to include in the generated
Apache configuration. May be specified multiple times.

 --env BEDROCK_CONFIG_PATH=/etc/bedrock --env DEBUG=1

I<Note: Environment variables are placed inside the C<LocationMatch>
directive. Under C<mod_cgi>, Apache will prefix them with
C<REDIRECT_>.>

=item B<--mod-perl>

Generate a C<mod_perl> configuration block (this is the default).

=item B<--mod-cgi>

Generate a C<mod_cgi> configuration block instead of C<mod_perl>.

=item B<--help>, B<-h>

Display the help message.

=back

=head1 EXAMPLES

=head2 Scaffold and deploy a new service

 # 1. Generate the service module
 bedrock-service.cgi --routes search=/search --routes details=/details \
   new ProductCatalog > lib/Bedrock/Service/ProductCatalog.pm

 # 2. Edit the generated stubs
 vi lib/Bedrock/Service/ProductCatalog.pm

 # 3. Generate and install the Apache config
 bedrock-service.cgi --service product-catalog --base-uri /api \
   --conf-dir /etc/apache2/conf-available install

 # 4. Enable and reload
 a2enconf product-catalog
 systemctl reload apache2

=head2 Quick route check

 bedrock-service.cgi --service product-catalog routes

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=head1 SEE ALSO

L<Bedrock::Service>, L<CLI::Simple>

=cut
