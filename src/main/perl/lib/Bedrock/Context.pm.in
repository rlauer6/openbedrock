#!@PERL@

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Context;

use strict;

BEGIN {
  use Exporter ();
  @Bedrock::Context::ISA = qw (Exporter);
}

use Bedrock::Text::URLEncode;

use Bedrock::BedrockConfig;
use Bedrock::Log;
use Bedrock::Dump;
use Bedrock::Array;

use CGI;
use File::Basename;
use Carp;
use IO::File;

# deprecated in favor of CGI.pm
sub args {
  my $self = shift;
  my $q    = $ENV{'QUERY_STRING'};
  my @args;
  for ( split( '&', $q ) ) {
    my ( $key, $value ) = split '=';
    &Text::URLEncode::decode($value);
    push @args, $key, $value;
  }
  @args;
}

# deprecated in favor of CGI.pm
sub content {
  my $self = shift;
  return unless defined( $ENV{'CONTENT_LENGTH'} );
  my $q;
  read( STDIN, $q, $ENV{'CONTENT_LENGTH'} ) if $ENV{'CONTENT_LENGTH'} > 0;
  my @args;
  for ( split( '&', $q ) ) {
    my ( $key, $value ) = split '=';
    &Text::URLEncode::decode($value);
    push @args, $key, $value;
  }
  @args;
}

# upload_file(form-var-name, options ... | {})
#  options: path         =>
#           Content-Type => scalar | []
#           filename     => name of file
#           maxsize      => 0/undef, unlimited

sub upload_file {
  my $self     = shift;
  my $form_var = shift;
  my $options  = {};

  my $fh = $self->cgi->param($form_var);

  my $platform = $self->cgi->param('platform');

  die "upload_file upload error: ", $self->cgi->cgi_error() unless $fh;

  if ( UNIVERSAL::isa( $_[0], 'HASH' ) ) {
    $options = shift;
  }
  else {
    %{$options} = @_;
  }

  &LOG_MESSAGE( MSG_DEBUG,
                "upload_file options: " . Bedrock::Dump::compact($options) );

  my $upload_content_type = $self->cgi->uploadInfo($fh)->{'Content-Type'};

  # check to see if this is a valid mime-type to be uploaded
  if ( $options->{'Content-type'} || $options->{'content-type'} ) {
    my $content_type = $options->{'Content-type'} || $options->{'content-type'};
    my @content_types;
    push @content_types,
    ( UNIVERSAL::isa( $content_type, 'ARRAY' ) )
    ? @$content_type
    : $content_type;

    &LOG_MESSAGE( MSG_DEBUG,
                  sprintf( "upload_file acceptable content-types: %s",
                           join( ",", @content_types ) )
                );

    die sprintf(
          "upload_file content_type error: uploading (%s), must be one of (%s)",
          $self->cgi->uploadInfo($fh)->{'Content-Type'},
          join( ",", @content_types ) )
    unless grep { $_ eq $self->cgi->uploadInfo($fh)->{'Content-Type'} }
      @content_types;
  }

  # if the file came from a WinDoze machine...set the parsing appropriately
  if ( $platform =~ /win/i || $self->cgi->param($form_var) =~ /^[a-z]:.*$/i ) {
    fileparse_set_fstype('MSWin32');
  }

  my ( $name, $path, $ext ) =
  fileparse( $self->cgi->param($form_var), qr/\.[^.]*/ );

  my $upload_path;
  my $upload_filename;

  $upload_path = $options->{path}
  || ( $self->{CONFIG}->{UPLOAD_PATH} || '/tmp' );
  $upload_filename = $options->{filename} || ( $name . $ext );

  my $uploaded_file = sprintf( "%s/%s", $upload_path, $upload_filename );
  &LOG_MESSAGE( MSG_INFO,
        sprintf( "upload_file processing: file => [%s], content-type => [%s]\n",
                 $uploaded_file, $self->cgi->uploadInfo($fh)->{'Content-Type'}
               )
              );

  open TEMPFILE, ">$uploaded_file";
  my $buffer;
  my $bytesread;
  my $size;
  my $maxsize = $options->{maxsize};

  # allow 1k, 1m, etc.
  if ($maxsize) {
    $maxsize = $1 * 1024        if $maxsize =~ /^(\d+)k/i;
    $maxsize = $1 * 1024 * 1024 if $maxsize =~ /^(\d+)m/i;
  }

  while ( $bytesread = read( $fh, $buffer, 4096 ) ) {
    $size += $bytesread;
    die "File size limit reached.\n"
    if $maxsize && $size >= $maxsize;
    &LOG_MESSAGE( MSG_DEBUG,
                  sprintf( "upload_file bytes read: %d", $bytesread ) );
    print TEMPFILE $buffer;
  }

  close TEMPFILE;

  if ( -s $uploaded_file ) {
    my @l    = stat($uploaded_file);
    my $stat = Bedrock::Hash->new;
    @{$stat}
    {qw(dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks)}
    = @l;
    $stat->{file}           = $uploaded_file;
    $stat->{$form_var}      = "$name$ext";
    $stat->{'content-type'} = $upload_content_type;
    return $stat;
  }
  else {
    return undef;
  }
}

sub cgi {
  $_[0]->{cgi} = $_[0]->{cgi} ? $_[0]->{cgi} : new CGI;
}

#
# Method to get input parameter(s)/value(s)
# Invoked either with
#    1. a list of parameter names. Returns the value of the
#       parameters requested
#    2. No args. Returns the names of all parameters in the
#       input
sub getInputValue {
  my $self = shift;

  unless ( exists $self->{'INPUT'} ) {

    # Collect the input

    my $r = $self->{'APACHE_HANDLER'};

# - a mod_perl 1.x -> 2.x gotcha... $r->args, $r->content in array context no longer supported, does not return
#   parsed results.  Replaced with Apache::Request_cgi args/contents although I have a feeling there is a more
#   better faster way to do this...
#	my @args = ($self->args, $self->content);
    my @args = $self->cgi->param;

    my $input = {};
    foreach my $name (@args) {
      my @values = $self->cgi->param($name);
      if ( @values > 1 ) {
        $input->{$name} = Bedrock::Array->new(@values);
      }
      else {
        $input->{$name} = $values[0];
      }
    }
    $self->{'INPUT'} = $input;
  }

  if ( @_ > 0 ) {

    # Have some parameters -- need the values
    return @{ $self->{'INPUT'} }{@_};
  }
  else {

    # No parameters -- need the names of all parameters
    return keys %{ $self->{'INPUT'} };
  }
}

#
# Constructor for Apache modules
# Returns the created object
# Mandatory Arguments are as follows:
#    APACHE_HANDLER	=> Apache handler object
#    OUTPUT_HANDLER	=>
#	Output handler supporting a `print()' method. Defaults to APACHE_HANDLER
#	if not specified.
# One of the following must be present
#    CONFIG	        => Hash containing config info
#    CONFIG_FILE	=> Name of the config file
#
sub new {
  my $class = shift;
  my %args  = @_;

  die "$class->new(): CONFIG or CONFIG_FILE parameter must be specified."
  unless $args{'CONFIG'}
    or $args{'CONFIG_FILE'};

  die "$class->new(): APACHE_HANDLER parameter must be specified."
  unless $args{'APACHE_HANDLER'};

  my $self = bless {}, $class;
  if ( $args{'CONFIG'} ) {
    $self->{'CONFIG'} = $args{'CONFIG'};
  }
  else {
    $self->{'CONFIG'} = Bedrock::Config->new( $args{'CONFIG_FILE'} );
  }

  $self->{'APACHE_HANDLER'} = $args{'APACHE_HANDLER'};

  if ( $args{'OUTPUT_HANDLER'} ) {
    $self->{'OUTPUT_HANDLER'} = $args{'OUTPUT_HANDLER'};
  }
  else {
    $self->{'OUTPUT_HANDLER'} = $args{'APACHE_HANDLER'};
  }
 
  &Bedrock::Log::StartLogger(
			     LOGDIR   => $self->{'CONFIG'}->{'LOGDIR'},
			     LOGLEVEL => $self->{'CONFIG'}->{'LOGLEVEL'},
			     LOGFILE  => $self->{'CONFIG'}->{'LOGFILE'} || 'bedrock.log'
			    );
  $self;
}

#
# Close method is used when CGI wants to close browser connection and go off
# to do something else and not keep the user waiting
#
sub close {
  shift->{'OUTPUT_HANDLER'}->close;
}

sub print {
  shift->{'OUTPUT_HANDLER'}->print(@_);
}

sub cgi_header_in {
  my $self = shift;
  my $r    = $self->{APACHE_HANDLER};

  ref($r) =~ /Apache2/ ? %{ $r->headers_in } : $r->headers_in;
}

sub cgi_header_out {
  my $self = shift;
  my $r    = $self->{APACHE_HANDLER};

  ref($r) =~ /Apache2/ ? $r->err_headers_out->add(@_) : $r->header_out(@_);
}

sub send_http_header {
  shift->{'APACHE_HANDLER'}->send_http_header;
}

sub getOutputValue {
  my $self = shift;
  return unless exists $self->{'output_vars'};
  if ( @_ == 1 ) {
    return $self->{'output_vars'}->{ $_[0] };
  }
  elsif (@_) {
    &confess("Scalar context is not valid here: should be array context only")
    unless wantarray;
    return @{ $self->{'output_vars'} }{@_};
  }
  else {
    &confess("Scalar context is not valid here: should be array context only")
    unless wantarray;
    return keys %{ $self->{'output_vars'} };
  }
}

sub setOutputValue {
  my $self = shift;
  $self->{'output_vars'} = {} unless exists $self->{'output_vars'};
  my %args = @_;
  my ( $key, $value );
  while ( ( $key, $value ) = each %args ) {
    $self->{'output_vars'}->{$key} = $value;
  }
}

#
# Method returns a config parameter value. Used to hide the Config object from the public.
#
sub getConfigValue {
  my $self = shift;
  if ( @_ > 0 ) {
    wantarray ? @{ $self->{'CONFIG'} }{@_} : $self->{'CONFIG'}->{ $_[0] };
  }
  else {
    keys %{ $self->{'CONFIG'} };
  }
}

#
# Method for management of cookies
#
sub getCookieValue {
  my $self = shift;
  return unless exists $ENV{'HTTP_COOKIE'};

  my $raw_cookie = $ENV{'HTTP_COOKIE'};

  unless ( exists $self->{'__cookies__'} ) {

    $self->{'__cookies__'} = {};

    for my $cookie ( split( "[;,] ?", $raw_cookie ) ) {
      $cookie =~ s/^\s*(.*?)\s*$/$1/;
      my ( $key, $value ) = split( '=', $cookie );
      $self->{'__cookies__'}->{$key} = &Text::URLEncode::Decode($value);
    }
  }

  if ( @_ == 1 ) {
    $self->{'__cookies__'}->{ $_[0] };
  }
  elsif ( @_ > 1 ) {
    my @values;
    for (@_) {
      push @values, $self->{'__cookies__'}->{$_};
    }

    @values;
  }
  else {
    sort keys %{ $self->{'__cookies__'} };
  }
}

sub setCookieValue {
  my $self = shift;

  die "something's wrong, no HEADER object defined in the context object!"
    unless $self->{HEADER};
  
  $self->{HEADER}->set('Set-Cookie', shift);
}


sub config {
  my $self = shift;
  $self->{'CONFIG'};
}

sub input {
  my $self = shift;
  $self->{'INPUT'};
}

sub set_header {
  my $self = shift;
  $self->{HEADER} = shift;
}

sub header {
  my $self = shift;
  $self->{HEADER};

}

#
# Name of Release: $Name$
# $Log$
# Revision 1.23  2011/12/28 17:17:19  eutl420
# - remove supurious warning message
#
# Revision 1.22  2011/11/16 14:34:50  eutl420
# - added methods set_header(), header(), and setCookieValue().  The header object should be set in the Bedrock
#   handler startup code when it instantiates the header object.
#
# Revision 1.21  2011/09/15 16:05:32  eutl420
# - perl tidy
#
# Revision 1.20  2011/09/14 18:51:52  eutl420
# - support added for maxsize option to upload_file() method that restricts the size of files that can be uploaded
#
# Revision 1.19  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.18  2011/07/15 15:30:25  laytonax
# Minor changes to Startup/Header.pm and Bedrock/Context.pm, both of which were exposed when the application stack has multiple Cookie: headers (as is the case when sitting behind an application pool such as an F5 or Varnish).
#
# Revision 1.17  2011/07/04 13:40:07  eutl420
# - add content-type to the stat object returned in the upload_file call
#
# Revision 1.16  2011/03/02 10:25:27  eutl420
# - bugzilla #4499 upload_file, use fileparse_set_fstype
#
# Revision 1.15  2010/12/18 16:27:28  eutl420
# indents
#
# Revision 1.14  2010/12/12 17:16:07  eutl420
# - remove use of Data::Dumper
# - use Bedrock::Text::URLEncode
#
# Revision 1.13  2010/11/29 15:57:52  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.12  2010/11/20 04:09:30  rlauer
# - add client filename to info hash
#
# Revision 1.11  2010/06/24 21:36:25  rlauer
# rename the Bedrock/Config.pm file to Bedrock/BedrockConfig.pm to avoid Config.pm conflict
#
# Revision 1.10  2009/12/30 12:47:04  rlauer
# - CGI.pm module treats multiply named CGI vars from an HTML form by
#   separating the with "\0" if you use the Vars() method to retrieve
#   a hash of the values. That's pretty horrible, and would require some
#   fixup for compatibility with Bedrock I.
#
#   Therefore, we'll use the more straight forward approach of getting the
#   var names using param() and then iterating through the list, gettting the
#   values of each HTML form var.  In this case, param(name) "does the right
#   thing" by returning an array for multiply named CGI vars.
#
# Revision 1.9  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.8  2009/12/26 15:38:40  rlauer
# use CGI for parsing GET/POST data, added upload_file method, args(), content() deprecated
#
# Revision 1.7  2009/12/23 12:26:04  rlauer
# beefed up upload_file
#
# Revision 1.6  2009/12/23 00:46:04  rlauer
# experimental use of CGI, upload method
#
# Revision 1.5  2009/01/13 20:02:48  rlauer
# - modified cgi_header_out/in for Apache2
#
# Revision 1.4  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.3  2008/02/28 18:14:37  rlauer
# Applying Rob's patches to make Bedrock work on Apache 2.x
# (plus a few other obvious bug fixes).
#
# Revision 1.2  2001/02/14 15:35:42  sridhar
# Added copyright and GPL notice
#
# Revision 1.1  2000/12/18 17:59:39  sridhar
# 1. Moved Bedrock/SIS/Base.pm to Bedrock/Context.pm
# 2. Added options OUTPUT_HANDLER to constructor to use for in `print()'
#
# Revision 1.4  2000/12/12 20:18:50  sridhar
# 1. New version integrates SIS::Base and SIS::Base::Apache
# 2. No longer need to use SIS::InputSource since APACHE_HANDLER must be
# specified as an argument to constructor.
# 3. Creates log file named bedrock.log for both CGI and mod_perl
# versions
# 4. Threw out template junk
#
# Revision 1.3  2000/12/08 20:04:17  sridhar
# Added methods `getOutputValue()' and `setOutputValue()'
#
# Revision 1.2  2000/11/07 13:54:45  sridhar
# 1. Can pass a config object instead of a config file to the
# constructor
# 2. Kicked out use of IO::Handle object for output. Directly using
# `*STDOUT' for this purpose.
#
# Revision 1.1  2000/09/18 14:20:26  sridhar
# Moved some generally useful modules under Perl/SIS to Perl/Bedrock/SIS.
#
# Revision 1.10  2000/08/23 17:29:44  sridhar
# Added (empty) method cgi_header_in() which (purportedly) returns a
# hash or hash ref of header fields.
#
# Revision 1.9  2000/07/18 19:26:50  sridhar
# Closing STDOUT too in object method close().
#
# Revision 1.8  2000/07/17 13:57:57  sridhar
# 1. Some cleanup -- removed code not used by any modules.
# 2. Added a close() method for use when CGI wants to close browser
# connection and go off to do something else.
# 3. more comments
#
# Revision 1.7  2000/07/06 18:32:02  sridhar
# 1. new() creates an output handle from STDOUT
# 2. Added methods print(), cgi_header_out() and send_http_header() to
# mirror mod_perl environment
#
# Revision 1.6  2000/06/26 13:53:39  sridhar
# Decoding cookies
#
# Revision 1.5  2000/06/09 17:49:46  sridhar
# 1. Removed _locate_cfg() since same service provided by SIS::Config
# 2. Removed default CONFIG_PATH. Must be set outside now.
# 3. Added some comments
#
# Revision 1.4  2000/06/07 18:34:15  sridhar
# Using config object directly as a hash
#
# Revision 1.3  2000/05/24 13:49:27  sridhar
# 1. Support concept of CONFIG_PATH, a set of colon-separated
# directories where the config file is searched, if the config file is a
# filename without path info. CONFIG_PATH can be set in the environment,
# failing which a default value is used
# 2. The default config file for the class is `sis.cfg' (was `base.cfg'
# earlier)
# 3. XHTML_PATH is treated as a colon-separated list of directories in
# which to look for the template file
# 4. Added a method `getTemplate' for getting the full pathname of a
# template file.
#
# Revision 1.2  2000/05/08 12:57:46  sridhar
# Added method for getting cookies.
#
# Revision 1.1  2000/02/04 16:18:17  sridhar
# Added SIS::Base -- the base class of all CGI classes.
#
#

1;
