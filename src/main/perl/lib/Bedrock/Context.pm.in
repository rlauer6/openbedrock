package Bedrock::Context;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2024, TBC Development Group, LLC.
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

BEGIN {

  no strict 'refs'; ## no critic

  foreach my $sub (qw(request response cache route_params output_vars _shared_dbi)) {
    *{ __PACKAGE__ . "::$sub" } = sub {
      my (@args) = @_;
      return _set( @args, "_$sub" );
    };
  }

  foreach my $sub (qw(config input session header output_handler)) {
    *{ __PACKAGE__ . "::$sub" } = sub {
      my (@args) = @_;
      return _set( @args, uc $sub );
    };
  }
}

use BLM::DBHandler qw(easy_connect);
use Bedrock qw(:booleans :file);
use Bedrock::Array;
use Bedrock::Constants qw(:all);
use Bedrock::DBI::Locator;
use Bedrock::Dump;
use Bedrock::Hash;
use Bedrock::Request;
use Carp qw(carp cluck croak confess);
use Crypt::Cipher::AES;
use Cwd qw(getcwd abs_path);
use DBI;
use Data::Dumper;
use English qw(-no_match_vars);
use IO::File;
use List::Util qw( none pairs uniq );
use Log::Log4perl::Level;
use Scalar::Util qw( reftype );
use Text::URLEncode;

use Role::Tiny::With;
with 'Bedrock::Logger';
with 'Bedrock::Request::Upload';

use Readonly;

Readonly my $UPLOAD_BUFFER_SIZE => 4 * 1024;
Readonly my $UPLOAD_FILE_PERMS  => oct 777;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

use parent qw(Exporter);

our @EXPORT_OK = qw( find_log4perl_conf init_log4perl_logger parse_cookie);

########################################################################
sub new {
########################################################################
  my ( $class, @args ) = @_;

  my $options = ref $args[0] ? $args[0] : {@args};

  # note this does not remove the uc versions (yet)
  foreach ( keys %{$options} ) {
    $options->{ lc $_ } = $options->{$_};  # just lc everything please
  }

  my ( $config, $config_file ) = @{$options}{qw(config config_file)};

  my ($request_name) = grep { $options->{$_} } qw(apache_handler request_handler request);

  my $request = $options->{ $request_name // $EMPTY };

  carp "usage: Bedrock::Context->new( config => config, request => request )\n"
    if !$request || !$config;

  my $self = bless {}, $class;

  # Populate the configuration object...note that if the caller is
  # Apache::Bedrock, then the CONFIG object is most likely the fully
  # merged Bedrock site configuration. There may not be a use case for
  # calling Bedrock::Context with anything but Bedrock::configuration
  # object.

  $config //= eval { return Bedrock::Config->new($config_file); };

  croak "ERROR: could not create a configuration object\n$EVAL_ERROR"
    if !$config || $EVAL_ERROR;

  $self->config($config);
  $self->request($request);
  $self->cache( $options->{cache} );
  $self->route_params( $options->{route_params} );

  if ( $options->{output_handler} ) {
    $self->output_handler( $options->{output_handler} );
    $self->response( $options->{output_handler} );
  }
  else {
    $self->output_handler($request);
    $self->response( $self->request );
  }

  init_log4perl_logger();

  return $self;
}

########################################################################
sub param {
########################################################################
  my ( $self, $key ) = @_;

  # 1. Fetching a specific value: Enforce Sovereignty
  if ( defined $key ) {
    my $rp = $self->route_params;

    # Priority A: Authoritative Route
    return $rp->{$key} if $rp && exists $rp->{$key};

    # Priority B: Standard Input
    return $self->getInputValue($key);
  }

  # 2. Fetching all keys: Explicit and De-duplicated
  my %all_keys;

  if ( my $rp = $self->route_params ) {
    # Using curly braces for visual clarity as per BSG
    @all_keys{ keys %{$rp} } = (1) x keys %{$rp};
  }

  my @input_keys = $self->getInputValue();
  @all_keys{@input_keys} = (1) x @input_keys;

  return keys %all_keys;
}

########################################################################
sub xparam {
########################################################################
  my ( $self, $key ) = @_;

  # 1. If looking for a specific key
  if ( defined $key ) {

    # Priority A: Check Route Params (e.g. /customer/:id)
    # We check exists() because the value might be 0 or empty string
    if ( my $rp = $self->route_params ) {
      return $rp->{$key} if exists $rp->{$key};
    }

    # Priority B: Check Standard Input (Query/Post)
    # getInputValue handles the lazy loading of the request parameters
    return $self->getInputValue($key);
  }

  # 2. If looking for the list of all keys
  my %keys;

  # Gather Route Keys
  if ( my $rp = $self->route_params ) {
    map { $keys{$_} = 1 } keys %{$rp};
  }

  # Gather Input Keys
  map { $keys{$_} = 1 } $self->getInputValue();

  return keys %keys;
}

########################################################################
sub request_adapter {
########################################################################
  my ($self) = @_;

  # If we already have an adapter, return it
  return $self->{_request_adapter} if $self->{_request_adapter};

  # Instantiate Bedrock::Request.
  # We pass the apache_handler ($r) if it exists.
  # The Adapter uses this to decide if it should use Apache2::Request or CGI::Tiny.
  $self->{_request_adapter} = Bedrock::Request->new( $self->apache_handler );

  return $self->{_request_adapter};
}

# Backward compatibility: 'cgi' now returns the Adapter.
# The Adapter implements 'param', so most legacy code will still work.
sub cgi { goto &request_adapter; }

########################################################################
sub get_shared_dbi {
########################################################################
  my ($self) = @_;

  return $self->_shared_dbi
    if $self->_shared_dbi && $self->_shared_dbi->ping;

  my ( $dsn, $user, $pass, $host ) = Bedrock::DBI::Locator->resolve( config => $self->config );

  return
    if !$dsn;

  my $dbh = eval {
    easy_connect(
      dsn      => $dsn,
      user     => $user,
      password => $pass,
      host     => $host,
      # Web Context Safety Defaults
      RaiseError => $TRUE,
      AutoCommit => $TRUE,
      PrintError => $FALSE,
    );
  };

  if ( $EVAL_ERROR || !$dbh ) {
    $self->logger->warn("Context shared DBI connect failed: $EVAL_ERROR");
    return;
  }

  $dbh->{mysql_auto_reconnect} = $TRUE;

  $self->_shared_dbi($dbh);

  return $dbh;
}

########################################################################
# convience logging methods that you might NOT want to use if you
# want to see the real file and line number of log messages!!
########################################################################

{
  ## no critic (RequireArgUnpacking)
  sub debug { return shift->logger->debug(@_); }
  sub info  { return shift->logger->info(@_); }
  sub warn  { return shift->logger->warn(@_); } ## no critic (ProhibitBuiltinHomonyms)
  sub error { return shift->logger->error(@_); }
}

########################################################################
sub find_log4perl_conf {
########################################################################
  my (%options) = @_;

  my $config_paths = $options{path_list};

  my $file = $options{file} // 'log4perl.conf';

  # At one point we added `getcwd` to the list of paths to search.
  # This is a really bad idea since we don't know where the
  # current working directory is when this is being called. We may end
  # up doing a really deep search. Accordingly, we restrict the search
  # paths to the specified configuration directories. Alternatively,
  # the configuration variable LOG4PERL can be used to explicitly call
  # out the file.

  if ( !$config_paths ) {
    my @paths = split /:/xsm, $ENV{CONFIG_PATH} // $EMPTY;

    push @paths, grep {defined} $ENV{BEDROCK_CONFIG_PATH}, $DEFAULT_BEDROCK_CONFIG_PATH;

    $config_paths = [ uniq map { abs_path $_ } grep {$_} @paths ];
  }

  # filter out non-existent paths
  $config_paths = [ grep { $_ && -d $_ } @{$config_paths} ];

  return
    if !@{$config_paths};

  my ($path) = find_in_path(
    find_one  => $TRUE,
    path_list => $config_paths,
    file      => $file,
  );

  return $path;
}

########################################################################
# Usage      : init_log4perl_logger(log4perl_conf)
# Purpose    : initializes Log::Log4perl logging
# Parameters : log4perl_conf - reference to a text object representing
#              Log::Log4perl configuration or the name of a file that
#              contains the configuration
# Returns    : returns a boolean that indicates the success or failure of
#              intializing Log::Log4perl
# Errors     : none
########################################################################
sub init_log4perl_logger {
########################################################################
  my ($log4perl_conf) = @_;

  my $initialized = Log::Log4perl->initialized;

  return $initialized
    if $initialized;

  my $log4perl_conf_file;

  if ( !$log4perl_conf ) {
    $log4perl_conf_file = find_log4perl_conf;
  }

  return $initialized
    if !$log4perl_conf && !$log4perl_conf_file;

  if ( !ref $log4perl_conf && -e $log4perl_conf_file ) {
    my $log4perl_conf_text = slurp_file $log4perl_conf_file;

    $log4perl_conf = \$log4perl_conf_text;
  }

  $initialized = eval { return Log::Log4perl->init($log4perl_conf); };

  if ( !$initialized ) {
    print {*STDERR} sprintf
      "WARNING: could not initialize Log::Log4perl using %s\n%s",
      ${$log4perl_conf}, $EVAL_ERROR;
  }

  my $logger = Log::Log4perl->get_logger;

  $logger->debug(
    sprintf 'Log::Log4perl logging initialized using: %s',
    $log4perl_conf_file ? $log4perl_conf_file : ' passed configuration'
  );

  return $initialized;
}

########################################################################
# Usage      : getInputValue(names)
#            : getInputValue()
# Purpose    : returns array of input values or the names
# Parameters : names : list of input variable names
# Returns    : list of values or the list of variable names
# Errors     : none

########################################################################
sub getInputValue { ## no critic (Capitalization)
########################################################################
  my ( $self, @args ) = @_;

  if ( !defined $self->input ) {
    my $req    = $self->request_adapter;
    my @params = $req->param;  # Adapter handles list context

    my $input = {};

    foreach my $name (@params) {
      # Adapter guarantees multi_param works for both CGI::Tiny and mod_perl
      my @values = $req->multi_param($name);

      if ( @values > 1 ) {
        $input->{$name} = Bedrock::Array->new(@values);
      }
      else {
        $input->{$name} = $values[0];
      }
    }

    $self->input($input);
  }

  if ( @args > 0 ) {
    return @{ $self->input }{@args};
  }
  else {
    return keys %{ $self->input };
  }
}

# Close method is used when CGI wants to close browser connection and go off
# to do something else and not keep the user waiting
########################################################################
sub close { ## no critic
########################################################################
  my ($self) = @_;

  return $self->output_handler->close;
}

########################################################################
sub print { ## no critic
########################################################################
  my ( $self, @args ) = @_;

  return $self->output_handler->print(@args);
}

########################################################################
sub cgi_header_in {
########################################################################
  my ($self) = @_;

  my $r = $self->apache_handler;

  my $headers = $r->headers_in;
  $headers //= {};

  return %{$headers};
}

########################################################################
sub cgi_header_out { cluck 'deprecated! use headers_out()'; goto &headers_out; }
########################################################################
sub headers_out {
########################################################################
  my ( $self, @headers ) = @_;

  my $r = $self->request;

  return $r->headers_out(@headers)
    if ref($r) !~ /Apache2/xsm;

  return @headers ? $r->headers_out->add(@headers) : $r->headers_out;
}

########################################################################
sub send_http_header {
########################################################################
  my ( $self, @headers ) = @_;

  my $r = $self->apache_handler;

  return $r->send_http_header;
}

########################################################################
sub getOutputValue { ## no critic
########################################################################
  my ( $self, @args ) = @_;

  return if !defined $self->output_vars;

  if ( @args == 1 ) {
    return $self->output_vars->{ $args[0] };
  }
  elsif (@args) {
    if ( !wantarray ) {
      cluck 'Scalar context is not valid here: should be array context only';
    }

    return @{ $self->output_vars }{@args};
  }
  else {
    if ( !wantarray ) {
      cluck 'Scalar context is not valid here: should be array context only';
    }
    return keys %{ $self->output_vars };
  }
}

########################################################################
sub setOutputValue { ## no critic (Capitalization)
########################################################################
  my ( $self, @args ) = @_;

  if ( !defined $self->output_vars ) {
    $self->output_vars = {};
  }

  for my $p ( pairs @args ) {
    my ( $key, $value ) = @{$p};
    $self->output_vars->{$key} = $value;
  }

  return $self;
}

########################################################################
sub getConfigValue { ## no critic
########################################################################
  my ( $self, @args ) = @_;

  if ( @args > 0 ) {
    return wantarray ? @{ $self->config }{@args} : $self->config->{ $args[0] };
  }
  else {
    return keys %{ $self->config };
  }
}

sub getCookieValue { goto &get_cookie_value; }

########################################################################
sub get_cookie_value {
########################################################################
  my ( $self, @args ) = @_;

  my $r = $self->apache_handler;

  my $raw_cookie = $r->headers_in->{Cookie} // $ENV{HTTP_COOKIE};
  $raw_cookie //= $EMPTY;

  return
    if !$raw_cookie;

  if ( !exists $self->{__cookies__} ) {
    $self->{__cookies__} = parse_cookie($raw_cookie);
  }

  my %cookie_jar = %{ $self->{__cookies__} };

  my @cookies = sort keys %cookie_jar;
  return @cookies
    if !@args;

  return $cookie_jar{ $args[0] }
    if @args == 1;

  return @cookie_jar{@args};
}

########################################################################
sub parse_cookie {
########################################################################
  my ($raw_cookie) = @_;

  my %cookie_values;

  for my $cookie ( split /[;]\s?/xsm, $raw_cookie ) {
    $cookie =~ s/^\s*(.*?)\s*$/$1/xsm;

    my ( $key, $value ) = split /=/xsm, $cookie;

    $cookie_values{$key} = Text::URLEncode::Decode($value);
  }

  return \%cookie_values;
}

sub setCookieValue { goto &set_cookie_value; }

########################################################################
sub set_cookie_value {
########################################################################
  my ( $self, $cookie ) = @_;

  die q{something's wrong, no HEADER object defined in the context object!}
    if !$self->header;

  return $self->header->set( 'Set-Cookie', $cookie );
}

########################################################################
sub logger {
########################################################################
  my ($self) = @_;

  return $self->get_logger;
}

########################################################################
sub apache_handler { goto &request; }
########################################################################

# deprecated
########################################################################
sub set_header { goto &header; }
########################################################################

########################################################################
sub _set {
########################################################################
  my ( $self, @args ) = @_;

  my $key;
  my $value;

  if ( @args > 1 ) {
    ( $value, $key ) = @args;
    $self->{$key} = $value;
  }
  else {
    $key = $args[0];
  }

  return $self->{$key};
}

########################################################################
sub cleanup {
########################################################################
  my ($self) = @_;

  my $dbi = $self->_shared_dbi;

  return $TRUE
    if !$dbi;

  eval {
    if ( !$dbi->{AutoCommit} ) {
      $dbi->rollback;
    }

    $dbi->disconnect;
  };

  $self->_shared_dbi(undef);

  return $TRUE;
}

########################################################################
DESTROY {
  my ($self) = @_;

  local $EVAL_ERROR = undef;

  eval { $self->cleanup(); };

  return;
}

########################################################################

1;

__END__

=pod

=head1 PUBLIC

Bedrock::Context - provides contextual methods for Bedrock applications

=head1 SYNOPSIS

 use Bedrock::Context;

 my $ctx = Bedrock::Context->new( CONFIG => $config, REQUEST_HANDLER => $handler );

=head1 DESCRIPTION

The context object handles the task of gathering input and writing
output based on the context (web, cli) of the application.

=head1 METHODS AND SUBROUTINES

=head2 new

 new( args )

Constructor for context object.  Returns the created object.

=head2 get_shared_dbi

Returns a shared DBI handle for the current request.
Respects C<DBI_DSN> environment variables for CLI/Shell overrides.

=head2 param

 param( name )
 param()

Unified access to request parameters. This method searches for the parameter 
C<name> in the following order:

=over 4

=item 1. Route Parameters

Parameters extracted by the Bedrock Router (e.g. C</user/:id>).

=item 2. CGI Parameters

Standard Query String and POST parameters.

=back

If no argument is provided, returns a list of all unique parameter names
from both sources.

=head2 cleanup

Crucial lifecycle method. MUST be called at the end of every request.
It rolls back uncommitted transactions, disconnects database handles,
and breaks circular references to prevent memory leaks.

=head2 print

 print( list );

Sends the array of output to the destination.

=head2 upload_file

 upload_file(form-var-name, options ... | {})

Upload a file to the web server. Returns a hash containing metadata about the file.

=head1 AUTHOR

J. Sridhar

Rob Lauer - <bigfoot@cpan.org>

=cut
