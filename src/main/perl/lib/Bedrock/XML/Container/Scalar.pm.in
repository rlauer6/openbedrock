#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package Bedrock::XML::Container::Scalar;

use strict;
use UNIVERSAL;
use Bedrock::XML::Container;

@Bedrock::XML::Container::Scalar::ISA = qw(Bedrock::XML::Container);

# construct a new scalar
# Arguments: $class, $parser, [ <any additional options> ]
# Returns: item object
sub new
{
    my $class = shift;
    my $p = shift;
    my $self = bless Bedrock::XML::Container->new($p, @_), $class;
    $self->{'data'} = '';

    # Parse additional args here if needed
    $self;
}

# Scalars don't take anything other than text. So we croak here
# Arguments: $self, $parser, ..
# Returns: Does not return. Invokes xpcroak().
sub new_object
{
    my ($self, $p) = @_;
    $p->xpcroak("<object> cannot be contained in a <scalar>");
}

# Scalars don't take anything other than text. So we croak here
# Arguments: $self, $parser, ..
# Returns: Does not return. Invokes xpcroak().
sub new_array
{
    my ($self, $p) = @_;
    $p->xpcroak("<array> cannot be contained in a <scalar>");
}

# Add text into the item. Appended to the current data
# Arguments: $self, $p, $string
# Returns: $self
sub text
{
    my ($self, $p, $string) = @_;
    $string =~ s/&lt;/</g;
    $string =~ s/&gt;/>/g;
    $string =~ s/&apos;/\'/g;
    $string =~ s/&quot;/\"/g;
    $string =~ s/&amp;/\&/g;
    $self->{'data'} .= $string;
    $self;
}

sub finalize
{
    my $self = shift;
    $ENV{$self->{'name'}} = $self->{'data'} if $self->{'export_env'};
    delete $self->{'parent'};
    delete $self->{'data'};
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.3  2000/11/09 19:04:15  sridhar
# Unquote XML chars before saving data.
#
# Revision 1.2  2000/11/07 21:14:33  sridhar
# Deleting parent from each object on finalization since that leaves the
# objects in a circular list.
#
# Revision 1.1  2000/11/01 18:37:49  sridhar
# Adding XML capability to Bedrock. Basically we have a class here which
# can read and write arbitrary perl data structures in XML format.
#
#
