#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Bedrock::Application::Plugin;

use Bedrock::Hash;

use TagX::Log;

use vars qw(@ISA);

use strict;

@ISA = qw/Bedrock::Hash/;

=pod

=head1 PUBLIC

Bedrock::Application::Plugin

=head1 SYNOPSIS

  package BLM::Startup::Foo;

  use Bedrock::Application::Plugin;

  use vars qw(@ISA);

  @ISA = qw( Bedrock::Application::Plugin );

  1;

=head1 DESCRIPTION

C<Bedrock::Application::Plugin> is a base class that can be used to
provide the basics for the plumbing for your typical Bedrock
Application Plugin (nee: C<BLM>).

 package BLM::Startup::Foo;

 use Bedrock::Application::Plugin;

 @ISA = qw(Bedrock::Application::Plugin);

 # typically Plugins implement an initialization method
 sub init_plugin {
   my $self = shift;
   
   # your initialization code goes here...for example...connect to a database
   eval {
     my $dbi = DBI->connect( @{$self->config}{qw/DBI_DSN DBI_USER DBI_PASS/} );
     $self->set('dbi', $dbi );
   };

  return $@ ? 0 : 1;
 }

 sub hello_world {
   return "Hello World!";
 }
 
 1;

Create a Bedrock XML file that defines your Application Plugin and
drop this file in the C<$ENV{CONFIG_PATH}/config.d/startup> directory.

 <object> 
   <scalar name="binding">foo</scalar> 
   <scalar name="module">BLM::Startup::Foo</scalar> 
     <object name="config">
       <scalar name="data_source">dbi:mysql:bedrock</scalar>
       <scalar name="username">fred</scalar>
       <scalar name="password">flintstone</scalar>
     </object>
 </object> 

Then in your page...

 <var $foo.hello_world()>

=cut


sub TIEHASH {
  my ( $class, $ctx, $config ) = @_;

  my $self = bless {}, $class;

  $self->context( $ctx );

  $self->config( $config );

  die "plugin $class failed to initialize properly"
    unless $self->init_plugin;

  $self;
}

=pod

=head1 METHODS

=head2 closeBLM

Your plugin can implement an optional method (C<closeBLM>) that will
be called prior to the plugin objectE<039>s destruction.

You should perform any clean-up necessary in this method prior to your
object being destroyed. I<You should not implement a C<DESTROY> method
in your BLM, but rather use this method to perform your shutdown
actions.  Your method is called with the Bedrock object that
was tied to your pluginE<039>s implemention, so you need to use the
template below to access your objectE<039>s class instance>.

 sub closeBLM {
   my $obj = shift;

   my $self = tied(%{$obj});

   # your code here
 }

=cut

sub closeBLM {
  my $obj = shift;

  my $self = tied(%{$obj});
}

=pod

=head2 config

 config()

Returns the configuration object form your Plugin definition file.

=cut

sub config {
  my $self = shift;

  if ( @_ ) {
    $self->set('__config', @_);
  }

  return $self->get( '__config' );
}

=pod

=head2 context

 context()

Returns the context object (see C<Bedrock::Context>).

=cut

sub context {
  my $self = shift;

  if ( @_ ) {
    $self->set('__context', @_);
  }

  return $self->get('__context');
}


=pod

=head2 global_config

 global_config()

Returns the Bedrock F<tagx.xml> config object.

=cut

sub global_config {
  return $_[0]->context->{CONFIG};
}


=pod

=head2 init_plugin

 init_plugin()

You can implement an initialization routine which is called when
Bedrock creates your object.  At the point at which this method is
called you have access to both the PluginE<039>s configuration object
and the context object via the C<config()> and C<context()> methods.

Your initialization method should return true if successful.

=cut

sub init_plugin {
  return 1;
}


=pod

=head2 log_message

 log_message( level, message )

Log a message to the Bedrock page log using the current global logging
level.

Alternately, use the short-cut methods.

=cut

use constant MSG_ABORT    => 1 << 0;
use constant MSG_DEBUG    => 1 << 1;
use constant MSG_INFO     => 1 << 2;
use constant MSG_STATUS   => 1 << 3;
use constant MSG_WARNING  => 1 << 4;
use constant MSG_ERROR    => 1 << 5;
use constant MSG_SYSERROR => 1 << 6;
use constant MSG_FATAL    => 1 << 7;


my %LevelStrings = ( &MSG_DEBUG    => q(MSG_DEBUG),
                     &MSG_INFO     => q(MSG_INFO),
                     &MSG_STATUS   => q(MSG_STATUS),
                     &MSG_WARNING  => q(MSG_WARNING),
                     &MSG_ERROR    => q(MSG_ERROR),
                     &MSG_SYSERROR => q(MSG_SYSERROR),
                     &MSG_FATAL    => q(MSG_FATAL)
                   );

use Data::Dumper;

sub log_message {
  my $level = shift;

  my $self = shift;
  my $message = shift;

  my $cutoff = MSG_INFO;

  while ( my ($key, $val) = each %LevelStrings ) {
    last if 
      $cutoff = ($val eq $self->global_config->{LOGLEVEL}) ? $key : 0;
  }

  # Check that level is valid and return if below cut off level
  $level = MSG_INFO unless defined($level) and $LevelStrings{$level};
  print "cutoff: $cutoff $level\n";

  if ( $level >= $cutoff ) {

    # Convert level to string
    my $level_string = $LevelStrings{$level};

    print "cutoff: $cutoff $level\n";

    TagX::Log::log_message( undef, "[$level_string]: $message\n" );
  }

  return;
}

=pod

=head2 log_debug

=head2 log_error

=head2 log_info

=head2 log_status

=head2 log_warn

=cut

sub log_info   { log_message( MSG_INFO,    @_ ) };
sub log_debug  { log_message( MSG_DEBUG,   @_ ) };
sub log_status { log_message( MSG_STATUS,  @_ ) };
sub log_error  { log_message( MSG_ERROR,   @_ ) };
sub log_warn   { log_message( MSG_WARNING, @_ ) };

=pod

=head2 session

 session()

Return C<$session> object.  

I<Note that BLMs only have access to the C<$session> object via the
C<context> object if the C<$session> object is being pre-bound,
similar to the way the C<$header> object is treated.  Normally BLMs
(like the C<$session> object) are only created when they are used in
the Bedrock page itself. 

To have Bedrock pre-bind the C<$session> object you must declare the
session handling BLM as the official C<$session> object.>

    <!-- Generic Bedrock Sessions -->
    <object>
      <scalar name="binding">session</scalar>
      <scalar name="module">BLM::Startup::UserSession</scalar>

 -->  <scalar name="session">yes</scalar>

      <object name="config">
        <scalar name="verbose">2</scalar>
        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>
        <scalar name="data_source">dbi:mysql:bedrock</scalar>
        <scalar name="username">fred</scalar>
        <scalar name="password">flintstone</scalar>
        <scalar name="table_name">session</scalar>
        <scalar name="purge_user_after">30</scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>
    </object>

=cut

sub session {
  return $_[0]->context->{SESSION};
}


=pod

=head1 AUTHOR

Rob Lauer - rlauer@signatureinfo.com

=head1 SEE ALSO

C<Bedrock::Plugin>, C<Bedrock::Context>, C<Bedrock::Hash>

=cut

# $Log$
# Revision 1.7  2012/07/30 13:30:48  lauerrc
# - pod tweaks
#
# Revision 1.6  2012/07/29 18:39:35  lauerrc
# - finally added a much needed way to write to Bedrock's page log while in a BLM...uses TagX::Log which has been initialized with the
#   LOGFILE name already during page processing.  Methods added log_*() for loggging at various levels.
#
# Revision 1.5  2012/07/29 16:37:09  lauerrc
# - revamped pod, much was just wrong
# - made the module a bit more attractive to use as a starting point for BLMs by adding some helper methods
#   + config
#   + global_config
#   + context
#   + session
#   + init_plugin
#   + closeBLM (stub)
#
# Revision 1.4  2011/09/15 16:08:15  eutl420
# - perl tidy
#
# Revision 1.3  2011/07/17 16:43:21  eutl420
# - @PERL@
#
# Revision 1.2  2011/07/13 18:16:05  eutl420
# - added a config() method to return the module config object
# - updated pod, etc to reflect name change from BLM/AppPLUGIN to Bedrock/Application/Plugin
#

1;
