#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::Expr;

use strict;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  $VERSION = do { my @r = ( q$Revision$ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  @ISA = qw (Exporter);
}

use UNIVERSAL;
use TagX::Log;
use Scalar::Util qw(looks_like_number);
use Cwd;

my $Verbose;

my %STRING_CMP = ( '--gt'   => sub { return $_[0] gt $_[1]; },
                   '--ge'   => sub { return $_[0] ge $_[1]; },
                   '--lt'   => sub { return $_[0] lt $_[1]; },
                   '--le'   => sub { return $_[0] le $_[1]; },
                   '--eq'   => sub { return $_[0] eq $_[1]; },
                   '--ne'   => sub { return $_[0] ne $_[1]; },
                   '--and'  => sub { return $_[0] && $_[1]; },
                   '--or'   => sub { return $_[0] || $_[1]; },
                   '--file' => sub {
		     my $file;

		     if ( $_[1] =~/^(\S*)/ ) {
		       $file = $1;
		     }
		     else {
		       die "no filename specified: usage: filename --file file-test-op\n";
		     }

		     for ( $file )  {
		       /^\~([^~]*)$/  && do {
			 $file = getcwd() . '/' . $1;
			 last;
		       };
		       
		       /^\// && do {
			 $file = $ENV{DOCUMENT_ROOT} . '/' . $file;
			 last;
		       }; 
		     }
		     
		     $_[0] =~/^-?([rwxoRWXOezsfdlpSbctugkTBMAC])/ && do {
		       return eval "-$1 \"". $file ."\" ? 1 : 0"; 
		     };

		     die "invalid file test operation: '$_[0] $_[1]'";
		   },

                   '--ref' => sub { return ref( $_[1] ) =~ /$_[0]/ ? 1 : 0; },
                   '--re'  => sub { 
		     my ($lhs, $rhs) = @_;
		     my $re = ($rhs =~ /^qr/) ? eval $rhs : eval "qr/\$rhs/";
		     return $lhs =~ /$re/;
		   }
                 );

my %NUMBER_CMP = ( '--gt'  => sub { return $_[0] > $_[1]; },
                   '--ge'  => sub { return $_[0] >= $_[1]; },
                   '--lt'  => sub { return $_[0] < $_[1]; },
                   '--le'  => sub { return $_[0] <= $_[1]; },
                   '--eq'  => sub { return $_[0] == $_[1]; },
                   '--ne'  => sub { return $_[0] != $_[1]; },
                   '--and' => sub { return $_[0] && $_[1]; },
                   '--or'  => sub { return $_[0] || $_[1]; },
                 );

sub new {
  my $class = shift;
  my $self  = bless [], $class;
  my $nargs = @_;

  # Check whether unary or binary operator
  my $op_or_lhs = shift @_;

  if ( ref($op_or_lhs) ) {
    my $op = shift @_;

    die "Invalid operator in expression\n" 
      if ref($op);

    if ( $op =~ /^[\+\-\.\*\/]$/ ) {
      die "Insufficient number of arguments(",  $nargs - 1, ") to operator `$op'\n"
	unless $nargs > 2;

      @{$self} = ( $op_or_lhs, $op );

      while ( @_ > 0 ) {
        $op_or_lhs = shift @_;

        die "Operator `$op_or_lhs' is illegal here.\n"
	  unless ref($op_or_lhs);
        push @{$self}, $op_or_lhs;

        if ( @_ > 1 ) {
          $op_or_lhs = shift @_;

          die "Operator `$op_or_lhs' is illegal here: must be `+' only.\n"
	    if ref($op_or_lhs)
	      or ( $op_or_lhs ne '+' && $op_or_lhs ne '.' );

          push @{$self}, $op_or_lhs;
        }
      }
    }
    elsif ( $op =~ /^--(eq|ne|gt|ge|lt|le|re|or|and|ref|file)$/i ) {
      die "Invalid number of arguments(", $nargs - 1, ") for operator `$op'.\n"
	if $nargs != 3;

      my $rhs = shift @_;
      die "Token `$rhs' is illegal here.\n"
	unless ref($rhs);

      @{$self} = ( $op_or_lhs, $op, $rhs );
    }
    elsif ( $nargs == 1 ) {
      @{$self} = ($op_or_lhs);
    }
    else {
      die "Token `$op' is illegal here.\n";
    }
  }
  elsif ( $op_or_lhs =~ /^--(not|defined|exists|array|scalar|object)$/i ) {
    die "Unary operator `$op_or_lhs' requires a single argument: found ",
    $nargs - 1, " instead.\n"
    unless $nargs == 2;
    my $rhs = shift @_;
    die "Token `$rhs' is not a valid argument to unary operator `$op_or_lhs'.\n"
    unless ref($rhs);
    @{$self} = ( $op_or_lhs, $rhs );
  }
  else {
    die "Token `$op_or_lhs' is not a valid unary operator.\n";
  }
  $self;
}

sub verbose {
  my $self = shift;
  if (@_) {
    $Verbose = shift;
  }
  $Verbose;
}

sub eval {
  my $self = shift;
  my ( $l, $op, $r );

  my @args = @{$self};
  &log_message( undef,
                "$self: begin eval with @{[scalar(@args)]} items: (@args)" )
  if $Verbose;

  $l = shift @args;
  if ( defined($l) && ref($l) ) {
    &log_message( undef, "LHS [$l] is an object" ) if $Verbose;
    if ( @args > 0 ) {

      # binary operators
      $op = shift @args;
      die "Invalid operator `$op'.\n"
	unless $op =~ /^(--(eq|ne|gt|ge|lt|le|re|or|and|ref|file)|[\+\.\-\*\/])$/i;

      $op = lc($1);
      &log_message( undef, "op is [$op]" ) if $Verbose;

      if ( $op =~ /^[\+\-\.\*\/]$/ ) {
        $l->verbose(1) 
	  if $Verbose;

        my $str = $l->eval(@_);
        $l->verbose(0) 
	  if $Verbose;

        &log_message( undef, "$l eval'ed to [$str]" ) 
	  if $Verbose;

        do {
          $l = shift @args;
          $l->verbose(1) 
	    if $Verbose;
          my $str2 = $l->eval(@_);

          for ($op) {

            # arithmetic addition or string catenation
            /\+/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str + $str2;
              }
              else {
                $str .= $str2;
              }
              last;
            };

            # multiplication or string replication
            /\*/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str * $str2;
              }
              elsif ( looks_like_number($str2) ) {
                $str = $str x $str2;
              }
              next;
            };

            # division or string reduction?
            /\// && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str / $str2 if $str2;
              }
              else {
                $str =~ s/$str2//g;
              }
              last;
            };

            # subtraction or replacement (at end) with null
            /\-/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str - $str2;
              }
              else {
                $str =~ s/${str2}$//g;    # "barfoobar" - "bar" = "barfoo" ?
              }
              last;
            };

            # string catenation
            /\./ && do {
              $str .= $str2;
              last;
            };
          }

          $l->verbose(0) if $Verbose;
          $op = shift @args if @args > 1;
        } while ( @args > 0 );
        return $str;
      }
      else {
        $r = shift @args;
        $l->verbose(1) if $Verbose;
        my $lval = $l->eval(@_);
        $l->verbose(0) if $Verbose;
        $r->verbose(1) if $Verbose;
        my $rval = $r->eval(@_);
        $r->verbose(0) if $Verbose;
        &log_message( undef, "RHS: [$rval]" )
        if $Verbose;

        my $result;
        eval {
          if ( looks_like_number($lval) && looks_like_number($rval) )
          {
            &log_message( undef, "result: " . $NUMBER_CMP{$op}( $lval, $rval ) )
            if $Verbose;

            $result = $NUMBER_CMP{$op}( $lval, $rval );
          }
          else {
            &log_message( undef, "result: " . $STRING_CMP{$op}( $lval, $rval ) )
            if $Verbose;
            $result = $STRING_CMP{$op}( $lval, $rval );
          }
        };

        die
"internal error evaluating expression op: $op lval:[$lval] rval:[$rval]\n$@\n"
        if $@;
        return $result;
      }
    }
    else {
      $l->verbose(1) if $Verbose;
      my $v = $l->eval(@_);
      $l->verbose(0) if $Verbose;
      return $v;
    }
  }
  elsif ( $l && $l =~ /^--(not|defined|array|scalar|object|exists)$/oi ) {
    &log_message( undef, "LHS [$l] is an operator" ) if $Verbose;

    # unary operators
    $op = lc($l);
    $l  = shift @args;
    &log_message( undef, "Argument to unary(`op') operator is [$l]" )
    if $Verbose;
    if ( $op eq '--exists' ) {
      die "Invalid argument for `--exists' operator.\n"
      unless &UNIVERSAL::isa( $l, 'TagX::Term::Var' );
      $l->verbose(1) if $Verbose;
      my $exists = $l->exists(@_);
      $l->verbose(0) if $Verbose;
      return $exists;
    }
    elsif ( $op eq '--defined' ) {
      die "Invalid argument for `--defined' operator.\n"
      unless &UNIVERSAL::isa( $l, 'TagX::Term::Var' );
      $l->verbose(1) if $Verbose;
      my $defined = $l->defined(@_);
      $l->verbose(0) if $Verbose;
      return $defined;
    }
    elsif ( $op eq '--array' ) {
      die "invalid argument for unary(`$op') operator.\n"
      unless $l->can('eval');
      $l->verbose(1) if $Verbose;
      my $value = $l->eval(@_);
      $l->verbose(0) if $Verbose;
      &log_message( undef,
                    "Argument to unary(`op') operator evaluated to [$value]" )
      if $Verbose;
      return ref($value) =~ /array/i ? 1 : 0;
    }
    elsif ( $op eq '--scalar' ) {
      die "invalid argument for unary(`$op') operator.\n"
      unless $l->can('eval');
      $l->verbose(1) if $Verbose;
      my $value = $l->eval(@_);
      $l->verbose(0) if $Verbose;
      &log_message( undef,
                    "Argument to unary(`op') operator evaluated to [$value]" )
      if $Verbose;
      return ref($value) =~ /scalar/i ? 1 : 0;
    }
    elsif ( $op eq '--object' ) {
      die "invalid argument for unary(`$op') operator.\n"
      unless $l->can('eval');
      $l->verbose(1) if $Verbose;
      my $value = $l->eval(@_);
      $l->verbose(0) if $Verbose;
      &log_message( undef,
                    "Argument to unary(`op') operator evaluated to [$value]" )
      if $Verbose;
      return ref($value) =~ /hash/i ? 1 : 0;
    }
    else {
      die "invalid argument for unary(`$op') operator.\n"
      unless $l->can('eval');
      $l->verbose(1) if $Verbose;
      my $value = $l->eval(@_);
      $l->verbose(0) if $Verbose;
      &log_message( undef,
                    "Argument to unary(`op') operator evaluated to [$value]" )
      if $Verbose;
      return defined($value) && $value ? 0 : 1;
    }
  }
  else {
    my @caller = caller;
    warn "Caller is (@caller)";
    die "unsupported unary operator: $l\n";
  }
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.31  2013/01/21 00:09:50  rlauer
# - add support for --file (file test operators)
#
# Revision 1.30  2012/07/18 13:41:45  lauerrc
# - minor formatting changes
#
# Revision 1.29  2011/09/21 19:57:29  eutl420
# - allow quoted regexpr (qr//) in --re expressions
#
# Revision 1.28  2011/09/15 16:05:32  eutl420
# - perl tidy
#
# Revision 1.27  2011/09/09 18:58:06  eutl420
# - in the eval method a return from an eval block simply exists the eval, it did not return from the
#   eval method itself
# - fixed typo in log message defined(s)
#
# Revision 1.26  2011/09/05 16:46:16  eutl420
# - forgot that --and, --or might work on numbers too!.  Added eval block around evaluation
#   to trap any compatibility errors that might show up
#
# Revision 1.25  2011/09/01 01:33:00  eutl420
# - the comparison operators traditionally only worked with strings, Bedrock 2 is going
#   to implement numeric comparisons.  If both operands "look" like numbers, then we
#   will assume the comparison is intended to be a numeric one.
#
# Revision 1.24  2011/08/31 02:45:36  eutl420
# - added the unary operator --defined.  We had --exists, but now we have --defined
#
# Revision 1.23  2011/08/23 14:44:17  eutl420
# - when checking for the newly supported operators the old test did not look at the whole string because there
#   was no other context for the only supported operator (+). The test now must ensure that the operator is exactly
#   equivalent to the supported operators ., -, /, *
#
# Revision 1.22  2011/08/22 23:34:49  eutl420
# - define - operator for string ops
#
# Revision 1.21  2011/08/18 21:58:52  eutl420
# - allow ./* and + to support arithmetic and overload string ops
#
# Revision 1.20  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.19  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.18  2010/11/29 15:57:53  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.17  2008/12/11 13:39:26  rlauer
# support for new unary operartors and ref
#
# Revision 1.16  2008/12/11 13:35:47  rlauer
# support for new unary operartors and ref
#
# Revision 1.15  2008/12/11 13:30:20  rlauer
# support for new unary operartors and ref
#
# Revision 1.14  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.13  2001/02/14 15:35:48  sridhar
# Added copyright and GPL notice
#
# Revision 1.12  2000/11/16 19:22:39  sridhar
# 1. Better error trapping.
# 2. Fixed error messages so exceptions don't have perl source code
# locations in them.
#
# Revision 1.11  2000/07/18 14:34:44  sridhar
# Proper checking of object type as `TagX::Term' instead of just `Term'
#
# Revision 1.10  2000/06/27 12:52:00  sridhar
# BUG Fix: Expression was not working properly in a loop, due to
# `shift'ing of expression arguments. Fixed by copying the expression
# arguments to an array before shifting it.
#
# Revision 1.9  2000/06/21 15:59:17  sridhar
# Declaration for UNIVERSAL::isa() was missing
#
# Revision 1.8  2000/06/01 18:36:53  sridhar
# Brand new version with
# 1. Use of a package for parsing statements
# 2. Support for invocation of object methods
#
# Revision 1.7  2000/05/31 14:31:52  sridhar
# Yuck! compilation error for not declaring @ISA
#
# Revision 1.6  2000/05/31 14:26:23  sridhar
# Rigorous version numbering and usage
#
# Revision 1.5  2000/05/31 13:37:06  sridhar
# 1. Removed `--verbose' option to expressions
# 2. Added a `verbose' method which is invoked with an on or off flag
# when the expression is being finalized
# 3. More verbose message logging
#
# Revision 1.4  2000/05/25 18:30:21  sridhar
# Support for concatenation of strings.
#
# Revision 1.3  2000/05/18 13:47:18  sridhar
# 1. Added possibility of debugging with --verbose option to
# expressions.
# 2. More logging to go with it.
#
# Revision 1.2  2000/05/02 12:48:33  sridhar
# Fixed invocation of Expr->new().
#
# Revision 1.1  2000/04/13 15:12:25  sridhar
# Adding TagX::Expr -- class for processing expressions
#
#
