
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::Expr;

use strict;
use warnings;

use parent qw{Exporter};

use Role::Tiny::With;
with 'Bedrock::Logger';

use Scalar::Util qw(looks_like_number reftype);
use List::Util qw{ none any };
use Data::Dumper;
use English qw{-no_match_vars};

use Cwd;
use Bedrock::Constants qw{:chars :booleans};

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

########################################################################
my $Verbose;

our %STRING_CMP = (
  '--gt' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a gt $b;
  },
  '--ge' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a ge $b;
  },
  '--lt' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a lt $b;
  },
  '--le' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a le $b;
  },
  '--eq' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a eq $b;
  },
  '--ne' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a ne $b;
  },
  '--and' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a && $b;
  },
  '--or' => sub {
    my ( $a, $b ) = map { $_ // $EMPTY } @_;
    return $a || $b;
  },
  '--file' => sub {
    my $file;

    if ( $_[1] =~ /^(\S*)/ ) {
      $file = $1;
    }
    else {
      die "no filename specified: usage: filename --file file-test-op\n";
    }

    for ($file) {
      /^\~([^~]*)$/ && do {
        $file = getcwd() . '/' . $1;
        last;
      };

      /^[^\/~]/ && do {
        $file = $ENV{DOCUMENT_ROOT} . '/' . $file;
        last;
      };
    }

    $_[0] =~ /^-?([rwxoRWXOezsfdlpSbctugkTBMAC])/ && do {
      return eval "-$1 \"" . $file . "\" ? 1 : 0";
    };

    die "invalid file test operation: '$_[0] $_[1]'";
  },

  '--ref' => sub { return ( ref( $_[0] ) =~ /$_[1]/ ) ? 1 : 0; },

  '--reftype' =>
    sub { return ( ref( $_[0] ) && reftype( $_[0] ) eq $_[1] ) ? 1 : 0; },

  '--re' => sub {
    # $lhs may be undef
    my ( $lhs, $rhs ) = @_;
    $lhs = $lhs // $EMPTY;

    my $re = ( $rhs =~ /^qr/ ) ? eval $rhs : eval "qr/\$rhs/";

    # capture groups supported for perl >= 5.10
    if ( $^V ge 'v5.10' ) {
      return $lhs =~ /$re/ ? ( 1, eval { my %cg = %+; \%cg; } ) : undef;
    }
    else {
      return $lhs =~ /$re/;
    }
  },

  '--exists' => sub {
    my ( $lhs, $rhs ) = @_;

    die "invalid argument for '--exists': HASH --exists KEY\n"
      if !ref($lhs) || reftype($lhs) ne 'HASH';

    return exists $lhs->{$rhs} ? $TRUE : $FALSE;
  },

);

our %NUMBER_CMP = (
  '--gt' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a > $b;
  },
  '--ge' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a >= $b;
  },
  '--lt' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a < $b;
  },
  '--le' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a <= $b;
  },
  '--eq' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a == $b;
  },
  '--ne' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a != $b;
  },
  '--and' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a && $b;
  },
  '--or' => sub {
    my ( $a, $b ) = map { $_ || 0 } @_;
    return $a || $b;
  },
);

########################################################################
sub new {
########################################################################
  my ( $class, @args ) = @_;

  my $self  = bless [], $class;
  my $nargs = scalar @args;

  # Check whether unary or binary operator
  my $op_or_lhs = shift @args;

  if ( ref $op_or_lhs ) {
    my $op = shift @args;

    die "Invalid operator in expression\n"
      if ref $op;

    if ( $op =~ /^[+\-.*\/]$/xsm ) {
      die sprintf "Insufficient number of arguments(%s) to operator (%s)\n",
        $nargs - 1, $op
        if $nargs <= 2;

      @{$self} = ( $op_or_lhs, $op );

      while ( @args > 0 ) {
        $op_or_lhs = shift @args;

        die "Operator `$op_or_lhs' is illegal here.\n"
          if !ref $op_or_lhs;

        push @{$self}, $op_or_lhs;

        if ( @args > 1 ) {
          $op_or_lhs = shift @args;

          die "Operator `$op_or_lhs' is illegal here: must be `+' only.\n"
            if ref $op_or_lhs
            or ( $op_or_lhs ne $PLUS_SIGN && $op_or_lhs ne $DOT );

          push @{$self}, $op_or_lhs;
        }
      }
    }
    elsif ( any { $op eq $_ }
      map {"--$_"} qw{eq ne gt ge lt le re or and ref file exists } ) {
      die sprintf "Invalid number of arguments(%s) for operator (%s)\n",
        $nargs - 1, $op
        if $nargs != 3;

      my $rhs = shift @args;

      die "Token `$rhs' is illegal here.\n"
        if !ref $rhs;

      @{$self} = ( $op_or_lhs, $op, $rhs );
    }
    elsif ( $nargs == 1 ) {
      @{$self} = ($op_or_lhs);
    }
    else {
      die "Token `$op' is illegal here.\n";
    }
  }
  elsif (
    any { lc $op_or_lhs eq $_ }
    map {"--$_"} qw{ not defined exists array scalar hash object}
  ) {

    die sprintf
      "Unary operator %s requires a single argument: found %d instead\n",
      $op_or_lhs, $nargs - 1
      if $nargs != 2;

    my $rhs = shift @args;

    die
      "Token `$rhs' is not a valid argument to unary operator `$op_or_lhs'.\n"
      if !ref $rhs;

    @{$self} = ( $op_or_lhs, $rhs );
  }
  else {
    die "Token `$op_or_lhs' is not a valid unary operator.\n";
  }

  return $self;
}

########################################################################
sub verbose {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    $Verbose = $args[0];
  }

  return $Verbose;
}

########################################################################
sub eval {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my $self = shift;

  my $logger = $self->get_logger( ref $self );

  my ( $l, $op, $r );

  my @args = @{$self};

  $logger->debug(" begin eval with @{[scalar(@args)]} items: (@args)");

  $l = shift @args;

  if ( defined $l && ref $l ) {
    $logger->debug("LHS [$l] is an object");

    if ( @args > 0 ) {

      # binary operators
      $op = shift @args;

      if ( $op
        =~ /^(--(eq|ne|gt|ge|lt|le|or|and|reftype|ref|re|file|exists)|[\+\.\-\*\/])$/i
      ) {
        $op = lc $1;
      }
      else {
        die "Invalid operator `$op'.\n";
      }

      $logger->debug("op is [$op]");

      if ( $op =~ /^[\+\-\.\*\/]$/ ) {

        my $str = $l->eval(@_);

        $logger->debug("$l eval'ed to [$str]");

        do {
          $l = shift @args;

          my $str2 = $l->eval(@_);

          for ($op) {

            # arithmetic addition or string catenation
            /\+/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str + $str2;
              }
              else {
                $str .= $str2;
              }
              last;
            };

            # multiplication or string replication
            /\*/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str * $str2;
              }
              elsif ( looks_like_number($str2) ) {
                $str = $str x $str2;
              }
              next;
            };

            # division or string reduction?
            /\// && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str / $str2 if $str2;
              }
              else {
                $str =~ s/$str2//g;
              }
              last;
            };

            # subtraction or replacement (at end) with null
            /\-/ && do {
              if ( looks_like_number($str) && looks_like_number($str2) ) {
                $str = $str - $str2;
              }
              else {
                $str =~ s/${str2}$//g;  # "barfoobar" - "bar" = "barfoo" ?
              }
              last;
            };

            # string catenation
            /\./ && do {
              $str .= $str2;
              last;
            };
          }

          if ( @args > 1 ) {
            $op = shift @args;
          }

        } while ( @args > 0 );

        return $str;
      }
      else {
        $r = shift @args;

        my $lval = $l->eval(@_);

        my $rval = $r->eval(@_);

        $logger->debug("RHS: [$rval]");

        my $result;

        eval {
          if ( looks_like_number($lval) && looks_like_number($rval) ) {

            $logger->debug( 'result: ' . $NUMBER_CMP{$op}( $lval, $rval ) );

            $result = $NUMBER_CMP{$op}( $lval, $rval );
          }
          else {
            $logger->debug( 'result: ' . $STRING_CMP{$op}( $lval, $rval ) );

            my $cg;
            ( $result, $cg ) = $STRING_CMP{$op}( $lval, $rval );

            # grab capture group from regular expression if op is --re
            if ( $result && $op-- eq '--re' ) {
              map { $_[0]->{$_} = $cg->{$_}; } keys %{$cg};
            }
          }
        };

        die
          "internal error evaluating expression op: $op lval:[$lval] rval:[$rval]\n$EVAL_ERROR\n"
          if $EVAL_ERROR;

        return $result;
      }
    }
    else {

      my $v = $l->eval(@_);

      return $v;
    }
  }
  elsif ( $l && $l =~ /^--(not|defined|array|scalar|object|hash|exists)$/oi )
  {
    $logger->debug("LHS [$l] is an operator");

    # unary operators
    $op = lc $l;
    $l  = shift @args;

    $logger->debug("Argument to unary(`op') operator is [$l]");

    if ( $op eq '--exists' ) {
      die "Invalid argument for `--exists' operator.\n"
        if ref($l) ne 'TagX::Term::Var';

      my $exists = $l->exists(@_);

      return $exists;
    }
    elsif ( $op eq '--defined' ) {
      die "Invalid argument for `--defined' operator.\n"
        if ref($l) ne 'TagX::Term::Var';

      my $defined = $l->defined(@_);

      return $defined;
    }
    elsif ( $op eq '--scalar' ) {
      die "invalid argument for unary(`$op') operator.\n"
        if !$l->can('eval');

      my $value = $l->eval(@_);

      $logger->debug(
        "Argument to unary(`op') operator evaluated to [$value]");

      return ( ref($value) && reftype($value) eq 'SCALAR' ) ? 1 : 0;
    }
    elsif ( $op eq '--array' ) {
      die "invalid argument for unary(`$op') operator.\n"
        if !$l->can('eval');

      my $value = $l->eval(@_);

      $logger->debug(
        "Argument to unary(`op') operator evaluated to [$value]");

      return ( ref($value) && reftype($value) eq 'ARRAY' ) ? 1 : 0;
    }
    elsif ( $op eq '--hash' ) {
      die "invalid argument for unary(`$op') operator.\n"
        if !$l->can('eval');

      my $value = $l->eval(@_);

      $logger->debug(
        "Argument to unary(`op') operator evaluated to [$value]");

      return ( ref($value) && reftype($value) eq 'HASH' ) ? 1 : 0;
    }
    elsif ( $op eq '--object' ) {
      die "invalid argument for unary(`$op') operator.\n"
        if !$l->can('eval');

      my $value = $l->eval(@_);

      $logger->debug(
        "Argument to unary(`op') operator evaluated to [$value]");

      return ( ref($value) && reftype($value) eq 'HASH' ) ? 1 : 0;
    }
    else {
      die "invalid argument for unary(`$op') operator.\n"
        if !$l->can('eval');

      my $value = $l->eval(@_);

      $logger->debug(
        "Argument to unary(`op') operator evaluated to [$value]");

      return defined($value) && $value ? 0 : 1;
    }
  }
  else {
    die "unsupported unary operator: $l\n";
  }
}

1;
