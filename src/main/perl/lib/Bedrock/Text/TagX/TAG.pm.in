#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package TagX::TAG;

use strict;
use TagX::Expr;
use TagX::Term;
use TagX::Term::Var;
use TagX::Term::String;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

my $delim_expr		= $TagX::Expr::_delimiters;
my %ending		= %TagX::Expr::_delimiter_end;

sub new
{
    my $class = shift;
    my $self = bless {}, $class;
    $self->{'nobjs'} = 0;
    $self->{'subobjs'} = [];
    $self->{'parent'} = undef;
    my $tx = shift if @_ == 1;
    $self->{'TagX'} = $tx;
    $self;
}

sub start_location
{
    my $self = shift;
    if ( @_ > 0 ) {
	$self->{'__start_location'} = shift;
    }
    $self->{'__start_location'};
}

sub resolve_name
{
    my $self = shift;
    my $name = shift;
    warn "$self: name = ($name) context = (@_)\n" if $self->options->{'verbose'};
    $name =~ s/^\$//;
    my @components = split /\./oi, $name;
    my $first = shift @components;
    warn "$self: first = ($first)\n" if $self->options->{'verbose'};
    return undef unless $first;
    my $found;
    for my $context (@_) {
	if ( exists $context->{$first} ) {
	    $found = $context->{$first};
	    last;
	}
    }
    warn "$self: found $first in ($found)\n" if $self->options->{'verbose'};
    return undef unless defined( $found );
    for (@components) {
	if ( /^\Q[\E(\d+)\Q]\E/oi ) {
	    # array element
	    return undef unless ref( $found ) eq 'ARRAY';
	    $found = $found->[$1];
	    next;
	}

	if ( /^{(.*?)}/oi or /^([^.]+)/oi ) {
	    # hash element
	    if ( ref( $found ) eq 'HASH' ) {
		$found = $found->{$1};
	    } else {
		# Support syntax for accessing hash contained in an array
		# if the array contains only one element
		# Other cases are failures
		return undef unless ref( $found ) eq 'ARRAY' and @{$found} == 1;
		$found = $found->[0]->{$1};
	    }
	    next;
	}

	# illegal
	return undef;
    }
    $found;
}

sub name
{
    my $self = shift;
    $self->{'name'} = shift if @_ == 1;
    $self->{'name'};
}

sub parent
{
    my $self = shift;
    $self->{'parent'} = shift if @_ == 1;
    $self->{'parent'};
}

sub __save_option
{
    my ($argv, $optv, $generic, $key, $term) = @_;

    if ( defined ($key) && exists $generic->{$key} ) {
	$generic->{$key}++ unless defined( $term );
	return;
    }

    if ( defined( $term ) && defined( $key ) ) {
	push @{$argv}, $key, $term;
	if ( exists ( $optv->{$key} ) ) {
	    $optv->{$key} = [$optv->{$key}] unless ref($optv->{$key}) eq 'ARRAY';
	    push @{$optv->{$key}}, $term;
	} else {
	    $optv->{$key} = $term;
	}
    } elsif ( defined( $key ) ) {
	push @{$argv}, $key;
	$optv->{$key}++;
    } else {
	push @{$argv}, $term;
    }
}

#
# Parse Tag options, and return an array of parsed options. Takes an array reference to populate
# the options, and the string to parse. Returns the array reference
#
sub tagOptions_as_array
{
    my $args = shift;
    local $_ = shift;
    my $generic = shift;
    my $optref = {};
    my $term;
    while ( length ) {
	s/^\s*//;

	if ( s/^\x28\s*//oi ) {
	    push @{$args}, TagX::Expr->new;
	    next;
	}

	# Check for option with value
	if ( s/^--([\w-]+)\s*=\s*//oi ) {
	    my $key = lc ($1);

	    # value delimited by special chars
	    if ( s/^$delim_expr//oi ) {

		# Found a delimiter after '='
		# Check for value composed of non-delimiter, ended by the matching delimiter
		my $arg = ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?// ? $1 : $_ );
		if ( $key eq 'name' ) {
		    $arg =~ s/^/\$/ unless $arg =~ /^\$/;
		    $key = undef;
		}
		$term = TagX::Term::String->new( $arg );
		&__save_option ( $args, $optref, $generic, $key, $term );

		# continue parsing for more options
		next;
	    }

	    # option with value continued. No starting delimiter after '='
	    # Assume value delimited by spaces
	    if ( s/^([^\s\x28\x29]+)//oi ) {
		my $arg = $1;
		$key = undef if $key eq 'name';
		$term = ($arg =~ /^\$/o ? TagX::Term::Var->new( $arg ) : TagX::Term::String->new( $arg ));
	    } else {
		# No non-space stuff after '='
		# push a NULL value into array
		$term = TagX::Term::String->new('');
	    }
	    &__save_option ( $args, $optref, $generic, $key, $term );

	    # continue parsing for more options
	    next;
	}			# end of parsing option with value

	# Check for flag option -- option without '='
	if ( s/^--([\w-]+)//oi ) {
	    &__save_option ( $args, $optref, $generic, lc($1) );
	    next;
	}

	# Non-option -- text not an option specifier
	# Check if value delimited by special chars
	if ( s/^$delim_expr//oi ) {

	    # Yup, check for ending delimiter
	    $term = ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?//
		      ? TagX::Term::String->new( $1 ) : TagX::Term::String->new( $_ ) );
	    &__save_option ( $args, $optref, $generic, undef, $term );

	    # continue parsing for more options
	    next;
	}

	# Non-option continued
	# No starting delimiter, assume value delimited by spaces
	if ( s/^([^\s\x28\x29]+)//oi ) {
	    my $arg = $1;
	    $term = ($arg =~ /^\$/o ? TagX::Term::Var->new( $arg ) : TagX::Term::String->new( $arg ));
	    &__save_option ( $args, $optref, $generic, undef, $term );

	    # continue parsing for more options
	    next;
	}

	# Extra ')' get caught here
	die "Unmatched ')' encountered ($_).";
    } continue {
	s/^\s*//;
    }
    $optref;
}

sub options
{
    my $self = shift;
    if ( @_ == 1 ) {
	my $optstring = shift;
	$self->{'__optstring'} = $optstring;
	$self->{'__argv'} = [];
	my %generic = ('verbose' => undef);
	$self->{'__options'} = &tagOptions_as_array ( $self->{'__argv'}, $optstring, \%generic);
	map { $self->{'__' . $_} = $generic{$_} if defined $generic{$_} } keys %generic;
    }
    $self->{'__options'};
}

sub verbose
{
    my $self = shift;
    $self->{'__verbose'};
}

sub parse_options
{
    my $self = shift;
    my $optref = shift;
    my @keys = keys %$optref;
    my (%keys, %defaults);
    for my $key (@keys) {
	next unless $key =~ /^([^=:]+)([:=].*)?$/;
	$keys{$1} = $2;
	$defaults{$1} = $optref->{$key} if defined( $optref->{$key} );
    }
    %{$optref} = ();

    if ( $self->{'__verbose'} ) {
	my ($key, $value);
	$self->log_message( 0, "$self: argv .. (@{$self->{__argv}})" );
	while (($key, $value) = each %keys) {
	    $self->log_message( 0, "$self: keys{$key} => [$value] (default: $defaults{$key})" );
	}
    }

    my ($arg, @argv);
    for ( my $i = 0 ; $i < @{$self->{'__argv'}} ; $i++ ) {
	$arg = $self->{'__argv'}->[$i];
	if ( ref( $arg ) ) {
	    push @argv, $arg->eval(@_);
	    next;
	}

	if ( defined( $keys{$arg} ) ) {
	    $i++;
	    my $optval = $self->{'__argv'}->[$i];
	    if ( exists ( $optref->{$arg} ) ) {
		$optref->{$arg} = [$optref->{$arg}]
		    unless ref($optref->{$arg}) eq 'ARRAY';
		push @{$optref->{$arg}}, $optval->eval(@_);
	    } else {
		$optref->{$arg} = $optval->eval(@_);
	    }
	    next;
	}

	if ( exists( $keys{$arg} ) ) {
	    $optref->{$arg}++;
	    next;
	}

	push @argv, $arg;
    }

    for my $key (keys %defaults) {
	next if exists $optref->{$key};
	$optref->{$key} = $defaults{$key};
    }

    $self->log_message( 0, "$self: argv resolved to (@argv)" );
    @argv;
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.8  2000/04/19 20:04:32  sridhar
# 1. Bug fix: looking for options at the end of a string was failing.
# 2. More log messages.
#
# Revision 1.7  2000/04/13 15:11:47  sridhar
# 1. Using TagX::Term and TagX::Expr for handling expressions
# 2. Generic options support (options supported by all tags, currently
# only --verbose).
# 3. Kick out `--name =', replace argument with variable beginning with
# `$'.
# 4. Unquoted variable names without `$' not supported.
# 5. Added object method `verbose' since it is a generic option
# 6. Added a new method `parse_options' invoked by all tags to resolve
# variable on command line
# 7. No longer have any use for `resolve_name' method.
#
# Revision 1.6  2000/03/22 13:40:47  sridhar
# Method resolve_name() returns undef if variable does not exist.
#
# Revision 1.5  2000/03/21 16:12:06  sridhar
# 1. Require strings in tag options to be specified with q{ or qq{
# 2. Added new method start_location() for storing the starting location
# of the tag in the file.
# 3. Removed tagOptions_as_hash() method.
# 4. Method tagOptions_as_array() changed. Returns a hash reference of
# the options. Also, support for parsing expressions
# 5. Kicked out getoptions().
#
# Revision 1.4  2000/03/13 15:42:57  sridhar
# Added log messages which are effective when --verbose is specified.
#
# Revision 1.3  2000/03/10 13:48:50  sridhar
# 1. Variable names should start with `$' though names without are also
# supported for now
# 2. Reference to hash member is resolved correctly if there is an
# intervening array with just one element
#
# Revision 1.2  2000/02/08 15:37:30  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:24:57  sridhar
# Added TagX
#
#

1;
