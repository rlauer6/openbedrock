#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use TagX::Parser 1.04;

sub new
{
    my $class = shift;
    my $self = bless {}, $class;
    $self->{'nobjs'} = 0;
    $self->{'subobjs'} = [];
    $self->{'parent'} = undef;
    my $tx = shift if @_ == 1;
    $self->{'TagX'} = $tx;
    $self;
}

# Store the location where the tag definition started in the input
# Invoked with: $file, $line
sub start_location
{
    my $self = shift;
    if ( @_ > 0 ) {
	my ($file, $line) = @_;
	$self->{'file'} = $file;
	$self->{'line'} = $line;
	$self->{'__start_location'} = "$file($line)";
    }
    wantarray ? (@{$self}{qw(file line)}) : $self->{'__start_location'};
}

sub name
{
    my $self = shift;
    $self->{'name'} = shift if @_ == 1;
    $self->{'name'};
}

sub parent
{
    my $self = shift;
    $self->{'parent'} = shift if @_ == 1;
    $self->{'parent'};
}

sub __save_option
{
    my ($argv, $optv, $generic, $key, $term) = @_;

    if ( defined ($key) && exists $generic->{$key} ) {
	$generic->{$key}++ unless defined( $term );
	return;
    }

    if ( defined( $term ) && defined( $key ) ) {
	push @{$argv}, $key, $term;
	if ( exists ( $optv->{$key} ) ) {
	    $optv->{$key} = [$optv->{$key}] unless ref($optv->{$key}) eq 'ARRAY';
	    push @{$optv->{$key}}, $term;
	} else {
	    $optv->{$key} = $term;
	}
    } elsif ( defined( $key ) ) {
	push @{$argv}, $key;
	$optv->{$key}++;
    } else {
	push @{$argv}, $term;
    }
}

#
# Parse Tag options, and return an array of parsed options. Takes an array reference to populate
# the options, and the string to parse. Returns the array reference
#
sub tagOptions_as_array
{
    my $args = shift;
    local $_ = shift;
    my $generic = shift;
    my $optref = {};
    my $term;
    while ( length ) {
	s/^\s+// and next;

	# Check for option with value
	if ( s/^--([\w-]+)\s*=\s*//oi ) {
	    my $key = $1;
	    &__save_option ( $args, $optref, $generic, $key, &TagX::Parser::parse_stm );
	    next;
	}

	# Check for flag option -- option without '='
	if ( s/^--([\w-]+)//oi ) {
	    &__save_option ( $args, $optref, $generic, $1 );
	    next;
	}

	&__save_option ( $args, $optref, $generic, undef, &TagX::Parser::parse_stm );
    }
    $optref;
}

sub options
{
    my $self = shift;
    if ( @_ == 1 ) {
	my $optstring = shift;
	$self->{'__optstring'} = $optstring;
	$self->{'__argv'} = [];
	my %generic = ('verbose' => undef);
	$self->{'__options'} = &tagOptions_as_array ( $self->{'__argv'}, $optstring, \%generic);
	map { $self->{'__' . $_} = $generic{$_} if defined $generic{$_} } keys %generic;
	my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;
	if ( $verbose > 1 ) {
	    my $str = "Option string is\n\t$optstring\n  Resolved to\n\t@{$self->{'__argv'}}\n";
	    $str .= "  Options are\n";
	    for my $key (sort keys %{$self->{'__options'}}) {
		$str .= "\t$key => [" . $self->{'__options'}->{$key} . "]\n";
	    }
	    $str .= "  Generic options are\n";
	    for my $key (sort keys %generic) {
		$str .= "\t$key => [" . $generic{$key} . "]";
	    }
	    &log_message( $self, "$str\n" );
	}
    }
    $self->{'__options'};
}

sub verbose
{
    my $self = shift;
    $self->{'__verbose'};
}

sub eval_args
{
    my $self = shift;
    my $optref = shift;

    my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;
    &log_message( $self, "Context arguments are\n\t(@_)" ) if $verbose > 1;

    # command line has been parsed. Just need to eval arguments and
    # options with appropriate context
    my ($key, $value);
    %{$optref} = ();
    while (($key, $value) = each %{$self->{'__options_to_eval'}}) {
	my $ref = ref( $value );
	if ( $ref eq 'ARRAY' ) {
	    # more than one value for this option
	    # need to eval all
	    my @optvals;
	    for my $arg (@{$value}) {
		if ( ref( $arg ) ) {
		    $arg->verbose($verbose) if $verbose;
		    push @optvals, $arg->eval(@_);
		    $arg->verbose(0) if $verbose;
		} else {
		    push @optvals, $arg;
		}
	    }
	    $optref->{$key} = \@optvals;
	} elsif ( $ref ) {
	    $value->verbose($verbose) if $verbose;
	    $optref->{$key} = $value->eval(@_);
	    $value->verbose(0) if $verbose;
	} else {
	    $optref->{$key} = $value;
	}
    }

    # Reset any options to defaults if values for them not specified.
    for my $key (keys %{$self->{'__option_defaults'}}) {
	next if exists $optref->{$key};
	$optref->{$key} = $self->{'__option_defaults'}->{$key};
    }

    # Evaluate arguments now
    my @args;
    for my $arg (@{$self->{'__args_to_eval'}}) {
	if ( ref($arg) ) {
	    $arg->verbose($verbose) if $verbose;
	    push @args, $arg->eval(@_);
	    $arg->verbose(0) if $verbose;
	} else {
	    push @args, $arg;
	}
    }

    @args;
}

sub parse_options
{
    my $self = shift;
    return $self->eval_args(@_) if exists $self->{'__args_to_eval'};
    my $optref = shift;

    my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;

    # The supported options list is contained in %keys_lc (key is the name of option (in lowercase)
    # and value is the flag specified: `=s' if the option takes an argument)
    # and the defaults specified therein are in %defaults
    # %keys contains lower case options mapped to options with the right case
    my (%keys, %keys_lc, %defaults);
    for my $key (keys %$optref) {
	next unless $key =~ /^([^=:]+)([:=].*)?$/;
	my $lc = lc($1);
	$keys_lc{$lc} = $2;
	$keys{$lc} = $1;
	$defaults{$lc} = $optref->{$key} if defined( $optref->{$key} );
    }

    # Do some logging
    if ( $verbose > 1 ) {
	my ($key, $value, $str);
	$str = "Arguments [@{[scalar(@{$self->{__argv}})]}] are\n\t(@{$self->{__argv}})\n";
	while (($key, $value) = each %keys_lc) {
	    $str .= "  options{$key} => [";
	    $str .= $value if defined($value);
	    $str .= "] (default: ";
	    $str .= $defaults{$key} if defined($defaults{$key});
	    $str .= ")\n";
	}
	&log_message( $self, "$str\n");
    }

    # Step thru' the arguments list
    my ($arg, $arg_lc, @argv, $i, %options);
    for ( $i = 0 ; $i < @{$self->{'__argv'}} ; $i++ ) {
	# Get the next argument
	$arg = $self->{'__argv'}->[$i];

	# Is the argument a `Term' or an `Expr'
	if ( ref( $arg ) ) {
	    push @argv, $arg;
	    next;
	}

	# Argument is not a `Term' or an `Expr'
	# Is the argument an option which requires an argument?
	$arg_lc = lc( $arg );
	if ( defined( $keys_lc{$arg_lc} ) ) {
	    # Yes, fetch the next argument
	    $i++;
	    my $optval = $self->{'__argv'}->[$i];

	    # is this option repeated? if so, make an array ref and
	    # push the value into the array along with the earlier value
	    if ( exists ( $options{$arg_lc} ) ) {
		# make an array ref
		$options{$arg_lc} = [$options{$arg_lc}]
		    unless ref($options{$arg_lc}) eq 'ARRAY';
		push @{$options{$arg_lc}}, $optval;
	    } else {
		$options{$arg_lc} = $optval;
	    }
	    next;
	}

	# Check whether the argument is an option which does not require a
	# value
	if ( exists( $keys_lc{$arg_lc} ) ) {
	    # if so, increment the option value.
	    # note that multiple occurences of such options results in
	    # the value being incremented.
	    $options{$arg_lc}++;
	    next;
	}

	# if not an option, push into args array -- effectively just returns 
	# unsupported options to caller.
	push @argv, $arg;
    }

    # Remap the case of the options to the required case and save the parsed options
    for my $key (keys %options) {
	$self->{'__options_to_eval'}->{$keys{$key}} = $options{$key};
    }

    # Save the defaults too
    for my $key (keys %defaults) {
	$self->{'__option_defaults'}->{$keys{$key}} = $defaults{$key};
    }

    # and save the arguments too
    $self->{'__args_to_eval'} = \@argv;

    # Leave a trace before doing the eval
    if ( $verbose > 1 ) {
	my $str = "Specified options are\n";
	for my $key (sort keys %{$self->{'__options_to_eval'}}) {
	    $str .= "  $key => [" . $self->{'__options_to_eval'}->{$key} . "]\n";
	}

	$str .= "Defaults are\n";
	for my $key (sort keys %{$self->{'__option_defaults'}}) {
	    $str .= "  $key => [" . $self->{'__option_defaults'}->{$key} . "]\n";
	}

	$str .= "Arguments are\n  (@argv)";
	&log_message( $self, $str);
    }

    return $self->eval_args($optref, @_);
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.21  2001/02/14 15:35:49  sridhar
# Added copyright and GPL notice
#
# Revision 1.20  2000/11/16 19:24:58  sridhar
# Method start_location() takes file and line separately and stores them
# separately. In an array context returns them separately too.
#
# Revision 1.19  2000/09/08 14:02:57  sridhar
# 1. Logging messages for the scripter when verbose is 1 and for bedrock
# maintainer when verbose > 1
# 2. Passing the value of verbose to expressions and terms.
#
# Revision 1.18  2000/07/20 20:16:19  sridhar
# Fixed TagX::Parser version being used.
#
# Revision 1.17  2000/06/16 14:54:33  sridhar
# In quest for speed,
# 1. replaced all invocations of object method verbose with actual
# reference to variable
# 2. Split up parse_options() into two stages -- a parsing stage and an
# evaluating stage. Parsing is done first time only for an object,
# results of parse are stored to be evaluated in eval stage
#
# Revision 1.16  2000/06/01 18:43:51  sridhar
# Brand new version with
# 1. Use of a package for parsing statements
# 2. Support for invocation of object methods
# 3. Drastically reduced tagOptions_as_array() function
#
# Revision 1.15  2000/05/31 14:33:10  sridhar
# Rigorous version numbering and usage
#
# Revision 1.14  2000/05/31 13:31:52  sridhar
# Turning on verbose flag in expressions and terms if the verbose flag
# for the tag is on.
#
# Revision 1.13  2000/05/25 18:29:50  sridhar
# Echoing context arguments to log file.
#
# Revision 1.12  2000/05/02 20:34:49  sridhar
# 1. Options again became case-insensitive, but not by reducing tag options
# to lowercase, but rather by a lookup scheme when parsing options
#
# Revision 1.11  2000/05/01 15:13:55  sridhar
# Option keywords are now case-sensitive
#
# Revision 1.10  2000/04/27 19:59:55  sridhar
# Expressions were not supported in option values which has been fixed now.
#
# Revision 1.9  2000/04/24 12:46:54  sridhar
# 1. Using TagX::Log for logging messages
# 2. Kicked out resolve_name
#
# Revision 1.8  2000/04/19 20:04:32  sridhar
# 1. Bug fix: looking for options at the end of a string was failing.
# 2. More log messages.
#
# Revision 1.7  2000/04/13 15:11:47  sridhar
# 1. Using TagX::Term and TagX::Expr for handling expressions
# 2. Generic options support (options supported by all tags, currently
# only --verbose).
# 3. Kick out `--name =', replace argument with variable beginning with
# `$'.
# 4. Unquoted variable names without `$' not supported.
# 5. Added object method `verbose' since it is a generic option
# 6. Added a new method `parse_options' invoked by all tags to resolve
# variable on command line
# 7. No longer have any use for `resolve_name' method.
#
# Revision 1.6  2000/03/22 13:40:47  sridhar
# Method resolve_name() returns undef if variable does not exist.
#
# Revision 1.5  2000/03/21 16:12:06  sridhar
# 1. Require strings in tag options to be specified with q{ or qq{
# 2. Added new method start_location() for storing the starting location
# of the tag in the file.
# 3. Removed tagOptions_as_hash() method.
# 4. Method tagOptions_as_array() changed. Returns a hash reference of
# the options. Also, support for parsing expressions
# 5. Kicked out getoptions().
#
# Revision 1.4  2000/03/13 15:42:57  sridhar
# Added log messages which are effective when --verbose is specified.
#
# Revision 1.3  2000/03/10 13:48:50  sridhar
# 1. Variable names should start with `$' though names without are also
# supported for now
# 2. Reference to hash member is resolved correctly if there is an
# intervening array with just one element
#
# Revision 1.2  2000/02/08 15:37:30  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:24:57  sridhar
# Added TagX
#
#

1;
