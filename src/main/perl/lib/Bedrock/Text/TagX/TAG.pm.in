#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package TagX::TAG;

use strict;
use Getopt::Long;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

#
# Arg separators are single-quote, double quote, ..
# Note the following ascii codes
# " (double-quote)	=> \x22
# ' (single-quote)	=> \x27
# ( (open-paren)	=> \x28
# ) (close-paren)	=> \x29
# [ (open-bracket)	=> \x5b
# ] (close-bracket)	=> \x5d
# { (open-brace)	=> \x7b
# } (close-brace)	=> \x7d
# : (colon)		=> \x3a
my $delim_expr		= "([\x22\x27]|qq?[\x28\x5b\x7b\x3a])";
my %ending		= ("\x22"	=> "\x22",
			   "\x27"	=> "\x27",
			   "q("		=> ")",
			   "q["		=> "]",
			   "q{"		=> "}",
			   "q:"		=> ":",			   
			   "qq("	=> ")",
			   "qq["	=> "]",
			   "qq{"	=> "}",
			   "qq:"	=> ":");

sub new
{
    my $class = shift;
    my $self = bless {}, $class;
    $self->{'nobjs'} = 0;
    $self->{'subobjs'} = [];
    $self->{'parent'} = undef;
    my $tx = shift if @_ == 1;
    $self->{'TagX'} = $tx;
    $self;
}

sub start_location
{
    my $self = shift;
    if ( @_ > 0 ) {
	$self->{'__start_location'} = shift;
    }
    $self->{'__start_location'};
}

sub resolve_name
{
    my $self = shift;
    my $name = shift;
    warn "$self: name = ($name) context = (@_)\n" if $self->options->{'verbose'};
    $name =~ s/^\$//;
    my @components = split /\./oi, $name;
    my $first = shift @components;
    warn "$self: first = ($first)\n" if $self->options->{'verbose'};
    return undef unless $first;
    my $found;
    for my $context (@_) {
	if ( exists $context->{$first} ) {
	    $found = $context->{$first};
	    last;
	}
    }
    warn "$self: found $first in ($found)\n" if $self->options->{'verbose'};
    return undef unless defined( $found );
    for (@components) {
	if ( /^\Q[\E(\d+)\Q]\E/oi ) {
	    # array element
	    return undef unless ref( $found ) eq 'ARRAY';
	    $found = $found->[$1];
	    next;
	}

	if ( /^{(.*?)}/oi or /^([^.]+)/oi ) {
	    # hash element
	    if ( ref( $found ) eq 'HASH' ) {
		$found = $found->{$1};
	    } else {
		# Support syntax for accessing hash contained in an array
		# if the array contains only one element
		# Other cases are failures
		return undef unless ref( $found ) eq 'ARRAY' and @{$found} == 1;
		$found = $found->[0]->{$1};
	    }
	    next;
	}

	# illegal
	return undef;
    }
    $found;
}

sub name
{
    my $self = shift;
    $self->{'name'} = shift if @_ == 1;
    $self->{'name'};
}

sub parent
{
    my $self = shift;
    $self->{'parent'} = shift if @_ == 1;
    $self->{'parent'};
}

#
# Parse Tag options, and return an array of parsed options. Takes an array reference to populate
# the options, and the string to parse. Returns the array reference
#
sub tagOptions_as_array
{
    my $args = shift;
    local $_ = shift;
    my $optref = {};
    while ( length ) {
	s/^\s*//;

	if ( s/^([\x28\x29])\s*//oi ) {
	    push @{$args}, $1;
	    next;
	}

	# Check for option with value
	if ( s/^--([\w-]+)\s*=\s*//oi ) {
	    my $key = lc($1);
	    push @{$args}, '--' . $key;

	    # value delimited by special chars
	    if ( s/^$delim_expr//oi ) {

		# Found a delimiter after '='
		# Check for value composed of non-delimiter, ended by the matching delimiter
		if ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?// ) {
		    push @{$args}, $optref->{$key} = $1;
		} else {
		    push @{$args}, $optref->{$key} = $_;
		}

		# continue parsing for more options
		next;
	    }

	    # option with value continued. No starting delimiter after '='
	    # Assume value delimited by spaces
	    if ( s/^([^\s\x28\x29]+)//oi ) {
		push @{$args}, $optref->{$key} = $1;
	    } else {
		# No non-space stuff after '='
		# push a NULL value into array
		push @{$args}, $optref->{$key} = undef;
	    }
	    next;
	}			# end of parsing option with value

	# Check for flag option -- option without '='
	if ( s/^--([\w-]+)\s+//oi ) {
	    my $key = lc($1);
	    push @{$args}, '--' . $key;
	    $optref->{$key} = undef;
	    next;
	}

	# Non-option -- text not an option specifier
	# Check if value delimited by special chars
	if ( s/^$delim_expr//oi ) {

	    # Yup, check for ending delimiter
	    if ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?// ) {
		push @{$args}, $1;
	    } else {
		push @{$args}, $_;
	    }
	    next;
	}

	# Non-option continued
	# No starting delimiter, assume value delimited by spaces
	if ( s/^([^\s\x28\x29]+)//oi ) {
	    push @{$args}, $1;
	    next;
	}
    }
    $optref;
}

sub options
{
    my $self = shift;
    if ( @_ == 1 ) {
	my $optstring = shift;
	$self->{'optstring'} = $optstring;
	$self->{'argv'} = [];
	$self->{'options'} = &tagOptions_as_array ( $self->{'argv'}, $optstring);
    }
    $self->{'options'};
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.6  2000/03/22 13:40:47  sridhar
# Method resolve_name() returns undef if variable does not exist.
#
# Revision 1.5  2000/03/21 16:12:06  sridhar
# 1. Require strings in tag options to be specified with q{ or qq{
# 2. Added new method start_location() for storing the starting location
# of the tag in the file.
# 3. Removed tagOptions_as_hash() method.
# 4. Method tagOptions_as_array() changed. Returns a hash reference of
# the options. Also, support for parsing expressions
# 5. Kicked out getoptions().
#
# Revision 1.4  2000/03/13 15:42:57  sridhar
# Added log messages which are effective when --verbose is specified.
#
# Revision 1.3  2000/03/10 13:48:50  sridhar
# 1. Variable names should start with `$' though names without are also
# supported for now
# 2. Reference to hash member is resolved correctly if there is an
# intervening array with just one element
#
# Revision 1.2  2000/02/08 15:37:30  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:24:57  sridhar
# Added TagX
#
#

1;
