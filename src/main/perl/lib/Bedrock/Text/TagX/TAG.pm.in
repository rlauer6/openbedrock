#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG;

use strict;

BEGIN {
  use Exporter ();
  use vars	qw ($VERSION @ISA @INC);
  $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  @ISA	= qw (Exporter);
}

use TagX::Log;
use TagX::Parser;

sub new {
  my $class = shift;

  my $self = bless {}, $class;

  $self->{'nobjs'} = 0;
  $self->{'subobjs'} = [];
  $self->{'parent'} = undef;

  my $tx = shift if @_ == 1;
  $self->{'TagX'} = $tx;

  $self;
}

  
# Store the location where the tag definition started in the input
# Invoked with: $file, $line
sub start_location
  {
    my $self = shift;

    if ( @_ > 0 ) {
      my ($file, $line) = @_;
      $self->{'file'} = $file;
      $self->{'line'} = $line;
      $self->{'__start_location'} = "$file($line)";
    }

    wantarray ? (@{$self}{qw(file line)}) : $self->{'__start_location'};
  }

sub name
  {
    my $self = shift;
    $self->{'name'} = shift if @_ == 1;
    $self->{'name'};
  }

sub parent
  {
    my $self = shift;
    $self->{'parent'} = shift if @_ == 1;
    $self->{'parent'};
  }

sub __save_option
  {
    my ($argv, $optv, $generic, $key, $term) = @_;

    if ( defined ($key) && exists $generic->{$key} ) {
      $generic->{$key}++ unless defined( $term );
      return;
    }

    if ( defined( $term ) && defined( $key ) ) {
      push @{$argv}, $key, $term;
      if ( exists ( $optv->{$key} ) ) {
	$optv->{$key} = [$optv->{$key}] unless ref($optv->{$key}) eq 'ARRAY';
	push @{$optv->{$key}}, $term;
      } else {
	$optv->{$key} = $term;
      }
    } elsif ( defined( $key ) ) {
      push @{$argv}, $key;
      $optv->{$key}++;
    } else {
      push @{$argv}, $term;
    }
  }

#
# Parse Tag options, and return an array of parsed options. Takes an array reference to populate
# the options, and the string to parse. Returns the array reference
#
sub tagOptions_as_array
  {
    my $self = shift;

    my $args = shift;
    local $_ = shift;
    my $generic = shift;
    my $optref = {};

    $self->{'__term_type'} = [];

    my $term;
    while ( length ) {
      s/^\s+// and next;
    
      # Check for option with value
      if ( s/^--([\w-]+)\s*=\s*//oi ) {
	my $key = $1;
	&__save_option ( $args, $optref, $generic, $key, &TagX::Parser::parse_stm );
      
	unless ( defined ($key) && exists $generic->{$key} ) {
	  push @{$self->{'__term_type'}}, 'term';
	  push @{$self->{'__term_type'}}, 'term';
	}
      
	next;
      }
    
      # Check for flag option -- option without '='
      if ( s/^--([\w-]+)//oi ) {
	&__save_option ( $args, $optref, $generic, $1 );
	unless ( defined ($1) && exists $generic->{$1} ) {
	  push @{$self->{'__term_type'}}, 'optional';
	}
	
	next;
      }
    
      &__save_option ( $args, $optref, $generic, undef, &TagX::Parser::parse_stm );

      push @{$self->{'__term_type'}}, 'term';
    }

    $optref;
  }

  
sub options {
 
  my $self = shift;

  if ( @_ == 1 ) {
    my $optstring = shift;

    $self->{'__optstring'} = $optstring;
    $self->{'__argv'} = [];
    my %generic = ('verbose' => undef);

    # parse the options into an array
    $self->{'__options'} = &tagOptions_as_array ( $self, 
						  $self->{'__argv'}, 
						  $optstring, 
						  \%generic
						);

    map { $self->{'__' . $_} = $generic{$_} if defined $generic{$_} } keys %generic;

    my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;
	
    if ( $verbose > 1 ) {
      my $str = "Option string is\n\t$optstring\n  Resolved to\n\t@{$self->{'__argv'}}\n";
      $str .= " Option types:\n\t@{$self->{'__term_type'}}\n";
      $str .= " Options are\n";
      for my $key (sort keys %{$self->{'__options'}}) {
	$str .= "\t$key => [" . $self->{'__options'}->{$key} . "]\n";
      }
      $str .= "  Generic options are\n";
      for my $key (sort keys %generic) {
	$str .= "\t$key => [" . $generic{$key} . "]";
      }
      &log_message( $self, "$str\n" );
    }
  }
  $self->{'__options'};
}

sub verbose
  {
    my $self = shift;
    $self->{'__verbose'};
  }

sub eval_args
  {
    my $self = shift;
    my $optref = shift;

    my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;
    &log_message( $self, "Context arguments are\n\t(@_)" ) if $verbose > 1;

    # command line has been parsed. Just need to eval arguments and
    # options with appropriate context
    my ($key, $value);
    %{$optref} = ();
    while (($key, $value) = each %{$self->{'__options_to_eval'}}) {
      my $ref = ref( $value );
      if ( $ref eq 'ARRAY' ) {
	# more than one value for this option
	# need to eval all
	my @optvals;
	for my $arg (@{$value}) {
	  if ( ref( $arg ) ) {
	    $arg->verbose($verbose) if $verbose;
	    push @optvals, $arg->eval(@_);
	    $arg->verbose(0) if $verbose;
	  } else {
	    push @optvals, $arg;
	  }
	}
	$optref->{$key} = \@optvals;
      } elsif ( $ref ) {
	$value->verbose($verbose) if $verbose;
	$optref->{$key} = $value->eval(@_);
	$value->verbose(0) if $verbose;
      } else {
	$optref->{$key} = $value;
      }
    }

    # Reset any options to defaults if values for them not specified.
    for my $key (keys %{$self->{'__option_defaults'}}) {
      next if exists $optref->{$key};
      $optref->{$key} = $self->{'__option_defaults'}->{$key};
    }

    # Evaluate arguments now
    my @args;
    for my $arg (@{$self->{'__args_to_eval'}}) {

      # arguments to the while loop should not be evaluated at this point
      if ( ref($arg) && ref($self) !~/while/i ) {
	$arg->verbose($verbose) if $verbose;
	push @args, $arg->eval(@_);
	$arg->verbose(0) if $verbose;
      }
      else {
	push @args, $arg;
      }
    }

    @args;
  }


# getname(\%options, @argv)

sub get_name {
  my $self = shift;
  my $options = shift;

  $options->{'define-var'} = '_' unless defined $options->{'define-var'};

  my @argv = @_;
  my $tag_opts = $self->parse_tag_name( $argv[0] );

  if ( $tag_opts->{name} ) {
    $options->{'define-var'} = $tag_opts->{name};
    shift @argv;
  }

  return (@argv);
}

sub parse_tag_name 
  {
    my $self = shift;

    return {} unless $_[0] =~/^:/;
    my $tag = shift;

    # allow plugin:MIME::Lite, e.g.
    $tag =~s/::/~~/;
    my (undef, $type, $name) = split ":", $tag;
    $type =~s/~~/::/g;
    $name =~s/~~/::/g;

    if ( $name ) {
      return { type => $type, name => $name};
    } else {
      return { name => $type };
    }
  }

# dump_options(\%options)
sub dump_options {
  my $self = shift;

  return unless $self->verbose();

  my $options = shift;
  my ($key, $value);

  my $str = "$self: Options are\n";

  while (($key, $value) = each %$options) {
    $str .= "\t$key .. ($value)\n";
  }

  $str .= "Arguments .. (@_)";

  &log_message( $self, $str );
}

sub parse_options {
  my $self = shift;
  return $self->eval_args(@_) if exists $self->{'__args_to_eval'};
  my $optref = shift;

  my $verbose = defined($self->{'__verbose'}) ? $self->{'__verbose'} : 0;

  # The supported options list is contained in %keys_lc (key is the name of option (in lowercase)
  # and value is the flag specified: `=s' if the option takes an argument)
  # and the defaults specified therein are in %defaults
  # %keys contains lower case options mapped to options with the right case
  my (%keys, %keys_lc, %defaults);
  for my $key (keys %$optref) {
    next unless $key =~ /^([^=:]+)([:=].*)?$/;
    my $lc = lc($1);
    $keys_lc{$lc} = $2;
    $keys{$lc} = $1;
    $defaults{$lc} = $optref->{$key} if defined( $optref->{$key} );
  }
  
  # Do some logging
  if ( $verbose > 1 ) {
    my ($key, $value, $str);
    $str = "Arguments [@{[scalar(@{$self->{__argv}})]}] are\n\t(@{$self->{__argv}})\n";
    while (($key, $value) = each %keys_lc) {
      $str .= "  options{$key} => [";
      $str .= $value if defined($value);
      $str .= "] (default: ";
      $str .= $defaults{$key} if defined($defaults{$key});
      $str .= ")\n";
    }
    &log_message( $self, "$str\n");
  }
  
  # Step thru' the arguments list
  my ($arg, $arg_lc, @argv, $i, %options);
  my @opt_type = @{$self->{'__term_type'}};

  for ( $i = 0 ; $i < @{$self->{'__argv'}} ; $i++ ) {
    # Get the next argument
    $arg = $self->{'__argv'}->[$i];

    # Is the argument a `Term' or an `Expr'
    if ( ref( $arg ) ) {
      push @argv, $arg;
      next;
    }

    # Argument is not a `Term' or an `Expr'
    # Is the argument an option which requires an argument?
    $arg_lc = lc( $arg );


    # consider the case of 'optional' arguments...  when an option
    # like --table is used without an argument but has been defined
    # to accept one, we have a problem, so `tag_Options_as_array'
    # was modifed to to identify each term of a Bedrock tag as
    # 'optional' or 'term' - meaning it is an 'option' with no
    # arguments. That way the code below can interpret the option
    # meta-data and determine if it should grab the next term as an
    # argument or let it be.
    #
    # A better approach is to have more a robust option handler that
    # identifies such types of options ala GetOptions...I suspect
    # Jay regrets that laziness but it worked for a long time.

    if ( defined( $keys_lc{$arg_lc} ) && $opt_type[$i] ne 'optional') {
      # Yes, fetch the next argument
      $i++;
      my $optval = $self->{'__argv'}->[$i];
	  
      # is this option repeated? if so, make an array ref and
      # push the value into the array along with the earlier value
      if ( exists ( $options{$arg_lc} ) ) {
	# make an array ref
	$options{$arg_lc} = [$options{$arg_lc}]
	  unless ref($options{$arg_lc}) eq 'ARRAY';
	push @{$options{$arg_lc}}, $optval;
      } else {
	$options{$arg_lc} = $optval;
      }
      next;
    }

    # Check whether the argument is an option which does not require a
    # value
    if ( exists( $keys_lc{$arg_lc} ) ) {
      # if so, increment the option value.
      # note that multiple occurences of such options results in
      # the value being incremented.
      $options{$arg_lc}++;
      next;
    }

    die "unsupported option [--" . $arg . "]"
      unless ref($self) =~/(if|unless|while)/i;

    # Bedrock 1 behavior: if not an option, push into args array -- effectively just returns 
    # unsupported options to caller.
    push @argv, '--' . $arg;
  }

  # Remap the case of the options to the required case and save the parsed options
  for my $key (keys %options) {
    $self->{'__options_to_eval'}->{$keys{$key}} = $options{$key};
  }

  # Save the defaults too
  for my $key (keys %defaults) {
    $self->{'__option_defaults'}->{$keys{$key}} = $defaults{$key};
  }

  # and save the arguments too
  $self->{'__args_to_eval'} = \@argv;

  # Leave a trace before doing the eval
  if ( $verbose > 1 ) {
    my $str = "Specified options are\n";
    for my $key (sort keys %{$self->{'__options_to_eval'}}) {
      $str .= "  $key => [" . $self->{'__options_to_eval'}->{$key} . "]\n";
    }

    $str .= "Defaults are\n";
    for my $key (sort keys %{$self->{'__option_defaults'}}) {
      $str .= "  $key => [" . $self->{'__option_defaults'}->{$key} . "]\n";
    }

    $str .= "Arguments are\n  (@argv)";
    &log_message( $self, $str);
  }

  return $self->eval_args($optref, @_);
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.34  2011/09/09 19:02:52  eutl420
# - delay processing of <while> tag arguments in eval_args
# - don't die on unknown options for <while> tag too
# - return unknown options with '--' intact
#
# Revision 1.33  2011/09/05 16:49:31  eutl420
# - report unsupported options for tags other than if/unless since they rely on getting a list of arguments that
#   sometimes look like options --and, --eq, etc...
#
# Revision 1.32  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.31  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.30  2011/04/04 13:49:53  eutl420
# - before splitting on ':', change '::' to allow for plugin:MIME::Lite for example
#
# Revision 1.29  2011/03/25 17:46:40  eutl420
# - changes to Bedrock's option parser to allow for optional arguments, i.e.  --table or --table=$foo
#   + in tagOptions_as_array keep track of options that are supposed to have arguments
#     but no argument was supplied
#   + in parse_options, use the info tracked in tagOptions_as_array to determine whether
#     to grab the next argument or not
#
# Revision 1.28  2010/12/12 17:12:17  eutl420
# - add sub parse_tag_name
# - make get_name use parse_tag_name
#
# Revision 1.27  2010/11/29 15:57:53  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.26  2010/11/19 13:37:31  rlauer
# - comment dump_options
#
# Revision 1.25  2010/11/17 02:33:10  rlauer
# - add get_name sub
#
# Revision 1.24  2010/11/08 03:16:52  rlauer
# - bump version
# - add routines dump_options
#
# Revision 1.23  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.22  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.21  2001/02/14 15:35:49  sridhar
# Added copyright and GPL notice
#
# Revision 1.20  2000/11/16 19:24:58  sridhar
# Method start_location() takes file and line separately and stores them
# separately. In an array context returns them separately too.
#
# Revision 1.19  2000/09/08 14:02:57  sridhar
# 1. Logging messages for the scripter when verbose is 1 and for bedrock
# maintainer when verbose > 1
# 2. Passing the value of verbose to expressions and terms.
#
# Revision 1.18  2000/07/20 20:16:19  sridhar
# Fixed TagX::Parser version being used.
#
# Revision 1.17  2000/06/16 14:54:33  sridhar
# In quest for speed,
# 1. replaced all invocations of object method verbose with actual
# reference to variable
# 2. Split up parse_options() into two stages -- a parsing stage and an
# evaluating stage. Parsing is done first time only for an object,
# results of parse are stored to be evaluated in eval stage
#
# Revision 1.16  2000/06/01 18:43:51  sridhar
# Brand new version with
# 1. Use of a package for parsing statements
# 2. Support for invocation of object methods
# 3. Drastically reduced tagOptions_as_array() function
#
# Revision 1.15  2000/05/31 14:33:10  sridhar
# Rigorous version numbering and usage
#
# Revision 1.14  2000/05/31 13:31:52  sridhar
# Turning on verbose flag in expressions and terms if the verbose flag
# for the tag is on.
#
# Revision 1.13  2000/05/25 18:29:50  sridhar
# Echoing context arguments to log file.
#
# Revision 1.12  2000/05/02 20:34:49  sridhar
# 1. Options again became case-insensitive, but not by reducing tag options
# to lowercase, but rather by a lookup scheme when parsing options
#
# Revision 1.11  2000/05/01 15:13:55  sridhar
# Option keywords are now case-sensitive
#
# Revision 1.10  2000/04/27 19:59:55  sridhar
# Expressions were not supported in option values which has been fixed now.
#
# Revision 1.9  2000/04/24 12:46:54  sridhar
# 1. Using TagX::Log for logging messages
# 2. Kicked out resolve_name
#
# Revision 1.8  2000/04/19 20:04:32  sridhar
# 1. Bug fix: looking for options at the end of a string was failing.
# 2. More log messages.
#
# Revision 1.7  2000/04/13 15:11:47  sridhar
# 1. Using TagX::Term and TagX::Expr for handling expressions
# 2. Generic options support (options supported by all tags, currently
# only --verbose).
# 3. Kick out `--name =', replace argument with variable beginning with
# `$'.
# 4. Unquoted variable names without `$' not supported.
# 5. Added object method `verbose' since it is a generic option
# 6. Added a new method `parse_options' invoked by all tags to resolve
# variable on command line
# 7. No longer have any use for `resolve_name' method.
#
# Revision 1.6  2000/03/22 13:40:47  sridhar
# Method resolve_name() returns undef if variable does not exist.
#
# Revision 1.5  2000/03/21 16:12:06  sridhar
# 1. Require strings in tag options to be specified with q{ or qq{
# 2. Added new method start_location() for storing the starting location
# of the tag in the file.
# 3. Removed tagOptions_as_hash() method.
# 4. Method tagOptions_as_array() changed. Returns a hash reference of
# the options. Also, support for parsing expressions
# 5. Kicked out getoptions().
#
# Revision 1.4  2000/03/13 15:42:57  sridhar
# Added log messages which are effective when --verbose is specified.
#
# Revision 1.3  2000/03/10 13:48:50  sridhar
# 1. Variable names should start with `$' though names without are also
# supported for now
# 2. Reference to hash member is resolved correctly if there is an
# intervening array with just one element
#
# Revision 1.2  2000/02/08 15:37:30  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:24:57  sridhar
# Added TagX
#
#

1;
