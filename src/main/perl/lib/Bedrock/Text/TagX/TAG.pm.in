#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package TagX::TAG;

use strict;
use TagX::Log;
use TagX::Expr;
use TagX::Term;
use TagX::Term::Var;
use TagX::Term::String;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

my $delim_expr		= $TagX::Expr::_delimiters;
my %ending		= %TagX::Expr::_delimiter_end;

sub new
{
    my $class = shift;
    my $self = bless {}, $class;
    $self->{'nobjs'} = 0;
    $self->{'subobjs'} = [];
    $self->{'parent'} = undef;
    my $tx = shift if @_ == 1;
    $self->{'TagX'} = $tx;
    $self;
}

sub start_location
{
    my $self = shift;
    if ( @_ > 0 ) {
	$self->{'__start_location'} = shift;
    }
    $self->{'__start_location'};
}

sub name
{
    my $self = shift;
    $self->{'name'} = shift if @_ == 1;
    $self->{'name'};
}

sub parent
{
    my $self = shift;
    $self->{'parent'} = shift if @_ == 1;
    $self->{'parent'};
}

sub __save_option
{
    my ($argv, $optv, $generic, $key, $term) = @_;

    if ( defined ($key) && exists $generic->{$key} ) {
	$generic->{$key}++ unless defined( $term );
	return;
    }

    if ( defined( $term ) && defined( $key ) ) {
	push @{$argv}, $key, $term;
	if ( exists ( $optv->{$key} ) ) {
	    $optv->{$key} = [$optv->{$key}] unless ref($optv->{$key}) eq 'ARRAY';
	    push @{$optv->{$key}}, $term;
	} else {
	    $optv->{$key} = $term;
	}
    } elsif ( defined( $key ) ) {
	push @{$argv}, $key;
	$optv->{$key}++;
    } else {
	push @{$argv}, $term;
    }
}

#
# Parse Tag options, and return an array of parsed options. Takes an array reference to populate
# the options, and the string to parse. Returns the array reference
#
sub tagOptions_as_array
{
    my $args = shift;
    local $_ = shift;
    my $generic = shift;
    my $optref = {};
    my $term;
    while ( length ) {
	s/^\s*//;

	if ( s/^\x28\s*//oi ) {
	    push @{$args}, TagX::Expr->new;
	    next;
	}

	# Check for option with value
	if ( s/^--([\w-]+)\s*=\s*//oi ) {
	    my $key = $1;

	    # value delimited by special chars
	    if ( s/^$delim_expr//oi ) {

		# Found a delimiter after '='
		# Check for value composed of non-delimiter, ended by the matching delimiter
		my $arg = ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?// ? $1 : $_ );
		if ( $key eq 'name' ) {
		    $arg =~ s/^/\$/ unless $arg =~ /^\$/;
		    $key = undef;
		}
		$term = TagX::Term::String->new( $arg );
		&__save_option ( $args, $optref, $generic, $key, $term );

		# continue parsing for more options
		next;
	    }

	    # Check whether expression specified for value
	    if ( s/^\x28\s*//oi ) {
		my $expr = TagX::Expr->new;
		&__save_option ( $args, $optref, $generic, $key, $expr );
		next;
	    }

	    # option with value continued. No starting delimiter after '=' and no expr
	    # Assume value delimited by spaces
	    if ( s/^([^\s\x28\x29]+)//oi ) {
		my $arg = $1;
		$key = undef if $key eq 'name';
		$term = ($arg =~ /^\$/o ? TagX::Term::Var->new( $arg ) : TagX::Term::String->new( $arg ));
	    } else {
		# No non-space stuff after '='
		# push a NULL value into array
		$term = TagX::Term::String->new('');
	    }
	    &__save_option ( $args, $optref, $generic, $key, $term );

	    # continue parsing for more options
	    next;
	}			# end of parsing option with value

	# Check for flag option -- option without '='
	if ( s/^--([\w-]+)//oi ) {
	    &__save_option ( $args, $optref, $generic, $1 );
	    next;
	}

	# Non-option -- text not an option specifier
	# Check if value delimited by special chars
	if ( s/^$delim_expr//oi ) {

	    # Yup, check for ending delimiter
	    $term = ( s/^([^\Q$ending{$1}\E]*)\Q$ending{$1}\E?//
		      ? TagX::Term::String->new( $1 ) : TagX::Term::String->new( $_ ) );
	    &__save_option ( $args, $optref, $generic, undef, $term );

	    # continue parsing for more options
	    next;
	}

	# Non-option continued
	# No starting delimiter, assume value delimited by spaces
	if ( s/^([^\s\x28\x29]+)//oi ) {
	    my $arg = $1;
	    $term = ($arg =~ /^\$/o ? TagX::Term::Var->new( $arg ) : TagX::Term::String->new( $arg ));
	    &__save_option ( $args, $optref, $generic, undef, $term );

	    # continue parsing for more options
	    next;
	}

	# Extra ')' get caught here
	die "Unmatched ')' encountered ($_).";
    } continue {
	s/^\s*//;
    }
    $optref;
}

sub options
{
    my $self = shift;
    if ( @_ == 1 ) {
	my $optstring = shift;
	$self->{'__optstring'} = $optstring;
	$self->{'__argv'} = [];
	my %generic = ('verbose' => undef);
	$self->{'__options'} = &tagOptions_as_array ( $self->{'__argv'}, $optstring, \%generic);
	map { $self->{'__' . $_} = $generic{$_} if defined $generic{$_} } keys %generic;
	if ( $self->verbose ) {
	    my $str = "Option string is\n\t$optstring\n  Resolved to\n\t@{$self->{'__argv'}}\n";
	    $str .= "  Options are\n";
	    for my $key (sort keys %{$self->{'__options'}}) {
		$str .= "\t$key => [" . $self->{'__options'}->{$key} . "]\n";
	    }
	    $str .= "  Generic options are\n";
	    for my $key (sort keys %generic) {
		$str .= "\t$key => [" . $generic{$key} . "]";
	    }
	    &log_message( $self, "$str\n" );
	}
    }
    $self->{'__options'};
}

sub verbose
{
    my $self = shift;
    $self->{'__verbose'};
}

sub parse_options
{
    my $self = shift;
    my $optref = shift;

    # The supported options list is contained in %keys_lc (key is the name of option (in lowercase)
    # and value is the flag specified: `=s' if the option takes an argument)
    # and the defaults specified therein are in %defaults
    # %keys contains lower case options mapped to options with the right case
    my (%keys, %keys_lc, %defaults);
    for my $key (keys %$optref) {
	next unless $key =~ /^([^=:]+)([:=].*)?$/;
	my $lc = lc($1);
	$keys_lc{$lc} = $2;
	$keys{$lc} = $1;
	$defaults{$lc} = $optref->{$key} if defined( $optref->{$key} );
    }

    # Do some logging
    if ( $self->{'__verbose'} ) {
	my ($key, $value, $str);
	$str = "Arguments [@{[scalar(@{$self->{__argv}})]}] are\n\t(@{$self->{__argv}})\n";
	while (($key, $value) = each %keys_lc) {
	    $str .= "  options{$key} => [";
	    $str .= $value if defined($value);
	    $str .= "] (default: ";
	    $str .= $defaults{$key} if defined($defaults{$key});
	    $str .= ")\n";
	}
	&log_message( $self, "$str\n");
    }

    # Step thru' the arguments list
    my ($arg, $arg_lc, @argv, $i, %options);
    for ( $i = 0 ; $i < @{$self->{'__argv'}} ; $i++ ) {
	# Get the next argument
	$arg = $self->{'__argv'}->[$i];

	# Is the argument a `Term' or an `Expr'
	if ( ref( $arg ) ) {
	    # if so, evaluate it and push the value into the arguments array
	    push @argv, $arg->eval(@_);
	    next;
	}

	# Argument is not a `Term' or an `Expr'
	# Is the argument an option which requires an argument?
	$arg_lc = lc( $arg );
	if ( defined( $keys_lc{$arg_lc} ) ) {
	    # Yes, fetch the next argument
	    $i++;
	    my $optval = $self->{'__argv'}->[$i];

	    # is this option repeated? if so, make an array ref and
	    # push the value into the array along with the earlier value
	    if ( exists ( $options{$arg_lc} ) ) {
		# make an array ref
		$options{$arg_lc} = [$options{$arg_lc}]
		    unless ref($options{$arg_lc}) eq 'ARRAY';
		# and push the value
		push @{$options{$arg_lc}}, $optval->eval(@_);
	    } else {
		# not repeated -- just evaluate the value
		$options{$arg_lc} = $optval->eval(@_);
	    }
	    next;
	}

	# Check whether the argument is an option which does not require a
	# value
	if ( exists( $keys_lc{$arg_lc} ) ) {
	    # if so, increment the option value.
	    # note that multiple occurences of such options results in
	    # the value being incremented.
	    $options{$arg_lc}++;
	    next;
	}

	# if not an option, push into args array -- effectively just returns 
	# unsupported options to caller.
	push @argv, $arg;
    }

    # Remap the case of the options to the required case
    %{$optref} = ();
    for my $key (keys %options) {
	$optref->{$keys{$key}} = $options{$key};
    }

    # Reset any options to defaults if values for them not specified.
    for my $key (keys %defaults) {
	next if exists $options{$key};
	$optref->{$keys{$key}} = $defaults{$key};
    }

    # Leave a trace on the way out
    if ( $self->verbose ) {
	my $str = "Options evaluated to\n";
	for my $key (sort keys %{$optref}) {
	    $str .= "  $key => [" . $optref->{$key} . "]\n";
	}
	$str .= "Arguments evaluated to\n\t(@argv)";
	&log_message( $self, "$str\n" );
    }

    # And return the arguments array left behind after processing options.
    @argv;
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.12  2000/05/02 20:34:49  sridhar
# 1. Options again became case-insensitive, but not by reducing tag options
# to lowercase, but rather by a lookup scheme when parsing options
#
# Revision 1.11  2000/05/01 15:13:55  sridhar
# Option keywords are now case-sensitive
#
# Revision 1.10  2000/04/27 19:59:55  sridhar
# Expressions were not supported in option values which has been fixed now.
#
# Revision 1.9  2000/04/24 12:46:54  sridhar
# 1. Using TagX::Log for logging messages
# 2. Kicked out resolve_name
#
# Revision 1.8  2000/04/19 20:04:32  sridhar
# 1. Bug fix: looking for options at the end of a string was failing.
# 2. More log messages.
#
# Revision 1.7  2000/04/13 15:11:47  sridhar
# 1. Using TagX::Term and TagX::Expr for handling expressions
# 2. Generic options support (options supported by all tags, currently
# only --verbose).
# 3. Kick out `--name =', replace argument with variable beginning with
# `$'.
# 4. Unquoted variable names without `$' not supported.
# 5. Added object method `verbose' since it is a generic option
# 6. Added a new method `parse_options' invoked by all tags to resolve
# variable on command line
# 7. No longer have any use for `resolve_name' method.
#
# Revision 1.6  2000/03/22 13:40:47  sridhar
# Method resolve_name() returns undef if variable does not exist.
#
# Revision 1.5  2000/03/21 16:12:06  sridhar
# 1. Require strings in tag options to be specified with q{ or qq{
# 2. Added new method start_location() for storing the starting location
# of the tag in the file.
# 3. Removed tagOptions_as_hash() method.
# 4. Method tagOptions_as_array() changed. Returns a hash reference of
# the options. Also, support for parsing expressions
# 5. Kicked out getoptions().
#
# Revision 1.4  2000/03/13 15:42:57  sridhar
# Added log messages which are effective when --verbose is specified.
#
# Revision 1.3  2000/03/10 13:48:50  sridhar
# 1. Variable names should start with `$' though names without are also
# supported for now
# 2. Reference to hash member is resolved correctly if there is an
# intervening array with just one element
#
# Revision 1.2  2000/02/08 15:37:30  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:24:57  sridhar
# Added TagX
#
#

1;
