#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::Loop::Foreach;

use strict;
use warnings;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  @ISA = qw (Exporter);
}

use TagX::TAG::WithBody::Loop;
use Scalar::Util qw/reftype/;

use Log::Log4perl qw/:easy/;

@ISA = qw (TagX::TAG::WithBody::Loop);

sub closure {
  '/foreach';
}

sub define_options {
  return (
    'define-index=s'      => undef,
    'start-index=i'       => undef,
    'end-index=i'         => undef,
    'max-items=i'         => undef,
    'counter-start=i'     => 0,
    'counter-increment=i' => 1,
    'define-counter=s'    => undef,
    'alias=s'             => undef,
    'define-var=s'        => '_'
  );

} ## end sub define_options

sub finalize {
  my ( $self, $tx, @context ) = @_;

  my %options = $self->define_options;
  
  my @argv = $self->parse_options( \%options, @context );
  
  $self->dump_options( \%options, @argv );

  my @children = @{ $self->{'subobjs'} };

  my ( $start, $end, $nItems, $data );
  
  if ( @argv > 1 ) {

    # Force the argument list into an array
    TRACE sub {
      "More than one args found -- forced into an array: ("
        . @argv
        . ")";
    };

    $data   = \@argv;
    $start  = 0;
    $nItems = @argv;
    $end    = $nItems - 1;
  }
  elsif ( @argv == 1 ) {
    $data = $argv[0];

    if  ( ! defined($data) ) {
      WARN sub {
        "argument ["
          . $data
          . "] is undefined";
      };
        
      return;
    }

    if  ( !ref($data) || reftype($data) ne 'ARRAY' ) {
      DEBUG sub {
        "argument ["
          . $data
          . "] was not an array .. Bedrock would have forced into one";
      };
      
      my $alias = $options{'alias'} || $options{'define-var'};

      # --define-var='key,value,index'
      my $key;
      my $value;
      my $index;

      if ( $alias =~/,/ ) {
	$alias =~s/\s//g;
	($key, $value,$index) = split ",", $alias;
      }

      $key = $key || 'key';
      $value = $value || 'value';
      $index = $index || 'index';
	
     # iterate over a hash where $_ eq {}
      if ( ref($data) && reftype($data) eq 'HASH' ) {
        DEBUG sub {
          "argument ["
            . $data
            . "] is a hash ..";
        };
        
        my $idx = 0;
        my $tmp = [];
        
        foreach my $k (keys %$data) {
          push @$tmp, {
                       $index => $idx++,
                       $key => $k,
                       $value => $data->{$k}
                      };
        }

        $data = $tmp;
      }

      # promote a scalar to 1 element array
      else {
        $data = [$data];
      }
    }

    # defaults
    $start  = 0;
    $nItems = @{$data};
    $end    = $nItems - 1;
  }
  else {
    $start = 0;
  }

  #
  # Defining these things as options override defaults
  #
  $start = $options{'start-index'} 
    if defined $options{'start-index'};

  my $increment     = $options{'counter-increment'};
  my $counter_start = $options{'counter-start'};

  if ( defined $options{'end-index'} ) {
    $end = $options{'end-index'};
  }
  elsif ( defined $options{'max-items'} ) {
    $nItems = $options{'max-items'};
    $end    = $start + $nItems - 1;
  }

  my $define_index = $options{'define-index'}
    if exists $options{'define-index'};

  my $counter = $options{'define-counter'} 
    if exists $options{'define-counter'};

  my $alias = $options{'alias'} || $options{'define-var'};

  TRACE sub {
    "begin loop with data = [$data]\n"
      . "start = [$start]\n"
      . "end = [$end]\n"
      . "define-index = [$define_index]\n"
      . "counter = [$counter]\n"
      . "increment = [$increment]\n"
      . "alias = [$alias]"
    };
  
  my $counter_idx = $counter_start;

  for ( my $i = $start ; $i <= $end ; $i++ ) {

    # Begin building the arg list for children
    my @loop_args = ($tx);

    # Get the current element from the array
    my $loop_data = defined $data ? $data->[$i] : $i;

    # Create a hashref for storing loop vars
    # Alias the current element; note that alias is present even
    # if the current element is undefined. This way, the alias
    # evaluates to undef.
    my $loop_vars = { $alias => $loop_data };

    # Store index in loop vars hash if defined
    $loop_vars->{$define_index} = $i
      if defined $define_index;
    
    $loop_vars->{$counter} = $counter_idx
      if defined $counter;

    $counter_idx += $increment;
    push @loop_args, $loop_vars;

    # Store the current element too in the loop args list
    if ( ref($loop_data) && reftype($loop_data) eq 'HASH' ) {
      push @loop_args, $loop_data;

      # echo the loop data if requested
      TRACE sub {
        my @str = "Loop $i >>";
        
        for my $key ( sort keys %{$loop_data} ) {
          push @str, "    " . $key . "=> " . $loop_data->{$key};
        }
        
        join("\n", @str);
      };
    }

    $self->{'finalize_children'}->( $self->{'subobjs'}, @loop_args, @context );
  }
}

=pod

=head1 TAG - C<E<lt>foreachE<gt>>

=head1 PURPOSE

Iterate over an array (list) or hash.

=head1 SYNTAX

  <foreach [options] array|hash|list>
  </foreach>

=head1 DESCRIPTION

Use the C<foreach> tag to iterate over a container.  Containers can be
arrays, lists, hashes and record sets.

=head1 OPTIONS

 --define-var        = "var-name" (default = '_') | "key,value,[index]"
 --alias             = "var-name" (deprecated)
 --define-index      = "var-name"
 --start-index       = integer|expression
 --end-index         = integer|expression
 --max-items         = integer|expression
 --define-counter    = "var-name"
 --counter-start     = integer|expression
 --counter-increment = integer|expression

=over 5

=item --define-var

Name of the scalar object to use as the the current iteration value
(formerly "alias").  If not provided, Bedrock will use the default
variable (C<$_>) to hold the current data element of the container
object.

When iterating over hashes, you can you specify the key, value and
current index names using a comma delimited list of variable names.

 <hash:fruit apple 1 pear 2 orange 3>

 <foreach --define-var="k,v,i" $fruit>
   <var $k> : <var $v> : <var $i></foreach>

  apple : 1 : 0
  pear : 2 : 1
  orange : 3 : 2

=item --define-index

Name of a variable which will be incremented by 1 each time through the loop.

=item --start-index

Offset into the array to start iterating over.

=item --end-index

Index of last value in array to iterate over.

=item --max-items

Maximum number of times to iterate.

=item --define-counter

Name of a variable to use as an alternate indexing variable.

=item --counter-start

Start value of the counter variable.

=item --counter-increment

Increment to use for the counter variable.

=item --alias

Deprecated option.  Equivalent to C<--define-var>.

=back

=head1 NOTES

=over 5

=item * Limiting loop execution

You can limit the number of times the loop is executed using the
various options described above.  Specifically, you can use these
options to control the number of times the block is processed.

  --end-index  => last index to execute

  --max-items  => total number of times to execute the block

=item * Iterating over hashes

Iterating over hashes entails traversing the hash in key order
I<(which in Bedrock 2 happens to be the order in which the hash was
defined)> and presenting a three-element hash within the scope of the
loop.  The hash members are naturally 'key' and 'value', and 'index'.
The names of these variables can be overridden using the
C<--define-var> option.

  $_.key   => the current hash key 
  $_.value => the current hash value associate with that key
  $_.index => index of the current element

Assuming C<$data> is a hash that you would like to traverse, the perl
equivalent would look something like:

 my @loop_data = map { { key => $_, value => $data->{$_} } } keys %$data;
 foreach (@loop_data) {
   print $_->key . ': . $_->value . "\n";
 } 

I<All hashes are ordered hashes, thus they are traversed in the
order in which they were defined.>

The name of the three-element hash by default is C<$_> however you can
change that using C<--define-alias>.

When iterating over hashes the key C<index> is also exposed that indicates
the 0 based index of the current hash element.

The keys are also exposed as scalars whose names are C<$key>,
C<$value>, and C<$index> or the names you provided in the
C<--define-var> option.

These variables ($key, $value, $index) are lexically scoped within the
body of the C<foreach> tag.

=item * Iterating over Recordsets

A I<recordset> in Bedrock is both a logically defined object type as
well as real object type.  Logically speaking a record set is an array
of hashes.  We see logical recordsets when we use the Bedrock
C<E<lt>sqlselectE<gt>> tag.

 <sqlselect "select * from customer" --define-var="rs"></sqlselect>

...or when using C<BLM::IndexedTableHandler> to return rows from a table
using a SQL query.

 <null:list $customer.select_list("select * from customer where state='PA')>

...however we can promote logical record sets to real recordsets
object that provides a number of useful methods to manipulate records
using various techniques (See the C<E<lt>recordsetE<gt>> tag
documentation).

In any event we iterate over logical or real recordsets using the
C<E<lt>foreachE<gt>> tag.  When traversing a recordset the hash
members of each array element are exposed as scalars.  These scalars
are I<lexically scoped>, that is, they only exist within the context of
the C<E<lt>foreachE<gt>> tag.  Each array element is a hash and the
hash itself is exposed as either the default variable ($_) or one that
you specify using the C<--define-var> option.

 <null:list $customer.select_list("select * from customer where state='PA')>

 <foreach $list>
   <var $name>
   <var $address>
   <var $city>, <var $state> <var $zip></foreach>

 <foreach $list>
   <var $_.name>
   <var $_.address>
   <var $_.city>, <var $_.state> <var $_.zip></foreach>

 <foreach --define-var="c" $list>
   <var $c.name>
   <var $c.address>
   <var $c.city>, <var $c.state> <var $c.zip></foreach>

=back

=head1 EXAMPLES

=over 5

=item * Iterate over an array

  <array:foo 1 2 3>

  <foreach $foo> 
    <var $_><br>
  </foreach>

=item * Iterate over a hash

  <foreach $input>
     <var $_.key>:<var $_.value><br>
  </foreach>

  <foreach $input>
     <var $key>:<var $value><br>
  </foreach>

  <hash:fruits 1 apple 2 pear 3 banana>

  <select name="fruits">
  <foreach --define-var="item,id" $fruits>
     <option value="<var $id>"><var $item></option></foreach>
  </select>

=item * Iterate over a simple list

  <b>Who's your favorite Pep Boy?</b>
  <ol>
  <foreach Manny Moe Jack>
    <li><input type="radio" name="pep_boy" value="<var $_>">&nbsp;<var $_></li>
  </foreach>
  </ol>

=back

=head1 SEE ALSO

C<E<lt>whileE<gt>> C<E<lt>recordsetE<gt>>

=cut


1;
