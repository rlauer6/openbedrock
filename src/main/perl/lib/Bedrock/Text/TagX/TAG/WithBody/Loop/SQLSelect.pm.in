#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::Loop::SQLSelect;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = 1.19;
    @ISA	= qw (Exporter);
}

use DBI;

use TagX::Log 1.01;
use Bedrock::Hash;
use TagX::TAG::WithBody::Loop 1.03;

@ISA = qw (TagX::TAG::WithBody::Loop);

sub ANONYMOUS
{
    '*anonymous*';
}

sub closure
{
    '/sqlselect';
}

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options = ('dbname=s'		=> undef,
		   'db=s',		=> undef,
		   'statement=s'	=> undef,
		   'bind=s'		=> undef,
		   'arg=s'		=> undef,
		   'define-var=s'	=> undef,
		   'need-rows=s'	=> undef,
		   'raise=s'		=> undef,
		   'meta-info=s'	=> undef);
    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
	my ($key, $value);
	my $str = "$self: Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	&log_message( $self, $str );
    }

    my $name = $options{'dbname'};
    &log_message( undef, "Use of deprecated option `--dbname'. Use `--db' instead.\n" )
	if $name;

    my $dbh;
    if ( $options{'db'} ) {
	$dbh = $options{'db'};
    } elsif ( $name ) {
	$dbh = $tx->{'DB'}->{$name};
	die "Unknown database connection named `$name'.\n" unless $dbh;
    } else {
	$dbh = $tx->{'DB'}->{&ANONYMOUS};
    }

    die "No database connection to execute SQL statement.\n"
	unless defined($dbh) and ref($dbh);

    &log_message ( $self, "Using database handle ($dbh)")
	if $verbose;

    die "Specify SQL statement using --statement or as argument, not both.\n"
	if exists $options{'statement'} and @argv > 0;

    my $statement;
    if ( exists $options{'statement'} ) {
	$statement = delete $options{'statement'};
    } else {
	$statement = "@argv";
    }

    die "<sqlselect>: no statement specified.\n" unless length($statement);

    if ( exists $options{'arg'} ) {
	my @args = ref( $options{'arg'} ) eq 'ARRAY' ? @{$options{'arg'}} : ($options{'arg'});
	&log_message( $self, "Substituting following args into statement:\n@args" )
	    if $verbose;
	$statement = sprintf ($statement, @args);
	&log_message( $self, "Statement after arg-substitution\n$statement" )
	    if $verbose;
    }

    my $sth = $dbh->prepare ( $statement );
    die "Error in SQL Statement: `", $dbh->errstr, "'\n$statement\n" unless $sth;

    my $nParams = $sth->{NUM_OF_PARAMS};

    my @bind;
    if ( exists $options{'bind'} ) {
	my $bind = $options{'bind'};
	if ( ref( $bind ) and &UNIVERSAL::isa($bind, 'ARRAY') ) {
	    for my $item (@{$bind}) {
		if ( ref( $item ) and &UNIVERSAL::isa($item, 'ARRAY') ) {
		    push @bind, @{$item};
		} else {
		    push @bind, $item;
		}
	    }
	} else {
	    @bind = ($bind);
	}

	if ( $nParams < @bind ) {
	    die @bind - $nParams, " extra bind variable(s) specified.\n";
	} elsif ( $nParams > @bind ) {
	    die "Insufficient bind variables: need ", $nParams - @bind, " more.\n";
	}
    } elsif ( $nParams ) {
	die "SQL statement needs $nParams bind variable(s).\n";
    }

    my $i = 1;
    my $str = "Bind variables:\n" if $verbose;
    for my $bindval (@bind) {
	my $type = $1 if $bindval =~ s/\(\%\s*(\d+)\s*\%\)\s*$//;

	if ( defined( $type ) ) {
	    $sth->bind_param ( $i, $bindval, {TYPE => $type}) ||
		die "Failure binding param $i, TYPE $type: `", $sth->errstr, "'\n";
	} else {
	    $sth->bind_param ( $i, $bindval ) ||
		die "Failure binding param $i: `", $sth->errstr, "'\n";
	}

	if ( $verbose ) {
	    $str .= "Bound ($i";
	    $str .= ", $type" if defined( $type );
	    $str .= ", $bindval" if defined( $bindval );
	    $str .= ")";
	}
    } continue {
	$i++;
    }
    &log_message( $self, $str ) if $verbose;

    my $rows = $sth->execute;
    die "Error executing SQL statement: ", $sth->errstr, "\n$statement\n"
	unless defined( $rows );

    my $meta_info;
    if ( $options{'meta-info'} ) {
	&log_message( $self, "Need to define meta information variable $options{'meta-info'}" )
	    if $verbose;
	$meta_info = {'NUM_OF_FIELDS'	=> $sth->{NUM_OF_FIELDS},
		      'NUM_OF_PARAMS'	=> $sth->{NUM_OF_PARAMS},
		      'STATEMENT'	=> $sth->{Statement}};
	my @names = @{$sth->{NAME_uc}};
	for ( my $i = 0 ; $i < @names ; $i++ ) {
	    $meta_info->{FIELDS}->[$i] = {
		'NAME'		=> $names[$i],
		'TYPE'		=> $sth->{TYPE}->[$i],
		'PRECISION'	=> $sth->{PRECISION}->[$i],
		'SCALE'		=> $sth->{SCALE}->[$i],
		'NULLABLE'	=> $sth->{NULLABLE}->[$i]
		};
	}
    }

    my ($href, @rows, $defined);

    if ( exists $options{'define-var'} ) {
	$defined = $options{'define-var'};
	&log_message( $self, "Need to define <$defined>" ) if $verbose;
    }

    $i = 0;
    &log_message( $self, "we have [", scalar(@{$self->{'subobjs'}}), "] children" )
	if $verbose;
    while ( defined ($href = $sth->fetchrow_hashref) ) {

	if ( defined ( $defined ) ) {
	    my $href = Bedrock::Hash->new(%{$href});
	    push @rows, $href;
	}

	if ( $verbose ) {
	    my ($key, $value);
	    my $str = '';
	    while (($key, $value) = each %{$href}) {
		$str .= "\t$key = (";
		$str .= $value if defined( $value );
		$str .= "\n";
	    }
	    &log_message ( $self, "Row .. $i\n$str");
	}

	$self->{'finalize_children'}->($self->{'subobjs'}, $tx, $href, @context );
	$i++;
    }
    &log_message( $self, "Found <$i> row(s)." ) if $verbose;
    &log_message( $self, "we have [", scalar(@{$self->{'subobjs'}}), "] children" )
	if $verbose;

    if ( $options{'meta-info'} ) {
	$meta_info->{'COUNT'} = $i;
	$tx->param ( $options{'meta-info'}=> $meta_info );
    }

    if ( $options{'need-rows'} ) {
	if ( $options{'need-rows'} =~ /^([\+\-]?)(\d+)$/oi ) {
	    my ($sgn, $num) = ($1, $2);
	    if ( $sgn eq '+' ) {
		# need at least $num rows
		if ( $i < $num ) {
		    if ( $options{'raise'} ) {
			die "$options{'raise'}\n";
		    } else {
			die "Insufficient number of rows found($i) (at least $num needed)\n";
		    }
		}
	    } elsif ( $sgn eq '-' ) {
		# need max of $num rows
		if ( $i > $num ) {
		    $tx->error->location( $self->start_location );
		    if ( $options{'raise'} ) {
			die "$options{'raise'}\n";
		    } else {
			die "Too many rows found($i) (max of $num exceeded)\n";
		    }
		}
	    } elsif ( $i != $num ) {
		# need exactly $num rows
		$tx->error->location( $self->start_location );
		if ( $options{'raise'} ) {
		    die "$options{'raise'}\n";
		} else {
		    die "Invalid number of rows found($i) (need exactly $num rows)\n";
		}
	    }
	} else {
	    $tx->error->location( $self->start_location );
	    die "Invalid integer `$options{'need-rows'}' specified as argument to --need-rows.\n";
	}
    }

    $tx->param ( $defined => \@rows ) if $defined;
}


=pod

=head1 TAG sqlselect

=head1 PURPOSE

Execute a SQL select statement. Iterates until no rows are returned.

=head1 SYNTAX

  <sqlselect [--db="name"]
             [--statement="statement"]
             [--define-var="name"]
             [--bind="var"]
             [--need-rows="n"]
             [--raise="string"]
             [--meta-info="name"]
             [--arg="var"]

=head1 OPTIONS

=over 5

=item --db

Name of the database handle object.  The handle associated with the
most recent C<&lt;sqlconnect&gt;> is assumed if this parameter is not
specified.

=item --statement

SQL query statement to execute

=item --define-var

Name of an array object which will be used to store the query results.

=item --bind

One or more bind variables may be specified by this option.  They are bound in the order in which they are defined.

=item --arg

One or more arguments to use as arguments to sprintf applied against the SQL statement.

=item --raise

Exception string to raise if the number of rows specfied by --need-rows is not found.

=item --need-rows

Maximum number of rows to return

=item --meta-info

Name of the object that will hold the meta data associated with the
execution of the query.  Meta data may include the following data
elements depending upon the DBI implementation:

=over 10

=item NUM_OF_FIELDS

=item NUM_OF_PARMS

=item STATEMENT

=item FIELDS

=over 15

=item TYPE

=item PRECISION

=item SCALE

=item NULLABLE

=back

=item COUNT

=back

=back

=head1 EXAMPLE

  <sqlselect --define-var="foo" "select * from customer"></select>
  
  <foreach $foo>
    <var $_.NAME> <var $_.ADDRESS><br>
  </foreach>

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.21  2009/12/28 20:31:35  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.20  2008/12/03 14:01:21  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.19  2008/12/02 15:02:33  rlauer
# Added pod for tag reference
#
# Revision 1.18  2001/02/14 15:35:51  sridhar
# Added copyright and GPL notice
#
# Revision 1.17  2001/01/09 20:25:34  sridhar
# Removed an unnecessary check for extra bind variables.
#
# Revision 1.16  2000/12/15 14:29:07  sridhar
# Bug fix for reporting error when using --need-rows: the script line
# number was not being reported correctly.
#
# Revision 1.15  2000/11/21 19:25:14  sridhar
# 1. Support for passing a database handle using the option --db.
# 2. Error messages cleaned.
# 3. More error checks.
# 4. --dbname option deprecated.
#
# Revision 1.14  2000/11/16 19:05:48  sridhar
# Using function stored under `finalize-children' which is set by the
# parent object.
#
# Revision 1.13  2000/10/25 17:26:49  sridhar
# Argument to --bind can be an array. The array is expanded and used with
# the other bind arguments appropriately.
#
# Revision 1.12  2000/09/22 20:24:12  sridhar
# Argument is treated as SQL select statement to execute if --statement
# is not present.
#
# Revision 1.11  2000/08/11 14:13:34  sridhar
# Bugfix: was previously killing all children after first pass through.
# Was failing to properly generate output since there were no children
# in the second and subsequent loops when invoked in a loop. Fixed by
# not killing children after finishing the loop.
#
# Revision 1.10  2000/07/06 17:21:09  sridhar
# Had to swap computation of meta-info from after `fetch' to before
# `fetch' to accomodate mySQL which seems to treat meta-info retrieval
# after all fetches as invalid.
#
# Revision 1.9  2000/06/21 16:08:16  sridhar
# 1. Added new option `meta-info' for defining variable with query
# information
# 2. Using SIS::Hash for making a hash instead of {}
#
# Revision 1.8  2000/05/31 14:47:34  sridhar
# Rigorous version numbering and usage
#
# Revision 1.7  2000/04/27 20:01:23  sridhar
# Execute was returning undef and *NOT* throwing an exception due to an SQL
# error. Has been fixed now.
#
# Revision 1.6  2000/04/24 12:49:34  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.5  2000/04/13 15:21:07  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.4  2000/03/13 15:47:29  sridhar
# Added two options --need-rows and --raise, first for raising exception
# when required number of rows are not found, second for specifying the
# error message to throw as an exception.
#
# Revision 1.3  2000/03/09 14:21:40  sridhar
# Using Output handle object for printing which enables buffering.
#
# Revision 1.2  2000/03/06 18:37:24  sridhar
# Replaced all ad-hoc message logging with message logging only on
# demand, by the use of --verbose option.
#
# Revision 1.1  2000/03/02 15:00:04  sridhar
# Moved WithBody/SQLSelect.pm to WithBody/Loop/SQLSelect.pm. SQLSelect.pm
# is now a subclass of Loop, which overrides `parent' method to force own
# finalize_children function.
#
# Revision 1.3  2000/02/23 13:43:52  sridhar
# Removed some commented useless code.
#
# Revision 1.2  2000/02/08 15:37:46  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:03  sridhar
# Added TagX
#
#

1;
