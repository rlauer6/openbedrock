#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::SQLConnect;

use strict;
use warnings;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  @ISA = qw (Exporter);
}

use DBI;
use Data::Dumper;

use TagX::Log;
use TagX::TAG::NoBody;

@ISA = qw (TagX::TAG::NoBody);

sub ANONYMOUS {
  '*anonymous*';
}

sub _fetch_dsn {
  my ($dsn_source) = @_;

  return @{$dsn_source}{qw/DBI_DSN DBI_USER DBI_PASS DBI_HOST/};
}

sub _check_options {
  my ($tx, $name, %options) = @_;

  foreach (qw/db data-source username password/) {
    die "sqlconnect: option --" . $_ . " requires a value.\n"
      if exists $options{$_} && ! $options{$_};
  }

  if ( exists $tx->{'VARS'}->{$name} ) {
    die "sqlconnect: cannot assign database connection to `$name': variable already exists.\n";
  }
}

# returns (dsn, username, password)
sub _get_dsn_from_config {
  my ($tx, $options) = @_;

  my %dsn_spec;

  foreach (qw/DBI_DSN DBI_USER DBI_PASS DBI_HOST/) {
    $dsn_spec{$_} = $tx->config($_);
  }
  
  return _fetch_dsn(\%dsn_spec);
}

sub _get_dsn_from_data_sources {
  my ($tx, %options) = @_;
  
  my $dsn_name = $options{dsn};

  my ($dsn, $user, $pass, $host);
  
  if ( $dsn_name ) {
    my $dbnames = $tx->config->dbnames() || {};
    
    if ( ! $dbnames->{$dsn_name} ) {
      die "sqlconnect: no named connection '" . $options{dsn} . "' found.\n";
    }
    
    ($dsn, $user, $pass, $host ) = _fetch_dsn($dbnames->{$dsn_name});
  }

  return ($dsn, $user, $pass, $host);
}

sub _get_dsn_from_options {
  my ($tx, %options) = @_;

  return @options{qw/data-source username password/};
}

sub _get_dsn_from_environment {
  my ($tx, %options) = @_;
  
  return _fetch_dsn(\%ENV);
}

sub _get_dsn {
  my ($tx, %options) = @_;

  my %source = (
    'options'      => \&_get_dsn_from_options,
    'data-sources' => \&_get_dsn_from_data_sources,
    'environment'  => \&_get_dsn_from_environment,
    'config'       => \&_get_dsn_from_config,
  );
                

  my ($dsn, $user, $pass, $host);
  
  foreach my $src (keys %source) {
    ($dsn, $user, $pass, $host) = $source{$src}->($tx, %options);
    
    if ( $dsn && $user ) {
      $tx->{DB_DSN_SOURCE} = $src;
      last;
    }
  }

  return ($dsn, $user, $pass, $host);
}


sub _check_for_existing_connection {
  my ($tx, $name, %options) = @_;
  
  my $is_connected = exists $tx->{'DB'}->{$name};

  if ( $is_connected ) {
    
    $tx->{'DB'}->{$name}->disconnect;
    
    delete $tx->{'DB'}->{$name};
    delete $tx->{'VARS'}->{$name};
  }

  return $is_connected;
}

sub finalize {
  my ( $self, $tx, @context ) = @_;

  my %options = ( 'AutoCommit=s'  => 1,
                  'PrintError=s'  => 1,
                  'RaiseError=s'  => 1,
                  'ChopBlanks=s'  => 1,
                  'dbname=s'      => undef,
                  'db=s'          => undef,
                  'data-source=s' => undef,
                  'dsn=s'         => undef,
                  'username=s'    => undef,
                  'password=s'    => undef,
                  'hostname=s'    => undef,
                );

  # --- parse options
  my @argv = $self->parse_options( \%options, @context );

  my $verbose = $self->verbose;

  $self->dump_options( \%options ) 
    if $verbose;

  
  # --- parse tag and determine name of variable for storing dbi handle
  my $tag_opts = $self->parse_tag_name($argv[0]);
  
  &log_message( $self, Dumper( \@argv, $tag_opts ) )
    if $verbose;

  my $name;
  
  if ( $tag_opts->{name} ) {
    $name = $tag_opts->{name};
    shift @argv;
  }
  elsif ( $options{'dbname'} ) {
    $name = $options{'dbname'};
    &log_message( $self, "deprecated use of --dbname, use --define-var instead." );
  }
  elsif ( $options{'db'} ) {
    $name = $options{'db'};
    &log_message( $self, "deprecated use of --dbname, use --define-var instead." );
  }
  else {
    $name = &ANONYMOUS;
  }

  
  # --- check option consistency
  _check_options($tx, $name, %options);

  
  # --- check for user of overlapping dsn
  if ( exists $options{'data-source'} and @argv ) {
    die "Specify the DSN using the `--data-source' option or as argument, but not both.\n";
  }
  elsif ( @argv ) {
    $options{'data-source'} = "@argv"; # all args must now come from options
  }

  
  # --- check for existing connection
  $tx->{'DB'} = $tx->{'DB'} || {};

  &log_message($self, 'sqlconnect: disconnecting previous connection')
    if _check_for_existing_connection($tx, $name, %options) && $verbose;

  # --- look for connection information
  $self->dump_options(\%options)
    if $verbose;
  
  my ($dsn, $user, $pass, $host) = _get_dsn($tx, %options);


  # --- connect to database

  # note: password can be optional...
  if ( $dsn && $user ) {
    
    if ( ! $pass ) {
      &log_message($self, 'sqlconnect: no password');
    }

    $dsn = "$dsn:$host" if $host;

    if ($verbose) {
      &log_message( $self,
            'sqlconnect: attempting connection to '
          . $dsn
          . ' with for user '
          . $user );
    } ## end if ($verbose)
    
    my $dbh = DBI->connect(
      $dsn, $user, $pass,
      { 'AutoCommit' => $options{AutoCommit},
        'PrintError' => $options{PrintError},
        'RaiseError' => $options{RaiseError},
        'ChopBlanks' => $options{ChopBlanks}
      }
    );

    if ( $dbh ) {
      
      if ($verbose) {
        &log_message( $self,
              "sqlconnect: connected to database ($dsn) from "
            . $tx->{DB_DSN_SOURCE}
            . "\n" );
        
        &log_message( $self, Dumper( [ $name, $dbh, $tx ] ) );
      } ## end if ($verbose)
  
      # save for other <sql..> operations
      $tx->{'DB'}->{$name} = $dbh;
      
      # add $name to namespace
      $tx->{'VARS'}->{$name} = $dbh
        if $name ne &ANONYMOUS;
    }
    else {
      die "sqlconnect: unable to connect to database: ", $DBI::errstr, "\n"
    }
  }
  else {
    my ($missing) = map { eval "\$$_" ? () : $_ } qw/dsn user/;    

    die "sqlconnect: no $missing found from any source\n";
  }
}

=head1 TAG - C<E<lt>sqlconnectE<gt>>

=head1 PURPOSE

Connect to a database source.

=head1 SYNTAX

 <sqlconnect [options] [data-source]>

=head2 data-source

Connection string, ala perl's C<DBI> connection strings.  You can
optionally specify the connection string as a tag argument
(I<deprecated>) or by using the C<--data-source> or C<--dsn> option.

If you specify the connection string as an argument or you use the
C<--data-source> option, then all options to connect most be specified as
options.

=head2 options

 --data-source  = data-source
 --dsn          = named connection
 --db           = database connection handle name
 --username     = database user
 --password     = user password
 --ChopBlanks   = 1|0
 --PrintError   = 1|0
 --AutoCommit   = 1|0
 --RaiseError   = 1|0

=over 5

=item --dsn

Specifies a named connection that you created in the
F<data-sources.xml> file that you dropped in either the
C<$ENV{BEDROCK_CONFIG_PATH}> or C<$ENV{CONFIG_PATH}> directories.

=item --data-source

Data source name of the form:

C<dbi:database-type:database-name[:hostname]>

Example:

 dbi:Oracle:name_devl

 dbi:mysql:bedrock:localhost

=item --db

Optional name of an object that will store the database handle used in
subsequent database related calls.

=item --hostname

Optional name of the host.  If this value is present it will be
appended to the connection string.

=item --username

Username to authenticate with on opening the database.

=item --password

Password to  authenticate with on opening the database.

=item --ChopBlanks

Remove trailing blanks from fields.

=item --PrintError

Print the DBI error message if an error occurs.

=item --AutoCommit

Set C<AutoCommit> on.

=item --RaiseErrror

Raise an error if an SQL statement results in an error.

=back

=head1 NOTES

Bedrock's database layer is implemented using the Perl C<DBI> module.
For more information regarding the behavior of C<DBI> see C<perldoc
DBI>.

To connect to the database you must supply the connection information
in one of the ways described below. The order in which Bedrock will
look for connection information is:

=over 5

=item 1. options

=item 2. data sources file

=item 3. Environment variables

=item 4. Configuration object

=back

=head2 Specifying Connection Parameters in the Tag

Specify the username, password and connection string using options to
the C<E<lt>sqlconnectE<gt>> tag.

 <sqlconnect --username fred --password flintstone dbi:mysql:bedrock>
 <sqlconnect --username fred --password flintstone --hostname=localhost dbi:mysql:bedrock>
 <sqlconnect --username fred --password flintstone --data-source=dbi:mysql:bedrock>

=head2 Using a Data Sources XML File

Using the C<--dsn> option you can specify the name of a set of
connection parameters found in the F<data-sources.xml> file.  Create a
file named F<data-sources.xml> similar to the one below and copy it
Bedrock's configuration path.


 <object>
  <object name="customers">
   <scalar name="DBI_DSN">dbi:mysql:customers</scalar>
   <scalar name="DBI_USER">some-user</scalar>
   <scalar name="DBI_PASS">some-password</scalar>
  </object>
 </object>

Then, to connect to the database:

 <sqlconnect --dsn="customers">

=head2 Using Environment Variables to Specify Connection Parameters

As discussed previously, you can force Bedrock to export configuration
variables to the environment using the C<export_env="yes"> attribute
of a Bedrock XML C<E<lt>scalarE<gt>> tag.

 <scalar export_env="yes"  name="DBI_DSN">dbi:mysql:bedrock;host=localhost</scalar>
 <scalar export_env="yes"  name="DBI_USER">fred</scalar>
 <scalar export_env="yes"  name="DBI_PASS">bedrock</scalar>

=head2 Specifying Connection Parameters in a Configuration File

Bedrock will also look for connection information in the the configuration
object if no options are given in the tag.  The configuration object
is the result of merging any C<.xml> files in Bedrock's configuraiton
paths, so placing the variables:

 DBI_DSN
 DBI_USER
 DBI_PASS
 DBI_HOST

...in any of C<.xml> file will create a default database connection
configuration.

You can alternately set them in your Bedrock page by invoking the
C<set> method of the C<$config> object.

 <null $config.set('DBI_DSN', 'dbi:mysql:bedrock')>
 <null $config.set('DBI_USER', 'fred')>
 <null $config.set('DBI_PASS', 'flintstone')>

Still another way is to use the C<merge> method of the C<$config>
object and merge a customer configuration file with the system
configuration file.

 <null $config.merge("bedrock-connect.xml")>

=head2 Using Directory Specific Connection Parameters

Yet another way to provide connection information to Bedrock is to
create a directory specific configuration in F<tagx_apps.xml>.  This
file will be merged with the system configuration when Bedrock serves
a page from the directory specified as one of the keys in
F<tagx_apps.xml> file.

 <object>
  <object name="/accounting">
   <scalar name="DBI_DSN">dbi:mysql:accounting</scalar>
   <scalar name="DBI_USER">fred</scalar>
   <scalar name="DBI_PASS">flintstone</scalar>
  </object>
 </object>

=head1 EXAMPLE

 <sqlconnect --data-source="dbi:mysql:bedrock:10.1.1.1"  --username="srch" --password="srch">

 <sqlselect "select * from custmr where acct < 999">
  <var $ACCT> <var $NAME><br>
 </sqlselect>

=head1 SEE ALSO

C<E<lt>sqlE<gt>>, C<E<lt>sqlselectE<gt>>, C<BLM::Startup::Config>

=cut

1;
