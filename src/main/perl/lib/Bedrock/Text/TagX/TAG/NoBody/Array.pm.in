#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#) $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Array;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA @INC);
    $VERSION    = 1.01;
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use TagX::TAG::NoBody 1.03;
use Symbol;
use Bedrock::Array;
use Bedrock::JSON;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options = ('json' => undef,
		   'define-var' => undef
		  );

    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
	my ($key, $value);
	my $str = "$self: Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	&log_message( $self, "$str\n" );
    }

    my $name = $options{'define-var'} || '_';

    $argv[0] =~/^:([^:]*)$/;
    if ($1) {
      $name = $1;
      shift @argv;
    }

    my $obj;

    if ($options{'json'}) {
      my $json_string = join('', @argv);
      $obj = Bedrock::JSON::decode($json_string);
      die "Not an array definition ($json_string)!"
	unless (UNIVERSAL::isa($obj, 'ARRAY')) ;
    }
    else {
      $obj = Bedrock::Array->new(@argv);
    }

    $tx->{'VARS'}->{$name} = $obj;

    return $obj;
}


=head1 TAG - <array>

=head1 PURPOSE

Create a Bedrock array.

=head1 SYNTAX

 <array:[array name] [options] expression...>

=head1 DESCRIPTION

Creates a Bedrock array from the expression contained in the tag.  The
expression can be a simple list of scalars, a list of expressions or
the return value from a method call for example.

Bedrock arrays have a host of interesting methods and can be iterated
over using the C<foreach> tag.

=head1 OPTIONS

 --json
 --define-var = var-name

=over 5

=item --define-var

Name of the array to create.

=item --json

Consider the argument(s) to be a JSON string to convert to an internal
array representation.

Note that Bedrock will join the arguments and consider them one string
when decoding the string as a JSON object.  That means you can include
Bedrock objects in the JSON string without resorting to concatenation
using the '+' operator.

 <array:that woohoo woohoo2>

 <array:foo --json '["this",' $that.json() ',"another"]' >

 <pre>
 <var $foo --json>
 </pre>

 <array:foo --json ('["this",'+$that.json()+',"another"]') >

 <pre>
 <var $foo --json>
 </pre>

=back

=head1 METHODS

=head2 get( index )

Retrieve an element from the array based on the given index.

 <var $foo.get(0)>

=head2 grep( string|regexp )

Return an array of elements that match the given string or regular expression.  

If the argument is of the form C<qr/.../> then the string will be treated as a regular expression.

Return all elements of foo that start with "a"

  <null:foo_sub_set $foo.grep("qr/^a/i")>

Return all element of foo that are equal to "foo"

  <null:foo_sub_set $foo.grep("foo")>

=head2 isEmpty

Returns false if length of array is 0.

 <if $array.isEmpty()>  <=>  <if $array.length() --eq "0">

=head2 join( string )

Returns a string that is the result of joining elements of the array with the given string.

 <var $array.join("\<br\>")>

=head2 json

Returns the JSON representataion of the array.

 <var $array.json()>

=head2 length

Returns the length of the array.

=head2 map( format )

Returns an array that is the result of using the C<sprintf> style
format string given as the argument to C<map> with each value of the
array as an argument to C<sprintf>.  

  <null:temp $foo.map("%5.2f")>

Functionally equivalent to:

  <null:format "%5.2f"> <- create a format string
  <null:array:temp>     <- create an array to hold result

  <foreach $foo>
   <null $temp.push($_.format($format))>
  </foreach>

=head2 pop

Remove the last element from the array and return.

=head2 push( arg )

Add an element to the front of the array.

=head2 set( index, arg )

Assign the specified element of the array to the given value.
 
 <null $array.set(0, "foo")>

=head2 sort( [dir], [type] )

Returns an alphabetic sort (default: ascending).  The sort order can
be changed by the by passing the appropriate arguments (see below).

 <null:foo 01 0100 3 5 7 8 3 7 4 >

Ascending, lexical

 <var --json $foo.sort()><br>

Descending, lexical

 <var --json $foo.sort('desc')><br>

Ascending, numeric

 <var --json $foo.sort('asc', 'numeric')><br>

Descending, numeric

 <var --json $foo.sort('desc', 'numeric')><br>

=over 5

=item dir

B<asc> - sort in ascending order

B<desc> - sort in descending order

=item type

B<alpha> - do an alphabetic (ascii) sort

B<numeric> - do a numeric sort

=back

=head2 shift

Remove and return an element from the front of the array.

=head2 splice

Equivalent to the perl C<splice> function...from the perldocs...

I<Removes the elements designated by OFFSET and LENGTH from an array,
and replaces them with the elements of LIST, if any.  In list conâ€
text, returns the elements removed from the array.  In scalar context,
returns the last element removed, or "undef" if no elements are
removed.  The array grows or shrinks as necessary.  If OFFSET is
negative then it starts that far from the end of the array.  If LENGTH
is omitted, removes everything from OFFSET onward.  If LENGTH is
negative, removes the elements from OFFSET onward except for -LENGTH
elements at the end of the array.  If both OFFSET and LENGTH are
omitted, removes everything. If OFFSET is past the end of the array,
perl issues a warning, and splices at the end of the array.>

This implementation does not include the scalar context functionality, however.

=head2 unshift

Add an element to the front of the array.


=head2 xml( options )

Output the object as an XML document.  See the documentation regarding
XML conversion in the E<lt>varE<gt> tag.

=over 5

=item options

A list of key/value pairs of options as documented in the perl module C<XML::Simple>.

=back

=head1 EXAMPLE

Create an array from a simple list

 <array:foo 1 2 3 4 5 6>
 <array --define-var="foo" 1 2 3 4 5>

Create an array by decoding a JSON string

 <array:foo --json '[1,2,3,4,5]'>

Create an array as the output from a method

 <array:foo $obj.method()>

=head1 SEE ALSO

C<E<lt>nullE<gt>>, C<E<lt>foreachE<gt>>, C<E<lt>hashE<gt>>

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.5  2010/01/04 02:25:49  rlauer
# docs
#
# Revision 1.4  2009/12/31 18:30:41  rlauer
# sort with direction and type, methods documented
#
# Revision 1.3  2009/12/31 12:43:24  rlauer
# add --json and --define-var options
#
# Revision 1.2  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.1  2009/12/15 13:10:21  rlauer
# first check-in
#
# $Revision $

1;
