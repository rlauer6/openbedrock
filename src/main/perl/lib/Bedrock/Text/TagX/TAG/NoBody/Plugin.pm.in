#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#) $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Plugin;

use strict;

BEGIN {
  
  use Exporter ();
  use vars	qw ($VERSION @ISA @INC);
  $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  @ISA	= qw (Exporter);
}

use TagX::Log;
use TagX::TAG::NoBody;
use Symbol;
use Bedrock::Plugin;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
  {
    my ($self, $tx, @context) = @_;
    my $config = $tx->out_handle->{Handle}->{'CONFIG'};
    my %options = ('define-var=s'    => undef,
		   'dir-prefix=s'    => undef,
		   'define-plugin=s' => undef
		  );

    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    $self->dump_options( \%options ) if $verbose;

    $options{'define-var'} = '_' unless defined $options{'define-var'};

    my $tag_opts = $self->parse_tag_name( shift @argv );

    my $class = $tag_opts->{type} || $tag_opts->{name};
    my $name =  $options{'define-plugin'} || $tag_opts->{name};
    $name =~s/:://g;

    unless ( $name ) {
      $name = $class;
      if ( exists $tx->{'VARS'}->{$class} ) {
	&log_message(undef, 
		     "WARNING: Default name \$class already in use.\n" .
		     "You probably want to use --define-var to assign an object name."
		    ); 
      }
    }

    # still undecided about this 
    if (exists $options{'dir-prefix'}) {
      push @INC, $options{'dir-prefix'} 
	unless grep { $options{'dir-prefix'} } @INC;
    }

    if ( $config->{PLUGIN_PATH} ) {
      my @plugin_inc = split /:/, $config->{PLUGIN_PATH};
      
      foreach my $path ( @plugin_inc ) {
	push @INC, $path
	  unless grep { /$path/ } @INC;
      }
    }

    $class = 'BLM::' . $class unless $class =~ /^BLM::/;

    unless ( $self->loadModule( $class ) ) {
      die "Could not load module: $class\n";
    }

    my $obj;

    if ( &UNIVERSAL::can( $class, 'TIEHASH' ) ) {
      &log_message( undef, "$self: creating an object of class $class" ) if $verbose;
      $obj = {};
      tie %{$obj}, $class, @argv;
    } elsif ( &UNIVERSAL::can( $class, 'TIEARRAY' ) ) {
      &log_message( undef, "$self: creating an array of class $class" ) if $verbose;
      $obj = [];
      tie @{$obj}, $class, @argv;
    } elsif ( &UNIVERSAL::can( $class, 'TIEHANDLE' ) ) {
      &log_message( undef, "$self: creating a handle of class $class" ) if $verbose;
      $obj = gensym;
      tie *{$obj}, $class, @argv;
    } elsif ( &UNIVERSAL::can( $class, 'TIESCALAR' ) ) {
      &log_message( undef, "$self: creating a scalar of class $class" ) if $verbose;
      my $scalar;
      $obj = tie $scalar, $class;
      $$obj = $argv[0];
    } else {
      die "Attempt to load invalid module: $class.\n";
    }

    bless $obj, $class;
    
    if (&UNIVERSAL::can($class, 'new') && &UNIVERSAL::isa($obj, 'Bedrock::Plugin')) {
      $obj = $obj->new( @argv );
      $obj->verbose( $verbose );
      $obj->{_options} = Bedrock::Hash->new( %options );
      if (&UNIVERSAL::can($obj, 'init_plugin') ) {
	$tx->{'VARS'}->{$options{'define-var'}} = $obj->init_plugin( @argv );
      }
      $tx->{'VARS'}->{$name} = $obj;
    } else {
      $tx->{'VARS'}->{$name} = $obj;
    }

    return $tx->{'VARS'}->{$name};
  }

sub loadModule
  {
    my $self = shift;
    my @mods = @_;

    my $verbose = $self->{'config'}->{'verbose'};
    for my $class ( @mods ) {
      $class =~ s!::!/!g;
      $class =~ s!$!.pm! unless $class =~ /\.pm$/;
      next if $INC{$class};
      eval {
	require $class;
      };

      unless ( $@ ) {
	&log_message( undef, "$class loaded successfully" ) if $verbose;
      } else {
	&log_message( undef, "$class not loaded! " . $@ );
	return 0;
      }
    }

    return 1;
  }

=head1 TAG - C<E<lt>pluginE<gt>>

=head1 PURPOSE

Load a Bedrock Plugin.

=head1 SYNTAX

 <plugin:[plugin name][:name] [--define-var="name"] args...>

=head1 DESCRIPTION

Plugins are way to extend Bedrock.  They are typically used to provide
some functionality specific to your application or add features not
found in core Bedrock.

Plugins are used to invoke methods that perform actions or that return
snippets of HTML for assembling your page.

=head1 OPTIONS

 --define-var    = "var-name"
 --define-plugin = "var-name"

=over 5

=item --define-var

Name of the object that will hold the return value of the Plugin
initialization function.  If not supplied the value will be returned
in C<$_>.

=item --define-plugin

Name of the object that will be instantiated as the given Plugin.
If not supplied the object will have the same name as the Plugin.

=back

=head1 NOTES

Plugins are implemented as perl modules.  They should sub-class the
C<Bedrock::Plugin> perl class.  Typically a plugin will look something like this:

 package BLM::Foo;

 use strict;

 use vars qw(@ISA);

 use Bedrock::Plugin;

 @ISA = qw( Bedrock::Hash Bedrock::Plugin );

 sub init_plugin {
   my $self = shift;
   my @args = @_;

   "Greetings from Foo!";
 }
 
 sub hello_world {
   my $self = shift;

   "Hello World!";
 }

 1;

I<You should override the C<init_plugin> method if you want to return a
value upon instantiation.>

I<The plugin tag's arguments are passed to your initialization function.>

I<Plugins should be placed in a location where perl will find them.>

I<-- type options (e.g. --define-var) can be retrieved using the C<options()> method>

=head1 EXAMPLE

Load the C<BLM::FileIO> plugin and write something to the error log.

 <plugin:FileIO --define-plugin="fd" "/var/www/mysite.com/logs/error.log" "w+">

 <null $fd.write("Hello World!\n");
 <null $fd.close>

 <plugin:FileIO "/var/www/mysite.com/logs/error.log" "w+">
 <null $FileIO.write("Hello World!\n");
 <null $FileIO.close>

=head1 SEE ALSO

C<Bedrock::Plugin>, C<Bedrock::Application::Plugin>, C<E<lt>pebbleE<gt>>

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.13  2011/09/10 15:51:36  eutl420
# - use PLUGIN_PATH to find Plugins
#
# Revision 1.12  2011/07/17 16:56:09  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.11  2011/07/13 18:10:23  eutl420
# - renamed BLM/PLUGIN to Bedrock/Plugin so we updated the documentation
#
# Revision 1.10  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.9  2011/04/04 13:42:54  eutl420
# - take the :: out of plugin names in case we get something like <plugin:MIME::Lite>
# - sub loadModule() now returns a 0/1 on success so error can be propagated from caller
#
# Revision 1.8  2011/03/15 13:31:53  eutl420
# - set the value of a tied scalar after the tie because
#   of what seems to be bug in Tie::StdArray
#
# Revision 1.7  2010/12/20 20:18:01  eutl420
# - invoke verbose method of PLUGINs
# - define-plugin=s (was missing =s)
# - 1 too many invocations of new
#
# Revision 1.6  2010/12/12 17:05:48  eutl420
# - use dump_options
# - use parse_tag_name
#
# Revision 1.5  2010/11/29 15:57:54  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.4  2010/11/17 02:32:15  rlauer
# - switched --define-var meaning with --define-plugin
# - pod cleanup
#
# Revision 1.3  2010/11/08 03:11:36  rlauer
# - documentation changes only
#
# Revision 1.2  2009/12/31 18:38:36  rlauer
# updated docs
#
# Revision 1.1  2009/12/31 13:01:11  rlauer
# rename Blm.pm -> Plugin.pm
#
# Revision 1.7  2009/12/31 12:43:25  rlauer
# fixed documentation to indicate usage of plugin, etc.
#
# Revision 1.6  2009/12/29 12:21:50  rlauer
# add tied scalars to the list of things that can be loaded as a plugin
#
# Revision 1.5  2009/12/28 23:27:23  rlauer
# allow overwrite of plugin names, but warn to file
#
# Revision 1.4  2009/12/28 12:50:50  rlauer
# invoke method new() for PLUGINs if the class can new()
#
# Revision 1.3  2009/12/15 12:33:49  rlauer
# only warn if reusing $_
#
# Revision 1.2  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.1  2008/11/25 14:32:34  rlauer
# added as part of Bedrock 2.0.0 reorg
#
#

1;
