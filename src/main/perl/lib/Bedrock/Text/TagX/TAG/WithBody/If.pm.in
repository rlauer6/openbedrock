#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::If;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use TagX::Log;
use TagX::TAG::WithBody;

@ISA = qw (TagX::TAG::WithBody);

sub end_if
{
    my $self = shift;
    $self->parent;
}

sub else_obj
{
    my $self = shift;
    if ( @_ == 1 ) {
	$self->{'else'} = shift;
	$self->{'else'}->parent_if ( exists $self->{'parent_if'} ? $self->{'parent_if'} : $self );
	$self->{'else'}->parent ( $self->parent );
    }
    $self->{'else'};
}

sub end_child
{
    my $self = shift;
    $self->end_if;
}

sub closure
{
    '/if';
}

sub evaluate
{
    if ( @_ == 1 ) {
	return $_[0];
    } elsif ( @_ == 2 ) {
	# unary op
	my ($op, $v) = @_;
	for ($op) {
	    $_ eq '--not' and return not $v;
	    $_ eq '--exists' and return defined( $v );
	    $_ eq '--object' and return UNIVERSAL::isa($v, 'HASH');
	    $_ eq '--hash' and return UNIVERSAL::isa($v, 'HASH');
	    $_ eq '--blm' and return ref($v) =~/blm/i;
	    $_ eq '--plugin' and return ref($v) =~/blm/i;
	    $_ eq '--array' and return UNIVERSAL::isa($v, 'ARRAY');
	    $_ eq '--scalar' and return ! ref($v);
	    die "invalid unary operator in `if/else' statement: $_\n";
	}
    } elsif ( @_ == 3 ) {
	my ($lhs, $cond, $rhs) = @_;
	my $ref = ref($lhs);

	for (lc($cond)) {
	    $_ eq '--gt' and return $lhs gt $rhs;
	    $_ eq '--ge' and return $lhs ge $rhs;
	    $_ eq '--lt' and return $lhs lt $rhs;
	    $_ eq '--le' and return $lhs le $rhs;
	    $_ eq '--eq' and return $lhs eq $rhs;
	    $_ eq '--ne' and return $lhs ne $rhs;
	    $_ eq '--and' and return $lhs && $rhs;
	    $_ eq '--or' and return $lhs || $rhs;
	    $_ eq '--re' and return $lhs =~ /$rhs/ ? 1 : 0;
	    $_ eq '--ref' and return ref($lhs) =~/$rhs/ ? 1 : 0;
	    die "invalid binary operator in `if/else' statement: $_\n";
	}
    } else {
	die "invalid number of args(@{[scalar(@_)]}) to `if/else' statement.\n(@_)";
    }
}

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options;
    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
	my ($key, $value);
	my $str = "$self: Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	$str .= "Arguments ..(@argv)";
	&log_message( $self, $str );
    }

    # If no args defined, means we are executing the else branch
    unless ( @argv > 0 ) {
	$self->SUPER::finalize( $tx, @context );
	return;
    }

    my $v = &evaluate( @argv );

    $v = ! $v if ref( $self ) =~/unless/i;

    &log_message( $self, "Statement (@argv) evaluated to ($v): " . ($v ? "(true)" : "(false)" ))
	if $verbose;
    if ( $v ) {
	&log_message( $self, "Condition succeeded .." ) if $verbose;
	$self->SUPER::finalize ( $tx, @context );
    } elsif ( $self->else_obj ) {
	&log_message( $self, "Condition failed .. trying <else[if]> branch" ) if $verbose;
	$self->else_obj->finalize ( $tx, @context );
    }
}

=pod

=head1 TAG - C<E<lt>ifE<gt>>

=head1 PURPOSE

Conditional inclusion of a block of text.

=head1 SYNTAX

  <if boolean-expression >
   ...
  <elseif test>
   ...
  <else>
   ...
  </if>

Where I<boolean-expression> is a Bedrock expression that evaluates to true or false (in the perl sense).

Bedrock dyadic (has two arguments) boolean expressions include:

 arg1 --eq arg2
 arg1 --ne arg2
 arg1 --lt arg2
 arg1 --le arg2
 arg1 --gt arg2
 arg1 --ge arg2
 arg1 --re regexp
 arg1 --or arg2
 arg1 --and arg2
 arg1 --ref arg2

Bedrock monadic (has 1 argument) boolean expressions include:

 --not    arg1 => true if ! arg1
 --exists arg1 => true if exists arg1

 --scalar arg1 => true if arg1 is a scalar
 --array  arg1 => true if arg1 is an array object
 --hash   arg1 => true if arg1 is a hash object
 --plugin arg1 => true if arg1 is a Plugin

Deprecated
 --blm    arg1 => true if arg1 is a BLM 
 --object arg1 => true if arg1 is a hash object


=head1 OPTIONS

None

=head1 DESCRIPTION

The C<E<lt>ifE<gt> tag is, technically, to be used to conditionally
assemble portions of a document.  In other words the statement is
designed to conditionally include 1 of possibly several different
alternate snippets of Bedrock text to be processed.

If you find yourself programming too much, write a Plugin please.

=head1 EXAMPLES

 <if $input.name>
   <null --define-var="results" $foo.search($input.name)>
   <foreach $results>
      <var $fname> <var $lname><br>
   </foreach>
 <else>
   <form>
     <input type="name" size="40" value="<var $input.name>">&nbsp;
     <input type="submit">
   </form>
 </if>

=head1 NOTES

=over 5

=item 1. comparisons are done in the alpha-numeric sense, if either argument does not look like a number

=item 2. compound tests (more than one expression) are allowed, but use parentheses liberally

=item 3. whitespace is ALWAYS preserved by Bedrock!

If you don't want extra space in your HTML then construct accordingly.
In other words, pedantic indenting may look good to you in your raw
Bedrock page, but the resulting HTML will reflect your indenting.
Bedrock is essentially a templating tool, thus it interprets pages
literally.

The snippet below illustrates where whitespace (.) and newlines (^) will be preserved.

  <if $input.action --eq "save">^
  ...<null $foo.save()>^
  </if>^

If you wanted a cleaner HTML output you'd probably want:

  <if $input.action --eq "save"><null $foo.save()></if>

=item 4. C<--re> evaluates simple regular expressions using the following perl pseudo code

   $lhs =~ /$rhs/ 

The regular expression you pass is (C<$rhs>).

=item 5. C<--ref> evalues to true if ref(arg1) eq arg2

  <if $input --ref "BLM:Startup::Input">
    This is the input object!
  </if>

=item 6. Bedrock II introduces the C<E<lt>caseE<gt>> tag.  If it feels better using if, then use if, else use  C<E<lt>caseE<gt>>.

  <if $input.radio_1>checked=checked </if>
  <case $input.radio_1 "checked=checked ">

=back

=head1 SEE ALSO

C<E<lt>caseE<gt>>

=cut


#
# Name of Release: $Name$
# $Log$
# Revision 1.27  2011/09/09 19:45:49  eutl420
# - in the evaluate method, parse_options is now returning unknown options with '--' intact, so we should test for those
#   instead of naked operators
# - also need to add tests for --scalar, --array, --plugin
# - tweaked pod for better example
#
# Revision 1.26  2011/08/18 21:51:00  eutl420
# - invert test if the tag is an unless tag in finalize()
#
# Revision 1.25  2011/07/17 16:56:09  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.24  2011/07/12 19:10:37  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.23  2010/11/29 15:57:54  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.22  2010/11/17 02:49:52  rlauer
# - pod cleanup
#
# Revision 1.21  2010/11/17 02:45:52  rlauer
# - pod cleanup
#
# Revision 1.20  2010/11/17 02:27:35  rlauer
# - pod cleanup
#
# Revision 1.19  2009/12/31 18:38:42  rlauer
# updated docs
#
# Revision 1.18  2009/12/31 12:43:37  rlauer
# docs tweaks
#
# Revision 1.17  2009/12/31 00:02:05  rlauer
# use UNIVERSAL::isa to catch weird objects
#
# Revision 1.16  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.15  2008/12/02 15:02:31  rlauer
# Added pod for tag reference
#
# Revision 1.14  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.13  2008/11/12 13:49:58  rlauer
# pod changes
#
# Revision 1.12  2008/11/12 13:40:54  rlauer
# - added pod, added --blm, --object --scalar, --array boolean operators
#
# Revision 1.11  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.10  2000/12/15 14:30:20  sridhar
# Subclass overrides method `closure()' to report the correct way for
# closing the tag.
#
# Revision 1.9  2000/05/31 14:42:23  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:49:13  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:21:01  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:37:12  sridhar
# 1. Returns the value when evaluating checking a value
# 2. Added --exists condition
#
# Revision 1.5  2000/03/21 16:14:12  sridhar
# 1. Major changes: Support for expressions joined with --and and
# --or. Also supports --not. Expressions delimited by '(' and ')'.
# 2. Expression parser is recursive
#
# Revision 1.4  2000/03/06 18:36:26  sridhar
# 1. Bug-fix: when an argument to tag was `0', not being seen due to
# checking for non-zero value
# 2. Added more verbose logging only on demand using the --verbose
# option.
#
# Revision 1.3  2000/02/23 13:43:01  sridhar
# Bug fix: $_ was being used/set without local($_) declaration.
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:01  sridhar
# Added TagX
#
#

1;
