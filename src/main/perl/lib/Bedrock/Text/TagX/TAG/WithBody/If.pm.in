#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::If;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use TagX::TAG::WithBody 1.06;

@ISA = qw (TagX::TAG::WithBody);

sub end_if
{
    my $self = shift;
    $self->parent;
}

sub else_obj
{
    my $self = shift;
    if ( @_ == 1 ) {
	$self->{'else'} = shift;
	$self->{'else'}->parent_if ( exists $self->{'parent_if'} ? $self->{'parent_if'} : $self );
	$self->{'else'}->parent ( $self->parent );
    }
    $self->{'else'};
}

sub end_child
{
    my $self = shift;
    $self->end_if;
}

sub closure
{
    '/if';
}

sub evaluate
{
    if ( @_ == 1 ) {
	return $_[0];
    } elsif ( @_ == 2 ) {
	# unary op
	my ($op, $v) = @_;
	for ($op) {
	    $_ eq 'not' and return not $v;
	    $_ eq 'exists' and return defined( $v );
	    $_ eq 'object' and return ref($v) =~/hash/i;
	    $_ eq 'blm' and return ref($v) =~/blm/i;
	    $_ eq 'array' and return ref($v) =~/array/i;
	    $_ eq 'scalar' and return ! ref($v);
	    die "invalid unary operator in `if/else' statement: $_\n";
	}
    } elsif ( @_ == 3 ) {
	my ($lhs, $cond, $rhs) = @_;
	my $ref = ref($lhs);

	for (lc($cond)) {
	    $_ eq 'gt' and return $lhs gt $rhs;
	    $_ eq 'ge' and return $lhs ge $rhs;
	    $_ eq 'lt' and return $lhs lt $rhs;
	    $_ eq 'le' and return $lhs le $rhs;
	    $_ eq 'eq' and return $lhs eq $rhs;
	    $_ eq 'ne' and return $lhs ne $rhs;
	    $_ eq 'and' and return $lhs && $rhs;
	    $_ eq 'or' and return $lhs || $rhs;
	    $_ eq 're' and return $lhs =~ /$rhs/ ? 1 : 0;
	    $_ eq 'ref' and return ref($lhs) =~/$rhs/ ? 1 : 0;
	    die "invalid binary operator in `if/else' statement: $_\n";
	}
    } else {
	die "invalid number of args(@{[scalar(@_)]}) to `if/else' statement.\n(@_)";
    }
}

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options;
    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
	my ($key, $value);
	my $str = "$self: Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	$str .= "Arguments ..(@argv)";
	&log_message( $self, $str );
    }

    # If no args defined, means we are executing the else branch
    unless ( @argv > 0 ) {
	$self->SUPER::finalize( $tx, @context );
	return;
    }

    my $v = &evaluate( @argv );
    &log_message( $self, "Statement (@argv) evaluated to ($v): " . ($v ? "(true)" : "(false)" ))
	if $verbose;
    if ( $v ) {
	&log_message( $self, "Condition succeeded .." ) if $verbose;
	$self->SUPER::finalize ( $tx, @context );
    } elsif ( $self->else_obj ) {
	&log_message( $self, "Condition failed .. trying <else[if]> branch" ) if $verbose;
	$self->else_obj->finalize ( $tx, @context );
    }
}

=pod

=head1 TAG if

=head1 PURPOSE

Conditional inclusion of a block of text.

=head1 SYNTAX

  <if test >
  <elseif test>
  <else>
  </if>

Where I<test> is a Bedrock expression that evaluates to true or false (in the perl sense).

Bedrock diadic (has two arguments) boolean expressions include:

 arg1 --eq arg2
 arg1 --ne arg2
 arg1 --lt arg2
 arg1 --le arg2
 arg1 --gt arg2
 arg1 --ge arg2
 arg1 --re regexp
 arg1 --or arg2
 arg1 --and arg2

Bedrock monadic (has 1 argument) boolean expressions include:

 --not    arg1 => true if ! arg1
 --exists arg1 => true if exists arg1
 --object arg1 => true if arg1 is a hash reference
 --blm    arg1 => true if arg1 is a BLM
 --array  arg1 => true if arg1 is an array reference
 --scalar arg1 => true if arg1 is a scalar

=head1 EXAMPLES

 <if $input.action --eq "save">
   <null $blm.save()>
 <elseif $input.action --eq "delete">
   <null $blm.delete()>
 <else>
   <include:menu>
 </if>


 <if (($input.action --re "(save|update)")) --and $session.username)>
   <null $blm.save()>
 </if>

=head1 NOTES

=over 5

=item 1. comparisons are done in the alpha-numeric sense, not a numeric sense

=item 2. compound tests (more than one expression) are allowed, but use parens liberally

=item 3. whitespace is ALWAYS preserved by Bedrock!

If you don't want extra space in your HTML then construct accordingly.
In other words, pedantic indenting may look good to you in your raw
Bedrock page, but the resulting HTML will reflect your indenting.
Bedrock is essentially a templating tool, thus it interprets pages
literally.

The snippet below illustrates where whitespace (.) and newlines (^) will be preserved.

  <if $input.action --eq "save">^
  ...<null $blm.save()>^
  </if>^

If you wanted a cleaner HTML output you'd probably want:

  <if $input.action --eq "save"><null $blm.save()></if>

=item 4. C<--re> evaluates simple regular expressions using the following perl pseudo code

   $lhs =~ /$rhs/ 

The regular expression you pass is (C<$rhs>).

=back

=cut


#
# Name of Release: $Name$
# $Log$
# Revision 1.14  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.13  2008/11/12 13:49:58  rlauer
# pod changes
#
# Revision 1.12  2008/11/12 13:40:54  rlauer
# - added pod, added --blm, --object --scalar, --array boolean operators
#
# Revision 1.11  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.10  2000/12/15 14:30:20  sridhar
# Subclass overrides method `closure()' to report the correct way for
# closing the tag.
#
# Revision 1.9  2000/05/31 14:42:23  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:49:13  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:21:01  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:37:12  sridhar
# 1. Returns the value when evaluating checking a value
# 2. Added --exists condition
#
# Revision 1.5  2000/03/21 16:14:12  sridhar
# 1. Major changes: Support for expressions joined with --and and
# --or. Also supports --not. Expressions delimited by '(' and ')'.
# 2. Expression parser is recursive
#
# Revision 1.4  2000/03/06 18:36:26  sridhar
# 1. Bug-fix: when an argument to tag was `0', not being seen due to
# checking for non-zero value
# 2. Added more verbose logging only on demand using the --verbose
# option.
#
# Revision 1.3  2000/02/23 13:43:01  sridhar
# Bug fix: $_ was being used/set without local($_) declaration.
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:01  sridhar
# Added TagX
#
#

1;
