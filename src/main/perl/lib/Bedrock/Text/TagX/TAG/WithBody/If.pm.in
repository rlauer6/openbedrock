#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::If;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use TagX::TAG::WithBody 1.06;

@ISA = qw (TagX::TAG::WithBody);

sub end_if
{
    my $self = shift;
    $self->parent;
}

sub else_obj
{
    my $self = shift;
    if ( @_ == 1 ) {
	$self->{'else'} = shift;
	$self->{'else'}->parent_if ( exists $self->{'parent_if'} ? $self->{'parent_if'} : $self );
	$self->{'else'}->parent ( $self->parent );
    }
    $self->{'else'};
}

sub end_child
{
    my $self = shift;
    $self->end_if;
}

sub closure
{
    '/if';
}

sub evaluate
{
    if ( @_ == 1 ) {
	return $_[0];
    } elsif ( @_ == 2 ) {
	# unary op
	my ($op, $v) = @_;
	for ($op) {
	    $_ eq 'not' and return not $v;
	    $_ eq 'exists' and return defined( $v );
	    die "invalid unary operator in `if/else' statement: $_\n";
	}
    } elsif ( @_ == 3 ) {
	my ($lhs, $cond, $rhs) = @_;
	for (lc($cond)) {
	    $_ eq 'gt' and return $lhs gt $rhs;
	    $_ eq 'ge' and return $lhs ge $rhs;
	    $_ eq 'lt' and return $lhs lt $rhs;
	    $_ eq 'le' and return $lhs le $rhs;
	    $_ eq 'eq' and return $lhs eq $rhs;
	    $_ eq 'ne' and return $lhs ne $rhs;
	    $_ eq 'and' and return $lhs && $rhs;
	    $_ eq 'or' and return $lhs || $rhs;
	    $_ eq 're' and return $lhs =~ /$rhs/ ? 1 : 0;
	    die "invalid binary operator in `if/else' statement: $_\n";
	}
    } else {
	die "invalid number of args(@{[scalar(@_)]}) to `if/else' statement.\n(@_)";
    }
}

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options;
    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
	my ($key, $value);
	my $str = "$self: Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	$str .= "Arguments ..(@argv)";
	&log_message( $self, $str );
    }

    # If no args defined, means we are executing the else branch
    unless ( @argv > 0 ) {
	$self->SUPER::finalize( $tx, @context );
	return;
    }

    my $v = &evaluate( @argv );
    &log_message( $self, "Statement (@argv) evaluated to ($v): " . ($v ? "(true)" : "(false)" ))
	if $verbose;
    if ( $v ) {
	&log_message( $self, "Condition succeeded .." ) if $verbose;
	$self->SUPER::finalize ( $tx, @context );
    } elsif ( $self->else_obj ) {
	&log_message( $self, "Condition failed .. trying <else[if]> branch" ) if $verbose;
	$self->else_obj->finalize ( $tx, @context );
    }
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.11  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.10  2000/12/15 14:30:20  sridhar
# Subclass overrides method `closure()' to report the correct way for
# closing the tag.
#
# Revision 1.9  2000/05/31 14:42:23  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:49:13  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:21:01  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:37:12  sridhar
# 1. Returns the value when evaluating checking a value
# 2. Added --exists condition
#
# Revision 1.5  2000/03/21 16:14:12  sridhar
# 1. Major changes: Support for expressions joined with --and and
# --or. Also supports --not. Expressions delimited by '(' and ')'.
# 2. Expression parser is recursive
#
# Revision 1.4  2000/03/06 18:36:26  sridhar
# 1. Bug-fix: when an argument to tag was `0', not being seen due to
# checking for non-zero value
# 2. Added more verbose logging only on demand using the --verbose
# option.
#
# Revision 1.3  2000/02/23 13:43:01  sridhar
# Bug fix: $_ was being used/set without local($_) declaration.
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:01  sridhar
# Added TagX
#
#

1;
