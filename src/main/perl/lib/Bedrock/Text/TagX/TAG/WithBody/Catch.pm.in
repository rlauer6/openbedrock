#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::WithBody::Catch;

use strict;
use warnings;

use English qw/-no_match_vars/;

use parent qw (Exporter TagX::TAG::WithBody);
use Bedrock::Constants qw{:chars :booleans};

use Role::Tiny::With;
with 'Bedrock::Logger';

########################################################################
sub parent_try {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args == 1 ) {
    $self->{'parent_try'} = shift @args;
  }

  return $self->{'parent_try'};
}

########################################################################
sub end_try {
########################################################################
  my ($self) = @_;

  return $self->parent;
}

########################################################################
sub closure {
########################################################################
  return '/try';
}

########################################################################
sub catch {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args == 1 ) {
    $self->{'catch'} = shift @args;

    $self->{'catch'}->parent_try(
      exists $self->{'parent_try'} ? $self->{'parent_try'} : $self );

    $self->{'catch'}->parent( $self->parent );
  }

  return $self->{'catch'};
}

########################################################################
sub finalize {
########################################################################
  my ( $self, $tx, @context ) = @_;

  my $errstr = $EVAL_ERROR;

  my %options;
  my @argv = $self->parse_options( \%options, @context );

  $self->dump_options( \%options, @argv );

  if ( @argv > 0 ) {
    my $rhs = "@argv";

    my $re = ( $rhs =~ /^qr/i ) ? eval $rhs : eval "qr/$rhs/ism";  ## no critic (ProhibitStringyEval)

    my $test = ( $errstr =~ $re );

    if ($test) {
      my %capture_group = %LAST_PAREN_MATCH;

      map { $context[0]->{$_} = $capture_group{$_}; } keys %capture_group;
    }

    # note that the evals above will reset $@ so we reset it so we can
    # continue with other <catch> blocks
    $EVAL_ERROR = $errstr;  ## no critic (RequireLocalizedPunctuationVars)

    if ($test) {
      $self->get_logger->debug(
        sub {
          sprintf "Caught exception [%s]\nusing regexp [%s]", $EVAL_ERROR,
            $rhs;
        }
      );

      $self->SUPER::finalize( $tx, @context );

      $self->get_logger->debug('Done handling exception');
    }
    elsif ( $self->catch ) {
      $self->get_logger->debug(
        sub {
          sprintf 'Trying next exception handler for %s', $EVAL_ERROR;
        }
      );

      $self->catch->finalize( $tx, @context );
    }
    else {
      $self->get_logger->debug(
        sub {
          sprintf 'No exception handler for (%s)', $EVAL_ERROR;
        }
      );

      die;
    }
  }
  else {
    # A catch-all exception handler
    $self->get_logger->debug('<catch> exception handler');

    $self->SUPER::finalize( $tx, @context );
  }

  return;
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 TAG - C<E<lt>catchE<gt>>

=head1 PURPOSE

Begins the "catch" portion or exception handling portion of a try/catch block.

=head1 SYNTAX

  <catch [regexp]>


=head1 DESCRIPTION

C<catch> is part of the C<try/catch> mechanism for trapping
application errors.  One or more C<catch> blocks may be defined by
your application.  If the regular expression argument form of C<catch>
is used, then the exception is matched against the regular expression
to determine if the subsequent C<catch> block will handle the exception.

If no regular expression is present, then that C<catch> block will be
the default exception path.

  <try>
  ...
  <catch "error 1">
  ...
  <catch "error 2">
  ...
  <catch>
  ...
  </try>

=over 5

=item regexp

C<regexp> can be simple string that represents a regular expression that will be
matched against the current exception to determine if this catch block
should be evaluated.  The catch blocks are examined in order and if no
regular expression is matched the default catch block will be used.

Simple regular expresssions are evaluated in a case-insensitive manner.

You can also use quoted regular expressions, the same kind used by Perl.

 <catch "qr/error 1/i">

...is equivalent to:

 <catch "error 1"

You can also use capture groups in more complex regular expressions:

 <try>
   <raise "bad apple">
 <catch "qr/^bad\\s*(?'what'.*?)$/i">
   You have a bad something error: bad <var $what>
 </try>

I<Note you must escape backslashes in Bedrock strings!>

=back

=head1 OPTIONS

None

=head1 EXAMPLE

  <try>
    <pebble:mypeb "arg1">
  <catch "connect">
    Could not connect!
  <catch "parameter">
    Illegal parameter!
  <catch>
    Unknown error!
  </try>

=head1 SEE ALSO

C<E<lt>tryE<gt>>, C<E<lt>raiseE<gt>>, 

=cut
