#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::NULL;

use strict;
use warnings;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
}

use Bedrock::Array;
use Bedrock::BedrockJSON;
use Bedrock::Dump;
use Bedrock::Hash;
use Bedrock::XML;

use MIME::Base64;

use Data::Dumper;

use Scalar::Util qw/reftype/;

use TagX::Log;
use TagX::TAG::NoBody;

@ISA = qw (TagX::TAG::NoBody);

sub param {
  my ($options, $tx, $obj ) = @_;

  my $name;
  
  foreach ( qw/define-var define-array define-object/ ) {
    last if $name = $options->{$_};
  }

  # create a Bedrock::RecordSet object
  if ( $options->{recordset} && ref($obj) ) {

    die "invalid object type: must be array"
      unless reftype($obj) eq 'ARRAY';

    $obj = Bedrock::RecordSet->new($obj);
  }
  
  $tx->param( $name => $obj );
}

sub finalize {
  my ( $self, $tx, @context ) = @_;

  my %options = (
		 'base64'          => undef,
		 'bedrock-xml'     => undef,
		 'create-object=s' => undef,
		 'default=s'       => undef,
		 'define-array=s'  => undef,
		 'define-object=s' => undef,
		 'define-var=s'    => undef,
		 'escape'          => undef,
		 'encode'          => undef,
		 'expand-all'      => undef,
		 'expand-args'     => undef,
		 'expand'          => undef,
		 'file'            => undef,
		 'filter-hash=s'   => undef,
		 'handle'          => undef,
		 'json'            => undef,
		 'recordset'       => undef,
		 'serializer=s'    => undef,
		 'xml'             => undef,
		 'yaml'            => undef,
                );

  my @argv = $self->parse_options( \%options, @context );

  my $verbose = $self->verbose;

  $self->dump_options( \%options ) 
    if $verbose;

  my $tag_opts = $self->parse_tag_name($argv[0]);
  &log_message($self, sprintf("ARGV[0] => [%s], 1 =>  [%s], 2 => [%s]", $argv[0], @{$tag_opts}{qw(type name)})) 
    if $verbose;

  # synonymous tags
  if ( exists $options{'expand'} ) {
    $options{'expand-args'} = 1;
  }

  if ( $tag_opts->{type} ) {
    if ( $tag_opts->{type} =~ /(object|hash)/ ) {
      $options{'create-object'} = $tag_opts->{name};
    }
    elsif ( $tag_opts->{type} =~ /array/ ) {
      $options{'define-array'} = $tag_opts->{name};
    }
    elsif ( $tag_opts->{type} =~ /var/ ) {
      $options{'define-var'} = $tag_opts->{name};
    }
    shift @argv;
  }
  elsif ( $tag_opts->{name} ) {
    $options{'define-var'} = $tag_opts->{name};
    shift @argv;
  }

  if ( exists $options{'handle'} && ( @argv != 1 || !( -r $argv[0] || $argv[0]->can('getline') ) ) ) {
    die "Use only 1 argument with --handle option and must be a handle.\n";
  }
  elsif ( exists $options{'file'} && ( @argv != 1 || ref( $argv[0] ) ) ) {
    die "Use only 1 argument with --file option and must be filename.\n";
  }

  if ( exists $options{'create-object'} ) {
    $options{'define-object'} = $options{'create-object'};
    delete $options{'create-object'};
  }

  if ( exists $options{'define-var'} and exists $options{'define-array'} ) {
    die "Use either `--define-var' or `--define-array' here.\n";
  }

  if ( exists $options{'define-var'} and exists $options{'define-object'} ) {
    die "Use either `--define-var' or `--define-object' here.\n";
  }
  
  if (     exists $options{'define-array'} and exists $options{'define-object'} ) {
    die "Use either `--define-array' or `--define-object' here.\n";
  }

  die "Use `--define-var' once only.\n"
    if exists $options{'define-var'} and ref( $options{'define-var'} );

  die "Use `--define-array' once only.\n"
    if exists $options{'define-array'} and ref( $options{'define-array'} );

  die "Use `--define-object' once only.\n"
    if exists $options{'define-object'} and ref( $options{'define-object'} );

  die "Use `--json only' only for `--define-var'.\n"
    if exists $options{'json'} and exists $options{'define-array'};

  # locally define $_
  unless ( exists $options{'define-var'} || exists $options{'define-object'} || exists $options{'define-array'} ) {
    # see if current context has a default variable?
    &log_message( undef, "Warning! You are about to overwrite the default variable \$_ => (" . $context[0]->{'_'} . ")!")
      if $verbose && exists $context[0]->{'_'};
    
    $options{'define-var'} = '_';
  }
  
  # --base64 option tells Bedrock that the argument to the <null> tag is 
  # base64 encoded and should be decoded, before applying other options.
  # Currently this is available for a single argument (scalar or array)
  #
  # The string is base64 encoded
  #   <null:decoded --base64 $input.encoded>
  #
  # The string is a base64 encoded JSON string
  #   <null:decoded --json --base64 $input.encoded>
  
  if ( exists $options{'base64'} ) {
    if ( @argv == 1 && ! ref($argv[0]) ) {
      $argv[0] = decode_base64($argv[0]);
    }
    elsif ( reftype($argv[0]) eq 'ARRAY' ) {
      @argv = map { decode_base64($_); } @{$argv[0]};
    }
    else {
      die "Use --base64 with single argument: scalar or array reference - not " . ref($argv[0]). "\n"
    }
  }
  
  # Vanilla define-var does the following
  #  1. If there is a single argument, the argument is bound to the
  #     specified name
  #  2. If there is more than one argument, an array is created out of
  #     the args
  #  3. If there are no args, a generic object is bound to the specified name
  if ( exists $options{'define-var'} ) {
    if ( @argv > 1 ) {
      &log_message( $self, "Defining an array with (@argv)[" . scalar(@argv) . " items]" )
	if $verbose;

      # check to see if it's possible that this is just a trick
      # of quoting that resulted in the parser creating multiple
      # arguments - qw{ a b c d }
      my $arg = join(' ', @argv);

      if ( $arg =~/^\s*qw\{\s*([^}]+)\s*\}\s*$/s) {
	param(\%options, $tx, Bedrock::Array->new(split /\s+/, $1));
      }
      else {
	if ( exists $options{'json'} ) {
	  my $json_string = $arg || $options{'default'};
	  my $handler = $self->io_handler( $tx, 'JSON');
	  my $ref = $handler->in($json_string);
	  param(\%options, $tx, $ref);
	}
	else {
	  # arguments may be taken solely as list, first as expanded, or
	  # all as expanded...
	  if ( exists $options{'expand-args'} && reftype($argv[0]) eq 'ARRAY' ) {
	    param(\%options, $tx, Bedrock::Array->new(@{shift @argv}, @argv));
	  }
	  elsif ( exists $options{'expand-all'} ) {
	    param(\%options, $tx,  Bedrock::Array->new(map { ( reftype($_) eq 'ARRAY' ) ? @{$_} : $_ } @argv));
	  }
	  else {
	    param(\%options, $tx, Bedrock::Array->new(@argv));
	  }
	}
      }
    }
    elsif ( @argv == 1 ) {
      &log_message( $self, "Assigning $argv[0] to $options{'define-var'}" )
	if $verbose;

      if ( defined $options{'file'} || defined $options{'handle'} ) {
        my $fh = $argv[0];

        unless ( ref($fh) ) {
          my $file = $tx->find_file($fh, undef, ".");
	  unless ( $file && -s $file ) {
	    die "error: can't read [$fh]. Either it does not exist or is empty\n";
	  }

	  $fh = new IO::File;
	  $fh->open("<$file");
        }

        die "Could not open file ( $argv[0] ) for reading."
	  unless $fh && ( (-r $fh ) || $fh->can('getline'));

        {
          local $/;
          $argv[0] = <$fh>;
        }
      }

      if ( defined $options{'json'} ) {
	my $handler = $self->io_handler( $tx, 'JSON');
	my $value = shift @argv || $options{default};
	$value = $options{encode} ? $handler->serialize($value, { %options, @argv }) : $handler->deserialize($value, { %options, @argv});
	param( \%options, $tx, $value);
      }
      elsif ( defined $options{'bedrock-xml'} ) {
	my $handler = $self->io_handler( $tx, 'BedrockXML');
	my $value = shift @argv || $options{default};
	$value = $options{encode} ? $handler->serialize($value, { %options, @argv }) : $handler->deserialize($value, { %options, @argv});
	param( \%options, $tx, $value);
      }
      elsif ( defined $options{'xml'} ) {
	my $handler = $self->io_handler( $tx, 'XML');
	my $value = shift @argv || $options{default};
	$value = $options{encode} ? $handler->serialize($value, { %options, @argv }) : $handler->deserialize($value, { %options, @argv});
	param( \%options, $tx, $value);
      }
      elsif ( defined $options{'yaml'} ) {
	my $handler = $self->io_handler( $tx, 'YAML');
	my $value = shift @argv || $options{default};
	$value = $options{encode} ? $handler->serialize($value, { %options, @argv }) : $handler->deserialize($value, { %options, @argv});
	param( \%options, $tx, $value);
      }
      elsif ( defined $options{'serializer'} ) {
	my $handler = $self->io_handler( $tx, $options{serializer}, { 'out', @argv });
	my $value = shift @argv || $options{default};
	$value = $options{encode} ? $handler->serialize($value, { %options, @argv }) : $handler->deserialize($value, { %options, @argv});
	param( \%options, $tx, $value);
      }

      elsif ( defined $options{'filter-hash'} ) {
        &log_message($self, sprintf("filter-hash:%s", $options{'filter-hash'}))
	  if $verbose;

        my $filter = Bedrock::JSON::decode( $options{'filter-hash'} );
        my ( $key, $value );

        ( $key, $value ) = @$filter if reftype($filter) eq 'ARRAY';
        ( $key, $value ) = %$filter if reftype($filter) eq 'HASH';
	
        &log_message( $self, "filtering on key: $key value: $value" )
	  if $verbose;

        my @filtered_array;
	
        foreach ( @{$argv[0]} ) {
          if (reftype($_) eq 'HASH') {
            push @filtered_array, $_ if $_->{$key} eq $value;
          }
          else {
            push @filtered_array, $_;
          }
        }

        param( \%options, $tx, Bedrock::Array->new(@filtered_array) );
      }
      elsif ( defined $options{'default'} ) {
        param( \%options, $tx, defined $argv[0] ? $argv[0] : $options{'default'});
      }
      elsif ( defined $options{'expand-args'} && reftype($argv[0]) eq 'ARRAY') {
        param( \%options, $tx, Bedrock::Array::Reference->new($argv[0]));
      }
      else {
	if ( defined $options{escape} ) {
	  my %sub_strings = (
			     '\n' => "\n",
			     '\t' => "\t",
			     '\r' => "\r",
			    );
	  
	  $argv[0] =~ s/(\\n|\\t|\\r)/$sub_strings{$1}/gs;
	}

        param(\%options, $tx, $argv[0]);
      }
    }
    # no arguments (@argv is empty)
    else {
      &log_message( $self, "Creating an undefined scalar named $options{'define-var'}" )
	if $verbose;
      
      param( \%options, $tx, $options{default} );
    }
  }
  elsif ( exists $options{'define-array'} ) {
    # define-array explicitly specifies array creation with the arguments, if any
    &log_message($self,"Defining an array with (@argv)[" . scalar(@argv) . " items]")
      if $verbose;
    
    if ( defined $options{'expand-args'} || defined $options{'expand-args'} ) {
      param(\%options, $tx, Bedrock::Array->new(map { (reftype($_) eq 'ARRAY') ? @{$_} : $_; } @argv));
    }
    else {
      param(\%options, $tx, Bedrock::Array->new(@argv) );
    }
  }
  elsif ( exists $options{'define-object'} ) {
    # define-object creates an object and does the following
    #  0. If $options{'json'} then assume all args represent a JSON string to be converted into an object
    #  1. If the number of args is even, uses the arguments as
    #     key-value pairs to initialize the object
    #  2. If the number of args is odd and the first or last argument is
    #     an array, this array is expanded one level and combined with the
    #     rest of the arguments to use as key-value pairs
    #  3. In both cases, the key must be a scalar -- cannot be an object, array ..
    #  4. Anything else is an error
    
    if ( $options{'json'} && @argv % 2 ) {
      
      my $json_string = join( '', @argv );
      
      # interpret the arguments as JSON string
      my $json = Bedrock::JSON->new($json_string);
      
      &log_message( $self,
                    "in NULL " . Bedrock::Dump::compact( $json->decode ) )
	if $verbose;
      param( \%options, $tx, $json->decode );
    }
    else {
      # if odd number of elements, see if first or last element is a reference
      my $obj;

      if ( @argv % 2 ) {
        &log_message($self,"Odd number of elements in object creation list, merging in $argv[0]")
	  if $verbose;

        my $aref = $argv[0];

        if ( @argv == 1 ) {
          if ( reftype($aref) eq 'HASH' ) {
            $obj = Bedrock::Hash->new(%$aref);
          }
          elsif ( reftype($aref) eq 'ARRAY' ) {
            $obj = Bedrock::Hash->new(@$aref);
          }
          else {
            my $json = Bedrock::JSON->new($aref);
            $obj = $json->decode;
          }
          &log_message( $self, "in NULL " . Bedrock::Dump::compact($obj) )
	    if $verbose;
        }
        elsif ( reftype($aref) =~/(HASH|ARRAY)/ ) {
          shift @argv;
						 
          if ( reftype($aref), 'ARRAY') {
            &log_message( $self, "Prepending the following array to (@argv)\n(@{$aref})" )
	      if $verbose;
            unshift @argv, @{$aref};
          }
          else {
            &log_message( $self, "Prepending the following array to (@argv)\n(%{$aref})" )
	      if $verbose;
            unshift @argv, %$aref;
          }
        }
        elsif ( defined($aref = $argv[-1]) and (reftype($aref) =~/(HASH|ARRAY)/) ) {
          pop @argv;

          if ( reftype($aref) eq 'ARRAY') {
            &log_message( $self, "Appending the following array to (@argv)\n(@{$aref})" )
	      if $verbose;
            push @argv, @{$aref};
          }
          else {
            &log_message( $self, "Appending the following array to (@argv)\n(%{$aref})" )
	      if $verbose;
            push @argv, %$aref;
          }
        }
      }

      die "Odd number of elements [" . scalar(@argv). "] in object creation list. Use --json if this is a JSON string.\n"
	if @argv % 2 && !defined $obj;

      &log_message( $self, "Key-value pairs for object creation are\n(@argv)" )
	if ( $verbose && !defined $obj );

      $obj = Bedrock::Hash->new(@argv)
	unless defined $obj;

      &log_message( $self, "Creating an object named $options{'define-object'}" )
	if $verbose;
      
      param( \%options, $tx, $obj );
    }
  }
}

1;

=head1 TAG - C<E<lt>nullE<gt>>

=head1 PURPOSE

The C<null> tag is the I<do something> tag or more correctly I<the
possibly do something but donE<039>t output anything tag>.  It allows
for invocation of object methods and/or the creation of Bedrock
objects without inserting anything at the point at which the
C<E<lt>nullE<gt>> tag is encountered.

=head1 SYNTAX

<null[:type][:var-name] [options] [list | expression]>

I<type> should be one of:

=over 5

=item hash

Create a Bedrock hash object

=item array

Create a Bedrock array object

=back

If I<type> is not provided Bedrock will create the appropriate object
based on the argument(s).  If the argument is a list, then Bedrock
will create an array.  One element lists are created as scalars.  If the
argument is an expression, then the object type will be determined by
the the result of the expression.

=head1 DESCRIPTION

Use the C<E<lt>nullE<gt>> tag to create Bedrock objects or invoke methods on
objects when no output is desired.

=head1 OPTIONS

 --base64
 --bedrock-xml
 --create-object = "var-name" I<deprecated>
 --default
 --define-var    = "var-name"
 --define-array  = "var-name"
 --define-object = "var-name"
 --encode
 --expand-all
 --expand-args
 --file
 --handle
 --json
 --recordset
 --xml

=over 5

=item --base64

This option tells Bedrock that the argument to the C<E<lt>nullE<gt>> tag is 
a I<base64> encoded string and should be decoded before applying other options.

Currently this option will only work with a single argument which can either
be a scalar or an array reference.

Examples:

The string is base64 encoded

 <null:decoded --base64 $input.encoded>

The string is a base64 encoded JSON string

 <null:decoded --json --base64 $input.encoded>

=item --bedrock-xml

Consider the input to be a scalar string (or an open filehandle) that
represents a valid Bedrock XML object (or valid Bedrock XML file).
This has the effect of essentially deserializing the string file into
a Bedock object.

 <plugin:FileIO ($env.BEDROCK_CONFIG_PATH + "/tagx.xml")>
 <null:tagx --bedrock-xml $FileIO.handle>
 <trace --output $tagx>


 <null:foo a b c d>
 <trace --output $foo>

 <null:xml $foo.bedrock_xml()>

 <null:foo --bedock-xml $xml>
 <trace --output $foo>

=item --create-object

I<Deprecated> use C<--define-object>.

=item --default

Provides a default value if the argument is B<undefined>.

 <null:foo --default="red" $input.color>

If you want to provide a default value when a value is B<not true> in
the B<Perl> sense, then try this:

 <null:foo ($nput.color --or "red")>

=item --define-var

Create a scalar, array or object (only if no content).

=item --define-array

Create a Bedrock array.

=item --define-object

Create a Bedrock hash. All Bedrock hashes are ordered, with the
exception of those created using the C<--json> option.

 <null --define-object="foo" red 1 green 2 blue 3>

=item --encode

Encodes the object if any of the options:

 --bedrock-xml

 --json

 --xml
 
 --yaml

...are also present.  Normally these options indicate to Bedrock, how to
I<decode> the object during the assignment.  By using the C<--encode>
option you are asking Bedrock to create a scalar from the object and
encode it as a JSON or XML object.

 <null:env_xml --encode --bedrock-xml $env>

=item --expand-args

=item --expand-all

Expand array objects into lists.  If the C<--define-var> option is
used, this only applies to the first object in the list.  If the
C<--define-array> option is used, then all array references are
expanded into lists.  To force the expansion of all objects into a
list, use the C<--expand-all> option.

=item --file

Indicates that the argument is the name of a file and that it should
be slurped. If the file is not found or is empty, an exception will be
thrown.

 <null:config --bedrock-xml --file ($env.CONFIG_PATH + "/tagx.xml")>

You can add options as shown above that tell Bedrock how to interpret
the file.

 --bedrock-xml
 --json
 --xml
 --yaml

=item --handle

Indicates that the argument is a file handle and the file should be
slurped.

 <open:fh --mode="r" $file>
 <null:text --file $fh>

=item --json

For C<--define-var> consider the string to be a JSON string.

 <null:foo --json '{red : 1, green : 2, blue : 3}'>

 <null --define-var='foo' --json '{red : 1, green : 2, blue : 3}'>

=item --recordset

Creates an object that is a C<Bedrock::Recordset> from an array.

=item --escape

Escapes certain special characters (\n, \r, \t)

 <null:foo --escape 'foo\\n'>

...is sometimes preferable to:

 <sink:foo>foo
 </sink>

=item --xml

For C<--define-var> consider the string to be an XML string.  Consider using
the C<< <sink> >> tag for this purpose.

 <null $config.XML('in', 'KeepRoot', 0)>
 <null:foo --xml '<colors\><red\>1</red\><green\>2</green\><blue\>2</blue\></colors\>'>

=back

=head1 NOTE

Arrays and hashes have a boat load of useful methods.  See the
documentation on the C<E<lt>hashE<gt>> and C<E<lt>arrayE<gt>> tags for
a description of the methods associated with those objects.

=head1 EXAMPLE

=over 5

=item * Create an object as the return result from some method:

 <null --define-var="x" $object.method()>

=item * Create a hash

 <null --define-object="foo" key1 value1 key2 value2>
 <null:hash:foo key1 value1 key2 value2>
 <null:foo --json '{key1 : "value1", key2 : "value2"}'>

Note that quotes around keys are not required.

=item * Create an array

 <null --define-array="x" 1 2 3 4>

 <null:array:x 1 2 3 4>

I<Bedrock assumes you want to create a list from a list ;-)>

 <null:x 1 2 3 4>

 <null:x --json '[1,2,3,4]'>

=item * Invoke a method, no return value

 <null $header.see_other("/new_url")>

=back

=head1 SEE ALSO

C<E<lt>hashE<gt>>, C<E<lt>arrayE<gt>>, C<E<lt>recordsetE<gt>>, C<Bedrock::Array>, C<Bedrock::Hash>

=cut

#
# Revision 1.49  2013/11/09 19:20:00  rlauer
# - subtle correction of pod for --default option
#
# Revision 1.48  2013/10/28 23:54:00  rlauer
# - pod tweak
#
# Revision 1.47  2013/01/04 02:10:31  rlauer
# - pod for --recordset option
#
# Revision 1.46  2012/07/29 18:42:07  lauerrc
# - support for --recordset option
#
# Revision 1.45  2012/06/04 13:43:08  eutl420
# - added the --encode option to the null tag which allows one to encode objects into their scalar representation.  More or
#   less equivalent to <sink> but there may be some future possbilities for additional encoding hooks
#
# Revision 1.44  2012/04/13 14:29:54  eutl420
# - do not close file after slurping file
#
# Revision 1.43  2012/03/05 16:31:51  eutl420
# - throw exception if try to read from non-existent or empty file
# - pod tweaks - some options were not documented
# - only create object from xml if objects is not empty
#
# Revision 1.42  2012/02/07 14:29:41  eutl420
# - check for array ref or scalar, not array ref or scalar ref
#
# Revision 1.41  2012/02/06 18:43:50  eutl420
# - added new option --base64 for decoding a base64 string
#
# Revision 1.40  2011/09/29 12:57:40  eutl420
# - when using --handle, $fh not set properly from $argv[0]
#
# Revision 1.39  2011/09/21 20:31:55  eutl420
# - pod for matches()
#
# Revision 1.38  2011/09/15 16:05:33  eutl420
# - perl tidy
#
# Revision 1.37  2011/09/14 19:06:54  eutl420
# - reworked file reading slightly to localize $/ properly
#
# Revision 1.36  2011/09/09 19:36:25  eutl420
# - added options --bedrock-xml, --file, --handle, --expand, --expand-all
#   --bedrock-xml argument can be a handle or a scalar
#   --file argument can be a handle or a filename to slurp
#   --expand <=> --expand-args
#   --expand-args is equivalent to --expand-all if you say --define-array
#   --expand-all will flatten all elements (1-level)
#
# Revision 1.35  2011/08/31 02:57:02  eutl420
# - create an undefined scalar instead of a Bedrock::Hash in the case where someone creates a Bedrock object thusly:
#   <null:foo>, previous version created a Bedrock::Hash which really makes no sense.
#
# Revision 1.34  2011/08/22 23:29:48  eutl420
# - updated the pod to reflect more correct syntactic explanation
#
# Revision 1.33  2011/08/07 16:06:49  eutl420
# use Bedrock::BedrockJSON instead of Bedrock::JSON to avoid namespace collisions with JSON when use Bedrock; is employed
#
# Revision 1.32  2011/07/17 16:50:26  eutl420
# @PERL@, log_message if verbose
#
# Revision 1.31  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.30  2011/03/28 16:25:53  eutl420
# - 1 arg form of <null --create-object > did not create Bedrock::Hash object
#   just hash ref
#
# Revision 1.29  2011/03/25 20:31:16  eutl420
# - when there is only 1 argument to NULL tag, need to accept
#   a hash or array ref in addition to JSON string
#
# Revision 1.28  2011/03/25 13:30:36  eutl420
# - set $VERSION based on CVS revision
# - <null:object:foo json-string> was not working properly, when 'create-object' && @argv = 1 added
#   json decode logic
#
# Revision 1.27  2010/12/12 17:08:03  eutl420
# - remove use of Data::Dumper
# - use parse_tag_name
# - use dump_options
#
# Revision 1.26  2010/11/29 15:57:54  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.25  2010/11/26 22:51:44  rlauer
# - pod tweak, extra spaces
#
# Revision 1.24  2010/11/19 13:35:21  rlauer
# - give a clue about using --json wehn odd number of elements
#
# Revision 1.23  2010/11/17 02:27:25  rlauer
# - pod cleanup
#
# Revision 1.22  2010/11/14 21:12:21  rlauer
# - allow odd number of elements for object creation and recognize
#   hash and array refs as valid first and last arguments in that case
#
# Revision 1.21  2010/11/13 17:27:50  rlauer
# - --expand-args tag for --define-array, --define-var
#
# Revision 1.20  2010/11/08 03:13:35  rlauer
# - bump version
# - support for --define-object, deprecate --create-object
# - update documentaion, some options missing
#
# Revision 1.19  2010/01/11 22:44:24  rlauer
# have default work like it does in <var>, i.e. default if undef
#
# Revision 1.18  2010/01/09 14:04:43  rlauer
# add default option
#
# Revision 1.17  2010/01/04 02:22:49  rlauer
# add option --xml
#
# Revision 1.16  2009/12/31 18:31:52  rlauer
# updating docs
#
# Revision 1.15  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.14  2009/12/26 15:19:54  rlauer
# remove BLM::OrderedObject since all objects are now ordered
#
# Revision 1.13  2009/12/18 21:49:07  rlauer
# filter-hash!
#
# Revision 1.12  2009/12/17 23:23:30  rlauer
# more JSON awareness
#
# Revision 1.11  2009/12/16 23:22:27  rlauer
# fix docs, tighter error checing
#
# Revision 1.10  2009/12/15 23:06:58  rlauer
# added a json option
#
# Revision 1.9  2009/12/15 13:06:41  rlauer
# simplified object creation syntax, +ordered objects
#
# Revision 1.8  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.7  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.6  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.5  2000/12/15 14:26:58  sridhar
# Proper checking for presence of any one of --define-var,
# --define-array or --create-object.
#
# Revision 1.4  2000/11/29 21:00:37  sridhar
# 1. Added option --create-object which takes the arguments and makes it
# the properties of a newly created object.
# 2. If the there are odd number of arguments, the first or last
# argument is expanded if it is an array
# 3. Throws exception if the object cannot be created due to invalid
# arguments.
#
# Revision 1.3  2000/11/16 19:10:28  sridhar
# Fixed error messages so exceptions don't have perl source code
# locations in them.
#
# Revision 1.2  2000/09/22 20:23:06  sridhar
# 1. Have a --define-array option which makes an array of the arguments,
# if any are present. Defines an empty array, if no arguments
# 2. --define-var makes an empty object if no arguments. Also makes an
# array of the arguments if more than one argument present.
#
# Revision 1.1  2000/06/06 20:00:11  sridhar
# Adding a tag which does not produce any output; only purpose of this
# tag is to invoke object methods.
#
#

#  LocalWords:  argv
