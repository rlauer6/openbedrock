#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::NULL;

use strict;

BEGIN {
  use Exporter ();
  use vars	qw ($VERSION @ISA);
  $VERSION    = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r if @r};
}

use Bedrock::Hash;
use Bedrock::Array;
use Bedrock::BedrockJSON;
use Bedrock::Dump;
use Bedrock::XML;

use Data::Dumper;

use XML::Simple;
use XML::Parser;

use TagX::Log;
use TagX::TAG::NoBody;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
  {
    my ($self, $tx, @context) = @_;

    my %options = (
		   'bedrock-xml'        => undef,
		   'define-var=s'	=> undef,
		   'define-array=s'	=> undef,
		   'default=s'          => undef,
		   'file'               => undef,
		   'create-object=s'	=> undef,
		   'define-object=s'    => undef,
		   'expand-args'        => undef,
		   'expand-all'         => undef,
		   'expand'             => undef,
                   'handle'             => undef,
		   'json'               => undef,
		   'xml'                => undef,
		   'filter-hash=s'      => undef
		  );

    my @argv = $self->parse_options (\%options, @context);

    my $verbose = $self->verbose;

    $self->dump_options( \%options ) if $verbose;

    my $tag_opts = $self->parse_tag_name( $argv[0] );
    &log_message($self, sprintf("ARGV[0] => [%s], 1 =>  [%s], 2 => [%s]", $argv[0], @{$tag_opts}{qw(type name)} )) if $verbose;

    # synonymous tags
    if ( exists $options{'expand'} ) {
      $options{'expand-args'} = 1;
    }

    if ( $tag_opts->{type} ) {
      if ($tag_opts->{type} =~/(object|hash)/) {
	$options{'create-object'} = $tag_opts->{name};
      } elsif ($tag_opts->{type} =~/array/) {
	$options{'define-array'} = $tag_opts->{name};
      } elsif ($tag_opts->{type} =~/var/) {
	$options{'define-var'} = $tag_opts->{name};
      }
      shift @argv;
    } elsif ($tag_opts->{name}) {
      $options{'define-var'} = $tag_opts->{name};
      shift @argv;
    }

    if ( exists $options{'handle'} && ( @argv != 1 || ! (-r $argv[0] || $argv[0]->can('getline'))) ) {
      die "Use only 1 argument with --handle option and must be a handle.\n";
    }
    elsif ( exists $options{'file'} && ( @argv != 1 || ref($argv[0])) ) {
      die "Use only 1 argument with --file option and must be filename.\n";
    }

    if ( exists $options{'create-object'} ) {
      $options{'define-object'} = $options{'create-object'};
      delete $options{'create-object'};
    }

    if ( exists $options{'define-var'} and
	 exists $options{'define-array'} ) {
      die "Use either `--define-var' or `--define-array' here.\n";
    }

    if ( exists $options{'define-var'} and
	 exists $options{'define-object'} ) {
      die "Use either `--define-var' or `--define-object' here.\n";
    }

    if ( exists $options{'define-array'} and
	 exists $options{'define-object'} ) {
      die "Use either `--define-array' or `--define-object' here.\n";
    }

    die "Use `--define-var' once only.\n"
      if exists $options{'define-var'} and ref($options{'define-var'});
    
    die "Use `--define-array' once only.\n"
      if exists $options{'define-array'} and ref($options{'define-array'});

    die "Use `--define-object' once only.\n"
      if exists $options{'define-object'} and ref($options{'define-object'});

    die "Use `--json only' only for `--define-var'.\n"
      if exists $options{'json'} and exists $options{'define-array'};

    # locally define $_
    unless (exists $options{'define-var'} ||
	    exists $options{'define-object'} || 
	    exists $options{'define-array'} ) {

      # see if current context has a default variable?
      &log_message(undef, 
		   "Warning! You are about to overwrite the default variable \$_ => (" . 
		   $context[0]->{'_'} . ")!"
		  ) 
	if exists $context[0]->{'_'};

      $options{'define-var'} = '_';
    }

    if ( exists $options{'define-var'} ) {
      # Vanilla define-var does the following
      #  1. If there is a single argument, the argument is bound to the
      #     specified name
      #  2. If there is more than one argument, an array is created out of
      #     the args
      #  3. If there are no args, a generic object is bound to the specified name
      if ( @argv > 1 ) {
	&log_message( $self, "Defining an array with (@argv)[" . scalar(@argv) . " items]" )
	  if $verbose;
	# check to see if it's possible that this is just a trick
	# of quoting that resulted in the parser creating multiple
	# arguments - q{{foo:1, bar:2}}

	if ( exists $options{'json'} ) {
	  my $json_string = join('', @argv);
	  $json_string = $json_string || $options{'default'};
	  $tx->param( $options{'define-var'} => Bedrock::JSON::decode($json_string));
	} else {
	  # arguments may be taken solely as list, first as expanded, or all as expanded...
	  if ( exists $options{'expand-args'} && UNIVERSAL::isa($argv[0], 'ARRAY') ) {
	    my $ref = shift @argv;
	    $tx->param( $options{'define-var'} => Bedrock::Array->new(@{$ref}, @argv) );    
	  }
	  elsif ( exists $options{'expand-all'} ) {
	    my @list;
	    foreach ( @argv ) {
	      (UNIVERSAL::isa($_, 'ARRAY')) ?  push @list, @{$_} : push @list, $_;
	    }
	    $tx->param( $options{'define-var'} => Bedrock::Array->new( @list ) );
	  }
	  else {
	    $tx->param( $options{'define-var'} => Bedrock::Array->new( @argv ) );
	  }
	}
      } elsif ( @argv == 1 ) {
	&log_message( $self, "Assigning $argv[0] to $options{'define-var'}" ) 
	  if $verbose;
	
	if ( defined $options{'file'} || defined $options{'handle'} ) {
	  my $fh = ref($argv[0]) ? $argv[0] : IO::File->new($argv[0], "r");
	  die "Could not open file ($argv[0]) for reading." 
	    unless -r $fh || $fh->can('getline');

	  local $/;
	  $argv[0] = <$fh>;
          close $fh;
	}

	if ( defined $options{'json'} ) {
	  my $json = Bedrock::JSON->new($argv[0] || $options{'default'});
	  &log_message($self, "in NULL " . Bedrock::Dump::compact($json->decode)) if $verbose;
	  $tx->param($options{'define-var'} => $json->decode);
	}
	elsif (defined $options{'bedrock-xml'}) {
	  my $xml;

	  if ( ref($argv[0]) && -r $argv[0] )  {
	    $xml = Bedrock::XML->new( $argv[0] );
	  }
	  else {
	    $xml = Bedrock::XML->newFromString( $argv[0] );
	  }
	  $tx->param($options{'define-var'} => $xml || $options{'default'});
  	} elsif (defined $options{'xml'} ) {
	  my $config = $tx->out_handle->{Handle}->{'CONFIG'};
	  my $options = $config->{XML}->{in}->devolve;
	  my $xml = XML::Simple->new(%{$options});
	  # see if --xml in context of a file handle output
	  $tx->param($options{'define-var'} => $xml->XMLin($argv[0] || $options{'default'}));
	} elsif (defined $options{'filter-hash'} ) {
	  &log_message($self, sprintf("filter-hash:%s", $options{'filter-hash'})) if $verbose;
	  my $filter = Bedrock::JSON::decode($options{'filter-hash'});
	  my ($key, $value);
	  ($key, $value) = @$filter if (UNIVERSAL::isa($filter, 'ARRAY'));
	  ($key, $value) = %$filter if (UNIVERSAL::isa($filter, 'HASH'));
	  &log_message($self, "filtering on key: $key value: $value") if $verbose;

	  my @filtered_array;
	  foreach (@{$argv[0]}) {
	    if (UNIVERSAL::isa($_, 'HASH')) {
	      push @filtered_array, $_  if $_->{$key} eq $value;
	    } else {
	      push @filtered_array, $_;
	    }
	  }
	  $tx->param($options{'define-var'} => Bedrock::Array->new(@filtered_array));
	} elsif (defined $options{'default'}) {
	  $tx->param( $options{'define-var'} => defined $argv[0] ? $argv[0] : $options{'default'});
	} elsif ( defined $options{'expand-args'} && UNIVERSAL::isa($argv[0], 'ARRAY') ) {
	  $tx->param( $options{'define-var'} => Bedrock::Array->new(@{$argv[0]}) );
	} else {
	  $tx->param( $options{'define-var'} => $argv[0]);
	}
      } else {
	&log_message( $self, "Creating an undefined scalar named $options{'define-var'}" ) if $verbose;
	$tx->param( $options{'define-var'} => undef );
      }
    } elsif ( exists $options{'define-array'} ) {
      # define-array explicitly specifies array creation with the arguments, if any
      &log_message( $self, "Defining an array with (@argv)[" . scalar(@argv) . " items]" )
	if $verbose;
      if ( defined $options{'expand-args'} || defined $options{'expand-args'} ) { 
	# 
	my @list;
	foreach ( @argv ) {
	  (UNIVERSAL::isa($_, 'ARRAY')) ?  push @list, @$_ : push @list, $_;
	}
	$tx->param( $options{'define-array'} => Bedrock::Array->new( @list ) );
      } else {
	$tx->param( $options{'define-array'} => Bedrock::Array->new( @argv ) );
      }
    } elsif ( exists $options{'define-object'} ) {
      # define-object creates an object and does the following
      #  0. If $options{'json'} then assume all args represent a JSON string to be converted into an object
      #  1. If the number of args is even, uses the arguments as
      #     key-value pairs to initialize the object
      #  2. If the number of args is odd and the first or last argument is
      #     an array, this array is expanded one level and combined with the
      #     rest of the arguments to use as key-value pairs
      #  3. In both cases, the key must be a scalar -- cannot be an object, array ..
      #  4. Anything else is an error

      if ($options{'json'} && @argv % 2) {

	my $json_string = join('', @argv);

	# interpret the arguments as JSON string
	my $json = Bedrock::JSON->new($json_string);

	&log_message($self, "in NULL " . Bedrock::Dump::compact($json->decode)) if $verbose;
	$tx->param($options{'define-object'} => $json->decode);	  
      } 
      else {
	# if odd number of elements, see if first or last element is a reference
	my $obj;
	if ( @argv % 2 ) {

	  &log_message( $self, "Odd number of elements in object creation list, merging in $argv[0]" ) if $verbose;
	  my $aref = $argv[0];
	  if ( @argv == 1) {
            if ( UNIVERSAL::isa( $aref, 'HASH') ) {
              my %hash = %$aref;
              $obj = Bedrock::Hash->new( %hash );
            }
            elsif ( UNIVERSAL::isa( $aref, 'ARRAY') ) {
              
              $obj = Bedrock::Hash->new( @$aref );
            }
            else {
              my $json = Bedrock::JSON->new( $aref );

              $obj = $json->decode;
            }
	    &log_message($self, "in NULL " . Bedrock::Dump::compact( $obj )) if $verbose;
	  }
	  elsif ( &UNIVERSAL::isa($aref, 'ARRAY') || &UNIVERSAL::isa($aref, 'HASH') )  {

	    shift @argv;

	    if (&UNIVERSAL::isa($aref, 'ARRAY')) {
	      &log_message( $self, "Prepending the following array to (@argv)\n(@{$aref})" ) if $verbose;
	      unshift @argv, @{$aref};
	    }
	    else {
	      &log_message( $self, "Prepending the following array to (@argv)\n(%{$aref})" ) if $verbose;
	      unshift @argv, %$aref;
	    }
	  } 
	  elsif ( defined($aref = $argv[-1]) and (&UNIVERSAL::isa($aref, 'ARRAY') || &UNIVERSAL::isa($aref, 'HASH')) ) {

	    pop @argv;

	    if (&UNIVERSAL::isa($aref, 'ARRAY')) {
	      &log_message( $self, "Appending the following array to (@argv)\n(@{$aref})" ) if $verbose;
	      push @argv, @{$aref};
	    }
	    else {
	      &log_message( $self, "Appending the following array to (@argv)\n(%{$aref})" ) if $verbose;
	      push @argv, %$aref;
	    }
	  }
	}
	
	die "Odd number of elements [" . scalar(@argv) . "] in object creation list. Use --json if this is a JSON string.\n" if @argv % 2 && ! defined $obj;

	&log_message( $self, "Key-value pairs for object creation are\n(@argv)" ) 
	  if ($verbose && ! defined $obj);
	$obj = Bedrock::Hash->new(@argv) unless defined $obj;
	
	&log_message( $self, "Creating an object named $options{'define-object'}" ) if $verbose;
	$tx->param( $options{'define-object'} => $obj);
      }
    }
  }

1;

=head1 TAG - C<E<lt>nullE<gt>>

=head1 PURPOSE

The C<null> tag is the I<do something> tag or more correctly
I<possibly do something but don't output anything>.  It allows for
invocation of object methods and/or the creation of Bedrock objects
without inserting anything at the point at which the C<E<lt>nullE<gt>>
tag is encountered.

=head1 SYNTAX

  <null[:type][:var-name] [options] [list | expression]>

I<type> should be one of:

=over 5

=item hash

Create a Bedrock hash object

=item array

Create a Bedrock array object

=back

If I<type> is not provided Bedrock will create the appropriate object
based on the argument(s).  If the argument is a list, then Bedrock
will create an array.  One element lists are created as scalars.  If the
argument is an expression, then the object type will be determined by
the the result of the expression.

=head1 DESCRIPTION

Use the C<E<lt>nullE<gt>> tag to create Bedrock objects or invoke methods on
objects when no output is desired.

=head1 OPTIONS

 --bedrock-xml
 --expand-args
 --define-var    = "var-name"
 --define-array  = "var-name"
 --define-object = "var-name"
 --create-object = "var-name" I<deprecated>
 --json
 --xml

=over 5

=item --bedrock-xml

Consider the input to be a scalar string (or an open filehandle) that
represents a valid Bedrock XML object (or valid Bedrock XML file).
This has the effect of essentially deserializing the string file into
a Bedock object.

 <plugin:FileIO ($env.BEDROCK_CONFIG_PATH + "/tagx.xml")>
 <null:tagx --bedrock-xml $FileIO.handle>
 <trace --output $tagx>


 <null:foo a b c d>
 <trace --output $foo>

 <null:xml $foo.bedrock_xml()>

 <null:foo --bedock-xml $xml>
 <trace --output $foo>

=item --expand-args

Expand array objects into lists.  If the C<--define-var> option is
used, this only applies to the first object in the list.  If the
C<--define-array> option is used, then all array references are
expaned into lists.

=item --define-var

Create a scalar, array or object (only if no content).

=item --define-array

Create a Bedrock array.

=item --define-object

Create a Bedrock hash. All Bedrock hashes are ordered, with the
exception of those created using the C<--json> option.

 <null --define-object="foo" red 1 green 2 blue 3>

=item --create-object

I<Deprecated> use C<--define-object>.

=item --json

For C<--define-var> consider the string to be a JSON string.

 <null:foo --json '{red : 1, green : 2, blue : 3}'>

 <null --define-var='foo' --json '{red : 1, green : 2, blue : 3}'>

=item --xml

For C<--define-var> consider the string to be an XML string.  Consider using
the C<< <sink> >> tag for this purpose.

 <null $config.XML('in', 'KeepRoot', 0)>
 <null:foo --xml '<colors\><red\>1</red\><green\>2</green\><blue\>2</blue\></colors\>'>

=back

=head1 NOTE

Arrays and hashes have a boat load of useful methods.  See the
documentation on the C<E<lt>hashE<gt>> and C<E<lt>arrayE<gt>> tags for
a description of the methods associated with those objects.

=head1 EXAMPLE

=over 5

=item * Create an object as the return result from some method:

  <null --define-var="x" $object.method()>

=item * Create a hash

  <null --define-object="foo" key1 value1 key2 value2>
  <null:hash:foo key1 value1 key2 value2>
  <null:foo --json '{key1 : "value1", key2 : "value2"}'>

Note that quotes around keys are not required.

=item Create an array

  <null --define-array="x" 1 2 3 4>

  <null:array:x 1 2 3 4>

I<Bedrock assumes you want to create a list from a list ;-)>

  <null:x 1 2 3 4>

  <null:x --json '[1,2,3,4]'>

=item * Invoke a method, no return value

  <null $header.see_other("/new_url")>

=back

=head1 SEE ALSO

C<E<lt>hashE<gt>>, C<E<lt>arrayE<gt>>, C<Bedrock::Array>, C<Bedrock::Hash>

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.36  2011/09/09 19:36:25  eutl420
# - added options --bedrock-xml, --file, --handle, --expand, --expand-all
#   --bedrock-xml argument can be a handle or a scalar
#   --file argument can be a handle or a filename to slurp
#   --expand <=> --expand-args
#   --expand-args is equivalent to --expand-all if you say --define-array
#   --expand-all will flatten all elements (1-level)
#
# Revision 1.35  2011/08/31 02:57:02  eutl420
# - create an undefined scalar instead of a Bedrock::Hash in the case where someone creates a Bedrock object thusly:
#   <null:foo>, previous version created a Bedrock::Hash which really makes no sense.
#
# Revision 1.34  2011/08/22 23:29:48  eutl420
# - updated the pod to reflect more correct syntactic explanation
#
# Revision 1.33  2011/08/07 16:06:49  eutl420
# use Bedrock::BedrockJSON instead of Bedrock::JSON to avoid namespace collisions with JSON when use Bedrock; is employed
#
# Revision 1.32  2011/07/17 16:50:26  eutl420
# @PERL@, log_message if verbose
#
# Revision 1.31  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.30  2011/03/28 16:25:53  eutl420
# - 1 arg form of <null --create-object > did not create Bedrock::Hash object
#   just hash ref
#
# Revision 1.29  2011/03/25 20:31:16  eutl420
# - when there is only 1 argument to NULL tag, need to accept
#   a hash or array ref in addition to JSON string
#
# Revision 1.28  2011/03/25 13:30:36  eutl420
# - set $VERSION based on CVS revision
# - <null:object:foo json-string> was not working properly, when 'create-object' && @argv = 1 added
#   json decode logic
#
# Revision 1.27  2010/12/12 17:08:03  eutl420
# - remove use of Data::Dumper
# - use parse_tag_name
# - use dump_options
#
# Revision 1.26  2010/11/29 15:57:54  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.25  2010/11/26 22:51:44  rlauer
# - pod tweak, extra spaces
#
# Revision 1.24  2010/11/19 13:35:21  rlauer
# - give a clue about using --json wehn odd number of elements
#
# Revision 1.23  2010/11/17 02:27:25  rlauer
# - pod cleanup
#
# Revision 1.22  2010/11/14 21:12:21  rlauer
# - allow odd number of elements for object creation and recognize
#   hash and array refs as valid first and last arguments in that case
#
# Revision 1.21  2010/11/13 17:27:50  rlauer
# - --expand-args tag for --define-array, --define-var
#
# Revision 1.20  2010/11/08 03:13:35  rlauer
# - bump version
# - support for --define-object, deprecate --create-object
# - update documentaion, some options missing
#
# Revision 1.19  2010/01/11 22:44:24  rlauer
# have default work like it does in <var>, i.e. default if undef
#
# Revision 1.18  2010/01/09 14:04:43  rlauer
# add default option
#
# Revision 1.17  2010/01/04 02:22:49  rlauer
# add option --xml
#
# Revision 1.16  2009/12/31 18:31:52  rlauer
# updating docs
#
# Revision 1.15  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.14  2009/12/26 15:19:54  rlauer
# remove BLM::OrderedObject since all objects are now ordered
#
# Revision 1.13  2009/12/18 21:49:07  rlauer
# filter-hash!
#
# Revision 1.12  2009/12/17 23:23:30  rlauer
# more JSON awareness
#
# Revision 1.11  2009/12/16 23:22:27  rlauer
# fix docs, tighter error checing
#
# Revision 1.10  2009/12/15 23:06:58  rlauer
# added a json option
#
# Revision 1.9  2009/12/15 13:06:41  rlauer
# simplified object creation syntax, +ordered objects
#
# Revision 1.8  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.7  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.6  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.5  2000/12/15 14:26:58  sridhar
# Proper checking for presence of any one of --define-var,
# --define-array or --create-object.
#
# Revision 1.4  2000/11/29 21:00:37  sridhar
# 1. Added option --create-object which takes the arguments and makes it
# the properties of a newly created object.
# 2. If the there are odd number of arguments, the first or last
# argument is expanded if it is an array
# 3. Throws exception if the object cannot be created due to invalid
# arguments.
#
# Revision 1.3  2000/11/16 19:10:28  sridhar
# Fixed error messages so exceptions don't have perl source code
# locations in them.
#
# Revision 1.2  2000/09/22 20:23:06  sridhar
# 1. Have a --define-array option which makes an array of the arguments,
# if any are present. Defines an empty array, if no arguments
# 2. --define-var makes an empty object if no arguments. Also makes an
# array of the arguments if more than one argument present.
#
# Revision 1.1  2000/06/06 20:00:11  sridhar
# Adding a tag which does not produce any output; only purpose of this
# tag is to invoke object methods.
#
#
