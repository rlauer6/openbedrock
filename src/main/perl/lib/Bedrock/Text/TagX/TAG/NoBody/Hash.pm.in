#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#) $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Hash;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA @INC);
    $VERSION    = 1.01;
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use TagX::TAG::NoBody 1.03;
use Symbol;
use Bedrock::Hash;
use Bedrock::JSON;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options = ('json' => undef,
		   'define-var' => undef
		  );

    my @argv = $self->parse_options (\%options, @context);
    my $verbose = $self->verbose;

    if ( $verbose ) {
      my ($key, $value);
      my $str = "$self: Options are\n";
      while (($key, $value) = each %options) {
	$str .= "\t$key .. ($value)\n";
      }
      &log_message( $self, "$str\n" );
    }
    
    my $name = $options{'define-var'} || '_';

    $argv[0] =~/^:([^:]*)$/;
    if ($1) {
      $name = $1;
      shift @argv;
    }

    my $obj;

    if ($options{'json'}) {
      my $json_string = join('', @argv);
      $obj = Bedrock::JSON::decode($json_string);
      die "Not a hash definition ($json_string)!"
	unless (UNIVERSAL::isa($obj, 'HASH')) ;
    }
    else {
      
      # see if odd number of elements
      if ( @argv % 2 ) {

	&log_message( $self, "Odd number of elements in object creation list, merging in $argv[0]" ) if $verbose;
	my $aref = $argv[0];
	
	if ( &UNIVERSAL::isa($aref, 'ARRAY') || &UNIVERSAL::isa($aref, 'HASH') )  {

	  shift @argv;

	  if (&UNIVERSAL::isa($aref, 'ARRAY')) {
	    &log_message( $self, "Prepending the following array to (@argv)\n(@{$aref})" ) if $verbose;
	      unshift @argv, @{$aref};
	  }
	  else {
	    &log_message( $self, "Prepending the following array to (@argv)\n(%{$aref})" ) if $verbose;
	    unshift @argv, %$aref;
	  }
	} 
	elsif ( defined($aref = $argv[-1]) and (&UNIVERSAL::isa($aref, 'ARRAY') || &UNIVERSAL::isa($aref, 'HASH')) ) {

	  pop @argv;

	  if (&UNIVERSAL::isa($aref, 'ARRAY')) {
	    &log_message( $self, "Appending the following array to (@argv)\n(@{$aref})" ) if $verbose;
	    push @argv, @{$aref};
	  }
	  else {
	    &log_message( $self, "Appending the following array to (@argv)\n(%{$aref})" ) if $verbose;
	    push @argv, %$aref;
	  }
	}
      }
	
      $obj = Bedrock::Hash->new(@argv);
    }

    $tx->{'VARS'}->{$name} = $obj;

    return $obj;
}


=head1 TAG - <hash>

=head1 PURPOSE

Create a Bedrock hash.

=head1 SYNTAX

 <hash[:name] [options] expression..>

=head1 DESCRIPTION

The C<hash> tag is used to create a hash object.  The expression may
be a simple list, a list of expressions or a JSON string
representation of a hash object.

Using JSON notation you can create arbitraily complex hashes.

Simple hashes are typically created using list notation.

A simple hash:

  <hash:foo  red 1 green 2 blue 3 >
  <var $foo.get(1)>

If you pass an odd number of list elements then Bedrock will see if
either the first or last element is itself a hash and consider that a
simple hash to flatten as part of your list. For example:

  <hash:foo red 1 blue 2>
  <hash:bar $foo green 3>

If your an object is deeper than a simple hash, then those values will
be added "as-is", in other words at true recursive flatten is
performed.

Show the keys and values of the hash:

  <foreach $foo.keys()>
  Key: <var $_> Value: <var $foo.get($_)><br>
  </foreach>

Dump the hash as a stringified JSON object:

  <var $foo.json()>

A complex hash:

  <hash:foo --json '{menu : ["steak", "potatoes","carrots","peas"], desert : ["pie", "cake", "cookies", "ice cream"]}'>

  <pre>
  <trace --output $foo>
  </pre>

You can also use the E<lt>nullE<gt> and E<lt>sinkE<gt> tags to create hashes.  Methods also may return hashes.

=head1 OPTIONS

 --define-var = "var-name"
 --json
 --xml

=over 5

=item --define-var

Name of the hash object being defined

=item --json

Considers the argument(s) to be JSON strings for conversion to internal hash representation

=back

=head1 METHODS

=head2 delete( key ) 

Deletes the given key from the hash.

=head2 get( key )

Returns the value of the given key from the hash.

=head2 isEmpty

Returns true if the hash is empty.

=head2 json

Returns a JSON stringified representation of the hash object.

=head2 keys

Returns a Bedrock array containing the keys (in the order in which you
defined the hash elements).

=head2 print( [file] )

Either returns the hash in a dump format to the caller or writes the
output to a file if the optional file argument is given.

=head2 set( key, value )

Sets the specified key to the specified value in the hash.

=head2 xml( options )

Output the object as an XML document.  See the documentation regarding
XML conversion in the E<lt>varE<gt> tag.

=over 5

=item options

A list of key/value pairs of options as documented in the perl module C<XML::Simple>.

=back

=head1 EXAMPLE

 <hash:foo red 1 blue 2 green 3>

 <hash --define=var="foo" red 1 blue 2 green 3>

 <hash:foo --json '{foo:1, blue:2, green:3}'>

=head1 NOTES

=over 5

=item * All hashes are ordered hashes!  WooHoo!  Who the heck wants random hashes?

=item * You can use E<lt>foreachE<gt> to iterate over hashes.

=back

=head1 SEE ALSO

C<E<lt>nullE<gt>>, C<E<lt>arrayE<gt>>

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.9  2010/11/14 21:13:32  rlauer
# - allow odd number of elements for object creation and recognize
#   hash and array refs as valid first and last arguments in that case
# - spruce up docs to describe above
#
# Revision 1.8  2010/11/08 03:14:05  rlauer
# - documentation changes only
#
# Revision 1.7  2010/01/04 02:47:46  rlauer
# add --xml to options section of docs
#
# Revision 1.6  2010/01/04 02:25:11  rlauer
# docs
#
# Revision 1.5  2009/12/31 18:31:12  rlauer
# updating docs
#
# Revision 1.4  2009/12/31 12:43:28  rlauer
# add --json and --define-var options
#
# Revision 1.3  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.2  2009/12/26 15:20:58  rlauer
# all objects now ordered, may remove this experimental tag in final release
#
# Revision 1.1  2009/12/15 13:10:04  rlauer
# first check-in
#
# $Revision $

1;
