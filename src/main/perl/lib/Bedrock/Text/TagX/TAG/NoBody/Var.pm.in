package TagX::TAG::NoBody::Var;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2024, TBC Development Group, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock::BedrockJSON;
use Bedrock::Constants qw( :booleans :chars );
use Bedrock::Constants qw( :chars );
use Bedrock::Dump;
use Bedrock::HTML::Helper qw(create_xhtml_element create_xhtml_element_header);
use Bedrock;
use Data::Dumper;
use English qw(-no_match_vars);
use List::Util qw(  any pairs  );
use MIME::Base64;
use Scalar::Util qw( reftype blessed );
use TagX::TAG::NoBody;
use Text::URLEncode;

use Role::Tiny::With;
with 'Bedrock::Logger';

use parent qw (TagX::TAG::NoBody);

use Readonly;

Readonly::Array our @VALID_TYPES => qw(
  button
  checkbox
  file
  radio
  select select-group
  submit
  text
  textarea
);

########################################################################
sub create_label {
########################################################################
  my ( $attributes, $options ) = @_;

  my $label_element;

  my $label = delete $attributes->{'label'};

  if ( !exists $options->{'no_style'} ) {
    my @style = split $SEMICOLON, $attributes->{'style'};

    push @style, 'vertical-align:middle;';
    $attributes->{'style'} = join $SEMICOLON, @style;
  }

  if ( $attributes->{'id'} && $label ) {
    return create_xhtml_element( 'label', $label, 'for', $attributes->{'id'} );
  }

  # auto labeling...
  return
    if ( exists $options->{'no-label'}
    || exists $options->{'button'}
    || exists $options->{'submit'} );

  if ( ( exists $options->{'checkbox'} ) || ( exists $options->{'radio'} ) ) {
    return create_xhtml_element( 'label', $attributes->{'value'} . '&nbsp;', 'for', $attributes->{'id'} );

  }
  else {
    return create_xhtml_element( 'label', $attributes->{'name'} . '&nbsp;', 'for', $attributes->{'id'} );
  }
}

########################################################################
sub create_widget_registry {
########################################################################
  my ($context) = @_;

  $context->{'__widgets'} //= {};

  return $context->{'__widgets'};
}

########################################################################
sub set_last_widget {
########################################################################
  my ( $widgets, $attributes, $type ) = @_;

  my $attr = {};

  map { $attr->{$_} = $attributes->{$_} } keys %{$attributes};

  $attr->{'type'} = $type;

  $widgets->{'__last_widget'} = $attr;

  $widgets->{'__last_widget_name'} = $attr->{'name'};

  return $widgets->{'__last_widget_name'};
}

########################################################################
sub get_last_widget_name {
########################################################################
  my ($widgets) = @_;

  return $widgets->{'__last_widget'}->{'name'};
}

########################################################################
sub get_last_widget_type {
########################################################################
  my ($widgets) = @_;

  return $widgets->{'__last_widget'}->{'type'};
}

########################################################################
sub get_last_widget_id {
########################################################################
  my ($widgets) = @_;

  return $widgets->{'__last_widget'}->{'id'};
}

########################################################################
sub get_next_widget_id {
########################################################################
  my ( $widgets, $type ) = @_;

  $widgets->{$type}->{'__id'} //= 0;
  $widgets->{$type}->{'__id'}++;

  $widgets->{$type}->{'__last_widget_id'}
    = $type . '_' . $widgets->{$type}->{'__id'};

  return $widgets->{$type}->{'__last_widget_id'};
}

########################################################################
sub register_widget {
########################################################################
  my ( $widgets, $type, $attributes ) = @_;

  die 'register_widget: attributes must be HASH'
    if !ref $attributes || reftype($attributes) ne 'HASH';

  $widgets->{$type} //= {};

  set_last_widget( $widgets, $attributes, $type );

  return
    if $attributes->{'id'};

  $attributes->{'id'} = get_next_widget_id( $widgets, $type );

  if ( any { $_ eq $type } @VALID_TYPES ) {
    $attributes->{'name'} //= $attributes->{'id'};
  }

  set_last_widget( $widgets, $attributes, $type );

  return $attributes->{'id'};
}

########################################################################
sub is_form_widget {
########################################################################
  my ($options) = @_;

  my ($tag_type) = map { exists $options->{$_} ? $_ : () } @VALID_TYPES;

  return $tag_type;
}

########################################################################
sub define_options {
########################################################################
  return (
    'address=s'      => undef,
    'anchor=s'       => undef,
    'base64'         => undef,
    'bedrock-xml'    => undef,
    'blockquote=s'   => undef,
    'button=s'       => undef,
    'cache=s'        => undef,
    'checkbox=s'     => undef,
    'code=s'         => undef,
    'columns=s'      => undef,
    'decode=s'       => undef,
    'default=s'      => undef,
    'delimiter=s'    => undef,
    'div=s'          => undef,
    'file=s'         => undef,
    'flush'          => undef,
    'format=s'       => undef,
    'group'          => undef,
    'handle=s'       => undef,
    'htmlencode'     => undef,
    'img=s'          => undef,
    'json'           => undef,
    'lc'             => undef,
    'markdown'       => undef,
    'name=s'         => undef,
    'no-style'       => undef,
    'no-handler'     => undef,
    'no-label'       => undef,
    'ol=s'           => undef,
    'p=s'            => undef,
    'pre=s'          => undef,
    'pretty'         => undef,
    'raw'            => undef,
    'radio=s'        => undef,
    'span=s'         => undef,
    'submit=s'       => undef,
    'select=s'       => undef,
    'select-group=s' => undef,
    'serialize'      => undef,
    'serializer=s'   => undef,
    'table=s'        => undef,
    'textarea=s'     => undef,
    'text=s'         => undef,
    'ttl=s'          => undef,
    'toggle=s'       => undef,
    'uc'             => undef,
    'ul=s'           => undef,
    'urlencode'      => undef,
    'xml'            => undef,
    'yaml'           => undef
  );

}

########################################################################
sub finalize {
########################################################################
  my ( $self, $tx, @context ) = @_;

  my %options = $self->define_options;

  my @argv = $self->parse_options( \%options, @context );

  my $logger = $self->get_logger;

  $logger->debug( Dumper( [ \@argv, \%options ] ) );

  $self->dump_options( \%options, @argv );

  # flush all previous frames...
  if ( $options{flush} ) {
    $tx->out_handle->discard_frame;
  }

  if ( exists $options{serialize} ) {
    $options{'bedrock-xml'} = 1;
  }

  my $delimiter = $options{delimiter} || $EMPTY;

  # create a widget registry
  my $widgets = create_widget_registry( $context[0] );

  my $value;
  my $tag_type;

  if ( @argv == 0 ) {
    #    WARN "No variable specified.";

    $self->get_logger( ref $self )->debug(
      sub {
        return sprintf 'Value not defined, default is [%s]', $options{default} // 'undefined';
      }
    );

    if ( exists $options{'default'} ) {
      $value = $options{'default'};
    }

  }
  else {
    $value = shift @argv;

    if ( exists $options{'default'} ) {
      $value //= $options{'default'};
    }
  }

  #  DEBUG sub {
  #    "Value: <$value>";
  #  };

  if ( exists $options{handle} && exists $options{raw} ) {
    if ( $options{handle}->can('print') ) {
      $options{handle}->print( $value, @argv );
    }
    return;
  }

  # encode argument before other options
  if ( defined $options{'base64'} ) {
    if ( !ref $value ) {
      $value = encode_base64($value);
    }
    elsif ( ref($value) && reftype($value) eq 'ARRAY' ) {
      my $dummy = [];

      foreach ( @{$value} ) {
        push @{$dummy}, encode_base64($_);
      }

      $value = $dummy;
    }
    elsif ( ref $value && reftype($value) eq 'HASH' ) {
      my $dummy = {};

      foreach ( keys %{$value} ) {
        $dummy->{$_} = encoded_base64( $value->{$_} );
      }
      $value = $dummy;
    }
  }

  if ( defined $options{'bedrock-xml'} ) {
    my $handler = $self->io_handler( $tx, 'BedrockXML' );
    $value = $handler->serialize( $value, {@argv} );
  }
  elsif ( defined $options{json} ) {
    my $handler = $self->io_handler( $tx, 'JSON' );

    $value
      = $handler->serialize( $value, { @argv, exists $options{pretty} ? ( pretty => $options{pretty} ) : () } );
  }

  if ( defined $options{xml} ) {
    my $handler = $self->io_handler( $tx, 'XML' );
    $value = $handler->serialize( $value, {@argv} );
  }
  elsif ( defined $options{markdown} ) {
    eval {
      require Text::Markdown::Discount;
      Text::Markdown::Discount->import('markdown');
    };

    die "Text::Markdown::Discount is not available\n"
      if $EVAL_ERROR;

    $value = markdown($value);
  }
  elsif ( defined $options{yaml} ) {
    my $handler = $self->io_handler( $tx, 'YAML' );
    $value = $handler->serialize( $value, {@argv} );
  }
  elsif ( defined $options{serializer} ) {
    my $handler
      = $self->io_handler( $tx, $options{serializer}, { out => {@argv} } );
    $value = $handler->serialize( $value, {@argv} );
  }
  elsif ( defined $options{format} ) {
    $value = sprintf $options{format}, $value;
  }
  elsif ( defined $options{decode} ) {
    #    DEBUG sub {
    #      "decode using " . $options{'decode'};
    #    };

    my $obj = Bedrock::JSON::decode( $options{'decode'} );

    if ( exists $obj->{$value} ) {
      $value = $obj->{$value};
    }
    elsif ( exists $obj->{default} ) {
      $value = $obj->{default};
    }
    else {
      $value = undef;
    }
  }
  elsif ( defined $options{'toggle'} ) {
    my ( $aa, $bb ) = split /\s*,\s*/xsm, $options{'toggle'};
    $value = ( $value eq $aa ) ? $bb : $aa;
  }
  elsif ( exists $options{'anchor'} ) {
    my $attributes = get_json_attributes( 'anchor', \%options );
    register_widget( $widgets, 'anchor', $attributes );

    if ( !$attributes->{'href'} && @argv ) {
      $attributes->{'href'} = shift @argv;
    }

    $value = create_xhtml_element( 'a', $value, %{$attributes} );
  }
  elsif ( exists $options{'img'} ) {
    my $attributes = get_json_attributes( 'img', \%options );
    register_widget( $widgets, 'img', $attributes );

    if ( !$attributes->{'src'} ) {
      $attributes->{'src'} = $value;
    }

    $value = create_xhtml_element( 'img', undef, %{$attributes} );
  }
  elsif ( ($tag_type) = map { exists $options{$_} ? $_ : () } qw(address blockquote code div  p pre span textarea) ) {
    my $attributes = get_json_attributes( $tag_type, \%options );
    register_widget( $widgets, $tag_type, $attributes );
    $value = create_xhtml_element( $tag_type, $value, %{$attributes} );
  }
  elsif ( ($tag_type) = map { exists $options{$_} ? $_ : () } qw(radio checkbox) ) {
    my $attributes = get_json_attributes( $tag_type, \%options );

    #   TRACE sub {
    #     Bedrock::Dump::compact( [ $value, scalar(@argv), $attributes ] );
    #   };

    if ( ( exists $options{'group'} ) && !$attributes->{'name'} ) {
      #      WARN '--group only valid for same type of form elements'
      #        if $tag_type ne get_last_widget_type($widgets);

      if ( $tag_type eq get_last_widget_type($widgets) ) {
        $attributes->{'name'} = get_last_widget_name($widgets);
      }

      #      DEBUG sub {
      #        'group name set to: ' . $attributes->{'name'};
      #      };
    }

    # <var --radio/checkbox value default-value name label>
    if (@argv) {
      if ( exists $attributes->{'value'} ) {

        # ignore already captured $value
        $value = shift @argv;
      }
      else {
        $attributes->{'value'} = $value;
        $value = shift @argv;
      }

      if ( $attributes->{'name'} ) {
        shift @argv;
      }
      else {
        $attributes->{'name'} = shift @argv;
      }

      if ( !$attributes->{'label'} ) {
        $attributes->{'label'} = shift @argv;
      }
    }
    elsif ( defined $value ) {
      $attributes->{'value'} = $value;
      $value = undef;
    }

    if ( exists $options{'group'} && !$attributes->{'name'} ) {
      $logger->warn(
        sub {
          sprintf '%s will have a the group name : %s ', $tag_type, get_last_widget_id($widgets);
        }
      );
    }

    register_widget( $widgets, $tag_type, $attributes );

    if ( ref($value) && reftype($value) eq 'HASH' ) {
      $value = $value->{ $attributes->{'name'} };
    }

    die "usage: <var --$tag_type value default-value name label> or <var --$tag_type=JSON-STRING \$input.name>\n"
      if !defined $attributes->{'name'} || !exists $attributes->{'value'};

    if ( ref($value) && reftype($value) eq 'HASH' ) {
      $value = $value->{ $attributes->{'name'} };
    }

    if ( ref($value) && reftype($value) eq 'ARRAY' ) {

      if ( any { $_ eq $attributes->{value} } @{$value} ) {
        $attributes->{checked} = 'checked';
      }
    }
    else {
      if ( $value eq $attributes->{value} ) {
        $attributes->{checked} = 'checked';
      }
    }

    $attributes->{type} = $tag_type;

    #    DEBUG sub {
    #      Bedrock::Dump::compact($value)
    #        . Bedrock::Dump::compact( $attributes->{value} )
    #        . Bedrock::Dump::compact($attributes);
    #    };

    $value = create_xhtml_element( 'input', undef, %{$attributes} );
    $value .= create_label( $attributes, \%options );
  }

  # { 1: "that", 2: "this"}
  # [ { 1: "this"}, {2: "that"}]
  # [
  #   { text: "this", attributes: {value : 1}},
  #   { text: "that", attributes: {value : 2}}
  # ]
  elsif ( exists $options{'select'} ) {
    my $attributes = get_json_attributes( 'select', \%options );

    my $cur_selected = shift @argv;

    if (@argv) {
      if ( !exists $attributes->{'name'} ) {
        $attributes->{'name'} = shift @argv;
      }

      if ( !exists $attributes->{'label'} ) {
        $attributes->{'label'} = shift @argv;
      }
    }

    #    DEBUG sub {
    #      "attributes: " . Bedrock::Dump::compact($attributes);
    #    };

    register_widget( $widgets, 'select', $attributes );

    if ( !ref $value ) {  # <var --select '["this",1,"that",2]'

      eval { $value = Bedrock::JSON::decode($value); };

      die sprintf "possibly an invalid JSON string: %s - %s\n", $value, $EVAL_ERROR
        if $EVAL_ERROR;

      die "scalar argument to --select must be JSON string that evaluates to an array\n"
        if !ref $value || reftype($value) ne 'ARRAY';
    }

    if ( ref $cur_selected && reftype($cur_selected) eq 'HASH' ) {
      $cur_selected = $cur_selected->{ $attributes->{'name'} };
    }

    my @options;

    if ( ref($value) && reftype($value) eq 'ARRAY' ) {
      my @rows = @{$value};

      foreach my $p ( pairs @rows ) {
        my ( $text, $key ) = @{$p};

        my $item = {};

        if ( ref($key) && reftype($key) eq 'HASH' ) {
          if ( exists $key->{'value'} && !ref $text ) {
            $item = {
              attributes => $key,
              text       => $text
            };
          }
          else {
            die "HASH argument for --select is not well formed.  Must be {attributes}, text...\n";
          }
        }
        else {
          $item = {
            attributes => { value => $key },
            text       => $text
          };
        }

        # set selected if provided
        if ( defined $cur_selected ) {
          if ( !ref $cur_selected || reftype($cur_selected) ne 'ARRAY' ) {

            if ( $cur_selected eq $item->{'attributes'}->{'value'} ) {
              $item->{'attributes'}->{'selected'} = 'selected';
            }
          }
          else {  # multiple select box
            if ( any { $_ eq $item->{'attributes'}->{'value'} } @{$cur_selected} ) {
              $item->{'attributes'}->{'selected'} = 'selected';
            }

          }
        }

        push @options, $item;
      }
    }
    else {
      die "usage: <var --select=attributes value default-value name label\n";
    }

    #    DEBUG sub {
    #      Bedrock::Dump::compact(@options);
    #    };

    $value = create_label( $attributes, \%options );
    $value
      .= create_xhtml_element( 'select',
      join( $EMPTY, map { create_xhtml_element( 'option', $_->{text}, %{ $_->{attributes} } ) } @options ),
      %{$attributes} );
  }

  # [ { label: "foo",  group : [ { attributes : {value : 1}, text: "this"}, { attributes: { value: 2, selected: "selected"}, text: "that"}] }
  #   { label: "foo2", group : [ { attributes : {value : 3}, text: "foo this"}, { attributes: { value: 4}, text: "foo that"}] }
  # ]
  elsif ( exists $options{'select-group'} ) {
    my $attributes = get_json_attributes( 'select-group', \%options );

    my $cur_selected = shift @argv;

    if (@argv) {
      if ( !exists $attributes->{'name'} ) {
        $attributes->{'name'} = shift @argv;
      }

      if ( !exists $attributes->{'label'} ) {
        $attributes->{'label'} = shift @argv;
      }
    }

    #    DEBUG sub {
    #      "attributes: " . Bedrock::Dump::compact($attributes);
    #    };

    register_widget( $widgets, 'select-group', $attributes );

    # <var --select-group '{ menu1 : ["this",1,"that",2], menu2 : [ "foo", 3, "bar", 4] }'
    if ( !ref $value ) {

      eval { $value = Bedrock::JSON::decode($value); };

      die sprintf "possibly an invalid JSON string: %s - %s\n", $value, $EVAL_ERROR
        if $EVAL_ERROR;

      die "scalar argument to --select-group must be JSON string that evaluates to a hash\n"
        if !ref $value || reftype($value) ne 'HASH';
    }

    # { "foo"  : [ {value : 1}, "this",     {value: 2}, "that"]
    #   "foo2" : [ {value : 3}, "foo this", {value: 4}, "foo that"]
    # }
    #
    my @opt_group;

    if ( ref($cur_selected) && reftype($cur_selected) eq 'HASH' ) {
      $cur_selected = $cur_selected->{ $attributes->{'name'} };
    }

    if ( ref $value && reftype($value) eq 'HASH' ) {
      my @labels = keys %{$value};
      my @menus  = values %{$value};

      foreach my $group (@menus) {
        my @options;

        my @rows = @{$group};

        my $this_group = { label => shift @labels };

        foreach my $p ( pairs @rows ) {
          my ( $text, $key ) = @{$p};
          my $item = {};

          if ( ref $key && reftype($key) eq 'HASH' ) {
            if ( exists $key->{'value'} && !ref $text ) {
              $item = {
                attributes => $key,
                text       => $text,
              };
            }
            else {
              die "HASH argument for --select is not well formed.  Must be {attributes}, text...\n";
            }
          }
          else {
            $item = {
              attributes => { value => $key },
              text       => $text,
            };
          }

          # set selected if provided
          if ( defined $cur_selected ) {
            if ( !ref $cur_selected || reftype($cur_selected) ne 'ARRAY' ) {
              if ( $cur_selected eq $item->{'attributes'}->{'value'} ) {
                $item->{'attributes'}->{'selected'} = 'selected';
              }
            }
            else {  # multiple select box
              if ( any { $_ eq $item->{'attributes'}->{'value'} } @{$cur_selected} ) {
                $item->{'attributes'}->{'selected'} = 'selected';
              }
            }
          }
          push @options, $item;
        }

        $this_group->{'group'} = \@options;
        push @opt_group, $this_group;
      }
    }
    else {
      die "usage: <var --select=attributes value default-value name label\n";
    }

    #    DEBUG sub {
    #      Bedrock::Dump::compact(@opt_group);
    #    };

    $value = create_label( $attributes, \%options );
    $value = $value . create_xhtml_element(
      'select',
      eval {
        my $text;
        foreach my $group (@opt_group) {
          $text .= create_xhtml_element(
            'optgroup',
            join( $EMPTY, map { create_xhtml_element( 'option', $_->{text}, %{ $_->{attributes} } ) } @{ $group->{group} } ),
            ( label => $group->{label} )
          );
        }
        $text;
      },
      %{$attributes}
    );

  }
  elsif ( ($tag_type) = map { exists $options{$_} ? $_ : () } qw(button submit text file) ) {

    my $attributes = get_json_attributes( $tag_type, \%options );

    if (@argv) {
      $attributes->{'value'} = $value;

      if ( exists $attributes->{'name'} ) {
        shift @argv;
      }
      else {
        $attributes->{'name'} = shift @argv;
      }

      if ( !$attributes->{'label'} ) {
        $attributes->{'label'} = shift @argv;
      }
    }
    elsif ( ref($value) && reftype($value) eq 'ARRAY' ) {
      die "usage: <var --$tag_type\[=json-attributes] value name label>\n";
    }

    if ( $tag_type ne 'text' && !$attributes->{'value'} ) {
      $attributes->{'value'} = {
        submit => 'Submit',
        button => 'Button',
        text   => ''
      }->{$tag_type};
    }

    if ( $tag_type eq 'button'
      && ( !exists $options{'no-handler'} )
      && ( !( exists $attributes->{'onClick'} || exists $attributes->{'onclick'} ) ) ) {
      $attributes->{'onClick'} = 'javascript: this.form.submit();';
    }

    $attributes->{'type'} = $tag_type;

    register_widget( $widgets, $tag_type, $attributes );

    if ( ref $attributes->{'value'}
      && reftype( $attributes->{'value'} ) eq 'HASH' ) {
      $attributes->{'value'}
        = $attributes->{'value'}->{ $attributes->{'name'} };
    }

    $value = create_label( $attributes, \%options );
    $value .= create_xhtml_element( 'input', undef, %{$attributes} );
  }
  elsif ( ($tag_type) = map { exists $options{$_} ? $_ : () } qw(ol ul) ) {
    my $attributes = get_json_attributes( $tag_type, \%options );

    register_widget( $widgets, $tag_type, $attributes );

    # allow <var --ul aa bb cc>
    $value
      = ( ref($value) && reftype($value) eq 'ARRAY' )
      ? $value
      : [ $value, @argv ];
    $value
      = create_xhtml_element( $tag_type, join( $EMPTY, map { create_xhtml_element( 'li', $_ ) } @{$value} ), %{$attributes} );
  }
  # <var --columns= --table array>
  elsif ( ( exists $options{'table'} )
    && ( ref($value) && reftype($value) eq 'ARRAY' ) ) {

    #    DEBUG sub {
    #      "table: " . Bedrock::Dump::compact($value);
    #    };

    my $column_attributes = {};
    my $header_attributes = {};
    my @column_headers;

    # allow a JSON string, an array, or a comma or pipe delimited string
    if ( defined $options{'columns'} ) {
      if ( $options{'columns'} =~ /^\s*[\[]/xsm ) {
        eval { @column_headers = @{ Bedrock::JSON::decode( $options{'columns'} ) }; };

        die "possible invalid JSON string: $EVAL_ERROR\n"
          if $EVAL_ERROR;
      }
      elsif ( ref( $options{'columns'} )
        && reftype( $options{'columns'} ) eq 'ARRAY' ) {
        @column_headers = @{ $options{'columns'} };
      }
      elsif ( !ref $options{'columns'} ) {
        @column_headers = split /[,|]+/xsm, $options{'columns'};
      }

      die "invalid argument for --columns\n"
        if !@column_headers;

      # --columns='["foo", "bar", "baz"]'
      # --columns='[["foo", "bar", "baz"], {valign:"top", align:"right"}]'

      if ( !is_simple_object( \@column_headers ) ) {
        $column_attributes = $column_headers[1];
        $header_attributes = $column_headers[2];
        @column_headers    = @{ $column_headers[0] };
      }
    }
    else {
      @column_headers
        = ( ref( $value->[0] ) && reftype( $value->[0] ) eq 'HASH' )
        ? keys %{ $value->[0] }
        : ();
    }

    #    DEBUG sub {
    #      "ref(0):"
    #        . ref( $value->[0] )
    #        . "Column headers are..."
    #        . join( "|", @column_headers );
    #    };

    my $table_attributes = get_json_attributes( 'table', \%options );
    register_widget( $widgets, 'table', $table_attributes );

    #    DEBUG sub {
    #      Bedrock::Dump::compact( $value, $table_attributes );
    #    };

    $value = create_xhtml_element(
      'table',
      eval {
        if (@column_headers) {
          create_xhtml_element(
            'tr',
            eval {
              my $row;
              foreach (@column_headers) {
                $row .= create_xhtml_element( 'th', $_, %{$header_attributes} );
              }
              $row;
            }
          );
        }
        else {
          undef;
        }
      }
        . eval {
        my $text;

        foreach my $row ( @{$value} ) {

          $text .= create_xhtml_element(
            'tr',
            eval {
              my $text;

              # this obfuscation warrants an explanation... ;-)
              # the object that contains the data for for the body of the table can be:
              # ...an array ref or
              # ...a hash ref
              # if an array ref
              # ...then the order is dictated by the array's natural order
              # if the object is a hashref && it is an ordered hash, all's well (or not ymmv),
              # ...but if not you may have specified a column order (--columns=)
              # ...in which case we'll slice the hash that way to get the values for the columns.
              my @cell_values
                = ref($row) =~ /array/xsmi ? @{$row}
                : (
                ( @column_headers > 0 ) ? @{$row}{@column_headers}
                : values %{$row}
                );
              foreach (@cell_values) {
                $text .= create_xhtml_element( 'td', $_, %{$column_attributes} );
              }
              $text;
            }
          );
        }
        $text;
        },
      %{$table_attributes}
    );

    if ($EVAL_ERROR) {
      $logger->error($EVAL_ERROR);
    }

  }
  elsif ( ref $value && reftype($value) eq 'ARRAY' ) {
    $value = join $delimiter, grep { defined $_ || $EMPTY } @{$value};
  }
  elsif ( ref $value && reftype($value) eq 'HASH' ) {
    $value = join $delimiter, grep { defined $_ || $EMPTY } %{$value};
  }
  elsif ( ref $value && ref($value) eq 'Tie::Scalar' ) {
    $value = ${$value};
  }

  if ( $options{'htmlencode'} ) {
    $value =~ s/\x26/&amp;/xsmg;
    $value =~ s/\x3c/&lt;/xsmg;
    $value =~ s/\x3e/&gt;/xsmg;
    $value =~ s/\x22/&quot;/xsmg;
  }
  elsif ( exists $options{'urlencode'} and $options{'urlencode'} > 0 ) {
    Text::URLEncode::encode($value);
  }

  if ( $options{lc} ) {
    $value = lc $value;
  }

  if ( $options{uc} ) {
    $value = uc $value;
  }

  if ( exists $options{handle} ) {
    if ( $options{handle}->can('print') ) {
      $options{handle}->print( $value, @argv );
    }
  }
  else {
    $tx->out_handle->print($value);
  }

  if ( $options{cache} ) {
    $tx->write_cache( $options{cache}, $value, $options{ttl} );
  }

  return;
}

########################################################################
sub get_json_attributes {
########################################################################
  my ( $key, $options ) = @_;

  my $attributes = {};

  return $attributes
    if !exists $options->{$key} || !defined $options->{$key};

  my $options_val = $options->{$key};

  if ( !ref $options_val && $options_val =~ /^\s*[{\[]/xsm ) {
    eval { $attributes = Bedrock::JSON::decode($options_val); };

    die sprintf "possibly an invalid JSON string: %s\n%s", $options_val, $EVAL_ERROR
      if $EVAL_ERROR;
  }
  elsif ( ref($options_val) && reftype($options_val) eq 'HASH' ) {
    $attributes = $options_val;
  }

  return $attributes;
}

########################################################################
sub is_simple_object {
########################################################################
  my ($obj) = @_;

  if ( ref $obj && reftype($obj) =~ /array/ixsm ) {

    foreach ( @{$obj} ) {
      return 0
        if ref $_;
    }

    return 1;
  }
  elsif ( ref $obj =~ /object|hash/ixsm ) {
    foreach ( keys %{$obj} ) {
      return 0
        if ref $obj->{$_};
    }
    return 1;
  }

  return 1;
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 TAG - C<E<lt>varE<gt>>

=head1 PURPOSE

Output the value of a Bedrock expression.

=head1 SYNTAX

<var [options] [object | result of method call | expression]>

=head1 DESCRIPTION

The C<E<lt>varE<gt>> tag is the I<output this> tag and the principal
way that output from Bedrock objects is included in your Bedrock
pages.  It indicates to Bedrock that the value of the object or
expression is to be included in the page at the point at which the tag
is encountered.

=head1 OPTIONS INDEX

L</--address>

L</--anchor>

L</--base64>

L</--bedrock-xml>

L</--blockquote>

L</--button>

L</--cache>

L</---checkbox>

L</--code>

L</--columns>

L</--decode>

L</--default>

L</--delimiter>

L</--div>

L</--file>

L</--flush>

L</--format>

L</--group>

L</--handle>

L</--htmlencode>

L</--img>

L</--json>

L</--markdown>

L</--name>

L</--no-style>

L</--no-handler>

L</--no-label>

L</--ol>

L</--p>

L</--pre>

L</--pretty>

L</--raw>

L</--radio>

L</--span>

L</--submit>

L</--select>

L</--select-group>

L</--serialize>

L</--serializer>

L</--table>

L</--textarea>

L</--text>

L</--ttl>

L</--toggle>

L</--ul>

L</--urlencode>

L</--xml>

L</--yaml>

=over 5

=item  --base64

Encodes the variable as base64 before output.

 <var --base64 $foo>

=item  --bedrock-xml

Output the Bedrock XML representation of the object.

=item --cache=s

Output the value to an in-memory cache using the key as specified in
the argument to the option.  Currently this option is only supported
when a Redis server is configured for caching.  You can set a ttl for
the key using the --ttl option.

See L<Bedrock::RedisCache> for details.

 <var --cache="foo" --ttl=60 bar>

The output of the tag will be written to the cache and the current
page. If you want simply store a value to the cache use the
E<lt>inkE<gt> tag with the --cache option.

=item --default=s

Output the value of the C<--default> option if the value of variable
is undefined.

 <var --default="none" $foo>

=item --delimiter=s

SetE<039>s the delimiter used when joining elements of an array or hash
before they are output.

default: ''

 <null:foo Fred Wilma Barney Betty>
 <var --delimiter=', ' $foo>

 <null:hash:foo Fred Wilma Barney Betty>
 <var --delimiter=', ' $foo>

=item --flush

Flushes all output that was produced prior to this tag. This is useful
for discarding whitespace before outputting the finalized page or data.

 <var --flush --json --pretty $result>

=item --format=s

Use the value of the scalar as input to the sprintf function using the
value of the C<--format> option as the format string.

 <var --format="%5.2f" $foo>

=item  --htmlencode

HTML encode the string before output.

=item  --json

Output the object or array as a JSON string.  You can I<pretty print> JSON by usnig the =--pretty= option.

=item --lc

Lower case the output.

=item --markdown

Considers the variable markdown and converts it to HTML using L<Text::Markdown::Discount>.

=item --pretty

Pretty pring JSON objects.

=item --uc

Upper case the output.

=item  --urlencode

URL encode the string before output.

=item --xml

Output the object or array as an XML object. Default XML support is provided
by the Perl module C<XML::Simple>.

The default options sent to XMLout can be configured in F<tagx.xml> as
an object named XML and represents the options that you would send to
the perl module C<XML::Simple> to control the behaviour of XML conversions.

A sensible default configuration is shown below:

  <object name="XML">
    <object name="out">
      <scalar name="NoAttr">1</scalar>
      <scalar name="KeepRoot">0</scalar>
      <scalar name="RootName">response</scalar>
      <scalar name="NoSort">1</scalar>
      <array name="KeyAttr"></array>
        <scalar name="XMLDecl">1</scalar>
        <scalar name="NoEscape">1</scalar>
      </array>
    </object>

    <object name="in">
      <scalar name="NoAttr">0</scalar>
      <scalar name="KeepRoot">1</scalar>
      <array name="KeyAttr"></array>
    </object>
  </object>

While this provides something passable as an XML document it may not
be exactly what you were looking for.  As shown above the options
passed to C<XMLout> for the conversion from your object to an XML
string should be contained in the F<tagx.xml> file as an object named
C<XML>.

What you see in the configuration above is workable, but you may
want to change either the defaults or the behaviour on a case by case
basis. You can do the latter by dynamically altering the configuration
using the C<XML> method of the C<$config> object.

 <null $config.XML('out', 'XMLDecl', 0)>

The first argument to the C<XML> method is either the string 'in' or
'out' which indicates which set of options you are about to set.
Subsequent arguments should be key, value pairs that represent the
options and values that will control either the conversion to or from
XML.

Converting an array to an XML document will generally require a root
element.  Bedrock will use the C<RootName> option of the
C<XML-E<gt>out> object as the root element when converting Bedrock
arrays to XML.

I<If your goal is to build a Bedrock component or service that outputs
an XML document that may be utilized by another web application or an
AJAX component for example, you may also want to set the content type
of the document being served.  This can be done using the C<$header>
object.>

  <null $header.content_type('application/xml')><var --xml $xml>

If you want to dynamically pass options for outputting your XML, you
can pass key/value pairs as additional arguments to the
C<E<lt>varE<gt>> tag.


  <var --xml $foo KeepRoot 1 NoAttr 1>

See perldoc C<XML::Simple> for more details regarding options that you
can use to control XML parsing.

=item --yaml

In a similar vein as the C<--xml> option, the C<--yaml> option can be
used to serialize your Bedrock objects in YAML format.

 <var --yaml $foo>

You can pass additional options for parsing YAML as arguments to the
C<E<lt>varE<gt>> tag.

=back

=head1 NOTES

The argument to the tag is a Bedrock object or expression which should
evaluate to a scalar or list.  The argument may be a Bedrock object
name (C<$name>), the result of a method call (C<$foo.bar()>), or an
expression.  BedrockE<039>s expression parsing requires that you use
parentheses.  Parentheses can be nested. Some examples of expressions:

 ($foo + "-" + $bar)

 ($foo --eq "foo")

 (5 + 6)

 ($foo.bar + " is a foobar")

The use cases for this tag include:

Output the value of scalar:

 <var $some_variable>

Output the value of a method call of an object:

 <var $input.get("foo")>

Dump an array or hash (equivalent to C<array.join(' ')> )
 
 <var $input.keys()>

 <var $input>

In Bedrock 1 (during the Stone Age) using the C<E<lt>varE<gt>> tag on
arrays or objects was undefined.  In Bedrock 2 the values are output
as a space delimited list.

 <var $array> <=> <var $array.join(' ')>

 <var $hash> <=> <foreach $hash><var $_.key> <var $_.value></foreach>

Translate the value of an expression:

 <var --json $foo>
 <var --htmlencode $foo>
 <var --urlencode $foo>
 <var --decode='{1:"red", 2:"green", 3:"blue"}' $foo>
 <var --toggle="1,0" $foo>
 <var --format="%5.2f" $foo>

=head1 EXAMPLE

=over 5

=item * Output the value of a variable or a default

 <var --default="Please enter a value" $input.fname>

=item * Format a value on output

 <var --format="%5.2f" $input.cost>

=item * Output an array as a JSON string

 <null:foo 1 2 3 4 5>

 <var --json $foo> => ["1", "2", "3","4", "5"]

=back

=head1 EXPERIMENTAL OPTIONS

=head2 Translation Options

 --decode
 --toggle

=over 5

=item  --decode

Provides the same functionality found in the Oracle DECODE function,
namely it will translate a scalar value base on a list of key/value
pairs you provide.

The argument to the C<--decode> option is currently defined to be a
JSON string that represents a hash.  For example:

 <null:foo 3>
 <var $foo --decode='{1:"red", 2:"green", 3:"blue", 4:"yellow", default:"unknown"}'>

=item  --toggle

Outputs a value based on two alternatives, alternating between the two.

 <var $foo --toggle="a,b">

If C<$foo> = 'a', then Bedrock will output 'b', else if C<$foo> is 'b'
Bedrock will output 'a'

=back

=head2 HTML Widgets

B<The following options are experimental.>

These B<experimental options> represent a set of HTML widget
constructors.  A "widget" is defined by Bedrock to be a small snippet
of HTML that provides a standardized way to express an HTML pattern.

It is produced by providing the C<E<lt>varE<gt>> tag with certain
options and arguments depending upon the widget being
produced. Widgets for most of the commonly used HTML constructions,
including form elements are available.

Some of these widgets are self explanatory and obvious, some may seem
esoteric and may have limited usage for those who prefer clean and
crisp, self documented HTML pages.  If you like "frameworks" and want
to standardize your web development, you might find these widgets very
usef. There are situations where the best approach is to DIY. As
always YMMV.

In general, the idea is to create an intuitive interface for
constructing HTML elements.  The widget option (C<--checkbox>, for
example) will commonly accept an argument that represents the various
attributes possible for that HTML tag.  For example consider the
C<E<lt>ulE<gt>> tag:

 <ul style="color:red;margin-top:5px;" id="fruits">
  <li>Apples</li>
  <li>Pears</li>
 </ul>

Here we have two elements being set; C<style> and C<id>.  The Bedrock
widget equivalent would be:

 <var --ul='{style:"color:red;margin-top:5px", id:"fruits"}' Apple Pears>

Note that the argument to the widget option C<--ul> is a JSON string
where the hash contains key/value pairs of the C<ul> attributes you
want to set.  Of course, TIMTOWTDI:

 <hash:ul style color:red;margin-top:5px id fruits>
 <array:fruits Apples Pears>

 <var --ul=$ul $fruits>

As you can see the option argument for C<ul>, like most widget
options, can be a JSON string or a Bedrock object.

If you do not provide an C<id> attribute then Bedrock will
automatically create a unique C<id> for each widget it creates.

You can inspect the last widget id created using the variable
C<$__widgets.__last_widget_id>.

 <var --ul Apples Pears>

 The id for the the <code>ul</code> was <var $__widgets.__last_widget_id>

Frameworks can be a good thing, but the perl way (and BedrockE<039>s) is
that I<There Is More Than One To Do IT> (TIMTOWTDI).

=head3 Form Widgets

=head4 --button

=head4 --checkbox

=head4 --file

=head4 --select

=head4 --select-group

=head4 --submit

=head4 --text

=head4 --textarea

=head4 --radio

Form widgets that create form elements have a very specific interface
which creates a flexible but intuituive way to construct HTML forms.
Whereas the argument to non-form HTML widgets is typically a data
object that is used in the construction of the widget (e.g. an array
or scalar), the form widgets have a functional argument syntax.
The generalized interface is as follows:

For C<checkbox>, C<radio>, C<select>, C<select-group> form elements the generalized form is:

 <var --widget[=attributes] value default-value name label >

For the C<text>, C<textarea>, C<file> form element the generalized form is:

 <var --widget[=attributes] default-value name label >

For the C<submit> and C<button> elements, the generalized form is:

 <var --widget[=attributes] default-value name >

The arguments are described below.

=over 5

=item attributes

This is an optional JSON string that should interpret to a hash
element. The argument can also be a Bedrock hash object.  The argument
is used to provide additional attributes to the form element being
constructed.  Additionally, you can provide the C<name>, C<value> or
C<label> right hand arguments in this hash.

Using a JSON string:

The attributes argument letE<039>s you pass a JSON string that
represents a HASH of attributes to apply to the HTML element.

 <var --text='{label:"Last Name ",size:20,maxlength:40}' $input.text>

...would be equivalent to:

 <label for="text_1">Last Name </label>
 <input type="text" name="text_1" size="40" maxlength="60" \
        value="<var $input.text_1>">

=item value

The value of the form element when submitted.  For C<select> and
C<select-group> widgets the C<value> argument is a more robust data
structure that describes the select object (itE<039>s option values and
text).  See L<select> and L<select-group> below.

=item default-value

Typically this is the value the C<$input> object has for that form
element.  You can pass the entire C<$input> object and Bedrock will
fish for the value in the hash.

=item name

The name of the HTML form element.

=item label

The text value that should be used to label the form element.  Bedrock
will automatically add a label element to each form element.  You can
prevent Bedrock from doing this by including the C<--no-label> option.

 <var --radio "Apple" $input.fruit fruit>

Would result in an HTML construction:

 <input type="radio" value="Apple" name="fruit" id="radio_1"/>
 <label for="radio_1">Apple</label>

If you do not provide a label value, Bedrock will use as the label
value the widgetE<039>s C<value> argument for I<checkbox> and I<radios> or
the form elementE<039>s C<name> argument for all other form input objects.

=back

The Bedrock widget constructor will provide an C<id> and C<name>
element if you do not provide these.  You can inspect the value of
these elements by looking at:

 $__widgets.__last_widget_id
 $__widgets.__last_widget_name


The Bedrock widget constructor will provide intelligent defaults for
missing parameters and create labels for your form elements.

Create a set of radio buttons:

 <var --radio='{name:"fruit",value:"Apple"}' '' $input.fruit>
 <var --radio='{name:"fruit",value:"Pear"}'  '' $input.fruit>

For checkboxes and radio buttons if you do not provide a label, the
label will be taken from the C<value> the radio or checkbox element.

 <var --radio Apple $input.fruit fruit >
 <var --radio Pear $input.fruit fruit >

You can create checkbox or radio "groups" by using the --group option.

 <var --radio Apples $input.fruit fruit >
 <foreach Pears Bananas Oranges>
  <var ---group --radio $_ $input.fruit></foreach>

The elementE<039>s C<name> for grouped objects will be taken from the most
recent widget created if one is not provided.  If the widget element being created is
different than the last widget created and the C<--group> option is
used, then a new name will be created.  Thus, this can be a valid construction:

 <foreach Apples Pears Bananas Oranges>
  <var ---group --radio $_ $input.fruit></foreach>

...as long as the last widget constructed was not a radio.

=head4 Form Widget Listing

=over 5

=item --button

Creates a button with a default handler for submitting the form.  The
argument to the button is the value of the button text.

 <var --button[=attributes] value name>

Example:

 <var --button "Click-Me">

The default handler simply submits the form.

 onClick='javascript: this.form.submit();'

You can turn off the association of a handler with the button by
either providing your own C<onClick> handler or providing the
C<--no-handler> option.

 <var --no-handler --button "I'm a Do Nothing Button">

=item --checkbox

=item --radio

Creates a checkbox or radio element.

 <var --checkbox[=attributes] value default-value name label>

Examples:

 <var --checkbox='{name:"foo", value:1}' $input.foo>

 <var --checkbox foo 1 $input.foo>

 <var --checkbox=$attributes $input.foo>

=item --file

Create an upload file form element.

 <var --file[=attributes] default-value name label>

=item --select

Create a simple select element.

 <var --select[=attributes] value default-value name label>

C<value> is either a JSON string that evaluates to an array or a Bedrock array.

The array can be a simple array that defines pairs of values that
represent the option text and the option value or a more complex array
where the second item in the tuple is a hash that is interpreted to be
the attributes (including the value of the option) to be applied to
the option tag.

 <var --select '["this", 1, "that", 2]' $input.foo foo>

 <var --select '["this", {value:1, style:"color:green;"},"that", 2]' $input>

=item --select-group

Creates a 'grouped' select box where items are grouped under headings.

 <var --select-group[=attributes] value default-value name label>

C<value> is a JSON string that evaluates to a hash or a Bedrock hash.

The hash keys are the labels used for each menu group, the values are
arrays as required by the C<--select> widget.
 
 <var --select-group 
  '{ Fruits : [ "Apple", 1, "Pear"], Veggie : [ "Peas", 3, "Carrots", 4 ]}' $input.food food>

The HTML element is constructed using the C<E<lt>optgroupE<gt>> tags.  When rendered groups are
indented under a label similar to the menus below.

 Fruits
   Apple
   Pear
 Veggies
   Peas
   Carrots

=item --submit

Creates a submit button.

 <var --submit[=attributes] value name>

=item --textarea

Creates a textarea form element.

 <var --textarea[=attributes] default-value name label>

=item --text

=item --radio

See 'checkbox'.

=back

=head3 HTML Block Widgets

Most of these are probably not terribly useful.  You may find the
C<ol>, C<ul>, and the C<table> widgets somewhat useful.

=head4 HTML Widget Listing

=over 5

=item --address

=item --anchor

Create a link object.

 <var --anchor[=attributes] value link>

Example:

 <var --anchor Google http://www.google.com>

=item --blockquote

=item --code

=item --div

=item --pre

=item --p

=item --span

Create a block object.

 <var --div[=attributes] value>

=item --ol

See L<ul>

=item --img

Create an image tag.

 <var --img[=attributes] image-path>

=item --table

 <var --table[=attributes] value>

Use C<--table> to quickly dump an array of arrays that represent the
rows and columns of a table.  

The object you want to convert to a table can also be an array of
hashes.  This might be the return value for example of a query that
returns an array of hashes representing a result set.  If no
C<--columns> option is present the widget constructor will use the
hash keys a column names.

 <hash:foo red 1 blue 2 green 3>
 <array:foo_array $foo $foo $foo>
 <var --table $foo_array>
  
 <sink:flintstones --json>
 [
  ["fred", "flintstone","fflintstone@openbedrock.net"],
  ["barney" "rubble", "brubble@openbedrock.net"]
 ]
 </sink>
  
 <var --table $flintstones>

Add table headers using the C<--columns option>

 <var --columns='["First Name", "Last Name", "E-Mail"]' --table $foo_array>
 <var --table $foo_array>

The C<--columns> option can be any of:

=over 5

=item an array object

 <array:headers this that "the other">
 <var --table --columns=$headers $foo>

=item an JSON string representing an array

 <var --table --columns='["this", "that", "the other"]' $foo>

=item a comma, space or pipe delimited string

 <var --table --columns="this,that,the&nbsp;other" $foo>

=back

Attributes for the cells of the table (C<td>) and each header element
(C<th>) can be addded by adding a second and third element to the JSON
object when specifiying a JSON string as argument for the C<--columns>
option.

 <var --table 
      --columns='[["this","that","the other"], 
                  {valign:"top",class:"foo"},
                  {align:"left";}]' $foo>

=item --ul

Creates an HTML C<ul> element from an array.

 <var --ul[=attributes] value>

Examples:

 <array:pepboyz manny moe jack>
 <var --ul $pepboyz>

You can specify attributes such as styles by setting the C<--ul>
option to a hash or JSON string.

 <var --ul='{ style: color:"red" }' $pepbozy>

=back

=head1 METHODS

Typically, the C<E<lt>varE<gt>> tag is used with a I<Bedrock Scalar> or
an expression that evaluates to a I<Bedrock Scalar>.  Bedrock promotes
all expressions that evaluate to a scalar to a I<Bedrock Scalar> object,
thus it seems logical to describe scalar B<methods> here in the
C<E<lt>varE<gt>> tag documentation.

ThereE<039>s a faily long list of methods you can invoke on scalars.
As you might expect since Bedrock is written in perl, a lot of these
are simply covers on the corresponding perl built-in functions with a
twist or two to make the API easy for Bedrock devlopers and/or
appropriate for the Bedrock environment.  Some of these methods may
have the same names as options to the the C<E<lt>varE<gt>> tag but may
operate in slighly different manners since output of text or HTML is
not I<always> the purpose of these methods.

The methods operate on the value of the scalar but aside from two
methods C<toggle>, C<replace>, the methods B><do not alter the
scalarE<039>s value>, they return the value that the method returns.

Unless otherwise noted below, the argument to the method is the
scalar's value.

=head2 align(direction, width)

Align a string within a string of a given width.

B<direction> is C<left>, C<center> or C<right>.

 <var $foo.align('center', 80)>

=head2 align_center(width)

Convenience routine for C<align>.

=head2 align_left(width)

Convenience routine for C<align>.

=head2 align_right(width)

Convenience routine for C<align>.

=head2 base64

Returns the base64 encoding of the scalar's value.  Equivalent to C<--base64>.

=head2 chr

Return the character representation of the integer.

=head2 chomp

Removes trailing new line characters.  This method does not alter the
scalar.  It returns a chompE<039>d version of the scalar.

=head2 crypt(salt)

Creates a digest string. C<man crypt(3)>

=head2 decode(key, value, ... , default)

Decode the scalar by using the list of key / value pairs.  If there is
an odd number of values, the last value is considered the default
value to use in the event the scalar does not equal any of the give
keys.

 <var $answer.decode(0, "No", 1, "Yes", "Maybe")>

=head2 eq(value) I<deprecated>

Returns 1 if the scalar is equal to this value.

 <if $foo.eq(4.3)> 

=head2 format(format string)

Formats the scalar according to the C<printf> like format string.

 <var $screen.format("/index.roc?screen=%s")>

=head2 format_time([format string])

Considers the scalar a time value returned by the C<time> function and
formats the time according to the optional format string (see perl
C<strftime>).  If no format string is give, the method returns the
time as a C<ctime> value.

 <var $time.format_time()>

=head2 ge(value) I<deprecated>

Returns 1 if scalar is greater than or equal to the given value.

=head2 gt(value) I<deprecated>

Returns 1 if scalar is greater than the given value.

=head2 hex

Returns the hex value of a number.

=head2 hmac_sha1(key)

=head2 hmac_sha224(key)

=head2 hmac_sha256(key)

=head2 hmac_sha384(key)

=head2 hmac_sha512(key)

Returns HMAC-SHA-1/224/256/384/512 digest of the scalar value + a passed key as a binary string.

=head2 htmlencode

Returns the HTML encoded version of the scalar.  Useful for display HTML entities.

=head2 isEmpty

Returns undef if scalar is  undef.

Returns 0 if string of length 0.

Returns 1 if string of length > 0.

=head2 json 

Considers the scalar to be a JSON string and returns the appropriate
Bedrock object.

 <null:bar '{red : 1, blue : 2}'>

 <null:foo $bar.json()>

The above example creates a Bedrock hash.

=head2 lc               

Lower case the string.

=head2 lcfirst  

Lower case the first letter of the string.

=head2 le(value) I<deprecated>

Returns 1 if the scalar is less than or equal to the given value.

=head2 length

Return the length of the string.

=head2 lt(value) I<deprecated>

Returns 1 if the scalar is less than to the given value.

=head2 ltrim

Trims the white space from the beginning of a string.

=head2 matches( pattern, [flags] )

Returns an array of matched strings based on a pattern.

If the pattern begins with 'qr', then the pattern is assumed to be
a quoted regular expression.

C<flags> can be any of:

=over

=item i

Ignore case.

=item m

Treat string as multiple lines.

=item s

Treat string as single line.

=item g

Global matching.  See examples below.

=back

The function will return an array of matches, only if you
use grouping to indicate you want to return the matched strings.  If
you do not use grouping, then the array either returned will be empty
if no match is found or will contain 1 element composed of a true
value indicate the regular expression matched.

Examples:

 ---- scalar, no grouping
 <null:bar "Robert">
 <null:results $bar.matches("qr/[rb][^ ]/i")>
 <trace --compact --output $results>
  
 ---- scalar, grouping
 <null:results $bar.matches("([rb][^ ])", "i")>
 <trace --compact --output $results>
  
 ---- scalar, grouping, global
 <null:results $bar.matches("([rb][^ ])", "ig")>
 <trace --compact --output $results>

...would result in 

 ---- scalar, no grouping
 .[0] = (1)
 
 ---- scalar, grouping
 .[0] = (Ro)
    
 ---- scalar, grouping, global
 .[0] = (Ro)
 .[1] = (be)
 .[2] = (rt)

I<Note: that if you want to use a quoted regexp and the B<g> flag, you
should pass the flag as the second argument.>

 <null:foo "barfoo thisfoo foobar foofoobar">
 <null:result $foo.matches("qr/(.*?)foo\\s+/", "g")>

=head2 oct

Returns the octal value of a number.

=head2 or(value)

Returns the value if the scalar is false.

 <var $foo.or("alternative")>

=head2 replace(pattern, string, flags)

Poor mans reg-ex substitution for a scalar.

 <var $foo.replace("foo", "bar", "i")>

=head2 reverse

Reverse the characters in a string.

=head2 rtrim

Trims the whitespace from the back of a string.

=head2 sign(value)

Returns 0 if scalar and value are equal

Returns 1 if scalar is greater than value

Returns -1 if scalar is less than value

=head2 split(value)

Returns an array split on value.

=head2 sprintf([args])

Considers the string to be a C<sprintf> format string and the optional
arguments to be additional arguments to pass to C<sprintf>.

=head2 substr( offset, length )

Returns a portion of a string.  A negative offset indicates a
substring from the far end of string.

 <var $foo.substr(0, 3)>
 <var $foo.substr(-1, 3)

=head2 toggle(a, b)

Returns value b if scalar eq a, a if scalar eq b and sets scalar to
returned value.

=head2 tr(search-list, replacement-list)

Transliterates all occurrences in the scalar of the characters found
in the search list with the corresponding character in the replacement
list. See C<perldoc perlop> for more information regarding the perl
C<tr> operator.

 <null:foo $foo.tr('_-', '+/')>

=head2 trim

Trim the whitespace from the front and back of a string.

=head2 uc               

Upper case a string

=head2 ucfirst  

Upper case first letter of string.

=head2 urlencode

Consider the scalar value to be a URL and encode appropriately.

=head1 SEE ALSO

C<E<lt>hashE<gt>>, C<E<lt>arrayE<gt>>, C<E<lt>nullE<gt>>, C<E<lt>sinkE<gt>>, 

=cut

