#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Var;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = 1.13;
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use Text::URLEncode 1.01;
use TagX::TAG::NoBody 1.03;
use Bedrock::HTML::Helper qw(create_xhtml_element create_xhtml_element_header);
use Bedrock::JSON;
use Data::Dumper;
use XML::Simple;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options = ('name=s'	=> undef,
		   'urlencode'	=> undef,
		   'htmlencode'	=> undef,
		   'format=s'	=> undef,
		   'decode=s'	=> undef,
		   'toggle=s'	=> undef,
		   'default=s'	=> undef,
		   'table=s'    => undef,
                   'ul=s'       => undef,
		   'div=s'      => undef,
		   'radio=s'    => undef,
		   'checkbox=s' => undef,
                   'span=s'     => undef,
                   'select=s'   => undef,
                   'select-group=s' => undef,
		   'columns=s'  => undef,
                   'textarea=s' => undef,
                   'json'       => undef,
		   'xml'        => undef
		  );

    my $verbose = $self->verbose;
    &log_message($self, Dumper(\%options, @context, $self, $tx))
      if $verbose;
    my @argv = $self->parse_options (\%options, @context);

    if ( $verbose ) {
	my ($key, $value);
	my $str = "Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	$str .= "Arguments ..(@argv)";
	&log_message( $self, $str );
    }

    my $value;
    if ( exists $options{'name'} ) {
	$value = $options{'name'};
    } elsif ( @argv == 0 ) {
      # Oh Brother! Good thing Jay isn't around to see this hack...
      # a) bedrock's parser is junk, ask Jay, he'll tell you.
      # b) unfortunately, you cannot have an option that SOMETIMES takes an argument
      # c) this is a guess as to what probably happened...so we try to make it right
      # d) so we take the arguments value if it makes sense and set the option value to undef,
      #    the option is still in effect, but it has not JSON attributes
      if (defined $options{'table'} && (ref($options{'table'}) =~/array/i) ) {
	$value = $options{'table'};
	$options{'table'} = undef;
      }
      elsif (defined $options{'div'} && ! ref($options{'div'}) ) {
	  $value = $options{'div'};
	  $options{'div'} = undef;
	}
      elsif (defined $options{'span'} && ! ref($options{'span'}) ) {
	  $value = $options{'span'};
	  $options{'span'} = undef;
	}
      elsif (defined $options{'ul'} && ref($options{'ul'}) ) {
	  $value = $options{'ul'};
	  $options{'ul'} = undef;
	}
      elsif ( defined $options{'radio'} ) {
  	  die "usage: <var --radio=json-string expression>";
	}
      elsif (defined $options{'checkbox'} && ref($options{'radio'}) ) {
  	  die "usage: <var --checkbox=json-string expression|array>";
	}
      elsif (defined $options{'select'} && ref($options{'select'}) ) {
	  $value = $options{'select'};
	  $options{'select'} = undef;
	}
      elsif (defined $options{'select-group'} && ref($options{'select-group'}) ) {
	  $value = $options{'select-group'};
	  $options{'select-group'} = undef;
	}
      else {
	&log_message( $self, "No variable specified" );
	return;
      }
    } else {
	$value = shift @argv;
    }

    &log_message( $self, "Value = <$value>" ) if $verbose;

    unless ( defined ( $value ) ) {
	&log_message ( $self, "Value not defined, default is <$options{'default'}>" )
	    if $verbose;
	$value = $options{'default'} if exists $options{'default'};
    }

    return unless defined( $value );

    if (defined($options{'xml'})) {
      my $config = $tx->out_handle->{Handle}->{'CONFIG'};
      my $options = $config->{XML}->{out}->devolve;
      &log_message($self, Dumper(%{$options})) 
	if $verbose;

      if (UNIVERSAL::isa($value, 'ARRAY')) {
	$value = { $config->{RootName} => $value};
      }

      $value = XMLout($value, %{$options});
    }


    if ( exists $options{'urlencode'} and $options{'urlencode'} > 0 ) {
	&Text::URLEncode::encode( $value );
	&log_message ( $self, "URLEncoded to <$value>" ) if $verbose;
    }

    if ( defined($options{'format'}) ) {
	$value = sprintf $options{'format'}, $value;
    }

    if ( defined($options{'decode'}) ) {
      &log_message($self, "decode using ".$options{'decode'}) if $verbose;
      my $obj = Bedrock::JSON::decode($options{'decode'});
      if (exists $obj->{$value}) {
	$value = $obj->{$value};
      }
      elsif (exists $obj->{default}) {
	$value = $obj->{default};
      }
      else {
	$value = undef;
      }
    }

    if ( defined($options{'toggle'}) ) {
        my ($a,$b) = split /\s*,\s*/, $options{'toggle'};
	$value = ($value eq $a) ? $b : $a;
    }

    if (exists $options{'div'} ) {
      my $attributes = get_json_attributes('div', \%options);
      $value = create_xhtml_element('div', $value, %{$attributes});
    }


    if (exists $options{'radio'} ) {
      my $attributes = get_json_attributes('radio', \%options);

      die q/radio widgets must have 'name' and 'value' keys defined. --radio='{name :"foo", value : 1}'/
	unless (exists $attributes->{name} && exists $attributes->{value});

      $attributes->{checked} = 'checked' if $value eq $attributes->{value};
      $attributes->{type} = 'radio';

# vertically align radio buttons
#    <label for="fruits-1">Banana &nbsp;<var --radio='{name : "fruits", value : "banana", id : "fruits_1", style : "vertical-align:middle;"}' $foo></label>

      $value = create_xhtml_element('input', undef, %{$attributes});
    }

    if (exists $options{'checkbox'} ) {

      my $attributes = get_json_attributes('checkbox', \%options);
      if ( ref($value) =~/array/i ) {
	my $this = $attributes->{value};

	$attributes->{checked} = 'checked' 
	  if grep(/$this/, @{$value});
      }
      else {
	$attributes->{checked} = 'checked' if $value eq $attributes->{value};
      }

      $attributes->{type} = 'checkbox';
#
## vertically align radio buttons
##    <label for="fruits-1">Banana &nbsp;<var --radio='{name : "fruits", value : "banana", id : "fruits_1", style : "vertical-align:middle;"}' $foo></label>

      $value = create_xhtml_element('input', undef, %{$attributes});
    }

    if (defined($options{'span'} ) ) {
      my $attributes = get_json_attributes('span', \%options);
      $value = create_xhtml_element('span', $value, %{$attributes});
    }

    if (defined($options{'textarea'} ) ) {
      my $attributes = get_json_attributes('textarea', \%options);
      $value = create_xhtml_element('textarea', $value, %{$attributes});
    }

    # { 1: "that", 2: "this"}
    # [ { 1: "this"}, {2: "that"}]
    # [ 
    #   { text: "this", attributes: {value : 1}}, 
    #   { text: "that", attributes: {value : 2}}
    # ]
  
    if (exists $options{'select'} ) {
      my $attributes = get_json_attributes('select', \%options);
      my @options;
      if (ref($value) =~/(object|hash)/i) {
        @options = map { { attributes => {value => $_}, text => $value->{$_} }; } keys %$value;
      }
      elsif (ref($value) =~/array/i) {
	foreach (@$value) {
	  if (exists $_->{text} && exists $_->{attributes}) {
	    push @options, $_;
	  }
	  else {
	    my $key = (keys %$_)[0]; # take first key we find
	    push @options, {attributes  => {value => $key}, text => $_->{$key} };
	  }
	}
      }
      else {
	die "Use array or hash to describe select options.";
      }

      $value = create_xhtml_element('select', join('', map { create_xhtml_element('option', $_->{text}, %{$_->{attributes}}) } @options), %$attributes);
    }

    # [ { label: "foo",  group : [ { attributes : {value : 1}, text: "this"}, { attributes: { value: 2, selected: "selected"}, text: "that"}] }
    #   { label: "foo2", group : [ { attributes : {value : 3}, text: "foo this"}, { attributes: { value: 4}, text: "foo that"}] }
    # ]
    if (exists $options{'select-group'} ) {
      my $attributes = get_json_attributes('select', \%options);
      if (ref($value) =~/array/i) {
	$value = create_xhtml_element('select', 
				      eval {
					my $text;
					foreach my $group (@$value) {
					  $text .= create_xhtml_element('optgroup', 
									join('',map { create_xhtml_element('option', $_->{text}, %{$_->{attributes}}) } @{$group->{group}}),
									(label => $group->{label})
								       );
					}
					$text;
				      },
				      %$attributes
				     );
      }
      else {
	die "--select-group requires an array of hashes.";
      }
    }


    if (exists $options{'ul'} ) {
      die "--ul can only be used on arrays."
	unless ref($value) =~/array/i;
      my $attributes = get_json_attributes('ul', \%options);
      $value = create_xhtml_element('ul',join('', map { create_xhtml_element('li', $_) } @$value),  %{$attributes});
    }

    if (defined($options{'json'} ) ) {
      if (ref($value)) {
	$value = Bedrock::JSON::encode($value);
      }
      else {
	die "Can't use --json on a scalar object."
      }
    }
    
    if ( (exists $options{'table'}) && ref($value) =~/array/i ) {

      my $column_attributes = {};
      my @column_headers;
      if (defined $options{columns} && $options{columns} =~/^\s*[\[]/) {
	@column_headers = @{Bedrock::JSON::decode($options{columns})};
	if (! is_simple_object(\@column_headers)) {
	  $column_attributes = $column_headers[1];
	  @column_headers = @{$column_headers[0]};
	}
      }
      else {
	@column_headers = (ref($value->[0]) =~/(hash|object)/i) ? keys %{$value->[0]} : ();
      }

      &log_message($self, sprintf("ref(0):%s Column headers are...%s" , ref($value->[0]),  join("|", @column_headers)) ) if $verbose;

      my $table_attributes = get_json_attributes('table', \%options);
      &log_message($self, Dumper($value, $table_attributes)) if $verbose;

      $value = create_xhtml_element('table', 
				    eval {
				      if (@column_headers) {
					create_xhtml_element('tr', 
							     eval {
							       my $row;
							       foreach (@column_headers) {
								 $row .= create_xhtml_element('th', $_);
							       }
							       $row;
							     }
							    );
				      }
				      else {
					undef;
				      }
				    } . 
				    eval {
				      my $text;
				      foreach my $row (@$value) {

					$text .= create_xhtml_element('tr',
								      eval {
									my $text;
									# this obfuscation warrants an explanation... ;-)
									# the object that contains the data for for the body of the table can be:
									# ...an array ref or 
									# ...a hash ref 
									# if an array ref 
									# ...then the order is dictated by the array's natural order
									# if the object is a hashref && it is an ordered hash, all's well (or not ymmv),
									# ...but if not you may have specified a column order (--columns=)
									# ...in which case we'll slice the hash that way to get the values for the columns.
									my @cell_values = ref($row) =~/array/i ? @$row : ((@column_headers > 0) ? @{$row}{@column_headers} : values %$row);
									foreach (@cell_values) {
									  $text .= create_xhtml_element('td', $_, %{$column_attributes});
									}
									$text;
								      }
								     );
				      }
				      $text;
				    },
				    %{$table_attributes}
				   );
      
      &log_message($self, "error: ". $@) if $@;
    }

    if (UNIVERSAL::isa($value, 'ARRAY')) {
      $value = join('', @$value);
    }
    elsif (UNIVERSAL::isa($value, 'Tie::Scalar')) {
      $value = $$value;
    }

    if ( $options{'htmlencode'} ) {
      $value =~ s/\x26/&amp;/g;
      $value =~ s/\x3c/&lt;/g;
      $value =~ s/\x3e/&gt;/g;
      &log_message ( $self, "HTMLEncoded to <$value>" ) if $verbose;
    }
        
    $tx->out_handle->print($value);
}

sub get_json_attributes {
  my $key = shift;
  my $options = shift;

  my $attributes = {};

  if ($options->{$key} =~/^\s*[\{]/ ) {
    $attributes = Bedrock::JSON::decode($options->{$key});
  }
  # if it's not a JSON string, then consider it an HTML element ID
  # <var --ul='foo' $some_array>
  elsif ($options->{$key}) {
    $attributes = {id => $options->{$key}};
  }

  $attributes;
}

sub is_simple_object {
  my $obj = shift;

  if (ref($obj) && ref($obj) =~/array/i) {
    foreach (@$obj) {
      return 0 if ref($_);
    }
    return 1;
  }
  elsif (ref($obj) =~/(object|hash)/i) {
    foreach (keys %$obj) {
      return 0 if ref($obj->{$_});
    }
    return 1;
  }

  return 1;
}

=pod

=head1 TAG - C<E<lt>varE<gt>>

=head1 PURPOSE

Output the value of a Bedrock expression.

=head1 SYNTAX

  <var [options] expression>

=head1 DESCRIPTION

The C<E<lt>varE<gt>> tag is the I<output this> tag and the principal
way that output from Bedrock objects is included in your Bedrock
pages.  It indicates to Bedrock that the value of the expression is to
be included in the page at the point at which the tag is encountered.

=head1 OPTIONS

 --urlencode
 --htmlencode
 --format
 --default
 --json
 --xml

=over 5

=item  --urlencode

URL encode the string before output.

=item  --htmlencode

HTML encode the string before output.

=item --format=s

Use the value of the scalar as input to the sprintf function using the
value of the C<--format> option as the format string.

  <var --format="%5.2f" $foo>

=item --default=s

Output the value of the C<--default> option if the value of variable is null.

 <var --default="none" $foo>

=item  --json

Output the object or array as a JSON string.

=item --xml

Output the object or array as an XML object. XML support is provided
by the perl module C<XML::Simple>.

The default options sent to XMLout can be configured in F<tagx.xml> as
an object named XML and represents the options that you would send to
the perl module C<XML::Simple> to control the behaviour of XML conversions.

A sensible default configuration is shown below:

 <object name="XML">
   <object name="out">
     <scalar name="NoAttr">1</scalar>
     <scalar name="KeepRoot">0</scalar>
     <scalar name="RootName">response</scalar>
     <scalar name="NoSort">1</scalar>
     <array name="KeyAttr"></array>
     <scalar name="XMLDecl">1</scalar>
     <scalar name="NoEscape">1</scalar>
   </object>
   <object name="in">
     <scalar name="NoAttr">0</scalar>
     <scalar name="KeepRoot">1</scalar>
     <array name="KeyAttr"></array>
   </object>

While this provides something passable as an XML document it may not
be exactly what you were looking for.  As shown above the options
passed to C<XMLout> for the conversion from your object to an XML
string should be contained in the F<tagx.xml> file as an object named
C<XML>.

What you see in the configuration above is workable, but you may
want to change either the defaults or the behaviour on a case by case
basis. You can do the latter by dynamically altering the configuration
using the C<XML> method of the C<$config> object.

 <null $config.XML('out', 'XMLDecl', 0)>

The first argument to the C<XML> method is either the string 'in' or
'out' which indicates which set of options you are about to set.
Subsequent arguments should be key, value pairs that represent the
options and values that will control either the conversion to or from
XML.

Converting an array to an XML document will generally require a root
element.  Bedrock will use the C<RootName> option of the
C<XML-E<gt>out> object as the root element when converting Bedrock
arrays to XML.

I<If your goal is to build a Bedrock component or service that outputs
an XML document that may be utilized by another web application or an
AJAX component for example, you may also want to set the content type
of the document being served.  This can be done using the C<$header>
object.>

  <null $header.content_type('application/xml')><var --xml $xml>

see perldoc C<XML::Simple> for more details regarding options that you
can use to control XML parsing.

=back


=head1 NOTES

The object of the tag is an Bedrock expression which may consist of
things like scalars, method calls, or concatenated strings using the
'+' operator.  Bedrock's parsing is rather primitive, so use
parentheses liberally and in fact B<must be used when using the '+'
operator>.  Some examples of expressions include things like:

  $foo

  $some_object.foo()

  ($foo + "-" + $bar)

The use cases for this tag include:

Output the value of scalar:

 <var $some_variable>

Output the value of a method call of an object:

 <var $input.get("foo")>

Dump an array (equivalent to C<array.join('')> )

 <var $input.keys()>

Translate the value of an expression:

 <var --json $foo>
 <var --htmlencode $foo>
 <var --urlencode $foo>
 <var --decode='{1:"red", 2:"green", 3:"blue"}' $foo>
 <var --toggle="1,0" $foo>
 <var --format="%5.2f" $foo>

In Bedrock I (during the Stone Age) using the C<E<lt>varE<gt>> tag on
arrays or objects was undefined.  In Bedrock II at least, array
references are dumped...in other words something similar to:

  <var $array.join('')>

...is done to provide something a tad more satisfying than C<Bedrock::Array>.

We're still debating what to do with objects. A JSON representation
might be appropriate as the default I<stringified> representation of an
object.  The jury is still out.  Send your comments to bedrock-dev@cj-mailman.choicepoint.net

=head1 EXAMPLE

=over 5

=item * Output the value of a variable or a default

  <var --default="Please enter a value" $input.fname>

=item * Format a value on output

  <var --format="%5.2f" $input.cost>

=item * Output an array as a JSON string

 <null:foo 1 2 3 4 5>

 <var --json $foo> => ["1", "2", "3","4", "5"]

=back

=head1 EXPERIMENTAL OPTIONS

 --decode
 --toggle
 --table
 --ul
 --div
 --span
 --select
 --select-group
 --column
 --textarea
 --radio
 --checkbox

There are some experimental options that may be implemented or
partially implented.  In fact they may or may not be useful.  YMMV.

=over 5

=item  decode

Provides the same functionality found in the Oracle DECODE function,
namely it will translate a scalar value base on a list of key/value
pairs you provide.

The argument to the C<--decode> option is currently defined to be a
JSON string that represents a hash.  For example:

 <null:foo 3>
 <var $foo --decode='{1:"red", 2:"green", 3:"blue", 4:"yellow", default:"unknown"}'>

=item  toggle

Outputs a value based on two alternatives, alternating between the two.

  <var $foo --toggle="a,b">

If C<$foo> = 'a', then Bedrock will output 'b', else if C<$foo> is 'b'
Bedrock will output 'a'

=back

=over 5

B<The following options are HIGHLY experimental...and thus not yet documented!>

The gist of these experimental options is to help in the construction
of HTML pages.  Some of these are self explanatory, some are highly
esoteric.

=item table

=item ul

Try this on an array.

=item div

Try this on a scalar.

=item span

Try this on a scalar.

=item select

=item select-group

=item column

Used with the C<--table> option, expects an array object.

=item textarea

=item checkbox

=item radio

=back

=head1 SCALAR METHODS

When used with the C<E<lt>varE<gt>> tag a Bedrock expression usually
evaluates to a scalar.  Bedrock promotes all expressions that evaluate
to a scalar to a Bedrock Scalar object, thus it seems logical to
describe scalar methods here in the C<E<lt>varE<gt>> tag documentation.

There's a long list of methods you can invoke on scalars.  As you
might expect since Bedrock is written in perl, a lot of these are
simply covers on the corresponding perl built-in functions with a
twist or two for the Bedrock environment.  Some of these methods may
have the same names as options to the the C<E<lt>varE<gt>> tag but may
operate in different manners since output of text or HTML is not
I<always> the purpose of these methods.

The main argument to most of the scalar methods is the value of the
scalar itself.

=head2 align(direction, width)

Align a string within string of a given width.

B<direction> is C<left>, C<center> or C<right>.

  <var $foo.align('center', 80)>

=head2 align_center(width)

Convenience routine for C<align>.

=head2 align_left(width)

Convenience routine for C<align>.

=head2 align_right(width)

Convenience routine for C<align>.

=head2 chr

Same as perl C<chr>.

=head2 crypt(salt)

Same as perl C<crypt>

=head2 decode(key, value, ... , default)

Decode the scalar by using the list of key / value pairs.  If there is
an odd number of values, the last value is considered the default
value to use in the event the scalar does not equal any of the give
keys.

  <var $answer.decode(0, "No", 1, "Yes", "Maybe")>

=head2 eq(value)

Returns 1 if the scalar is equal to this value.

  <if $foo.eq(4.3)> 

=head2 format(format string)

Formats the scalar according to the C<printf> like format string.

  <var $screen.format("/index.roc?screen=%s")>

=head2 format_time([format string])

Considers the scalar a time value returned by the C<time> function and
formats the time according to the optional format string (see perl
C<strftime>).  If no format string is give, the method returns the
time as a C<ctime> value.

  <var $time.format_time()>

=head2 ge(value)

Returns 1 if scalar is greater than or equal to the given value.

=head2 gt(value)

Returns 1 if scalar is greater than the given value.

=head2 htmlencode

Returns the HTML encoded version of the scalar.  Useful for display HTML entities.

=head2 isEmpty

Returns undef if scalar is  undef.

Returns 0 if string of length 0.

Returns 1 if string of length > 0.

=head2 json 

Considers the scalar a JSON string and returns the appropriate Bedrock object.

  <null:bar '{red : 1, blue : 2}'>

  <null:foo $bar.json()>

The above example creates a Bedrock hash.

=head2 lc		

Same as perl C<lc>

=head2 lcfirst	

Same as perl C<lcfirst>

=head2 le(value)

Returns 1 if the scalar is less than or equal to the given value.

=head2 length

Same as perl C<length>

=head2 lt(value)   

Returns 1 if the scalar is less than to the given value.

=head2 ltrim

Trims the white space from the beginning of a string.

=head2 or(value)

Returns 1 if the logical or of the scalar and given value are 1.

=head2 replace(pattern, string, flags)

Poor mans reg-ex substitution for a scalar.

 <var $foo.replace("foo", "bar", "i")>

=head2 reverse

Same as perl C<reverse>

=head2 rtrim

Trims the whitespace from the back of a string.

=head2 sign(value)

Returns 0 if scalar and value are equal

Returns 1 if scalar is greater than value

Returns -1 if scalar is less than value

=head2 split(value)

Returns an array split on value.

=head2 sprintf([args])

Considers the string to be a C<sprintf> format string and the optional
arguments to be additional arguments to pass to C<sprintf>.

=head2 substr

Same as perl C<substr>

=head2 toggle(a, b)

Returns value b if scalar eq a, a if scalar eq b and sets scalar to
returned value.

=head2 trim

Trim the whitespace from the front and back of a string.

=head2 uc		

Same as perl C<uc>

=head2 ucfirst	

Same as perl C<ucfirst>

=head2 urlencode

Consider the scalar value to be URL and encode appropriately.

=head1 SEE ALSO

C<E<lt>hashE<gt>>, C<E<lt>arrayE<gt>>, C<E<lt>nullE<gt>>, C<E<lt>sinkE<gt>>, 

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.31  2010/11/17 02:27:37  rlauer
# - pod cleanup
#
# Revision 1.30  2010/11/16 00:16:28  rlauer
# - document scalar methods
# - process --htmlencode after flattening arrays, and other operations
#
# Revision 1.29  2010/11/08 07:31:36  rlauer
# - --checkbox, --radio option
#
# Revision 1.28  2010/01/03 19:20:16  rlauer
# add --xml option
#
# Revision 1.26  2009/12/31 18:38:40  rlauer
# updated docs
#
# Revision 1.25  2009/12/31 12:43:36  rlauer
# more robust documentation
#
# Revision 1.24  2009/12/30 12:42:13  rlauer
# dump array references rather than "Bedroc::Array" as output
#
# Revision 1.23  2009/12/30 00:15:11  rlauer
# log messages on verbose only
#
# Revision 1.22  2009/12/29 12:23:26  rlauer
# check to see if object is a tied scalar and access value via reference on output
#
# Revision 1.21  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.20  2009/12/28 19:28:26  rlauer
# renamed BLM::IndexedTableHandler::Common to Bedrock::HTML::Helper
#
# Revision 1.19  2009/12/26 15:18:53  rlauer
# remove BLM::OrderedObject since all objects are now ordered
#
# Revision 1.18  2009/12/17 13:14:57  rlauer
# added span tag
#
# Revision 1.17  2009/12/16 23:25:09  rlauer
# wip - html widgets
#
# Revision 1.16  2009/12/15 23:09:59  rlauer
# wip - html options to var like --div/table/ul/select, etc
#
# Revision 1.15  2009/12/09 12:52:16  rlauer
# added decode/toggle
#
# Revision 1.14  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.13  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.12  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.11  2000/08/21 18:14:21  sridhar
# Added --format option to <var>
#
# Revision 1.10  2000/07/11 20:57:45  sridhar
# Added --HTMLEncode option to encode [<>&] in output.
#
# Revision 1.9  2000/05/31 15:00:21  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:48:28  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:20:37  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:40:47  sridhar
# Can be used as <var $name>, in addition to the yet-supported
# <var --name = "$name">.
#
# Revision 1.5  2000/03/13 15:43:33  sridhar
# More verbose message logging.
#
# Revision 1.4  2000/03/09 14:18:34  sridhar
# Using Output handle object for printing which enables buffering.
#
# Revision 1.3  2000/03/06 18:32:00  sridhar
# Replaced all ad-hoc message logging with message logging only on demand
# -- via --verbose flag specified as a tag option
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:00  sridhar
# Added TagX
#
#

1;
