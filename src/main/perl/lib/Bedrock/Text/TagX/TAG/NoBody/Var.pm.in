#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Var;

use strict;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  $VERSION = do { my @r = ( q$Revision$ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r if @r };
  @ISA = qw (Exporter);
}

use TagX::Log;
use Bedrock::Text::URLEncode;
use TagX::TAG::NoBody;
use Bedrock::HTML::Helper qw(create_xhtml_element create_xhtml_element_header);
use Bedrock::BedrockJSON;
use Bedrock::Dump;
use XML::Simple;

@ISA = qw (TagX::TAG::NoBody);

sub create_label {
  my $attributes = shift;
  my $options    = shift;

  my $label_element;

  my $label = delete $attributes->{'label'};

  unless ( exists $options->{'no_style'} ) {
    my @style = split ";", $attributes->{'style'};
    push @style, 'vertical-align:middle;';
    $attributes->{'style'} = join( ';', @style );
  }

  if ( $attributes->{'id'} && $label ) {
    return create_xhtml_element( 'label', $label, "for", $attributes->{'id'} );
  }

  # auto labeling...
  return
    if (    exists $options->{'no-label'}
	    || exists $options->{'button'}
	    || exists $options->{'submit'} );

  if ( ( exists $options->{'checkbox'} ) || ( exists $options->{'radio'} ) ) {
    return
      create_xhtml_element( 'label', $attributes->{'value'} . '&nbsp;',
			    "for", $attributes->{'id'} );

  } else {
    return
      create_xhtml_element( 'label', $attributes->{'name'} . '&nbsp;',
			    "for", $attributes->{'id'} );
  }
}

sub create_widget_registry {
  my $context = shift;

  $context->{'__widgets'} = {} unless exists $context->{'__widgets'};
  return $context->{'__widgets'};
}

sub set_last_widget {
  my ( $widgets, $attributes, $type ) = @_;
  my $attr = {};

  map { $attr->{$_} = $attributes->{$_} } keys %$attributes;
  $attr->{'type'} = $type;

  $widgets->{'__last_widget'} = $attr;

  $widgets->{'__last_widget_name'} = $attr->{'name'};
}

sub get_last_widget_name {
  my $widgets = shift;

  return $widgets->{'__last_widget'}->{'name'};
}

sub get_last_widget_type {
  my $widgets = shift;

  return $widgets->{'__last_widget'}->{'type'};
}

sub get_last_widget_id {
  my $widgets = shift;

  return $widgets->{'__last_widget'}->{'id'};
}

sub get_next_widget_id {
  my $widgets = shift;
  my $type    = shift;

  $widgets->{$type}->{'__id'} = 0 unless exists $widgets->{$type}->{'__id'};
  $widgets->{$type}->{'__id'}++;

  $widgets->{$type}->{'__last_widget_id'} =
    $type . '_' . $widgets->{$type}->{'__id'};

  $widgets->{$type}->{'__last_widget_id'};
}

sub register_widget {
  my ( $widgets, $type, $attributes ) = @_;

  die "register_widget: \$attributes must be HASH"
    unless UNIVERSAL::isa( $attributes, 'HASH' );

  $widgets->{$type} = {} unless exists $widgets->{$type};

  set_last_widget( $widgets, $attributes, $type );

  return undef if $attributes->{'id'};

  $attributes = {} unless ref($attributes);
  $attributes->{'id'} = get_next_widget_id( $widgets, $type );

  if ( $type =~
       /(button|checkbox|file|radio|select|select-group|submit|text|textarea)/ ) {
    $attributes->{'name'} = $attributes->{'id'} unless $attributes->{'name'};
  }

  set_last_widget( $widgets, $attributes, $type );

  return $attributes->{'id'};
}

sub is_form_widget {
  my $options = shift;

  my $tag_type;

  my @form_elements =
    qw(button checkbox file radio select select-group text textarea);

  ($tag_type) = map { exists $options->{$_} ? $_ : () } @form_elements;

  return $tag_type;
}

sub finalize {
  my ( $self, $tx, @context ) = @_;

  my %options = ( 'address=s'      => undef,
                  'anchor=s'       => undef,
                  'bedrock-xml'    => undef,
                  'blockquote=s'   => undef,
                  'button=s'       => undef,
                  'checkbox=s'     => undef,
                  'code=s'         => undef,
                  'columns=s'      => undef,
                  'decode=s'       => undef,
                  'default=s'      => undef,
                  'delimiter=s'    => undef,
                  'div=s'          => undef,
                  'file=s'         => undef,
                  'format=s'       => undef,
                  'group'          => undef,
                  'htmlencode'     => undef,
                  'img=s'          => undef,
                  'json'           => undef,
                  'name=s'         => undef,
                  'no-style'       => undef,
                  'no-handler'     => undef,
                  'no-label'       => undef,
                  'ol=s'           => undef,
                  'p=s'            => undef,
                  'pre=s'          => undef,
                  'radio=s'        => undef,
                  'span=s'         => undef,
                  'submit=s'       => undef,
                  'select=s'       => undef,
                  'select-group=s' => undef,
                  'serialize'      => undef,
                  'table=s'        => undef,
                  'textarea=s'     => undef,
                  'text=s'         => undef,
                  'toggle=s'       => undef,
                  'ul=s'           => undef,
                  'urlencode'      => undef,
                  'xml'            => undef
                );

  my $verbose = $self->verbose;

  &log_message( $self, 'context: ' . Bedrock::Dump::compact( \@context ) )
    if $verbose;

  my @argv = $self->parse_options( \%options, @context );

  if ( exists $options{serialize} ) {
    $options{'bedrock-xml'} = 1;
  }

  $self->dump_options( \%options, @argv ) if $verbose;

  my $delimiter = $options{delimiter} || '';

  # create a widget registry
  my $widgets = create_widget_registry( $context[0] );

  my $value;
  my $tag_type;

  if ( @argv == 0 ) {
    &log_message( $self, "warning: No variable specified." );
    &log_message( $self, "Value not defined, default is <$options{'default'}>" )
      if $verbose && exists $options{'default'};
    $value = $options{'default'}
      if exists $options{'default'};
  } else {
    $value = shift @argv;
    $value = $options{'default'}
      if exists $options{'default'} && !defined $value;
  }

  &log_message( $self, "Value: <$value>" )
    if $verbose;

  if ( defined $options{'bedrock-xml'} ) {
    if (    UNIVERSAL::isa( $value, 'ARRAY' )
	    || UNIVERSAL::isa( $value, 'HASH' ) ) {
      $value = Bedrock::XML::writeXML($value);
    } else {
      die "Invalid type for use with --bedrock-xml\n";
    }
  }
  if ( defined $options{'xml'} ) {
    my $config = $tx->out_handle->{Handle}->{'CONFIG'};
    die "no XML options defined in tagx.xml\n"
      unless exists $config->{'XML'};

    my $options = $config->{'XML'}->{'out'}->devolve;
    &log_message( $self, "XML:out options " . Bedrock::Dump::compact($options) )
      if $verbose;

    if ( UNIVERSAL::isa( $value, 'ARRAY' ) ) {
      $value = { $config->{RootName} => $value };
    }

    $value = XMLout( $value, %{$options} );
  } elsif ( defined( $options{'format'} ) ) {
    $value = sprintf $options{'format'}, $value;
  } elsif ( defined( $options{'decode'} ) ) {
    &log_message( $self, "decode using " . $options{'decode'} ) if $verbose;
    my $obj = Bedrock::JSON::decode( $options{'decode'} );
    if ( exists $obj->{$value} ) {
      $value = $obj->{$value};
    } elsif ( exists $obj->{default} ) {
      $value = $obj->{default};
    } else {
      $value = undef;
    }
  } elsif ( defined( $options{'toggle'} ) ) {
    my ( $a, $b ) = split /\s*,\s*/, $options{'toggle'};
    $value = ( $value eq $a ) ? $b : $a;
  } elsif ( exists $options{'anchor'} ) {
    my $attributes = get_json_attributes( 'anchor', \%options );
    register_widget( $widgets, 'anchor', $attributes );
    unless ( $attributes->{'href'} || @argv == 0 ) {
      $attributes->{'href'} = shift @argv;
    }
    $value = create_xhtml_element( 'a', $value, %{$attributes} );
  } elsif ( exists $options{'img'} ) {
    my $attributes = get_json_attributes( 'img', \%options );
    register_widget( $widgets, 'img', $attributes );
    unless ( $attributes->{'src'} ) {
      $attributes->{'src'} = $value;
    }
    $value = create_xhtml_element( 'img', undef, %{$attributes} );
  } elsif ( ($tag_type) =
	    map { exists $options{$_} ? $_ : () }
	    qw(address blockquote code div  p pre span textarea)
	  ) {
    my $attributes = get_json_attributes( $tag_type, \%options );
    register_widget( $widgets, $tag_type, $attributes );
    $value = create_xhtml_element( $tag_type, $value, %{$attributes} );
  } elsif ( ($tag_type) =
	    map { exists $options{$_} ? $_ : () } qw(radio checkbox)
	  ) {
    my $attributes = get_json_attributes( $tag_type, \%options );

    &log_message( $self,
                  Bedrock::Dump::compact( [ $value, scalar(@argv), $attributes ]
                                        )
                ) if $verbose;

    if ( ( exists $options{'group'} ) && !$attributes->{'name'} ) {
      &log_message( $self,
		    "warning: --group only valid for same type of form elements\n" )
	unless $tag_type eq get_last_widget_type($widgets);

      $attributes->{'name'} = get_last_widget_name($widgets)
	if $tag_type eq get_last_widget_type($widgets);

      &log_message( $self,
                    'group name set to: ' . $attributes->{'name'} . "\n" )
	if $verbose;
    }

    # <var --radio/checkbox value default-value name label>
    if (@argv) {
      if ( exists $attributes->{'value'} ) {

        # ignore already captured $value
        $value = shift @argv;
      } else {
        $attributes->{'value'} = $value;
        $value = shift @argv;
      }

      if ( $attributes->{'name'} ) {
        shift @argv;
      } else {
        $attributes->{'name'} = shift @argv;
      }
      $attributes->{'label'} = shift @argv unless $attributes->{'label'};
    } elsif ( defined $value ) {
      $attributes->{'value'} = $value;
      $value = undef;
    }

    if ( exists $options{'group'} && !$attributes->{'name'} ) {
      &log_message( $self,
                    "$tag_type will have a the group's name "
                    . get_last_widget_id($widgets)
                  ) if $verbose;
    }

    register_widget( $widgets, $tag_type, $attributes );

    if ( UNIVERSAL::isa( $value, 'HASH' ) ) {
      $value = $value->{ $attributes->{'name'} };
    }

    &log_message( $self, "attributes:\n" . Bedrock::Dump::compact($attributes) )
      if $verbose;

    die
      "usage: <var --$tag_type value default-value name label> or <var --$tag_type=JSON-STRING \$input.name>\n"
	unless ( defined $attributes->{'name'} && exists $attributes->{'value'} );

    if ( UNIVERSAL::isa( $value, 'HASH' ) ) {
      $value = $value->{ $attributes->{'name'} };
    }

    if ( UNIVERSAL::isa( $value, 'ARRAY' ) ) {
      $attributes->{checked} = 'checked'
	if ( grep { /$attributes->{value}/ } @$value );
    } else {
      $attributes->{checked} = 'checked' if $value eq $attributes->{value};
    }

    $attributes->{type} = $tag_type;

    &log_message( $self,
                  sprintf( "[%s]\n[%s]\n%s\n",
                           Bedrock::Dump::compact($value),
                           Bedrock::Dump::compact( $attributes->{value} ),
                           Bedrock::Dump::compact($attributes)
                         )
                ) if $verbose;

    $value = create_xhtml_element( 'input', undef, %{$attributes} );
    $value .= create_label( $attributes, \%options );
  }

  # { 1: "that", 2: "this"}
  # [ { 1: "this"}, {2: "that"}]
  # [
  #   { text: "this", attributes: {value : 1}},
  #   { text: "that", attributes: {value : 2}}
  # ]
  elsif ( exists $options{'select'} ) {
    my $attributes = get_json_attributes( 'select', \%options );

    my $cur_selected = shift @argv;

    if (@argv) {
      $attributes->{'name'}  = shift @argv unless exists $attributes->{'name'};
      $attributes->{'label'} = shift @argv unless exists $attributes->{'label'};
    }

    &log_message( $self, "attributes: " . Bedrock::Dump::compact($attributes) )
      if $verbose;
    register_widget( $widgets, 'select', $attributes );

    if ( !ref($value) ) {	# <var --select '["this",1,"that",2]'

      eval { $value = Bedrock::JSON::decode($value); };

      die "possibly an invalid JSON string: " . $value . " - $@\n"
	if $@;

      die
	"scalar argument to --select must be JSON string that evaluates to an array\n"
	  unless UNIVERSAL::isa( $value, 'ARRAY' );
    }

    if ( UNIVERSAL::isa( $cur_selected, 'HASH' ) ) {
      $cur_selected = $cur_selected->{ $attributes->{'name'} };
    }

    my @options;
    if ( UNIVERSAL::isa( $value, 'ARRAY' ) ) {
      my @rows = @$value;
      while (@rows) {
        my $text = shift @rows;
        my $key  = shift @rows;

        my $item = {};

        if ( UNIVERSAL::isa( $key, 'HASH' ) ) {
          if ( exists $key->{'value'} && !ref($text) ) {
            $item = { attributes => $key,
                      text       => $text
                    };
          } else {
            die
	      "HASH argument for --select is not well formed.  Must be {attributes}, text...\n";
          }
        } else {
          $item = { attributes => { value => $key },
                    text       => $text
                  };
        }

        # set selected if provided
        if ( defined $cur_selected ) {
          unless ( UNIVERSAL::isa( $cur_selected, 'ARRAY' ) ) {
            $item->{'attributes'}->{'selected'} = 'selected'
	      if $cur_selected eq $item->{'attributes'}->{'value'};
          } else {		# multiple select box
            $item->{'attributes'}->{'selected'} = 'selected'
	      if grep { /$item->{'attributes'}->{'value'}/ } @$cur_selected;
          }
        }

        push @options, $item;
      }
    } else {
      die "usage: <var --select=attributes value default-value name label\n";
    }

    &log_message( $self, Bedrock::Dump::compact(@options) ) if $verbose;

    $value = create_label( $attributes, \%options );
    $value .= create_xhtml_element(
				   'select',
				   join(
					'',
					map {
					  create_xhtml_element( 'option', $_->{text}, %{ $_->{attributes} } )
					} @options
				       ),
				   %$attributes
                                  );
  }

  # [ { label: "foo",  group : [ { attributes : {value : 1}, text: "this"}, { attributes: { value: 2, selected: "selected"}, text: "that"}] }
  #   { label: "foo2", group : [ { attributes : {value : 3}, text: "foo this"}, { attributes: { value: 4}, text: "foo that"}] }
  # ]
  elsif ( exists $options{'select-group'} ) {
    my $attributes = get_json_attributes( 'select-group', \%options );

    my $cur_selected = shift @argv;

    if (@argv) {
      $attributes->{'name'}  = shift @argv unless exists $attributes->{'name'};
      $attributes->{'label'} = shift @argv unless exists $attributes->{'label'};
    }

    &log_message( $self, "attributes: " . Bedrock::Dump::compact($attributes) )
      if $verbose;
    register_widget( $widgets, 'select-group', $attributes );

    # <var --select-group '{ menu1 : ["this",1,"that",2], menu2 : [ "foo", 3, "bar", 4] }'
    if ( !ref($value) ) {

      eval { $value = Bedrock::JSON::decode($value); };

      die "possibly an invalid JSON string: " . $value . " - $@\n"
	if $@;

      die
	"scalar argument to --select-group must be JSON string that evaluates to a hash\n"
	  unless UNIVERSAL::isa( $value, 'HASH' );
    }

    # { "foo"  : [ {value : 1}, "this",     {value: 2}, "that"]
    #   "foo2" : [ {value : 3}, "foo this", {value: 4}, "foo that"]
    # }
    #
    my @opt_group;

    if ( UNIVERSAL::isa( $cur_selected, 'HASH' ) ) {
      $cur_selected = $cur_selected->{ $attributes->{'name'} };
    }

    if ( UNIVERSAL::isa( $value, 'HASH' ) ) {
      my @labels = keys %$value;
      my @menus  = values %$value;

      foreach my $group (@menus) {
        my @options;
        my @rows = @$group;
        my $this_group = { label => shift @labels };

        while (@rows) {
          my $text = shift @rows;
          my $key  = shift @rows;
          my $item = {};

          if ( UNIVERSAL::isa( $key, 'HASH' ) ) {
            if ( exists $key->{'value'} && !ref($text) ) {
              $item = { attributes => $key,
                        text       => $text,
                      };
            } else {
              die
		"HASH argument for --select is not well formed.  Must be {attributes}, text...\n";
            }
          } else {
            $item = { attributes => { value => $key },
                      text       => $text,
                    };
          }

          # set selected if provided
          if ( defined $cur_selected ) {
            unless ( UNIVERSAL::isa( $cur_selected, 'ARRAY' ) ) {
              $item->{'attributes'}->{'selected'} = 'selected'
		if $cur_selected eq $item->{'attributes'}->{'value'};
            } else {		# multiple select box
              $item->{'attributes'}->{'selected'} = 'selected'
		if grep { /$item->{'attributes'}->{'value'}/ } @$cur_selected;
            }
          }
          push @options, $item;
        }

        $this_group->{'group'} = \@options;
        push @opt_group, $this_group;
      }
    } else {
      die "usage: <var --select=attributes value default-value name label\n";
    }

    &log_message( $self, Bedrock::Dump::compact(@opt_group) ) if $verbose;

    $value = create_label( $attributes, \%options );
    $value = $value . create_xhtml_element(
					   'select',
					   eval {
					     my $text;
					     foreach my $group (@opt_group) {
					       $text .= create_xhtml_element(
									     'optgroup',
									     join(
										  '',
										  map {
										    create_xhtml_element( 'option', $_->{text},
													  %{ $_->{attributes} } )
										  } @{ $group->{group} }
										 ),
									     ( label => $group->{label} )
									    );
					     }
					     $text;
					   },
					   %$attributes
                                          );

  } elsif ( ($tag_type) =
	    map { exists $options{$_} ? $_ : () } qw(button submit text file)
	  ) {

    my $attributes = get_json_attributes( $tag_type, \%options );

    if (@argv) {
      $attributes->{'value'} = $value;
      if ( exists $attributes->{'name'} ) {
        shift @argv;
      } else {
        $attributes->{'name'} = shift @argv;
      }

      $attributes->{'label'} = shift @argv unless $attributes->{'label'};
    } elsif ( UNIVERSAL::isa( $value, 'ARRAY' ) ) {
      die "usage: <var --$tag_type\[=json-attributes] value name label>\n";
    }

    unless ( $tag_type eq 'text' || $attributes->{'value'} ) {
      $attributes->{'value'} = { submit => 'Submit',
                                 button => 'Button',
                                 text   => ''
                               }->{$tag_type};
    }

    if (
	$tag_type eq 'button'
	&& ( !exists $options{'no-handler'} )
	&& (
	    !( exists $attributes->{'onClick'} || exists $attributes->{'onclick'} )
	   )
       ) {
      $attributes->{'onClick'} = 'javascript: this.form.submit();';
    }

    $attributes->{'type'} = $tag_type;

    register_widget( $widgets, $tag_type, $attributes );

    if ( UNIVERSAL::isa( $attributes->{'value'}, 'HASH' ) ) {
      $attributes->{'value'} =
	$attributes->{'value'}->{ $attributes->{'name'} };
    }

    $value = create_label( $attributes, \%options );
    $value .= create_xhtml_element( 'input', undef, %$attributes );
  } elsif ( ($tag_type) = map { exists $options{$_} ? $_ : () } qw(ol ul) ) {
    my $attributes = get_json_attributes( $tag_type, \%options );
    register_widget( $widgets, $tag_type, $attributes );

    # allow <var --ul aa bb cc>
    $value = UNIVERSAL::isa( $value, 'ARRAY' ) ? $value : [ $value, @argv ];
    $value = create_xhtml_element( $tag_type,
                                   join( '',
					 map { create_xhtml_element( 'li', $_ ) }
					 @$value ),
                                   %{$attributes}
                                 );
  } elsif ( defined( $options{'json'} ) ) {
    if ( ref($value) ) {
      $value = Bedrock::JSON::encode($value);
    } else {
      die "Can't use --json on a scalar object.";
    }
  }

  # <var --columns= --table array>
  elsif ( ( exists $options{'table'} ) && UNIVERSAL::isa( $value, 'ARRAY' ) ) {

    &log_message( $self, "table: " . Bedrock::Dump::compact($value) )
      if $verbose;

    my $column_attributes = {};
    my $header_attributes = {};
    my @column_headers;

    # allow a JSON string, an array, or a comma or pipe delimited string
    if ( defined $options{'columns'} ) {
      if ( $options{'columns'} =~ /^\s*[\[]/ ) {
        eval {
          @column_headers = @{ Bedrock::JSON::decode( $options{'columns'} ) };
        };

        die "possible invalid JSON string: $@\n"
	  if $@;
      } elsif ( UNIVERSAL::isa( $options{'columns'}, 'ARRAY' ) ) {
        @column_headers = @{ $options{'columns'} };
      } elsif ( !ref( $options{'columns'} ) ) {
        @column_headers = split /[,|]+/, $options{'columns'};
      }

      unless (@column_headers) {
        die "invalid argument for --columns\n";
      }

      # --columns='["foo", "bar", "baz"]'
      # --columns='[["foo", "bar", "baz"], {valign:"top", align:"right"}]'

      if ( !is_simple_object( \@column_headers ) ) {
        $column_attributes = $column_headers[1];
        $header_attributes = $column_headers[2];
        @column_headers    = @{ $column_headers[0] };
      }
    } else {
      @column_headers =
	UNIVERSAL::isa( $value->[0], 'HASH' ) ? keys %{ $value->[0] } : ();
    }

    &log_message( $self,
                  sprintf( "ref(0):%s Column headers are...%s",
                           ref( $value->[0] ),
                           join( "|", @column_headers )
                         )
                ) if $verbose;

    my $table_attributes = get_json_attributes( 'table', \%options );
    register_widget( $widgets, 'table', $table_attributes );
    &log_message( $self, Bedrock::Dump::compact( $value, $table_attributes ) )
      if $verbose;

    $value = create_xhtml_element(
				  'table',
				  eval {
				    if (@column_headers) {
				      create_xhtml_element(
							   'tr',
							   eval {
							     my $row;
							     foreach (@column_headers) {
							       $row .= create_xhtml_element( 'th', $_, %{$header_attributes} );
							     }
							     $row;
							   }
							  );
				    } else {
				      undef;
				    }
				  }
				  . eval {
				    my $text;
				    foreach my $row (@$value) {

				      $text .= create_xhtml_element(
								    'tr',
								    eval {
								      my $text;

								      # this obfuscation warrants an explanation... ;-)
								      # the object that contains the data for for the body of the table can be:
								      # ...an array ref or
								      # ...a hash ref
								      # if an array ref
								      # ...then the order is dictated by the array's natural order
								      # if the object is a hashref && it is an ordered hash, all's well (or not ymmv),
								      # ...but if not you may have specified a column order (--columns=)
								      # ...in which case we'll slice the hash that way to get the values for the columns.
								      my @cell_values =
									ref($row) =~ /array/i ? @$row
									  : ( ( @column_headers > 0 ) ? @{$row}{@column_headers}
									      : values %$row );
								      foreach (@cell_values) {
									$text .=
									  create_xhtml_element( 'td', $_, %{$column_attributes} );
								      }
								      $text;
								    }
								   );
				    }
				    $text;
				  },
				  %{$table_attributes}
                                 );

    &log_message( $self, "error: " . $@ ) if $@;
  } elsif ( UNIVERSAL::isa( $value, 'ARRAY' ) ) {
    $value = join( $delimiter, @$value );
  } elsif ( UNIVERSAL::isa( $value, 'HASH' ) ) {
    $value = join( $delimiter, %$value );
  } elsif ( UNIVERSAL::isa( $value, 'Tie::Scalar' ) ) {
    $value = $$value;
  }

  if ( $options{'htmlencode'} ) {
    $value =~ s/\x26/&amp;/g;
    $value =~ s/\x3c/&lt;/g;
    $value =~ s/\x3e/&gt;/g;
    &log_message( $self, "HTMLEncoded to <$value>" ) if $verbose;
  } elsif ( exists $options{'urlencode'} and $options{'urlencode'} > 0 ) {
    &Text::URLEncode::encode($value);
    &log_message( $self, "URLEncoded to <$value>" ) if $verbose;
  }

  $tx->out_handle->print($value);
}

sub get_json_attributes {
  my $key     = shift;
  my $options = shift;

  my $attributes = {};
  return $attributes
    unless ( exists $options->{$key} && defined $options->{$key} );

  my $options_val = $options->{$key};

  unless ( ref($options_val) || ( $options_val !~ /^\s*[\{\[]/ ) ) {
    eval { $attributes = Bedrock::JSON::decode($options_val); };

    die "possibly an invalid JSON string: " . $options_val . "\n"
      if $@;
  } elsif ( UNIVERSAL::isa( $options_val, 'HASH' ) ) {
    $attributes = $options_val;
  }

  $attributes;
}

sub is_simple_object {
  my $obj = shift;

  if ( ref($obj) && ref($obj) =~ /array/i ) {
    foreach (@$obj) {
      return 0 if ref($_);
    }
    return 1;
  } elsif ( ref($obj) =~ /(object|hash)/i ) {
    foreach ( keys %$obj ) {
      return 0 if ref( $obj->{$_} );
    }
    return 1;
  }

  return 1;
}

=pod

=head1 TAG - C<E<lt>varE<gt>>

=head1 PURPOSE

Output the value of a Bedrock expression.

=head1 SYNTAX

  <var [options] [object | result of method call | expression]>

=head1 DESCRIPTION

The C<E<lt>varE<gt>> tag is the I<output this> tag and the principal
way that output from Bedrock objects is included in your Bedrock
pages.  It indicates to Bedrock that the value of the object or
expression is to be included in the page at the point at which the tag
is encountered.

=head1 OPTIONS

 --bedrock-xml
 --default
 --delimiter
 --format
 --htmlencode
 --json
 --urlencode
 --xml

=over 5

=item  --bedrock-xml

Output the Bedrock XML representation of the object.

=item --default=s

Output the value of the C<--default> option if the value of variable
is undefined.

 <var --default="none" $foo>

=item --delimiter=s

SetE<039>s the delimiter used when joining elements of an array or hash
before they are output.

default: ''

 <null:foo Fred Wilma Barney Betty>
 <var --delimiter=', ' $foo>

 <null:hash:foo Fred Wilma Barney Betty>
 <var --delimiter=', ' $foo>

=item --format=s

Use the value of the scalar as input to the sprintf function using the
value of the C<--format> option as the format string.

  <var --format="%5.2f" $foo>

=item  --htmlencode

HTML encode the string before output.

=item  --json

Output the object or array as a JSON string.

=item  --urlencode

URL encode the string before output.

=item --xml

Output the object or array as an XML object. XML support is provided
by the perl module C<XML::Simple>.

The default options sent to XMLout can be configured in F<tagx.xml> as
an object named XML and represents the options that you would send to
the perl module C<XML::Simple> to control the behaviour of XML conversions.

A sensible default configuration is shown below:

 <object name="XML">
   <object name="out">
     <scalar name="NoAttr">1</scalar>
     <scalar name="KeepRoot">0</scalar>
     <scalar name="RootName">response</scalar>
     <scalar name="NoSort">1</scalar>
     <array name="KeyAttr"></array>
     <scalar name="XMLDecl">1</scalar>
     <scalar name="NoEscape">1</scalar>
   </object>
   <object name="in">
     <scalar name="NoAttr">0</scalar>
     <scalar name="KeepRoot">1</scalar>
     <array name="KeyAttr"></array>
   </object>

While this provides something passable as an XML document it may not
be exactly what you were looking for.  As shown above the options
passed to C<XMLout> for the conversion from your object to an XML
string should be contained in the F<tagx.xml> file as an object named
C<XML>.

What you see in the configuration above is workable, but you may
want to change either the defaults or the behaviour on a case by case
basis. You can do the latter by dynamically altering the configuration
using the C<XML> method of the C<$config> object.

 <null $config.XML('out', 'XMLDecl', 0)>

The first argument to the C<XML> method is either the string 'in' or
'out' which indicates which set of options you are about to set.
Subsequent arguments should be key, value pairs that represent the
options and values that will control either the conversion to or from
XML.

Converting an array to an XML document will generally require a root
element.  Bedrock will use the C<RootName> option of the
C<XML-E<gt>out> object as the root element when converting Bedrock
arrays to XML.

I<If your goal is to build a Bedrock component or service that outputs
an XML document that may be utilized by another web application or an
AJAX component for example, you may also want to set the content type
of the document being served.  This can be done using the C<$header>
object.>

  <null $header.content_type('application/xml')><var --xml $xml>

see perldoc C<XML::Simple> for more details regarding options that you
can use to control XML parsing.

=back

=head1 NOTES

The argument to the tag is a Bedrock object or expression which should
evaluate to a scalar or list.  The argument may be a Bedrock object
name (C<$name>), the result of a method call (C<$foo.bar()>), or an
expression.  BedrockE<039>s expression parsing requires that you use
parentheses.  Parentheses can be nested. Some examples of expressions:

  ($foo + "-" + $bar)

  ($foo --eq "foo")

  (5 + 6)

  ($foo.bar + " is a foobar")

The use cases for this tag include:

Output the value of scalar:

 <var $some_variable>

Output the value of a method call of an object:

 <var $input.get("foo")>

Dump an array or hash (equivalent to C<array.join(' ')> )

 <var $input.keys()>

 <var $input>

In Bedrock 1 (during the Stone Age) using the C<E<lt>varE<gt>> tag on
arrays or objects was undefined.  In Bedrock 2 the values are output
as a space delimited list.

  <var $array> <=> <var $array.join(' ')>

  <var $hash> <=> <foreach $hash><var $_.key> <var $_.value></foreach>

Translate the value of an expression:

 <var --json $foo>
 <var --htmlencode $foo>
 <var --urlencode $foo>
 <var --decode='{1:"red", 2:"green", 3:"blue"}' $foo>
 <var --toggle="1,0" $foo>
 <var --format="%5.2f" $foo>


=head1 EXAMPLE

=over 5

=item * Output the value of a variable or a default

  <var --default="Please enter a value" $input.fname>

=item * Format a value on output

  <var --format="%5.2f" $input.cost>

=item * Output an array as a JSON string

 <null:foo 1 2 3 4 5>

 <var --json $foo> => ["1", "2", "3","4", "5"]

=back

=head1 EXPERIMENTAL OPTIONS

=head2 Translation Options

 --decode
 --toggle

=over 5

=item  decode

Provides the same functionality found in the Oracle DECODE function,
namely it will translate a scalar value base on a list of key/value
pairs you provide.

The argument to the C<--decode> option is currently defined to be a
JSON string that represents a hash.  For example:

 <null:foo 3>
 <var $foo --decode='{1:"red", 2:"green", 3:"blue", 4:"yellow", default:"unknown"}'>

=item  toggle

Outputs a value based on two alternatives, alternating between the two.

  <var $foo --toggle="a,b">

If C<$foo> = 'a', then Bedrock will output 'b', else if C<$foo> is 'b'
Bedrock will output 'a'


=back

=head2 HTML Widgets

B<The following options are experimental.>

These B<experimental options> represent a set of HTML widget
constructors.  A "widget" is defined by Bedrock to be a small snippet
of HTML that provides a standardized way to express an HTML pattern.

It is produced by providing the C<E<lt>varE<gt>> tag with certain
options and arguments depending upon the widget being
produced. Widgets for most of the commonly used HTML constructions,
including form elements are available.

Some of these widgets are self explanatory and obvious, some may seem
esoteric and may have limited usage for those who prefer clean and
crisp, self documented HTML pages.  If you like "frameworks" and want
to standardize your web development, you might find these widgets very
usef. There are situations where the best approach is to DIY. As
always YMMV.

In general, the idea is to create an intuitive interface for
constructing HTML elements.  The widget option (C<--checkbox>, for
example) will commonly accept an argument that represents the various
attributes possible for that HTML tag.  For example consider the
C<E<lt>ulE<gt>> tag:

 <ul style="color:red;margin-top:5px;" id="fruits">
   <li>Apples</li>
   <li>Pears</li>
 </ul>

Here we have two elements being set; C<style> and C<id>.  The Bedrock
widget equivalent would be:

 <var --ul='{style:"color:red;margin-top:5px", id:"fruits"}' Apple Pears>

Note that the argument to the widget option C<--ul> is a JSON string
where the hash contains key/value pairs of the C<ul> attributes you
want to set.  Of course, TIMTOWTDI:

 <hash:ul style color:red;margin-top:5px 
          id    fruits>
 <array:fruits Apples Pears>

 <var --ul=$ul $fruits>

As you can see the option argument for C<ul>, like most widget
options, can be a JSON string or a Bedrock object.

If you do not provide an C<id> attribute then Bedrock will
automatically create a unique C<id> for each widget it creates.

You can inspect the last widget id created using the variable
C<$__widgets.__last_widget_id>.

  <var --ul Apples Pears>
  The id for the the <code>ul</code> was <var $__widgets.__last_widget_id>

Frameworks can be a good thing, but the perl way (and BedrockE<039>s) is
that I<There Is More Than One To Do IT> (TIMTOWTDI).

=head3 Form Widgets

 --button
 --checkbox
 --file
 --select
 --select-group
 --submit
 --text
 --textarea
 --radio

Form widgets that create form elements have a very specific interface
which creates a flexible but intuituive way to construct HTML forms.
Whereas the argument to non-form HTML widgets is typically a data
object that is used in the construction of the widget (e.g. an array
or scalar), the form widgets have a functional argument syntax.
The generalized interface is as follows:

For C<checkbox>, C<radio>, C<select>, C<select-group> form elements the generalized form is:

 <var --widget[=attributes] value default-value name label >

For the C<text>, C<textarea>, C<file> form element the generalized form is:

 <var --widget[=attributes] default-value name label >

For the C<submit> and C<button> elements, the generalized form is:

 <var --widget[=attributes] default-value name >

The arguments are described below.

=over 5

=item attributes

This is an optional JSON string that should interpret to a hash
element. The argument can also be a Bedrock hash object.  The argument
is used to provide additional attributes to the form element being
constructed.  Additionally, you can provide the C<name>, C<value> or
C<label> right hand arguments in this hash.

Using a JSON string:

The attributes argument letE<039>s you pass a JSON string that
represents a HASH of attributes to apply to the HTML element.

 <var --text='{label:"Last Name ",size:20,maxlength:40}' $input.text>

...would be equivalent to:

  <label for="text_1">Last Name </label>
  <input type="text" name="text_1" size="40" maxlength="60" \
         value="<var $input.text_1>">

=item value

The value of the form element when submitted.  For C<select> and
C<select-group> widgets the C<value> argument is a more robust data
structure that describes the select object (itE<039>s option values and
text).  See L<select> and L<select-group> below.

=item default-value

Typically this is the value the C<$input> object has for that form
element.  You can pass the entire C<$input> object and Bedrock will
fish for the value in the hash.

=item name

The name of the HTML form element.

=item label

The text value that should be used to label the form element.  Bedrock
will automatically add a label element to each form element.  You can
prevent Bedrock from doing this by including the C<--no-label> option.

  <var --radio "Apple" $input.fruit fruit>

Would result in an HTML construction:

  <input type="radio" value="Apple" name="fruit" id="radio_1"/>
  <label for="radio_1">Apple</label>

If you do not provide a label value, Bedrock will use as the label
value the widgetE<039>s C<value> argument for I<checkbox> and I<radios> or
the form elementE<039>s C<name> argument for all other form input objects.

=back

The Bedrock widget constructor will provide an C<id> and C<name>
element if you do not provide these.  You can inspect the value of
these elements by looking at:

 $__widgets.__last_widget_id
 $__widgets.__last_widget_name


The Bedrock widget constructor will provide intelligent defaults for
missing parameters and create labels for your form elements.

Create a set of radio buttons:

  <var --radio='{name:"fruit",value:"Apple"}' '' $input.fruit>
  <var --radio='{name:"fruit",value:"Pear"}'  '' $input.fruit>

For checkboxes and radio buttons if you do not provide a label, the
label will be taken from the C<value> the radio or checkbox element.

  <var --radio Apple $input.fruit fruit >
  <var --radio Pear $input.fruit fruit >

You can create checkbox or radio "groups" by using the --group option.

  <var --radio Apples $input.fruit fruit >
  <foreach Pears Bananas Oranges>
  <var ---group --radio $_ $input.fruit></foreach>

The elementE<039>s C<name> for grouped objects will be taken from the most
recent widget created if one is not provided.  If the widget element being created is
different than the last widget created and the C<--group> option is
used, then a new name will be created.  Thus, this can be a valid construction:

  <foreach Apples Pears Bananas Oranges>
  <var ---group --radio $_ $input.fruit></foreach>

...as long as the last widget constructed was not a radio.

=head4 Form Widget Listing

=over 5

=item button

Creates a button with a default handler for submitting the form.  The
argument to the button is the value of the button text.

  <var --button[=attributes] value name>

Example:

  <var --button "Click-Me">

The default handler simply submits the form.

  onClick='javascript: this.form.submit();'

You can turn off the association of a handler with the button by
either providing your own C<onClick> handler or providing the
C<--no-handler> option.

  <var --no-handler --button "I'm a Do Nothing Button">

=item checkbox

=item radio

Creates a checkbox or radio element.

  <var --checkbox[=attributes] value default-value name label>

Examples:

  <var --checkbox='{name:"foo", value:1}' $input.foo>

  <var --checkbox foo 1 $input.foo>

  <var --checkbox=$attributes $input.foo>

=item file

Create an upload file form element.

  <var --file[=attributes] default-value name label>

=item select

Create a simple select element.

  <var --select[=attributes] value default-value name label>

C<value> is either a JSON string that evaluates to an array or a Bedrock array.

The array can be a simple array that defines pairs of values that
represent the option text and the option value or a more complex array
where the second item in the tuple is a hash that is interpreted to be
the attributes (including the value of the option) to be applied to
the option tag.

  <var --select '["this", 1, "that", 2]' $input.foo foo>

  <var --select '["this", {value:1, style:"color:green;"},"that", 2]' 
                $input>

=item select-group

Creates a 'grouped' select box where items are grouped under headings.

  <var --select-group[=attributes] value default-value name label>

C<value> is a JSON string that evaluates to a hash or a Bedrock hash.

The hash keys are the labels used for each menu group, the values are
arrays as required by the C<--select> widget.

  <var --select-group '{ Fruits : [ "Apple", 1, "Pear"], 
                         Veggie : [ "Peas", 3, "Carrots", 4 ]
                       }' $input.food food>

The HTML element is constructed using the C<E<lt>optgroupE<gt>> tags.  When rendered groups are
indented under a label similar to the menus below.

  Fruits
    Apple
    Pear
  Veggies
    Peas
    Carrots

=item submit

Creates a submit button.

  <var --submit[=attributes] value name>

=item textarea

Creates a textarea form element.

  <var --textarea[=attributes] default-value name label>
=item text


=item radio

See 'checkbox'.

=back

=head3 HTML Block Widgets

 --anchor
 --address
 --blockquote
 --code
 --div
 --img
 --ol
 --pre
 --p
 --span
 --table
 --ul

Most of these are probably not terribly useful.  You may find the
C<ol>, C<ul>, and the C<table> widgets somewhat useful.

=head4 HTML Widget Listing

=over 5

=item address

=item anchor

Create an link object.

  <var --anchor[=attributes] value link>

Example:

  <var --anchor Google http://www.google.com>

=item blockquote

=item code

=item div

=item pre

=item p

=item span

Create a block object.

  <var --div[=attributes] value>

=item ol

See L<ul>

=item img

Create an image tag.

  <var --img[=attributes] image-path>

=item table

  <var --table[=attributes] value>

Use C<--table> to quickly dump an array of arrays that represent the
rows and columns of a table.  

The object you want to convert to a table can also be an array of
hashes.  This might be the return value for example of a query that
returns an array of hashes representing a result set.  If no
C<--columns> option is present the widget constructor will use the
hash keys a column names.

  <hash:foo red 1 blue 2 green 3>
  <array:foo_array $foo $foo $foo>
  <var --table $foo_array>
  
  <sink:flintstones --json>
    [
     ["fred", "flintstone","fflintstone@openbedrock.net"],
     ["barney" "rubble", "brubble@openbedrock.net"]
    ]
  </sink>
  
  <var --table $flintstones>

Add table headers using the C<--columns option>

  <var --columns='["First Name", "Last Name", "E-Mail"]' --table $foo_array>
  <var --table $foo_array>

The C<--columns> option can be any of:

=over 5

=item an array object

  <array:headers this that "the other">
  <var --table --columns=$headers $foo>

=item an JSON string representing an array

  <var --table --columns='["this", "that", "the other"]' $foo>

=item a comma, space or pipe delimited string

  <var --table --columns="this,that,the&nbsp;other" $foo>

=back

Attributes for the cells of the table (C<td>) and each header element
(C<th>) can be addded by adding a second and third element to the JSON
object when specifiying a JSON string as argument for the C<--columns>
option.

 <var --table --columns='[ [ "this", "that", "the other" ], 
                           { valign : "top", 
                             class  : "foo" 
                           }, 
                           { align  : "left" }
                         ]' $foo>

=item ul

Creates an HTML C<ul> element from an array.

  <var --ul[=attributes] value>

Examples:

  <array:pepboyz manny moe jack>
  <var --ul $pepboyz>

You can specify attributes such as styles by setting the C<--ul>
option to a hash or JSON string.

 <var -ul='{ style: color:"red" }' $pepbozy>

=back

=head1 METHODS

When used with the C<E<lt>varE<gt>> tag a Bedrock expression usually
evaluates to a scalar.  Bedrock promotes all expressions that evaluate
to a scalar to a Bedrock Scalar object, thus it seems logical to
describe scalar methods here in the C<E<lt>varE<gt>> tag documentation.

ThereE<039>s a long list of methods you can invoke on scalars.  As you
might expect since Bedrock is written in perl, a lot of these are
simply covers on the corresponding perl built-in functions with a
twist or two for the Bedrock environment.  Some of these methods may
have the same names as options to the the C<E<lt>varE<gt>> tag but may
operate in different manners since output of text or HTML is not
I<always> the purpose of these methods.

The methods operate on the value of the scalar but aside from two
methods C<toggle>, C<replace>, the methods B><do not alter the
scalarE<039>s value>, they return the value of the transformation.

=head2 align(direction, width)

Align a string within a string of a given width.

B<direction> is C<left>, C<center> or C<right>.

  <var $foo.align('center', 80)>

=head2 align_center(width)

Convenience routine for C<align>.

=head2 align_left(width)

Convenience routine for C<align>.

=head2 align_right(width)

Convenience routine for C<align>.

=head2 chr

Return the character representation of the integer.

=head2 chomp

Removes trailing new line characters.  This method does not alter the
scalar.  It returns a chompE<039>d version of the scalar.

=head2 crypt(salt)

Creates a digest string. C<man crypt(3)>

=head2 decode(key, value, ... , default)

Decode the scalar by using the list of key / value pairs.  If there is
an odd number of values, the last value is considered the default
value to use in the event the scalar does not equal any of the give
keys.

  <var $answer.decode(0, "No", 1, "Yes", "Maybe")>

=head2 eq(value) I<deprecated>

Returns 1 if the scalar is equal to this value.

  <if $foo.eq(4.3)> 

=head2 format(format string)

Formats the scalar according to the C<printf> like format string.

  <var $screen.format("/index.roc?screen=%s")>

=head2 format_time([format string])

Considers the scalar a time value returned by the C<time> function and
formats the time according to the optional format string (see perl
C<strftime>).  If no format string is give, the method returns the
time as a C<ctime> value.

  <var $time.format_time()>

=head2 ge(value) I<deprecated>

Returns 1 if scalar is greater than or equal to the given value.

=head2 gt(value) I<deprecated>

Returns 1 if scalar is greater than the given value.

=head2 htmlencode

Returns the HTML encoded version of the scalar.  Useful for display HTML entities.

=head2 isEmpty

Returns undef if scalar is  undef.

Returns 0 if string of length 0.

Returns 1 if string of length > 0.

=head2 json 

Considers the scalar to be a JSON string and returns the appropriate
Bedrock object.

  <null:bar '{red : 1, blue : 2}'>

  <null:foo $bar.json()>

The above example creates a Bedrock hash.

=head2 lc		

Lower case the string.

=head2 lcfirst	

Lower case the first letter of the string.

=head2 le(value) I<deprecated>

Returns 1 if the scalar is less than or equal to the given value.

=head2 length

Return the length of the string.

=head2 lt(value) I<deprecated>

Returns 1 if the scalar is less than to the given value.

=head2 ltrim

Trims the white space from the beginning of a string.

=head2 matches( pattern, [flags] )

Returns an array of matched strings based on a pattern.

If the pattern begins with 'qr', then the pattern is assumed to be
a quoted regular expression.

C<flags> can be any of:

=over

=item i

Ignore case.

=item m

Treat string as multiple lines.

=item s

Treat string as single line.

=item g

Global matching.  See examples below.

=back

The function will return an array of matches, only if you
use grouping to indicate you want to return the matched strings.  If
you do not use grouping, then the array either returned will be empty
if no match is found or will contain 1 element composed of a true
value indicate the regular expression matched.

Examples:

  ---- scalar, no grouping
  <null:bar "Robert">
  <null:results $bar.matches("qr/[rb][^ ]/i")>
  <trace --compact --output $results>
  
  ---- scalar, grouping
  <null:results $bar.matches("([rb][^ ])", "i")>
  <trace --compact --output $results>
  
  ---- scalar, grouping, global
  <null:results $bar.matches("([rb][^ ])", "ig")>
  <trace --compact --output $results>

...would result in 

  ---- scalar, no grouping
  
  .[0] = (1)
  
  
  ---- scalar, grouping
  .[0] = (Ro)
  
  
  ---- scalar, grouping, global
  .[0] = (Ro)
  .[1] = (be)
  .[2] = (rt)

I<Note: that if you want to use a quoted regexp and the B<g> flag, you
should pass the flag as the second argument.>

 <null:foo "barfoo thisfoo foobar foofoobar">
 <null:result $foo.matches("qr/(.*?)foo\\s+/", "g")>

=head2 or(value)

Returns the value if the scalar is false.

 <var $foo.or("alternative")>

=head2 replace(pattern, string, flags)

Poor mans reg-ex substitution for a scalar.

 <var $foo.replace("foo", "bar", "i")>

=head2 reverse

Reverse the characters in a string.

=head2 rtrim

Trims the whitespace from the back of a string.

=head2 sign(value)

Returns 0 if scalar and value are equal

Returns 1 if scalar is greater than value

Returns -1 if scalar is less than value

=head2 split(value)

Returns an array split on value.

=head2 sprintf([args])

Considers the string to be a C<sprintf> format string and the optional
arguments to be additional arguments to pass to C<sprintf>.

=head2 substr( offset, length )

Returns a portion of a string.  A negative offset indicates a
substring from the far end of string.

 <var $foo.substr(0, 3)>
 <var $foo.substr(-1, 3)

=head2 toggle(a, b)

Returns value b if scalar eq a, a if scalar eq b and sets scalar to
returned value.

=head2 trim

Trim the whitespace from the front and back of a string.

=head2 uc		

Upper case a string

=head2 ucfirst	

Upper case first letter of string.

=head2 urlencode

Consider the scalar value to be URL and encode appropriately.

=head1 SEE ALSO

C<E<lt>hashE<gt>>, C<E<lt>arrayE<gt>>, C<E<lt>nullE<gt>>, C<E<lt>sinkE<gt>>, 

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.46  2011/09/29 13:00:22  eutl420
# pod tweak
#
# Revision 1.45  2011/09/21 20:38:30  eutl420
# - pod fixes
#
# Revision 1.44  2011/09/15 16:05:33  eutl420
# - perl tidy
#
# Revision 1.43  2011/09/09 19:42:13  eutl420
# - added options --bedrock-xml, --serialize, output Bedrock XML representation of object
#
# Revision 1.42  2011/08/31 02:58:32  eutl420
# - update pod to reflect change to chomp
#
# Revision 1.41  2011/08/30 12:34:51  eutl420
# - reformatted some pod to fit in narrower space
#
# Revision 1.40  2011/08/23 14:48:09  eutl420
# - somewhere along the way, <var> forgot how to handle --default.  Also updated documentation
#   to reflect the fact that --default is used when the value is undefined, not merely "untrue"
#
# Revision 1.39  2011/08/22 23:20:42  eutl420
# - --delimiter=s now used to determine the delimiter when outputting array or hash objects
# - better definition of syntax in pod
#
# Revision 1.38  2011/08/07 16:06:49  eutl420
# use Bedrock::BedrockJSON instead of Bedrock::JSON to avoid namespace collisions with JSON when use Bedrock; is employed
#
# Revision 1.37  2011/07/17 16:50:25  eutl420
# @PERL@, log_message if verbose
#
# Revision 1.36  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.35  2011/03/25 18:05:52  eutl420
# - created a set of methods to support the creation of widgets and auto naming and auto id generation
#   create_label, create_widget_registry, set_last_widget, get_last_widget_name, get_last_widget-id,
#   get_next_widget_id, is_form_widget
# - added new widgets and options
#   + text, file, code, img, pre, p, anchor, submit, button, blockquote, address
# - --group added to group radio and checkbox elements by using same name
# - --no-style option to prevent auto alignment of <label> element with form element
# - --no-lable to prevent auto labeling of form elements
# - --no-handler to prevent attaching a handler to the submit or button element
# - removed all the logic that tested for the option parsing bug, when the user does not
#   provide an argument to an option defined to accept one, the parser did not associate the arguments correctly
# - standardized the interface for widgets
#
# Revision 1.34  2010/12/12 17:03:14  eutl420
# - Bedrock::Text::URLEncode
# - remove Data:Dumper in favor of Bedrock::Dump
# - dump_options
#
# Revision 1.33  2010/12/06 14:19:20  rlauer
# - changed pod heading from SCALAR METHODS to METHODS to standardize docs
#
# Revision 1.32  2010/11/29 15:57:54  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.31  2010/11/17 02:27:37  rlauer
# - pod cleanup
#
# Revision 1.30  2010/11/16 00:16:28  rlauer
# - document scalar methods
# - process --htmlencode after flattening arrays, and other operations
#
# Revision 1.29  2010/11/08 07:31:36  rlauer
# - --checkbox, --radio option
#
# Revision 1.28  2010/01/03 19:20:16  rlauer
# add --xml option
#
# Revision 1.26  2009/12/31 18:38:40  rlauer
# updated docs
#
# Revision 1.25  2009/12/31 12:43:36  rlauer
# more robust documentation
#
# Revision 1.24  2009/12/30 12:42:13  rlauer
# dump array references rather than "Bedroc::Array" as output
#
# Revision 1.23  2009/12/30 00:15:11  rlauer
# log messages on verbose only
#
# Revision 1.22  2009/12/29 12:23:26  rlauer
# check to see if object is a tied scalar and access value via reference on output
#
# Revision 1.21  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.20  2009/12/28 19:28:26  rlauer
# renamed BLM::IndexedTableHandler::Common to Bedrock::HTML::Helper
#
# Revision 1.19  2009/12/26 15:18:53  rlauer
# remove BLM::OrderedObject since all objects are now ordered
#
# Revision 1.18  2009/12/17 13:14:57  rlauer
# added span tag
#
# Revision 1.17  2009/12/16 23:25:09  rlauer
# wip - html widgets
#
# Revision 1.16  2009/12/15 23:09:59  rlauer
# wip - html options to var like --div/table/ul/select, etc
#
# Revision 1.15  2009/12/09 12:52:16  rlauer
# added decode/toggle
#
# Revision 1.14  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.13  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.12  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.11  2000/08/21 18:14:21  sridhar
# Added --format option to <var>
#
# Revision 1.10  2000/07/11 20:57:45  sridhar
# Added --HTMLEncode option to encode [<>&] in output.
#
# Revision 1.9  2000/05/31 15:00:21  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:48:28  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:20:37  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:40:47  sridhar
# Can be used as <var $name>, in addition to the yet-supported
# <var --name = "$name">.
#
# Revision 1.5  2000/03/13 15:43:33  sridhar
# More verbose message logging.
#
# Revision 1.4  2000/03/09 14:18:34  sridhar
# Using Output handle object for printing which enables buffering.
#
# Revision 1.3  2000/03/06 18:32:00  sridhar
# Replaced all ad-hoc message logging with message logging only on demand
# -- via --verbose flag specified as a tag option
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:00  sridhar
# Added TagX
#
#

1;
