#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::TAG::NoBody::Var;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = 1.13;
    @ISA	= qw (Exporter);
}

use TagX::Log 1.01;
use Text::URLEncode 1.01;
use TagX::TAG::NoBody 1.03;
use Bedrock::HTML::Helper qw(create_xhtml_element create_xhtml_element_header);
use Bedrock::JSON;
use Data::Dumper;
use XML::Simple;

@ISA = qw (TagX::TAG::NoBody);

sub finalize
{
    my ($self, $tx, @context) = @_;

    my %options = ('name=s'	=> undef,
		   'urlencode'	=> undef,
		   'htmlencode'	=> undef,
		   'format=s'	=> undef,
		   'decode=s'	=> undef,
		   'toggle=s'	=> undef,
		   'default=s'	=> undef,
		   'table=s'    => undef,
                   'ul=s'       => undef,
		   'div=s'      => undef,
                   'span=s'     => undef,
                   'select=s'   => undef,
                   'select-group=s' => undef,
		   'columns=s'  => undef,
                   'textarea=s' => undef,
                   'json'       => undef,
		   'xml'        => undef
		  );

    my $verbose = $self->verbose;
    &log_message($self, Dumper(\%options, @context, $self, $tx))
      if $verbose;
    my @argv = $self->parse_options (\%options, @context);

    if ( $verbose ) {
	my ($key, $value);
	my $str = "Options are\n";
	while (($key, $value) = each %options) {
	    $str .= "\t$key .. ($value)\n";
	}
	$str .= "Arguments ..(@argv)";
	&log_message( $self, $str );
    }

    my $value;
    if ( exists $options{'name'} ) {
	$value = $options{'name'};
    } elsif ( @argv == 0 ) {
      # Oh Brother! Good thing Jay isn't around to see this hack...
      # a) bedrock's parser is junk, ask Jay, he'll tell you.
      # b) unfortunately, you cannot have an option that SOMETIMES takes an argument
      # c) this is a guess as to what probably happened...so we try to make it right
      if (defined $options{'table'} && (ref($options{'table'}) =~/array/i) ) {
	$value = $options{'table'};
	$options{'table'} = undef;
      }
      elsif (defined $options{'div'} && ! ref($options{'div'}) ) {
	  $value = $options{'div'};
	  $options{'div'} = undef;
	}
      elsif (defined $options{'span'} && ! ref($options{'span'}) ) {
	  $value = $options{'span'};
	  $options{'span'} = undef;
	}
      elsif (defined $options{'ul'} && ref($options{'ul'}) ) {
	  $value = $options{'ul'};
	  $options{'ul'} = undef;
	}
      elsif (defined $options{'select'} && ref($options{'select'}) ) {
	  $value = $options{'select'};
	  $options{'select'} = undef;
	}
      elsif (defined $options{'select-group'} && ref($options{'select-group'}) ) {
	  $value = $options{'select-group'};
	  $options{'select-group'} = undef;
	}
      else {
	&log_message( $self, "No variable specified" );
	return;
      }
    } else {
	$value = shift @argv;
    }

    &log_message( $self, "Value = <$value>" ) if $verbose;

    unless ( defined ( $value ) ) {
	&log_message ( $self, "Value not defined, default is <$options{'default'}>" )
	    if $verbose;
	$value = $options{'default'} if exists $options{'default'};
    }
    return unless defined( $value );

    if (defined($options{'xml'})) {
      my $config = $tx->out_handle->{Handle}->{'CONFIG'};
      my $options = $config->{XML}->{out}->devolve;
      &log_message($self, Dumper(%{$options})) 
	if $verbose;

      if (UNIVERSAL::isa($value, 'ARRAY')) {
	$value = { $config->{RootName} => $value};
      }

      $value = XMLout($value, %{$options});
    }


    if ( exists $options{'urlencode'} and $options{'urlencode'} > 0 ) {
	&Text::URLEncode::encode( $value );
	&log_message ( $self, "URLEncoded to <$value>" ) if $verbose;
    }

    if ( $options{'htmlencode'} ) {
	$value =~ s/\x26/&amp;/g;
	$value =~ s/\x3c/&lt;/g;
	$value =~ s/\x3e/&gt;/g;
	&log_message ( $self, "HTMLEncoded to <$value>" ) if $verbose;
    }

    if ( defined($options{'format'}) ) {
	$value = sprintf $options{'format'}, $value;
    }

    if ( defined($options{'decode'}) ) {
      &log_message($self, "decode using ".$options{'decode'}) if $verbose;
      my $obj = Bedrock::JSON::decode($options{'decode'});
      if (exists $obj->{$value}) {
	$value = $obj->{$value};
      }
      elsif (exists $obj->{default}) {
	$value = $obj->{default};
      }
      else {
	$value = undef;
      }
    }

    if ( defined($options{'toggle'}) ) {
        my ($a,$b) = split /\s*,\s*/, $options{'toggle'};
	$value = ($value eq $a) ? $b : $a;
    }

    if (exists $options{'div'} ) {
      my $attributes = get_json_attributes('div', \%options);
      $value = create_xhtml_element('div', $value, %{$attributes});
    }

    if (defined($options{'span'} ) ) {
      my $attributes = get_json_attributes('span', \%options);
      $value = create_xhtml_element('span', $value, %{$attributes});
    }

    if (defined($options{'textarea'} ) ) {
      my $attributes = get_json_attributes('textarea', \%options);
      $value = create_xhtml_element('textarea', $value, %{$attributes});
    }

    # { 1: "that", 2: "this"}
    # [ { 1: "this"}, {2: "that"}]
    # [ 
    #   { text: "this", attributes: {value : 1}}, 
    #   { text: "that", attributes: {value : 2}}
    # ]
  
    if (exists $options{'select'} ) {
      my $attributes = get_json_attributes('select', \%options);
      my @options;
      if (ref($value) =~/(object|hash)/i) {
        @options = map { { attributes => {value => $_}, text => $value->{$_} }; } keys %$value;
      }
      elsif (ref($value) =~/array/i) {
	foreach (@$value) {
	  if (exists $_->{text} && exists $_->{attributes}) {
	    push @options, $_;
	  }
	  else {
	    my $key = (keys %$_)[0]; # take first key we find
	    push @options, {attributes  => {value => $key}, text => $_->{$key} };
	  }
	}
      }
      else {
	die "Use array or hash to describe select options.";
      }

      $value = create_xhtml_element('select', join('', map { create_xhtml_element('option', $_->{text}, %{$_->{attributes}}) } @options), %$attributes);
    }

    # [ { label: "foo",  group : [ { attributes : {value : 1}, text: "this"}, { attributes: { value: 2, selected: "selected"}, text: "that"}] }
    #   { label: "foo2", group : [ { attributes : {value : 3}, text: "foo this"}, { attributes: { value: 4}, text: "foo that"}] }
    # ]
    if (exists $options{'select-group'} ) {
      my $attributes = get_json_attributes('select', \%options);
      if (ref($value) =~/array/i) {
	$value = create_xhtml_element('select', 
				      eval {
					my $text;
					foreach my $group (@$value) {
					  $text .= create_xhtml_element('optgroup', 
									join('',map { create_xhtml_element('option', $_->{text}, %{$_->{attributes}}) } @{$group->{group}}),
									(label => $group->{label})
								       );
					}
					$text;
				      },
				      %$attributes
				     );
      }
      else {
	die "--select-group requires an array of hashes.";
      }
    }


    if (exists $options{'ul'} ) {
      die "--ul can only be used on arrays."
	unless ref($value) =~/array/i;
      my $attributes = get_json_attributes('select', \%options);
      $value = create_xhtml_element('ul',join('', map { create_xhtml_element('li', $_) } @$value),  %{$attributes});
    }

    if (defined($options{'json'} ) ) {
      if (ref($value)) {
	$value = Bedrock::JSON::encode($value);
      }
      else {
	die "Can't use --json on a scalar object."
      }
    }
    
    if ( (exists $options{'table'}) && ref($value) =~/array/i ) {

      my $column_attributes = {};
      my @column_headers;
      if (defined $options{columns} && $options{columns} =~/^\s*[\[]/) {
	@column_headers = @{Bedrock::JSON::decode($options{columns})};
	if (! is_simple_object(\@column_headers)) {
	  $column_attributes = $column_headers[1];
	  @column_headers = @{$column_headers[0]};
	}
      }
      else {
	@column_headers = (ref($value->[0]) =~/(hash|object)/i) ? keys %{$value->[0]} : ();
      }

      &log_message($self, sprintf("ref(0):%s Column headers are...%s" , ref($value->[0]),  join("|", @column_headers)) ) if $verbose;

      my $table_attributes = get_json_attributes('table', \%options);
      &log_message($self, Dumper($value, $table_attributes)) if $verbose;

      $value = create_xhtml_element('table', 
				    eval {
				      if (@column_headers) {
					create_xhtml_element('tr', 
							     eval {
							       my $row;
							       foreach (@column_headers) {
								 $row .= create_xhtml_element('th', $_);
							       }
							       $row;
							     }
							    );
				      }
				      else {
					undef;
				      }
				    } . 
				    eval {
				      my $text;
				      foreach my $row (@$value) {

					$text .= create_xhtml_element('tr',
								      eval {
									my $text;
									# this obfuscation warrants an explanation... ;-)
									# the object that contains the data for for the body of the table can be:
									# ...an array ref or 
									# ...a hash ref 
									# if an array ref 
									# ...then the order is dictated by the array's natural order
									# if the object is a hashref && it is an ordered hash, all's well (or not ymmv),
									# ...but if not you may have specified a column order (--columns=)
									# ...in which case we'll slice the hash that way to get the values for the columns.
									my @cell_values = ref($row) =~/array/i ? @$row : ((@column_headers > 0) ? @{$row}{@column_headers} : values %$row);
									foreach (@cell_values) {
									  $text .= create_xhtml_element('td', $_, %{$column_attributes});
									}
									$text;
								      }
								     );
				      }
				      $text;
				    },
				    %{$table_attributes}
				   );
      
      &log_message($self, "error: ". $@) if $@;
    }

    if (UNIVERSAL::isa($value, 'ARRAY')) {
      $tx->out_handle->print(join('', @$value));
    }
    elsif (UNIVERSAL::isa($value, 'Tie::Scalar')) {
      $tx->out_handle->print($$value);
    }
    else {
      $tx->out_handle->print($value);
    }
}

sub get_json_attributes {
  my $key = shift;
  my $options = shift;

  my $attributes = {};

  if ($options->{$key} =~/^\s*[\{]/ ) {
    $attributes = Bedrock::JSON::decode($options->{$key});
  }
  elsif ($options->{$key}) {
    $attributes = {id => $options->{$key}};
  }

  $attributes;
}

sub is_simple_object {
  my $obj = shift;

  if (ref($obj) && ref($obj) =~/array/i) {
    foreach (@$obj) {
      return 0 if ref($_);
    }
    return 1;
  }
  elsif (ref($obj) =~/(object|hash)/i) {
    foreach (keys %$obj) {
      return 0 if ref($obj->{$_});
    }
    return 1;
  }

  return 1;
}

=pod

=head1 TAG - <var>

=head1 PURPOSE

Output the value of a Bedrock expression.

=head1 SYNTAX

  <var [options] expression>

=head1 OPTIONS

 --urlencode
 --htmlencode
 --format
 --default
 --json
 --xml

=head2 Experimental Options

 --decode
 --toggle
 --table
 --ul
 --div
 --span
 --select
 --select-group
 --column
 --textarea

=over 5

=item  --urlencode

URL encode the string before output.

=item  --htmlencode

HTML encode the string before output.

=item --format=s

Use the value of the scalar as input to the sprintf function using the
value of the C<--format> option as the format string.

  <var --format="%5.2f" $foo>

=item --default=s

Output the value of the C<--default> option if the value of variable is null.

 <var --default="none" $foo>

=item  --json

Output the object or array as a JSON string.

 <null:foo 1 2 3 4 5>

 <var --json $foo> => ["1", "2", "3","4", "5"]

=item --xml

Output the object or array as an XML object. XML support is provided
by the perl module C<XML::Simple>.

The default options sent to XMLout can be configured in F<tagx.xml> as
an object named XML and represents the options that you would send to
the perl module C<XML::Simple> to control the behaviour of XML conversions.

A sensible default configuration is shown below:

 <object name="XML">
   <object name="out">
     <scalar name="NoAttr">1</scalar>
     <scalar name="KeepRoot">0</scalar>
     <scalar name="RootName">response</scalar>
     <scalar name="NoSort">1</scalar>
     <array name="KeyAttr"></array>
     <scalar name="XMLDecl">1</scalar>
     <scalar name="NoEscape">1</scalar>
   </object>
   <object name="in">
     <scalar name="NoAttr">0</scalar>
     <scalar name="KeepRoot">1</scalar>
     <array name="KeyAttr"></array>
   </object>

While this provides something passable as an XML document it may not
be exactly what you were looking for.  As shown above the options
passed to C<XMLout> for the conversion from your object to an XML
string should be contained in the F<tagx.xml> file as an object named
C<XML>.  What you in the configuration above is workable, but you may
want to change either the default or the behaviour on a case by case
bases. You can do the latter by dynamically altering the configuration
using the C<XML> method of the C<$config> object.

 <null $config.XML('out', 'XMLDecl', 0)>

The first argument to the C<XML> method is either the string 'in' or
'out' which indicates which set of options you are about to set.
Subsequent arguments should be key, value pairs that represent the
options and values that will control either the conversion to or from
XML.

Converting an array to an XML document will generally require a root
element.  Bedrock will use the C<RootName> option of the
C<XML-E<gt>out> object as the root element when converting Bedrock
arrays to XML.

I<If your goal is to build a Bedrock component or service that outputs
an XML document that may be utilized by another web application or an
AJAX component for example, you may also want to set the content type
of the document being served.  This can be done using the C<$header>
object.>

  <null $header.content_type('application/xml')><var --xml $xml>

see perldoc C<XML::Simple> for more details regarding options that you
can use to control XML parsing.

=item  Experimental Options

There are some experimental options that may be implemented or partially implented.

=over 5

=item  decode

Provides the same functionality found in the Oracle DECODE function,
namely it will translate a scalar value base on a list of key/value
pairs you provide.

The argument to the C<--decode> option is currently defined to be a JSON string that represents a hash.  For example:

 <null:foo 3>
 <var $foo --decode='{1:"red", 2:"green", 3:"blue", 4:"yellow", default:"unknown"}'>

=item  toggle

Outputs a value based on two alternatives, alternating between the two.

  <var $foo --toggle="a,b">

If C<$foo> = 'a', then Bedrock will output 'b', else if C<$foo> is 'b'
Bedrock will output 'a'

=back

=over 5

B<The following options are HIGHLY experimental...and thus not yet documented!>

The gist of these experimental options is to help in the construction of HTML pages.

=item  table

=item  ul

=item  div

=item  span

=item  select

=item  select-group

=item  column

=item  textarea

=back

=back

=head1 DESCRIPTION

The C<E<lt>varE<gt>> tag is the principal way that output from Bedrock
objects is included in your Bedrock pages.  It indicates to Bedrock
that the value of the expression is to be included in the page at the
point at which the tag is encountered.

The object of the tag is an Bedrock expression which may consist of
things like scalars, method calls, or concatenated strings using the
'+' operator.  Bedrock's parsing is rather primitive, so use
parentheses liberally and in fact B<must be used when using the '+'
operator>.  Some exmamples of expressions include things like:

  $foo

  $some_object.foo()

  ($foo + "-" + $bar)

The use cases for this tag include:

Output the value of scalar:

 <var $some_variable>

Output the value of a method call of an object:

 <var $input.get("foo")>

Dump an array (equivalent to array.join(''))

 <var $input.keys()>

Translate the value of an expression:

 <var --json $foo>
 <var --htmlencode $foo>
 <var --urlencode $foo>
 <var --decode='{1:"red", 2:"green", 3:"blue"}' $foo>
 <var --toggle="1,0" $foo>
 <var --format="%5.2f" $foo>

=head1 EXAMPLE

  <var --default="Please enter a value" $input.fname>
  <var --format="%5.2f" $input.cost>

=head1 NOTES

In Bedrock I (during the Stone Age) using the C<E<lt>varE<gt>> tag on
arrays or objects was undefined.  In Bedrock II at least, array
references are dumped...in other words something similar to:

  <var $array.join('')>

...is done to provide something a tad more satisfying than C<Bedrock::Array>.

We're still debating what to do with objects. A JSON representation
might be appropriate as the default I<stringified> representation of an
object.  The jury is still out.  Send your comments to bedrock-dev@cj-mailman.choicepoint.net

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.27  2010/01/03 19:15:24  rlauer
# add --xml option
#
# Revision 1.26  2009/12/31 18:38:40  rlauer
# updated docs
#
# Revision 1.25  2009/12/31 12:43:36  rlauer
# more robust documentation
#
# Revision 1.24  2009/12/30 12:42:13  rlauer
# dump array references rather than "Bedroc::Array" as output
#
# Revision 1.23  2009/12/30 00:15:11  rlauer
# log messages on verbose only
#
# Revision 1.22  2009/12/29 12:23:26  rlauer
# check to see if object is a tied scalar and access value via reference on output
#
# Revision 1.21  2009/12/28 20:31:34  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.20  2009/12/28 19:28:26  rlauer
# renamed BLM::IndexedTableHandler::Common to Bedrock::HTML::Helper
#
# Revision 1.19  2009/12/26 15:18:53  rlauer
# remove BLM::OrderedObject since all objects are now ordered
#
# Revision 1.18  2009/12/17 13:14:57  rlauer
# added span tag
#
# Revision 1.17  2009/12/16 23:25:09  rlauer
# wip - html widgets
#
# Revision 1.16  2009/12/15 23:09:59  rlauer
# wip - html options to var like --div/table/ul/select, etc
#
# Revision 1.15  2009/12/09 12:52:16  rlauer
# added decode/toggle
#
# Revision 1.14  2008/12/03 14:01:20  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.13  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.12  2001/02/14 15:35:50  sridhar
# Added copyright and GPL notice
#
# Revision 1.11  2000/08/21 18:14:21  sridhar
# Added --format option to <var>
#
# Revision 1.10  2000/07/11 20:57:45  sridhar
# Added --HTMLEncode option to encode [<>&] in output.
#
# Revision 1.9  2000/05/31 15:00:21  sridhar
# Rigorous version numbering and usage
#
# Revision 1.8  2000/04/24 12:48:28  sridhar
# Using TagX::Log for logging messages
#
# Revision 1.7  2000/04/13 15:20:37  sridhar
# Using new parse_options method with support for expressions
#
# Revision 1.6  2000/03/23 20:40:47  sridhar
# Can be used as <var $name>, in addition to the yet-supported
# <var --name = "$name">.
#
# Revision 1.5  2000/03/13 15:43:33  sridhar
# More verbose message logging.
#
# Revision 1.4  2000/03/09 14:18:34  sridhar
# Using Output handle object for printing which enables buffering.
#
# Revision 1.3  2000/03/06 18:32:00  sridhar
# Replaced all ad-hoc message logging with message logging only on demand
# -- via --verbose flag specified as a tag option
#
# Revision 1.2  2000/02/08 15:37:45  sridhar
# Added support for being able to use Exporter version numbers
#
# Revision 1.1  2000/02/08 15:25:00  sridhar
# Added TagX
#
#

1;
