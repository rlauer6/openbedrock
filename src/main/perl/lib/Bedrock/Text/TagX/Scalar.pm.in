#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package TagX::Scalar;

use strict;
use POSIX;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use SIS::Array;
use Text::URLEncode;

sub new
{
    my $class = shift;
    my $scalar = shift;
    bless \$scalar, $class;
}

sub length      { CORE::length(${$_[0]); }
sub chr		{my $self = $_[0]; return chr($$self)}
sub crypt	{my $self = $_[0]; return crypt($$self, $_[1])}
sub lc		{my $self = $_[0]; return lc($$self)}
sub lcfirst	{my $self = $_[0]; return lcfirst($$self)}
sub uc		{my $self = $_[0]; return uc($$self)}
sub ucfirst	{my $self = $_[0]; return ucfirst($$self)}
sub reverse	{my $self = $_[0]; return scalar reverse($$self)}
sub format	{my $self = $_[0]; return sprintf($_[1], $$self)}

sub substr
{
    my $self = shift;
    my $offset = shift;
    my $len = shift;
    if ( defined($len) ) {return substr($$self, $offset, $len)}
    else {return substr($$self, $offset)}
}

sub replace
{
    my $self = shift;
    my $pat = shift;
    my $repl = shift;
    my $flags = shift;

    if ( defined( $flags ) ) {
	# sort flag chars, eliminate dups
	$flags = join '', sort split '', $flags;
	$flags =~ s/(.)\1{1,}/$1/g;

	if ( $flags eq 'gim' ) {
	    $$self =~ s/$pat/$repl/gim;
	} elsif ( $flags eq 'gi' ) {
	    $$self =~ s/$pat/$repl/gi;
	} elsif ( $flags eq 'im' ) {
	    $$self =~ s/$pat/$repl/im;
	} elsif ( $flags eq 'gm' ) {
	    $$self =~ s/$pat/$repl/gm;
	} elsif ( $flags eq 'g' ) {
	    $$self =~ s/$pat/$repl/g;
	} elsif ( $flags eq 'i' ) {
	    $$self =~ s/$pat/$repl/i
	} elsif ( $flags eq 'm' ) {
	    $$self =~ s/$pat/$repl/m;
	}
    } else {
	$$self =~ s/$pat/$repl/;
    }
    $$self;
}

sub split
{
    my $self = shift;
    my $pat = shift;
    my $max = shift;
    $pat = '\s+' unless defined $pat;
    my @a;
    if ( defined($max) ) {
	@a = split /$pat/, $$self, $max;
    } else {
	@a = split /$pat/, $$self;
    }
    return SIS::Array->new(@a);
}

sub align_left
{
    my $self = shift;
    my $cols = shift;
    sprintf( "%-" . $cols . "s", $$self );
}

sub align_center
{
    my $self = shift;
    my $cols = shift;

    my $nspaces = $cols - CORE::length($$self);
    return sprintf( "%." . $cols . "s", $$self ) if $nspaces <= 0;
    my $padding = ' ' x ($nspaces / 2);
    sprintf( $padding . "%s" . $padding . ($nspaces % 2 ? ' ': ''), $$self );
}

sub align_right
{
    my $self = shift;
    my $cols = shift;
    sprintf( "%" . $cols . "s", $$self );
}

sub align
{
    my $self = shift;
    my $l_c_r = shift;

    for ($l_c_r) {
	/left/i and return $self->align_left(@_);
	/center/i and return $self->align_center(@_);
	/right/i and return $self->align_right(@_);
    }
}

sub rtrim
{
    my $self = shift;
    my $s = $$self;
    $s =~ s/\s+$//;
    $s;
}

sub ltrim
{
    my $self = shift;
    my $s = $$self;
    $s =~ s/^\s+//;
    $s;
}

sub trim
{
    my $self = shift;
    my $s = $$self;
    $s =~ s/^\s*(.*?)\s*$/$1/;
    $s;
}

sub format_time
{
    my $self = shift;
    my $s = $$self;
    if ( @_ > 0 ) {
	return &POSIX::strftime($_[0], localtime($s));
    } else {
	return scalar(localtime($s));
    }
}

sub urlencode
{
    my $self = shift;
    return &Text::URLEncode::Encode($$self);
}

sub isEmpty
{
    my $self = shift;
    return undef unless defined($$self);
    return CORE::length($$self) > 0 ? 0 : 1;
}

sub htmlencode
{
    my $self = shift;
    $$self =~ s/\&/\&amp;/g;
    $$self =~ s/\</\&lt;/g;
    $$self =~ s/\>/\&gt;/g;
    $$self;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.10  2001/06/27 15:43:48  aviert
# Added length() method. This resulted in Ambiguity warnings
# between the new length method and CORE::length(). All
# other references to length were changed to CORE::length().
#
# Revision 1.9  2001/02/14 15:35:49  sridhar
# Added copyright and GPL notice
#
# Revision 1.8  2000/12/06 18:53:06  sridhar
# Added htmlencode() method.
#
# Revision 1.7  2000/11/29 21:01:53  sridhar
# Added method `isEmpty()'
#
# Revision 1.6  2000/10/24 17:02:38  sridhar
# Added method `urlencode()' to scalars
#
# Revision 1.5  2000/09/29 19:18:07  sridhar
# Added format_time() method to format a scalar as a timestamp using
# POSIX::strftime().
#
# Revision 1.4  2000/09/25 17:43:45  sridhar
# 1. Added methods align(), align_left(), align_center() and align_right()
# for aligning a string within a specified number of columns
# 2. Added trim(), ltrim() and rtrim() for trimming blanks at the
# beginning and the end.
#
# Revision 1.3  2000/09/11 17:41:33  sridhar
# Made the return value from split() a SIS::Array object so methods can
# be invoked on it.
#
# Revision 1.2  2000/08/31 17:21:29  sridhar
# Added method `split()' for splitting a string into an array of
# strings. Pattern defaults to white-space.
#
# Revision 1.1  2000/08/25 20:40:10  sridhar
# New module implementing operations on scalars in Bedrock.
#
#
