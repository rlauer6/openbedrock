package TagX::Scalar;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2026, TBC DevelopmentGroup, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock qw(toPascalCase toCamelCase to_snake_case);
use Bedrock::Array;
use Bedrock::BedrockJSON;
use Bedrock::Constants qw(:booleans :chars);
use Bedrock::Hash;
use Data::Dumper;
use Digest::SHA;
use English qw(-no_match_vars);
use List::Util qw(mesh none);
use MIME::Base64;
use POSIX;
use Scalar::Util qw(reftype);
use Text::URLEncode;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

use parent qw(Exporter);

########################################################################
sub new {
########################################################################
  my ( $class, $scalar ) = @_;

  $class = ref $class || $class;

  return bless \$scalar, $class;
}

{
  ## no critic (RequireArgUnpacking, ProhibitBuiltinHomonyms)
  ######################################################################

  ######################################################################
  sub chr     { my ($self) = @_; return CORE::chr ${$self}; }
  sub hex     { my ($self) = @_; return CORE::hex ${$self}; }
  sub lc      { my ($self) = @_; return CORE::lc ${$self}; }
  sub lcfirst { my ($self) = @_; return CORE::lcfirst ${$self}; }
  sub length  { my ($self) = @_; return CORE::length ${$self}; }
  sub oct     { my ($self) = @_; return CORE::oct ${$self}; }
  sub reverse { my ($self) = @_; return scalar CORE::reverse ${$self}; }
  sub uc      { my ($self) = @_; return CORE::uc ${$self}; }
  sub ucfirst { my ($self) = @_; return CORE::ucfirst ${$self}; }

  ######################################################################
  sub crypt  { my ( $self, @args ) = @_; return CORE::crypt ${$self}, @args; }
  sub format { my ( $self, @args ) = @_; return CORE::sprintf $args[0], ${$self}; }
  sub substr { my ( $self, @args ) = @_; return CORE::substr ${$self}, @args; }
  ######################################################################

  ######################################################################
  sub eq { my ( $self, $arg ) = @_; return ( ${$self} == $arg ); }
  sub ge { my ( $self, $arg ) = @_; return ( ${$self} >= $arg ); }
  sub gt { my ( $self, $arg ) = @_; return ( ${$self} > $arg ); }
  sub le { my ( $self, $arg ) = @_; return ( ${$self} <= $arg ); }
  sub lt { my ( $self, $arg ) = @_; return ( ${$self} < $arg ); }
  ######################################################################

  sub chomp {
    my ($self) = @_;

    my $value = ${$self};
    $value //= $EMPTY;
    CORE::chomp $value;

    return $value;
  }

  sub sprintf {
    my ( $self, @args ) = @_;

    die "argument to sprintf must be list or array ref\n"
      if ref $args[0] && reftype( $args[0] ) ne 'ARRAY';

    return CORE::sprintf ${$self}, ref $args[0] ? @{ $args[0] } : @args;
  }
}

########################################################################
sub translate {
########################################################################
  my ( $self, @args ) = @_;

  my $value = ${$self};

  my ( $from, $to ) = @args;

  die "arguments must be same length\n"
    if $to && CORE::length $from != CORE::length $to;

  $to   =~ s|/|\\/|xsm;
  $from =~ s|/|\\/|xsm;

  eval qq{\$value =~ tr/$from/$to/; }; ## no critic

  return $value;
}

########################################################################
sub snake_case {
########################################################################
  my ($self) = @_;
  return to_snake_case( ${$self} );
}

########################################################################
sub pascal_case {
########################################################################
  my ($self) = @_;
  return toPascalCase( ${$self} );
}

########################################################################
sub camel_case {
########################################################################
  my ($self) = @_;
  return toCamelCase( ${$self} );
}

########################################################################
sub muddle {
########################################################################
  my ( $self, $front, $back ) = @_;

  my $value = ${$self};

  return Bedrock::muddle($value)
    if !$front && !$back;

  return $value
    if CORE::length $value <= $front + $back;

  my $front_str = CORE::substr( $value, 0, $front );
  my $back_str  = CORE::substr( $value, -$back );

  return join q{}, $front_str, ( q{*} x ( CORE::length($value) - ( $front + $back ) ) ), $back_str;
}

########################################################################
sub base64 { goto &base64_encode; }
########################################################################

########################################################################
sub _base64 {
########################################################################
  my ( $self, $decode_flag, $arg ) = @_;

  if ( !defined $arg ) {
    $arg = ${$self};
  }

  return $decode_flag ? decode_base64($arg) : encode_base64($arg);
}

########################################################################
sub base64_encode {
########################################################################
  my ( $self, $arg ) = @_;

  return $self->_base64( 0, $arg );
}

########################################################################
sub base64_decode {
########################################################################
  my ( $self, $arg ) = @_;

  return $self->_base64( 1, $arg );
}

########################################################################
sub hmac_sha1 {
########################################################################
  my ( $self, $arg ) = @_;

  return Digest::SHA::hmac_sha1( ${$self}, $arg );
}

########################################################################
sub hmac_sha224 {
########################################################################
  my ( $self, $arg ) = @_;

  return Digest::SHA::hmac_sha224( ${$self}, $arg );
}

########################################################################
sub hmac_sha256 {
########################################################################
  my ( $self, $arg ) = @_;

  return Digest::SHA::hmac_sha256( ${$self}, $arg );
}

########################################################################
sub hmac_sha384 {
########################################################################
  my ( $self, $arg ) = @_;

  return Digest::SHA::hmac_sha384( ${$self}, $arg );
}

########################################################################
sub hmac_sha512 {
########################################################################
  my ( $self, $arg ) = @_;

  return Digest::SHA::hmac_sha512( ${$self}, $arg );
}

########################################################################
sub replace {
########################################################################
  my ( $self, $pat, $repl, $flags ) = @_;

  return ${$self}
    if !defined $pat || !defined $repl;

  $flags //= $EMPTY;

  foreach my $f ( split //isxm, $flags ) {
    die "invalid flag ($f). Valid flags are i,g,m,s\n"
      if none { CORE::lc $f eq $_ } qw(i g m s);
  }

  my $value = ${$self};

  eval "\$value =~ s/\$pat/\$repl/$flags;"; ## no critic

  if ($EVAL_ERROR) {
    die "Regex error in replace(): $EVAL_ERROR\n";
  }

  $self = bless \$value, ref $self;

  return $value;
}

########################################################################
sub split { ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $pat, $max ) = @_;

  if ( !defined $pat ) {
    $pat = '\s+';
  }

  my @parts;

  if ( defined $max ) {
    @parts = split /$pat/xsm, ${$self}, $max;
  }
  else {
    @parts = split /$pat/xsm, ${$self};
  }

  return Bedrock::Array->new(@parts);
}

########################################################################
sub align_left {
########################################################################
  my ( $self, $cols ) = @_;

  return CORE::sprintf( "%-${cols}s", ${$self} );
}

########################################################################
sub align_center {
########################################################################
  my ( $self, $cols ) = @_;

  my $nspaces = $cols - CORE::length( ${$self} );

  return CORE::sprintf( "%.${cols}s", ${$self} )
    if $nspaces <= 0;

  my $padding = $SPACE x ( $nspaces / 2 );

  return CORE::sprintf( $padding . "%s${padding}" . ( $nspaces % 2 ? $SPACE : $EMPTY ), ${$self} );
}

########################################################################
sub align_right {
########################################################################
  my ( $self, $cols ) = @_;

  return CORE::sprintf( "%${cols}s", ${$self} );
}

########################################################################
sub or { ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $val ) = @_;

  return ${$self} || $val;
}

########################################################################
sub sign {
########################################################################
  my ( $self, $val ) = @_;

  $val //= 0;

  if ( ( ${$self} - $val ) > 0 ) {
    return 1;
  }
  elsif ( ( ${$self} - $val ) < 0 ) {
    return -1;
  }
  else {
    return 0;
  }
}

########################################################################
sub toggle {
########################################################################
  my ( $self, @list ) = @_;

  if ( @list == 1 ) {
    @list = split /\s*,\s*/xsm, shift;
  }

  my ( $from, $to ) = @list;

  ${$self} = ( ${$self} eq $from ) ? $to : $from;

  return ${$self};
}

########################################################################
sub _decode {
########################################################################
  my ( $hash, $key ) = @_;

  if ( exists $hash->{$key} ) {
    return $hash->{$key};
  }
  elsif ( exists $hash->{default} ) {
    return $hash->{default};
  }

  return;
}

########################################################################
sub decode {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args > 1 ) {

    # if an odd number of elements, then last element is default
    if ( @args % 2 ) {
      my $default_value = pop @args;

      push @args, 'default', $default_value;
    }

    my %lookup = @args;

    return _decode( ${$self}, \%lookup );
  }
  else {
    my $json = shift @args;

    if ( ref $json =~ /object|hash/xsmi ) {
      return _decode( ${$self}, $json );
    }
    elsif ( ref $json ) {
      die "You must pass either a hash or scalar representing a JSON string.\n";
    }
    else {
      my $obj;

      eval { $obj = Bedrock::JSON::decode($json); };

      die "There was a problem decoding your JSON string ($json) - $EVAL_ERROR.\n"
        if $EVAL_ERROR;

      return _decode( ${$self}, $obj );
    }
  }
}

########################################################################
sub json {
########################################################################
  my ( $self, @args ) = @_;

  my $json = JSON->new;

  if ( !@args ) {
    $args[0] = ${$self};
  }

  $json->loose(JSON::true);
  $json->relaxed(JSON::true);

  my $data = $json->decode( $args[0] );

  if ( ref $data && reftype($data) eq 'HASH' ) {
    $data = Bedrock::Hash->new( %{$data} );
  }
  elsif ( ref $data && reftype($data) eq 'ARRAY' ) {
    $data = Bedrock::Array->new( @{$data} );
  }

  return $data;
}

########################################################################
sub align {
########################################################################
  my ( $self, $alignment_flag, @args ) = @_;

  if ( $alignment_flag eq 'left' ) {
    return $self->align_left(@args);
  }
  elsif ( $alignment_flag eq 'center' ) {
    return $self->align_center(@args);
  }
  elsif ( $alignment_flag eq 'right' ) {
    return $self->align_right(@args);
  }

  die "invalid alignment flag, must be 'left', 'center' or 'right'\n";
}

########################################################################
sub rtrim {
########################################################################
  my ($self) = @_;

  my $s = ${$self};

  $s =~ s/\s+\z//xsm;

  return $s;
}

########################################################################
sub ltrim {
########################################################################
  my ($self) = @_;

  my $s = ${$self};

  $s =~ s/\A\s+//xsm;

  return $s;
}

########################################################################
sub trim {
########################################################################
  my ($self) = @_;

  my $s = ${$self};

  $s =~ s/^\s*(.*?)\s*$/$1/;
  return $s;
}

########################################################################
sub format_time {
########################################################################
  my ( $self, $format ) = @_;

  my $time = ${$self} // time;

  return $format ? POSIX::strftime( $format, localtime $time ) : scalar localtime $time;
}

########################################################################
sub urlencode {
########################################################################
  my ($self) = @_;

  return Text::URLEncode::Encode( ${$self} );
}

# returns undef = null string, 0 = string of length 0, string of length > 0
########################################################################
sub isEmpty {
########################################################################
  my ($self) = @_;

  return if !defined ${$self};

  return CORE::length ${$self} == 0;
}

########################################################################
sub htmlencode {
########################################################################
  my ($self) = @_;

  Text::URLEncode::htmlencode( ${$self} );

  return ${$self};
}

########################################################################
sub matches {
########################################################################
  my ( $self, $pattern, $flags ) = @_;

  $flags //= $EMPTY;

  die "invalid flags: only i, m, g or s\n"
    if $flags && $flags !~ /^[imsg]+$/xsm;

  my $global = ( $flags && $flags =~ s/g//xsm ) ? $TRUE : $FALSE;

  # 2. FIX: Include the remaining flags in the pattern string
  my $re = eval {
    require Bedrock::RegExp;

    # Append flags to the regex delimiters
    my $final_pattern
      = $pattern =~ m{\A (?: / | qr ) }xms
      ? $pattern
      : "/$pattern/$flags";  # Now includes i, m, or s

    return Bedrock::RegExp::regexp_compile($final_pattern);
  };

  die "invalid regexp: $pattern\n$EVAL_ERROR\n"
    if $EVAL_ERROR || !$re;

  my $result = Bedrock::Array->new();
  my $target = ${$self};

  if ($global) {
    push @{$result}, ( $target =~ /$re/g );
  }
  else {
    # Perform match and capture result buffers
    if ( $target =~ /$re/ ) {
      # Use the special @- and @+ arrays to extract all match components
      # $0 is the full match, $1, $2... are capture groups
      no strict 'refs'; ## no critic
      for my $i ( 0 .. $#+ ) {
        push @{$result}, CORE::substr( $target, $-[$i], $+[$i] - $-[$i] );
      }
    }
  }

  return $result;
}

1;
