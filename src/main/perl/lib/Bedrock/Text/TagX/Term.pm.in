#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package TagX::Term;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION    = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use UNIVERSAL qw (isa);
use TagX::Log 1.01;

my $Verbose;

sub new
{
    my $class = shift;
    my $term = shift;
    bless \$term, $class;
}

sub verbose
{
    my $self = shift;
    if ( @_ ) {
	$Verbose = shift;
    }
    $Verbose;
}

sub resolve_var
{
    my $self = shift;
    my $name = shift;

    &log_message( undef, "$self: begin eval with ($name, @_)" ) if $Verbose;

    $name =~ s/^\$//;
    my @components = split /\./oi, $name;
    &log_message( undef, "$self: components of name are (@components)" ) if $Verbose;

    my $first = shift @components;
    unless ( $first ) {
	&log_message( undef, "$self: First component [$first] of name [$name] is undefined." )
	    if $Verbose;
	return undef;
    }

    if ( @components ) {
	unless ( $first =~ /^\w+$/o ) {
	    &log_message( undef, "$self: First component [$first] of name [$name] is not a word." )
		if $Verbose;
	    return undef;
	}
    } else {
	unless ( $first =~ /^(\w+|\@)$/o ) {
	    &log_message( undef, "$self: First component [$first] of name [$name] is not a word or `\@'." )
		if $Verbose;
	    return undef;
	}
    }

    my $found;
    for my $context (@_) {
	if ( exists $context->{$first} ) {
	    $found = $context->{$first};
	    last;
	}
    }
    &log_message( undef, "$self: [$first] found as [$found]" ) if $Verbose;
    return undef unless defined( $found );

    for (@components) {
	if ( /^\Q[\E(\d+)\Q]\E/oi ) {
	    # array element
	    my $i = $1;
	    &log_message( undef, "$self: looking for array item with index [$i]" ) if $Verbose;
	    unless ( &isa( $found, 'ARRAY') ) {
		&log_message( undef, "$self: [$found] is not an array." ) if $Verbose;
		return undef;
	    }

	    &log_message( undef, "$self: [$found] is an array" ) if $Verbose;
	    $found = $found->[$i];
	    next;
	}

	if ( /^{(.*?)}/oi or /^([^.]+)/oi ) {
	    # hash element
	    my $key = $1;
	    &log_message( undef, "$self: looking for a hash component [$key] in [$found]" ) if $Verbose;
	    if ( &isa( $found, 'HASH' ) ) {
		&log_message( undef, "$self: [$found] is a hash" ) if $Verbose;
		$found = $found->{$key};
	    } else {
		# Support syntax for accessing hash contained in an array
		# if the array contains only one element
		# Other cases are failures
		unless ( &isa( $found, 'ARRAY' ) and @{$found} == 1 ) {
		    &log_message( undef, "$self: [$found] is an array containing more than one element\n"
				  . ".. cannot access it as a hash" ) if $Verbose;
		    return undef;
		}
		&log_message( undef, "$self: [$found] is an array with a single element\n"
			      . ".. can access it as a hash" ) if $Verbose;
		$found = $found->[0]->{$key};
	    }
	    &log_message( undef, "$self: found component [$found]" ) if $Verbose;
	    next;
	}

	# illegal
	return undef;
    }
    $found;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.10  2000/06/07 18:00:21  sridhar
# Removed support for $joe.[$i] due to problems
#
# Revision 1.9  2000/06/07 15:38:55  sridhar
# *** empty log message ***
#
# Revision 1.8  2000/06/06 20:03:53  sridhar
# 1. Replaced object checking using ref() with isa()
# 2. Supports variable as an array index
#
# Revision 1.7  2000/05/31 15:36:42  sridhar
# Yuck! Compilation error (using `+' to add strings instead of `.')
#
# Revision 1.6  2000/05/31 14:21:12  sridhar
# Rigorous version numbering and usage
#
# Revision 1.5  2000/05/31 14:13:40  sridhar
# Rigorous version numbering and usage
#
# Revision 1.4  2000/05/31 14:06:21  sridhar
# Oops that contained some syntax errors
#
# Revision 1.3  2000/05/31 13:30:00  sridhar
# 1. Added a method `verbose' for turning on message logging
# 2. More verbose messages
#
# Revision 1.2  2000/04/19 20:05:31  sridhar
# BUG fix for resolving $@
#
# Revision 1.1  2000/04/13 15:13:00  sridhar
# Added TagX::Term -- class for handling terms -- component parts of an
# expression.
#
#
