#!/usr/bin/perl -w

package Text::TagX::Doc;

=head1 NAME

Text::TagX -- Perl class to recognize and expand tags in text files.

=head1 SYNOPSIS

In the program ..

    use Text::TagX;

    my $tx = Text::TagX->new ($input_handle, $output_handle, $warning_handler);
    $tx->param ('title' => 'Hello World',
		'name' => 'Scooby Doo',
		'remote_addr' => $ENV{REMOTE_ADDR},
		'timenow' => scalar(localtime));

    $tx->output;

In the text file ..

    <HTML>
    <HEAD>
    <TITLE><var --name = "title" --default "[no title specified]"> </TITLE>
    <BODY>
      Hi there, Your name is <var --name = "name" --default = "[no name]">.<BR>
      You seem to be coming from <var --name = "remote_addr" --default = "[unknown]"> <BR>
      The time now is <var --name = 'timenow'>.
    </BODY>

Of course, the text file need not be a HTML file.

=head1 DESCRIPTION

Use C<Text::TagX> to replace recognized tags within text files with dynamic content.
Tags are inserted within the text file which can be linked to certain variables within
the program, thus providing a linkage between an executing program and static text.

A tag definition begins with a '<' followed immediately by the tag name without intervening spaces,
followed by zero or more options, followed by a '>' to end the tag definition. Tag definition can span
multiple lines.

Each tag might require one or more arguments, some of which might be required, and some optional. All options
arguments start with C<-->. An option might require a value or might be a flag setting (without
value). Options which need a value follow the general syntax:

    --option = "value"

The quotes are optional, and any of C<[]>, C<{}>, C<()>, C<::>, C<''>, C<""> can be used in place of the quotes
to delimit the value. This convenience allows embedding of any character other than the delimiter within the value.

A Flag option is specified with the following syntax.

  --option

In the description below, optional tags are enclosed within C<[]> (just like in UNIX command descriptions).

=head2 Var

Use C<VAR> to substitute named variables with the text.

    <var --name = "name" [--default = "default"] [--URLEncode]>

Supported Options

B<--name = "name">
Used to identify the tag.

B<--default = "default">
Specify a default for the tag, substituted in case C<name> is undefined.

B<--URLEncode>
A flag which requests URL encoding of the value.

=over 4

=item Example

In the program ..

    use Text::TagX;

    my $tx = Text::TagX->new ($input_handle, $output_handle, $warning_handler);
    $tx->param ('title' => 'Hello World',
		'name' => 'Scooby Doo',
		'remote_addr' => $ENV{REMOTE_ADDR},
		'timenow' => scalar(localtime));

    $tx->output;

In the text file ..

    <HTML>
    <HEAD>
    <TITLE><var --name = "title" --default "[no title specified]"> </TITLE>
    <BODY>
      Hi there, Your name is <var --name = "name" --default = "[no name]">.<BR>
      You seem to be coming from <var --name = "remote_addr" --default = "[unknown]"> <BR>
      The time now is <var --name = 'timenow'>.
    </BODY>


=back

=head2 Include

To include files use <Include>. Some variables can also be defined for use within
the included as a part of the file inclusion process. The file modify time, change time and
access time can be defined as varibles, and the format of the time to be defined can also
be specified as a part of the tag definition.

    <include --dir-prefix = "Directory-Variable" --file = /some/file/here
             [--access-time = "access_time"]
             [--access-time-format = "strftime(3) format here"]
             [--change-time = "change_time"]
             [--change-time-format = "strftime(3) format here"]
             [--modify-time = "modify_time"]
             [--modify-time-format = "strftime(3) format here"]>

B<--dir-prefix = "Dir Var">
Specify a variable whose value is the directory containing the file.

B<--file = "file path">
Specify the full/partial pathname of the file to be included. If the full pathname (starting
with /) is specified, the C<--dir-prefix> option is ignored. Else, the file is searched
starting from the directory specified via C<--dir-prefix> option.

B<--access-time = "access_time">
Define a variable named C<access_time> to contain the time the file was last accessed.
This variable can be used within the included file.

B<--access-time-format = "strftime(3) format here">
Define the C<--access-time> variable with the time in this L<strftime(3)> format.

B<--change-time = "change_time">
Define a variable named C<change_time> to contain the time the file was last changed.
This variable can be used within the included file.

B<--change-time-format = "strftime(3) format here">
Define the C<--change-time> variable with the time in this L<strftime(3)> format.

B<--modify-time = "modify_time">
Define a variable named C<modify_time> to contain the time the file was last modified.
This variable can be used within the included file.

B<--modify-time-format = "strftime(3) format here">
Define the C<--modify-time> variable with the time in this L<strftime(3)> format.

=over 4

=item Example

The input:

    <HTML>
    <BODY>
      News today: <include --file = "news.html"
                           --modify-time = "last_updated"
                           --modify-time-format = "Last updated: %c">
    </BODY>
    </HTML>

=back

=head2 Foreach

To perform looping over an array use <Foreach>. The variable specified by C<--name> in the <Foreach>
tag must be an array of hash references, each hash defining the variables to be used with the loop.

    <foreach --name = "loop_1"
             [--define-index = "index_name"]
             [--start-index = "integer"]
             [--end-index = "integer"]
             [--max-items = "integer"]>
      ..
    </foreach>

B<--name = "name">
Identify the loop.

B<--define-index = "index_name">
Define a variable named C<index_name> to contain the loop index. This variable can be used
within the loop.

B<--start-index = "integer">
Specify the starting index of the loop. Items before the starting index are skipped. Index starts
from 0, anything less than 0 is ignored. Default is to start from 0.

B<--end-index = "integer">
Specify the last index for which the loop must be executed. Items after the specified index are
skipped. Default is one less than the number of items in the array.

B<--max-items = "integer">
Specify maximum number of iterations of the loop. Defaults to all the items in the array.

Only oneof C<--max-items> or C<--end-index> should be specified. If both are specified, C<--max-items>
setting takes precedence.

=over 4

=item Example

The input:

    <HTML>
    <BODY>
      Here is the list of users:
      <table> <tr><th>Name</th> <th>Extension</th></tr>
      <foreach --name = "userList">
        <tr> <td> <var --name = "userName"> </td>
             <td> <var --name = "userExt" --default = "[None defined]"></td>
        </tr>
      </foreach>
    </BODY>
    </HTML>

The program:

    ...
    my @userList;
    while (($name, $ext) = each %userInfo) {
	push @userList, {userName => $name, userExt => $ext};
    }
    $tx->param ( userList, \@userList );
    ...
    $tx->output;
    ...

=back

=head2 If

Use an <If> to check variable values, and conditionally do something. It comes in three flavors.

Do something if a variable named C<var_1> is defined.

    <if --name = "var_1"> .. </if>

Do something if a variable named C<var_1> is defined and equal to the value "value".

    <if --name = "var_1" --eq "value"> .. </if>

Do something if variables C<var_1> and C<var_2> are defined and equal to each other.

    <if --name = "var_1" --eq --name = "var_2"> .. </if>

In addition to C<--eq>, the following conditions can also be used.

B<--ne>
True if the left hand side is not equal to the right hand side.

B<--gt>
True if the left hand side is lexically greater than the right hand side.

B<--lt>
True if the left hand side is lexically less than the right hand side.

B<--ge>
True if the left hand side is lexically greater than or equal to the right hand side.

B<--gt>
True if the left hand side is lexically less than or equal to the right hand side.

B<--re>
True if the left hand side matches the regular expression on the right hand side.

=head3 Elseif

Use an <Elseif> tag within an C<<if>> .. C<</if>> block to conditionally execute one or more sub-blocks.
It has the same form as the <if> tag. Any number of C<<Elseif>> sub-blocks can appear within an C<<if>> .. C<</if>>
block.

    <if --name = "var_1">
      ...
    <elseif --name = "var_2">
      ...
    <elseif --name = "var_3" --eq "selected">
      ...
    </if>

It is a fatal error to use an C<<elseif>> tag except within an C<<if>> .. C<</if>> block.

=head3 Else

Use an <Else> sub-block as the last sub-block with an C<<If>> block. The C<<Else>> tag does not support any
options.

    <if --name = "var_1">
      ...
    <elseif --name = "var_2">
      ...
    <elseif --name = "var_3" --eq "selected">
      ...
    <else>
      ...
    </if>

It is a fatal error to use an C<<else>> tag except within an C<<if>> .. C<</if>> block.

=head2 SQLConnect

Connect to an SQL database using <SQLConnect>. 

    <sqlconnect [--data-source = "data_source"]
                [--dbname = "name"]
                [--username = "user"]
                [--password = "password"]
                [--AutoCommit = 0/1]
                [--PrintError = 0/1]
                [--RaiseError = 0/1]
                [--ChopBlanks = 0/1]>

All Options are optional. Defaults are as noted.

B<--data-source = "data source name">
The connect string passed to C<DBI::Connect>. Should be the DBI identifier for a database.
Default is the environment variable C<DBI_DSN>.

B<--dbname = "name">
Assign a symbolic name to the connection. Subsequent SQL commands can then refer to this connection
using the C<--dbname> option. If no name is assigned, subsequent commands should not use the C<--dbname>
option. Names should be assigned to be able to connect to more than one database at a time.

B<--username = "username"> and B<--password = "password">
Specify the connection username and password.

B<--AutoCommit = 0/1>
Turn on or off the C<AutoCommit> option of DBI.

B<--PrintError = 0/1>
Turn on or off the C<PrintError> option of DBI.

B<--RaiseError = 0/1>
Turn on or off the C<RaiseError> option of DBI.

B<--ChopBlanks = 0/1>
Turn on or off the C<ChopBlanks> option of DBI.

=head2 SQLSelect

Perform an SQL query using <SQLSelect>. 

    <sqlselect --statement = "select statement here"
               [--dbname = "symbolic_name"]
               [--bind = "var_name"]
               [--arg = "var_name"]
               [--define-var = "var_name"]
               [--need-rows = "number" [--raise = "error message"]] >
      ...
    </sqlselect>

Options are

B<--dbname = "symbolic_name">
Execute the query on this connection. C<symbolic_name> must have been defined in a previous C<<sqlconnect>>
statement for this options to be useful.

B<--statement = "select statement">
Specify the SQL query statement. The selected column names in the select statement must be aliased to
names comprised entirely of alphanumeric characters to be able to access the column value.

B<--bind = "var_name">
Use the value of the variable C<var_name> to bind to values in the select statement. Any number of C<--bind>
options can be used to bind more than one variable.

B<--arg = "var_name">
Use the value of the variable C<var_name> to substitute C<printf> directives in the SQL statement. Any number of
C<--arg> options can be used to substitute more than one variable.

B<--define-var = "var_name">
Define a variable named C<var_name> to contain all the rows extracted as the result of the query. This variable
is defined as an array of hash references, each hash containing the column name-value pairs. The variable
so defined can be used in a C<<Foreach>> statement.

B<--need-rows = "number" [--raise = "error message"]>
Require the C<SQLSelect> statement to find a specified number of rows failing which an exception is thrown.
The exception to be thrown can be specified with the C<--raise> option (which is useful only if C<--need-rows>
is specified).

The C<number> argument for C<--need-rows> should be specified as below.

=over 8

=item --need-rows = C<+integer>

Specifies that number of rows found be more than or equal to C<integer>.

=item --need-rows = C<-integer>

Specifies that number of rows found be less than or equal to C<integer>.

=item --need-rows = C<integer>

Specifies that number of rows found be exactly equal to C<integer>.

=back

=head2 SQL

Use C<SQL> to execute arbitrary SQL statements against the database.

    <sql --statement = "sql statement"
         [--dbname = "symbolic_name"]
         [--bind = "var_name"]
         [--arg = "var_name"]>

Options are

B<--dbname = "symbolic_name">
Execute the SQL statement on this connection. C<symbolic_name> must have been defined in a previous C<<sqlconnect>>
statement for this options to be useful.

B<--statement = "select statement">
Specify the SQL statement.

B<--bind = "var_name">
Use the value of the variable C<var_name> to bind to values in the SQL statement. Any number of C<--bind>
options can be used to bind more than one variable.

B<--arg = "var_name">
Use the value of the variable C<var_name> to substitute C<printf> directives in the SQL statement. Any number of
C<--arg> options can be used to substitute more than one variable.

=head2 Trace

Use C<TRACE> to trace execution state of the application.

    <trace [--dump-vars]
           [--[no]output]
           [--compact]>

Options are

B<--dump-vars>
Write all the defined variables to the log file.

B<--[no]output>
Include (do not include) information about variables in the output.

B<--compact>
Use compact form of variable dump.

=head1 NOTES

=head2 Common Options

The following options are supported by all the tags.

B<--verbose>
Generates extensive debugging information while processing the tag.

=head2 Variable Prefix

All variable names should be prefixed with C<$>. Though alternative syntax not requiring C<$> is
currently supported, it is deprecated. This support will soon be removed (and hence your scripts
will break :-). Use C<$> as the prefix in all instances where variables are used.

=head2 Variable Specification

Variables can be specified without I<context> information as in

    <var --name = "$edit" --default = "no edit">

or with full I<context> information as in 

    <var --name = "$input.edit" --default = "no edit">

in which case, the value for the variable I<$edit> is taken from the hash I<$input>, which could be defined
in the program as follows.

    use Text::TagX;

    my $tx = Text::TagX->new ($input_handle, $output_handle, $warning_handler);
    $tx->param ('input' => {'edit' => 1},
		'title' => 'Hello World',
		'name' => 'Scooby Doo',
		'remote_addr' => $ENV{REMOTE_ADDR},
		'timenow' => scalar(localtime));

    $tx->output;

Note carefully that I<$edit> is defined as a member of the hash I<$input>. If the variable is specified
without the context, it is located only if the enclosing block has defined it in. For example, I<$index> in the
example below is defined in the C<Foreach>, but not outside it.

In the program:

    $tx->param ('input' => [{'index' => 1, 'value' => 'apples'},
			    {'index' => 2, 'value' => 'oranges'}]);

In the HTML:

    <foreach --name = "$input">
      Index is defined here to be <var --name = "$index"> and value is <var --name = "$value">
    </foreach>

    Index here is undefined: <var --name = "$index"> and value is <var --name = "$value">

The syntax for refering to elements with intervening array elements is as follows. Given the definitions
in the above example, the following are valid references.


    The following are defined: <var --name = "$input.[0].index"> and value is <var --name = "$input.[0].value">
                               <var --name = "$input.[1].index"> and value is <var --name = "$input.[1].value">


Array elements are dereferenced by enclosing the array index within C<[]>  as shown above.

=cut

1;
