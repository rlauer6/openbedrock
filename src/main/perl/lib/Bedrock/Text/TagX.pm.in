#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package Text::TagX;

use strict;
use Carp;
use UNIVERSAL qw (isa);

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    @ISA	= qw (Exporter);
}

#
# Version number is composed as follows:
#    x.yyzz
# where
#    x => Version identifier changes if major changes in TagX, like
#         design changes, changing how the parser works, etc.
#   yy => Identifier changes if semi-major changes in TagX, like
#         addition of new tags, removal of existing tags, major
#         changes in options to tags, etc. Change in this number
#         may indicate that older scripts will break or may cause
#         inconsistent behavior.
#   zz => This changes with each bug fix, small updates or enhancements,
#         changes which may not break existing scripts (though
#         nothing is guaranteed), etc.
#
$VERSION	= '1.0502';

use Text::URLEncode;

use TagX::Symtab;
use TagX::Error;
use TagX::Expr 1.11;
use TagX::Func 1.05;
use TagX::Log 1.02;
use TagX::Output 1.07;
use TagX::Parser 1.05;
use TagX::Scalar 1.05;
use TagX::TAG 1.19;
use TagX::TAG::NoBody 1.04;
use TagX::TAG::NoBody::Exec 1.01;
use TagX::TAG::NoBody::Include 1.07;
use TagX::TAG::NoBody::NULL 1.02;
use TagX::TAG::NoBody::Raise 1.04;
use TagX::TAG::NoBody::SQL 1.09;
use TagX::TAG::NoBody::SQLConnect 1.09;
use TagX::TAG::NoBody::Trace 1.10;
use TagX::TAG::NoBody::Var 1.11;
use TagX::TAG::WithBody 1.07;
use TagX::TAG::WithBody::Cache;
use TagX::TAG::WithBody::Catch 1.05;
use TagX::TAG::WithBody::If 1.09;
use TagX::TAG::WithBody::If::Else 1.03;
use TagX::TAG::WithBody::Loop 1.03;
use TagX::TAG::WithBody::Loop::Foreach 1.15;
use TagX::TAG::WithBody::Loop::SQLSelect 1.12;
use TagX::TAG::WithBody::Loop::While 1.02;
use TagX::TAG::WithBody::Sink 1.01;
use TagX::TAG::WithBody::Try 1.05;
use TagX::Term 1.12;
use TagX::Term::String 1.03;
use TagX::Term::Var 1.02;

$Text::TagX::Opentag_expr	= '^(var|sink|include|sql|sqlconnect|trace|foreach|sqlselect|while|if|else?if|try|catch|raise|else|null|exec)(?=\W)';
$Text::TagX::Closetag_expr	= '^(/sink|/sqlselect|/foreach|/while|/if|/try)>';
$Text::TagX::Options_expr	= '^\s*(([^>\\\\]|\\\\.)*)>';

sub parse
{
    my $self = shift;
    my $newscan = 1;

    my $obj = TagX::TAG::WithBody::Cache->new( $self );
    my $input = $self->{'input'};
    my $optstring = '';

    my $text = '';
    my $line = 0;
    my $file = $self->{'error'}->file;

    local($_);
  INPUT:
    while (<$input>) {
	$self->{'error'}->line(++$line);
      MAIN: {

	  #
	  # Check whether we are into a new scan or collecting options
	  # for a matched tag
	  #
	  unless ( $newscan ) {

	      # Collecting options for a matched tag -- Look for tag end which is
	      # an un-escaped '>'
	      if ( s/$Text::TagX::Options_expr//o ) {

		  # Found an un-escaped '>', which terminates the current tag and its options
		  # $optstring contains the options collected so far
		  $optstring .= $1;

		  # Remove escapes from the option string
		  $optstring =~ s/\\([^\\])/$1/g;
		  $optstring =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $optstring );

		  # Start a new scan after this
		  $newscan = 1;

		  # Handle possible left over stuff after the '>'
		  redo MAIN;
	      } else {

		  # No terminating '>' in entire line -- start by reading input again
		  $optstring .= $_;
		  next INPUT;
	      }
	  }

	  # New scan from here -- scan afresh for tags.
	  # if no '<' found in line, skip line
	  unless ( s/^(.*?)<//oi ) {
	      $text .= $_ if length;
	      next INPUT;
	  }

	  $text .= $1 if length($1);

	  # We did find a '<' -- could be we have a possible supported tag next
	  # Check if we have a supported tag
	  if ( s/$Text::TagX::Opentag_expr//oi ) {

	      # Yes we do
	      # The text before the '<' needs to be processed.
	      if ( length($text) ) {
		  $obj->text ( $text );
		  $text = '';
	      }

	      for ($1) {
		  /^var$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Var->new );
		      last;
		  };

		  /^sqlconnect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQLConnect->new );
		      last;
		  };

		  /^sql$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQL->new );
		      last;
		  };

		  /^include$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Include->new );
		      last;
		  };

		  /^foreach$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::Foreach->new );
		      last;
		  };

		  /^sink$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Sink->new );
		      last;
		  };

		  /^sqlselect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::SQLSelect->new );
		      last;
		  };

		  /^while$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::While->new );
		      last;
		  };

		  /^if$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::If->new );
		      last;
		  };

		  /^else?if$/oi		and do {
		      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
		      last;
		  };

		  /^else/oi		and do {
		      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
		      last;
		  };

		  /^trace$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Trace->new );
		      last;
		  };

		  /^raise$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Raise->new );
		      last;
		  };

		  /^try$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Try->new );
		      last;
		  };

		  /^catch$/oi		and do {
		      $obj = $obj->catch( TagX::TAG::WithBody::Catch->new );
		      last;
		  };

		  /^null$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::NULL->new );
		      last;
		  };

		  /^exec$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Exec->new );
		      last;
		  };

		  die "Tag <$_> NYI";
	      }

	      $obj->start_location( $file, $line );

	      # After creating object of suitable type depending on the tag, check
	      # if the tag ends on the same line. Tag ending is an un-escaped '>'.
	      if ( s/$Text::TagX::Options_expr//oi ) {

		  # The tag definition ended on same line -- all options specified on
		  # one line
		  my $options = $1;

		  # Unescape the options
		  $options =~ s/\\([^\\])/$1/g;
		  $options =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $options );

		  # And rescan the string for more tags -- Note that $newscan is unchanged
		  # from its value of 1, so we don't need to set it here
		  redo MAIN;
	      } else {

		  # Tag definition did not end on one line -- Further input is consumed for
		  # looking for the tag ending
		  $newscan = 0;

		  # Start collection of the options string
		  $optstring = $_;
	      }

	  } elsif ( s/$Text::TagX::Closetag_expr//oi ) {

	      # A tag has ended. The text before the '<' needs to be processed.
	      if ( length($text) ) {
		  $obj->text ( $text );
		  $text = '';
	      }

	      # Check whether we have hit a tag-body-ending tag
	      # and if so, end the current object
	      $obj = $obj->end_child;

	      # And rescan string for more tags
	      redo MAIN;
	  } else {

	      # Unsupported tag hit -- output the '<' since we don't consume it
	      $text .= '<';

	      # And rescan for more tags
	      redo MAIN;
	  }
      }
    }

    if ( $obj->parent ) {
	my ($file, $line) = $obj->start_location;
	die "Tag on line $line, file $file not closed properly.\n";
    }

    if ( length($text) ) {
	$obj->text ( $text );
	$text = '';
    }

    $obj->finalize;
}

sub output
{
    my $self = shift;
    eval { $self->parse };
    $self->{'__input_opened'}->close if $self->{'__input_opened'};
    if ( $@ ) {
	chomp $@;
	$self->error->mesg($@);
	die "$@\n";
    } else {
	$self->error->endLevel;
    }
}

sub show_error
{
    my $self = shift;
    my $errfile = shift;
    local(*FILE);
    open( FILE, $errfile ) or die "Unable to open $errfile: $!\n";
    $self->{'input'} = *FILE;
    my $error = $self->{'error'};
    $self->{'error'} = TagX::Error->new($errfile);
    $self->param('ERROR' => $error);
    $self->output;
    close FILE;
}

sub error
{
    $_[0]->{'error'};
}

sub define_name
{
    my ($self, $name, $value) = @_;
    my @components = split /\./oi, $name;
    return unless @components;

    &log_message( undef, "$self: components are (@components)" );
    my $found = $self->{'VARS'};
    for (@components) {
	if ( /^\Q[\E(\d+)\Q]\E/ ) {
	    # array element
	    if ( &isa( $found, 'ARRAY' ) ) {
		$found = $found->[$1];
		next;
	    } else {
		&log_message ( undef, "Cannot define [$_] component in $name: $found is not an array" );
		return;
	    }
	}

	if ( /^(\w+)/ ) {
	    # hash element
	    my $key = $1;
	    if ( &isa( $found, 'HASH' ) ) {
		$found = $found->{$key};
	    } else {
		# Support syntax for accessing hash contained in an array
		# if the array contains only one element
		unless ( &isa( $found, 'ARRAY' ) and @{$found} == 1 ) {
		    &log_message( undef, "Cannot define [$_] component in [$name]: $found is an array\n"
				  . "containing more than one element .. cannot access it as a hash" );
		    return undef;
		}
		$found = $found->[0]->{$key};
	    }
	    next;
	}

	# illegal
	return;
    }
    &log_message( undef, "$self: finally found [$found]" );
    $found = $value;
}

sub param
{
    my $self = shift;
    my %args = @_;
    my ( $name, $value );
    while ( ( $name, $value) = each %args ) {
	if ( $name =~ /\./oi ) {
	    # more expensive resolve operation
	    $self->define_name ( $name, $value );
	} else {
	    $self->{'VARS'}->{$name} = $value;
	}
    }
}

sub out_handle
{
    my $self = shift;
    $self->{'out_handle'} = shift if @_ == 1;
    $self->{'out_handle'};
}

#
# Constructor -- Invoked as follows
#    $Class_or_Object->new( $Input_Handle [, $Output_Handle [, $Error_Handler ] ] )
# Return the constructed object
#
sub new
{
    my $proto = shift;
    my $input = shift;
    my $output = shift;
    my $error_handler = shift;
    my %args = @_;

    my ($class, $self);
    if ( $class = ref( $proto ) ) {
	$self = bless {'error' => {}}, $class;
	if ( $output ) { $self->out_handle( TagX::Output->new( $output ) ) }
	else { $self->out_handle( $proto->out_handle ) }
	$self->{'VARS'} = $proto->{'VARS'};
	$self->{'error'} = $proto->{'error'}->newLevel($input);
	$self->{'DB'} = $proto->{'DB'} if exists $proto->{'DB'};
    } else {
	$self = bless {}, $proto;
	$self->out_handle( TagX::Output->new( $output ) );
	$self->{'VARS'} = TagX::Symtab->new;
	$self->{'error'} = TagX::Error->new($input);
	$self->{'DB'} = {};
    }

    unless ( ref ($input) ) {
	my $file_or_fd = $input;
	$input = ref( $file_or_fd ) ? IO::Handle->new_from_fd( $file_or_fd ) : IO::File->new ( $file_or_fd );
	$self->{'__input_opened'} = $input;
	die "Unable to open [$file_or_fd] for input: $!\n" unless $input;
    }

    $self->{'input'} = $input;

    for (keys %args) {
	$self->{'VARS'}->{$_} = $args{$_};
    }

    $self;
}

#
# Hook for passing options to TagX.
# Takes an array which maps into a hash as arguments.
# valid options are
#   LOG_PREFIX          Directory and filename prefix for log file. An
#                       extension of `.log' is attached to this prefix
#   LOG_MAXSIZE         Maximum size of log file in bytes. If file is larger than
#                       this, it is truncated.
#   HEADER		Object for outputting headers.
# Returns: Nothing. 
sub options
{
    my $self = shift;
    my %args = @_;

    if ( exists $args{'LOG_PREFIX'} ) {
	my $pre = delete $args{'LOG_PREFIX'};
	my $max = delete $args{'LOG_MAXSIZE'};
	$max = 100000 unless defined ($max);
	&TagX::Log::start_logger (LOG_FILE	=> $pre . '.log',
				  LOG_MAXSIZE	=> $max);
    }

    if ( exists $args{'HEADER'} ) {
	$self->out_handle->header( delete $args{'HEADER'} );
    }

    my @keys = keys %args;
    die ref( $self ), "->options: unsupported option(s): (@keys)\n" if @keys > 0;
}

sub close
{
    my $self = shift;
    
    # Close any database handles left behind
    my @keys = keys %{$self->{'DB'}};
    for my $name (@keys) {
	my $dbh = $self->{'DB'}->{$name};
	my $rc = $dbh->disconnect;
	&log_message( undef, "Error shutting down db connection [$name]\n\t[" . $dbh->errstr . "]" )
	    unless $rc;
	delete $self->{'DB'}->{$name};
    }

    # Clean up symbol table.
    $self->{'VARS'}->close;
    delete $self->{'VARS'};
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.42  2000/11/22 15:20:34  sridhar
# No longer need to invoked `handle_error()' on the symbol table before
# showing error page since the symbol table keeps separate lists for
# variables bound to code and variables which have been
# constructed. Variables bound to code are not available when doing a
# dump on the symbol table.
#
# Revision 1.41  2000/11/20 18:11:22  sridhar
# Need to invoke Symbol table's `handle_error()' method before showing
# error page since variables bound to code needs to be deleted.
#
# Revision 1.40  2000/11/16 20:02:10  sridhar
# 1. Using globals for storing the opentag, closing tag and options
# parsing regex so other modules can use it.
# 2. Method `output()' now invoked `parse()' which does the bulk of the
# work which was being done by `output()'. Now `output()' does more of
# exception handling.
# 3. Stream lined error reporting with a class TagX::Error which stores
# the call call stack and locations.
# 4. Have a `show_error()' method which can be passed a file to use as
# the error reporting page.
#
# Revision 1.39  2000/11/13 18:48:55  sridhar
# 1. Using TagX::TAG::WithBody::Cache as the outer container since this
# can cache the output, thus allowing header settings anywhere within
# the webpage.
# 2. Text is now accumulated in a variable and $obj-text invoked only
# when required to -- just before processing a bedrock tag.
#
# Revision 1.38  2000/11/07 14:00:05  sridhar
# 1. Using TagX::Symtab for the symbol tables instead of a plain
# hash. Allows us to not construct an object till it is needed.
# 2. invoke the symbol table's `close()' method at close.
#
# Revision 1.37  2000/10/19 21:05:11  sridhar
# Version 1.0502 with the following changes
# 1. <hush> renamed to <sink>
# 2. Can pass one parameter to <sink> which should be a handle which can
# be written to.
#
# Revision 1.36  2000/10/18 18:19:04  sridhar
# 1. Complain louder if unable to open log file.
# 2. Added format_time() method to scalars to treat a scalar as a UNIX
# timestamp and format it using strftime()
# 3. Support for <hush></hush> tag.
#
# Revision 1.35  2000/10/17 15:39:42  sridhar
# 1. Complains if some tag has not been ended.
# 2. Need to finalize object after processing the file. Was a bug which
# would have been triggered if the entire contents of the file was in
# one line which was not terminated with "\n"
# 3. Input object not being checked for any methods if it is a ref.
#
# Revision 1.34  2000/10/16 14:01:12  sridhar
# Moved out @INC modification to Bedrock.pm
#
# Revision 1.33  2000/09/25 20:50:52  sridhar
# General:
# 1. --verbose settings are passed to function args too to enable more
# effective debugging.
# 2. When verbose level is >= 2, calling stack is printed using
# Carp::cluck().
#
# Scalars:
# 1. Added align() and align_left(), align_center() and align_right()
# methods to scalars.
# 2. Added trim(), ltrim() and rtrim() methods to scalars.
# 3. Return value from split() is a SIS::Array object so methods can be
# invoked on it.
#
# <null>:
# 1. Have a --define-array option which makes an array of the arguments,
# if any are present. Defines an empty array, if no arguments
# 2. --define-var makes an empty object if no arguments. Also makes an
# array of the arguments if more than one argument present.
#
# <sql>:
# 1. Argument to <sql> is treated as statement to execute if --statement is
# not used.
#
# <sqlconnect>:
# 1. RaiseError defaults to 1 (on)
# 2. Argument if present is treated as the data source to connect to if
# --data-source is not used.
#
# <foreach>:
# 1. Default value for --start-index when there are no arguments to
# <foreach>.
# 2. Loop data is the index when there are no arguments to loop or the
# argument is undefined.
# 3. Bug fix -- since arrays of ordinary scalars are supported, need to
# make sure context array passed to children are all hashes.
# 4. If more than one arg to <foreach>, they are coerced into an array.
#
# <sqlselect>:
# Argument is treated as SQL select statement to execute if --statement
# is not present.
#
# <while>
# 1. Default name for var is $_
# 2. Condition for loop should evaluate to false for termination
# (earlier it was undef)
#
# Revision 1.32  2000/09/08 15:29:15  sridhar
# Updated versions of various modules
#
# Revision 1.31  2000/09/08 15:27:56  sridhar
# Changes in version 1.0404
# 1. Support for methods on scalars like split(), replace(), etc.
# 2. Added long-needed `--alias = "name"' option to <foreach>
# 3. If <foreach> is invoked on a non-array, the item appears as a
# single element in an anonymous array
#
# Revision 1.30  2000/08/31 17:46:19  sridhar
# 1. Support for Bedrock scalars. Methods can be invoked on any scalar.
# 2. --alias option for <foreach>
# 3. Can use <foreach> on scalars -- will execute the loop once, unless
# the argument is undefined.
#
# Revision 1.29  2000/08/22 18:08:33  sridhar
# Changes from previous version:
# 1. Broken interpretation of `$@' fixed.
# 2. <trace> takes an optional variable name to print contents.
# 3. Added --format option to <var>
# 4. Fixed input file handle leak.
#
# Revision 1.28  2000/08/22 17:38:17  sridhar
# Close input file if we opened it (and not trust IO:: to deal with it
# -- gave rise to a leak of file handles)
#
# Revision 1.27  2000/08/17 17:37:20  sridhar
# Streamlining of version numbers.
#
# Revision 1.26  2000/08/17 17:23:46  sridhar
# Added support for <exec>.
#
# Revision 1.25  2000/08/11 17:09:12  sridhar
# Removed a destroy which was closing all database connections since we
# cannot afford that -- many scripts due database open in include files.
# This was originally needed since some scripts threw exceptions which
# were not caught. Hence close() was not being invoked with the result
# that database connections were left open in the mod_perl version. This
# situation is better handled by the client of TagX by trapping uncaught
# errors.
#
# Revision 1.24  2000/08/04 17:08:59  sridhar
# 1. Have a DESTROY which calls close -- useful when exceptions are
# thrown and are not caught
# 2. close deletes database handles which were closed so they don't get
# closed again.
#
# Revision 1.23  2000/07/20 20:26:13  sridhar
# 1. Added <while> loop.
# 2. Added --HTMLEncode option to <var>
# 3. Removed --name option from <foreach>
# 4. Fixed handling of --meta-info in <sqlselect> for mySQL
#
# Revision 1.22  2000/07/05 18:10:57  sridhar
# 1. Support for registering a header BLM for manipulation of HTTP
# header fields.
# 2. Some tweaking of <foreach> for speed improvement
# 3. <foreach> has multiple verbose levels.
# 4. <foreach> no longer needs an array of hash references and can loop
# over start and end indices.
# 5. Added `meta-info' option to <sqlselect>.
# 6. More options to TagX: HEADER option to specify an object with a
# print_header() method, which is invoked for generation of headers, if
# required.
#
# Revision 1.21  2000/06/28 18:57:21  sridhar
# 1. Not invoking $obj->text() method if no text to send.
# 2. Have a new object for setting headers
#
# Revision 1.20  2000/06/26 17:52:31  sridhar
# 1. Tuned Output.pm for speed
# 2. Tuned Foreach.pm for speed and use of --verbose more than once
# means more logging
# 3. Used isa() to check reference instead of ref().
# 4. Added --meta-info option to <sqlselect> to include more information
# about query
#
# Revision 1.19  2000/06/07 18:36:21  sridhar
# Removed a debug log message
#
# Revision 1.18  2000/06/06 20:10:28  sridhar
# 1. Added new tag <null> for object method invocation
# 2. Support in <foreach> to iterate over an array of ordinary elements
# 3. <trace> fixed to recognize objects properly
# 4. Half-finished version of define_name
#
# Revision 1.17  2000/06/01 18:51:09  sridhar
# 1. Support for invoking object methods
# 2. Brand new parser for parsing expressions.
#
# Revision 1.16  2000/05/31 15:15:39  sridhar
# Rigorous version numbering enforced across all modules.
#
# Revision 1.15  2000/05/30 17:48:55  sridhar
# Added a `close' method which cleans up database handles left
# open. Especially useful for mod_perl versions which cause the
# destructor to be called only when the Apache server exits.
#
# Revision 1.14  2000/05/03 18:51:54  sridhar
# 1. Hack to include proper path in @INC right next to the path where TagX
# was found
# 2. New versioning scheme not dependent on CVS versioning scheme
#
# Revision 1.13  2000/05/02 12:47:29  sridhar
# BUG FIX: fixed support for escaping '>' within SQL statements.
#
# Revision 1.12  2000/04/27 19:58:53  sridhar
# Fixed a confess message which was logging a wrong file name when including
# a file.
#
# Revision 1.11  2000/04/24 12:44:54  sridhar
# 1. Using new TagX::Log class.
# 2. Logging input filename with location.
# 3. Kicked out __start_logger and log_message methods.
#
# Revision 1.10  2000/04/19 20:01:28  sridhar
# New internal logging mechanism and a method for specifying options to
# tagx.
#
# Revision 1.9  2000/04/13 15:04:46  sridhar
# 1. Input can be a filename, handle or IO::
# 2. Handlers for warn and die.
# 3. Input filename logged with message logging
#
# Revision 1.8  2000/03/21 16:07:16  sridhar
# 1. Moved handling for <else> into main loop with others
# 2. <elseif> and <elsif> are both supported.
#
# Revision 1.7  2000/03/13 15:41:57  sridhar
# Bug fix: Opening Database in include page was causing database to be
# closed outside that page.
#
# Revision 1.6  2000/03/09 14:10:38  sridhar
# 1. Added <try>, <catch>, and <raise>.
# 2. Output is now not always written to output handle. Output can now
# be buffered. Added a new class Output for this. Buffering can be
# turned off and on at will.
#
# Revision 1.5  2000/03/06 18:29:31  sridhar
# Added support for <trace>, a very useful tool in debugging.
#
# Revision 1.4  2000/03/02 14:43:00  sridhar
# New class (Loop) between WithBody and Foreach, SQLSelect
#
# Revision 1.3  2000/03/02 13:44:39  sridhar
# 1. Added support for keeping track of line number of input.
# 2. Logging includes line number of current line
#
# Revision 1.2  2000/02/23 13:40:33  sridhar
# 1. Rearragement of program control
# 2. Added support for escaped '>' (does not terminate tag definition).
# 3. Added support for defining names other than at global level.
#
# Revision 1.1  2000/02/08 15:24:56  sridhar
# Added TagX
#
#

1;
