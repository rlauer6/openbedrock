#!/usr/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package Text::TagX;

use strict;
use Carp;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
    @ISA	= qw (Exporter);
}

use TagX::Output;
use TagX::TAG::WithBody;
use TagX::TAG::NoBody::Var;
use TagX::TAG::NoBody::Include;
use TagX::TAG::NoBody::SQL;
use TagX::TAG::NoBody::SQLConnect;
use TagX::TAG::NoBody::Trace;
use TagX::TAG::WithBody::Loop::Foreach;
use TagX::TAG::WithBody::Loop::SQLSelect;
use TagX::TAG::WithBody::If;
use TagX::TAG::WithBody::If::Else;
use TagX::TAG::WithBody::Try;
use TagX::TAG::WithBody::Catch;
use TagX::TAG::NoBody::Raise;

my %ErrorLevels = (MSG_DEBUG          => 1 << 1,
		   MSG_INFO           => 1 << 2,
		   MSG_STATUS         => 1 << 3,
		   MSG_WARNING        => 1 << 4,
		   MSG_ERROR          => 1 << 5,
		   MSG_FATAL          => 1 << 6);

sub output
{
    my $self = shift;
    my $newscan = 1;

    my $obj = TagX::TAG::WithBody->new( $self );
    my $input = $self->{'input'};
    my $optstring = '';
    $self->{'_line'} = 0;

  INPUT:
    while (<$input>) {
	$self->{'_line'}++;
      MAIN: {

	  #
	  # Check whether we are into a new scan or collecting options
	  # for a matched tag
	  #
	  unless ( $newscan ) {

	      # Collecting options for a matched tag -- Look for tag end which is
	      # an un-escaped '>'
	      if ( s/^(.*?[^\\])>// ) {

		  # Found an un-escaped '>', which terminates the current tag and its options
		  # $optstring contains the options collected so far
		  $optstring .= $1;

		  # Remove escapes from the option string
		  $optstring =~ s/\\([^\\])/$1/g;
		  $optstring =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $optstring );

		  # Start a new scan after this
		  $newscan = 1;

		  # Handle possible left over stuff after the '>'
		  redo MAIN;
	      } else {

		  # No terminating '>' in entire line -- start by reading input again
		  $optstring .= $_;
		  next INPUT;
	      }
	  }

	  # New scan from here -- scan afresh for tags.
	  # if no '<' found in line, skip line
	  unless ( s/^(.*?)<//oi ) {
	      $obj->text( $_ );
	      next INPUT;
	  }

	  # We did find a '<' -- could be we have a possible supported tag next
	  # The text before the '<' needs to be processed.
	  $obj->text ( $1 );

	  # Check if we have a supported tag
	  if ( s/^(var|include|sql|sqlconnect|trace|foreach|sqlselect|if|elseif|try|catch|raise)(?=\W)//oi ) {

	      # Yes we do
	      for ($1) {
		  /^var$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Var->new );
		      last;
		  };

		  /^sqlconnect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQLConnect->new );
		      last;
		  };

		  /^sql$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQL->new );
		      last;
		  };

		  /^include$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Include->new );
		      last;
		  };

		  /^foreach$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::Foreach->new );
		      last;
		  };

		  /^sqlselect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::SQLSelect->new );
		      last;
		  };

		  /^if$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::If->new );
		      last;
		  };

		  /^elseif$/oi		and do {
		      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
		      last;
		  };

		  /^trace$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Trace->new );
		      last;
		  };

		  /^raise$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Raise->new );
		      last;
		  };

		  /^try$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Try->new );
		      last;
		  };

		  /^catch$/oi		and do {
		      $obj = $obj->catch( TagX::TAG::WithBody::Catch->new );
		      last;
		  };

		  die "Tag <$_> NYI";
	      }

	      # After creating object of suitable type depending on the tag, check
	      # if the tag ends on the same line. Tag ending is an un-escaped '>'.
	      if ( s/^\s*(.*?[^\\]?)>//oi ) {

		  # The tag definition ended on same line -- all options specified on
		  # one line
		  my $options = $1;

		  # Unescape the options
		  $options =~ s/\\([^\\])/$1/g;
		  $options =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $options );

		  # And rescan the string for more tags -- Note that $newscan is unchanged
		  # from its value of 1, so we don't need to set it here
		  redo MAIN;
	      } else {

		  # Tag definition did not end on one line -- Further input is consumed for
		  # looking for the tag ending
		  $newscan = 0;

		  # Start collection of the options string
		  $optstring = $_;
	      }

	  } elsif ( s/^else>//oi ) {

	      # Check for more supported tags -- specifically '<else>' which
	      # can have no options
	      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );

	      # Rescan string for more tags
	      redo MAIN;
	  } elsif ( s:^(/sqlselect|/foreach|/doc|/if|/try)>::oi) {

	      # Check whether we have hit a tag-body-ending tag
	      # and if so, end the current object
	      $obj = $obj->end_child;

	      # And rescan string for more tags
	      redo MAIN;
	  } else {

	      # Unsupported tag hit -- output the '<' since we don't consume it
	      $obj->text( '<' );

	      # And rescan for more tags
	      redo MAIN;
	  }
      }
    }
}

sub define_name
{
    my ($self, $name, $value) = @_;
    my @components = split /\./oi, $name;
    return unless @components;

    my $found = $self->{'VARS'};
    for (@components) {

	if ( /^\Q[\E(\d+)\Q]\E/oi ) {
	    # array element
	    if ( ref( $found ) eq 'ARRAY' ) {
		$found = $found->[$1];
		next;
	    } else {
		$self->log_message ( MSG_WARNING => "Cannot define $name: not an array ref" );
		return;
	    }
	}

	if ( /^{(.*?)}/oi or /^([^.]+)/oi ) {
	    # hash element
	    if ( ref( $found ) eq 'HASH' ) {
		$found = $found->{$1};
		next;
	    } else {
		$self->log_message ( MSG_WARNING => "Cannot define $name: not a hash ref" );
		return;
	    }
	}

	# illegal
	return;
    }
    $found = $value;
}

sub param
{
    my $self = shift;
    my %args = @_;
    my ( $name, $value );
    while ( ( $name, $value) = each %args ) {
	if ( $name =~ /\./oi ) {
	    # more expensive resolve operation
	    $self->define_name ( $name, $value );
	} else {
	    $self->{'VARS'}->{$name} = $value;
	}
    }
}

sub log_message
{
    my $self = shift;
    return unless exists $self->{'error_handler'};
    my $level = shift;
    return unless $self->{'ErrorLevels'}->{uc $level} >= $self->{'error_level'};
    unshift @_, "[Line $self->{'_line'}]" if exists $self->{'_line'};
    goto &{$self->{'error_handler'}};
}

sub out_handle
{
    my $self = shift;
    $self->{'out_handle'} = shift if @_ == 1;
    $self->{'out_handle'};
}

#
# Constructor -- Invoked as follows
#    $Class_or_Object->new( $Input_Handle [, $Output_Handle [, $Error_Handler ] ] )
# Return the constructed object
#
sub new
{
    my $proto = shift;
    my $input = shift;
    my $output = shift;
    my $error_handler = shift;
    my %args = @_;

    confess qq(Input filehandle is not valid -- must support a method getline().\n)
	unless ref($input) and $input->can( 'getline' );

    my ($class, $self);
    if ( $class = ref( $proto ) ) {
	$self = bless {}, $class;
	$self->{'ErrorLevels'} = $proto->{'ErrorLevels'};
	$self->{'error_handler'} = $error_handler || $proto->{'error_handler'};
	$self->{'error_level'} = $proto->{'error_level'};
	$self->{'input'} = $input;
	if ( $output ) {
	    $self->out_handle( TagX::Output->new( $output ) );
	} else {
	    $self->out_handle( $proto->out_handle );
	}
	$self->{'VARS'} = $proto->{'VARS'};
	$self->{'DB'} = $proto->{'DB'} if exists $proto->{'DB'};
    } else {
	$self = bless {}, $proto;
	$self->{'ErrorLevels'} = \%ErrorLevels;
	$self->{'error_handler'} = $error_handler if ref ($error_handler) eq 'CODE';
	$self->{'error_level'} = $self->{'ErrorLevels'}->{'MSG_DEBUG'};
	$self->{'input'} = $input;
	$self->out_handle( TagX::Output->new( $output ) );
	$self->{'VARS'} = {};
	$self->{'DB'} = {};
    }

    for (keys %args) {
	$self->{'VARS'}->{$_} = $args{$_};
    }

    $self->log_message ( MSG_DEBUG => "Created $self" );
    $self;
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.7  2000/03/13 15:41:57  sridhar
# Bug fix: Opening Database in include page was causing database to be
# closed outside that page.
#
# Revision 1.6  2000/03/09 14:10:38  sridhar
# 1. Added <try>, <catch>, and <raise>.
# 2. Output is now not always written to output handle. Output can now
# be buffered. Added a new class Output for this. Buffering can be
# turned off and on at will.
#
# Revision 1.5  2000/03/06 18:29:31  sridhar
# Added support for <trace>, a very useful tool in debugging.
#
# Revision 1.4  2000/03/02 14:43:00  sridhar
# New class (Loop) between WithBody and Foreach, SQLSelect
#
# Revision 1.3  2000/03/02 13:44:39  sridhar
# 1. Added support for keeping track of line number of input.
# 2. Logging includes line number of current line
#
# Revision 1.2  2000/02/23 13:40:33  sridhar
# 1. Rearragement of program control
# 2. Added support for escaped '>' (does not terminate tag definition).
# 3. Added support for defining names other than at global level.
#
# Revision 1.1  2000/02/08 15:24:56  sridhar
# Added TagX
#
#

1;
