#!@PERL@ -w


#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package Text::TagX;

use strict;
use Carp;
use UNIVERSAL qw (isa);
use IO::Scalar;
use File::Basename;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  @ISA = qw (Exporter);
}

use TagX::Error;
use TagX::Expr;
use TagX::Func;
use TagX::Log;
use TagX::Output;
use TagX::Parser;
use TagX::Scalar;
use TagX::Symtab;
use TagX::TAG;
use TagX::TAG::NoBody;
use TagX::TAG::NoBody::Array;
use TagX::TAG::NoBody::Exec;
use TagX::TAG::NoBody::Comment;
use TagX::TAG::NoBody::Pebble;
use TagX::TAG::NoBody::Include;
use TagX::TAG::NoBody::Hash;
use TagX::TAG::NoBody::NULL;
use TagX::TAG::NoBody::Raise;
use TagX::TAG::NoBody::SQL;
use TagX::TAG::NoBody::SQLCommit;
use TagX::TAG::NoBody::SQLRollback;
use TagX::TAG::NoBody::SQLConnect;
use TagX::TAG::NoBody::SQLTable;
use TagX::TAG::NoBody::Open;
use TagX::TAG::NoBody::Plugin; 
use TagX::TAG::NoBody::RecordSet;
use TagX::TAG::NoBody::Case;
use TagX::TAG::NoBody::Trace;
use TagX::TAG::NoBody::Var;
use TagX::TAG::WithBody;
use TagX::TAG::WithBody::Cache;
use TagX::TAG::WithBody::Catch;
use TagX::TAG::WithBody::If;
use TagX::TAG::NoBody::Iif;
use TagX::TAG::WithBody::Unless;
use TagX::TAG::WithBody::If::Else;
use TagX::TAG::WithBody::Loop;
use TagX::TAG::WithBody::Loop::Foreach;
use TagX::TAG::WithBody::Loop::SQLSelect;
use TagX::TAG::WithBody::Loop::While;
use TagX::TAG::WithBody::NoExec;
use TagX::TAG::WithBody::PebbleDef;
use TagX::TAG::WithBody::Sink;
use TagX::TAG::WithBody::Snippet;
use TagX::TAG::WithBody::Try;
use TagX::Term;
use TagX::Term::String;
use TagX::Term::Var;

$Text::TagX::Opentag_expr =
'^(\#|\?|array|case|noexec|pebble|plugin|var|hash|include|sink|snippet|sql|sqlrollback|sqlcommit|sqlconnect|sqltable|trace|foreach|sqlselect|while|iif|if|unless|else?if|try|catch|raise|recordset|else|null|exec|open|pebbledef)(?=\W)';
$Text::TagX::Closetag_expr =
'^(/sink|/snippet|/sqlselect|/noexec|/pebbledef|/foreach|/while|/if|/unless|/try)>';
$Text::TagX::Options_expr = '^\s*(([^>\\\\]|\\\\.)*)>';

sub parse {
  my $self    = shift;
  my $newscan = 1;

  my $obj       = TagX::TAG::WithBody::Cache->new($self);
  my $input     = $self->{'input'};
  my $optstring = '';

  my $text = '';
  my $line = 0;
  my $file = $self->{'error'}->file;

  local ($_);
  my $raw;

  INPUT:
  while (<$input>) {
    # bedrock shell shebang
    next if $line == 0 && /^#!/;

    $self->{'error'}->line( ++$line );
    MAIN: {

      #
      # Check whether we are into a new scan or collecting options
      # for a matched tag
      #
      unless ($newscan) {

        # Collecting options for a matched tag -- Look for tag end which is
        # an un-escaped '>'
        if (s/$Text::TagX::Options_expr//o) {

     # Found an un-escaped '>', which terminates the current tag and its options
     # $optstring contains the options collected so far
          $optstring .= $1;

          # Remove escapes from the option string
          $optstring =~ s/\\([^\\])/$1/g;
          $optstring =~ s/\\\\/\\/g;

          # And set the current object options
          $obj = $obj->options($optstring);

          # Start a new scan after this
          $newscan = 1;

          # Handle possible left over stuff after the '>'
          redo MAIN;
        }
        else {

          # No terminating '>' in entire line -- start by reading input again
          $optstring .= $_;
          next INPUT;
        }
      }

      # New scan from here -- scan afresh for tags.
      # if no '<' found in line, skip line
      unless (s/^(.*?)<//oi) {
        $text .= $_ if length;
        next INPUT;
      }

      $text .= $1 if length($1);

      # We did find a '<' -- could be we have a possible supported tag next
      # Check if we have a supported tag
      my $tag = $_;

      if ( !$raw && s/$Text::TagX::Opentag_expr//oi ) {
        # Yes we do
        # The text before the '<' needs to be processed.
        if ( length($text) ) {
          $obj->text($text);
          $text = '';
        }

        for ($1) {
          /^var$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Var->new );
            last;
          };

          /^#$/ and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Comment->new );
            last;
          };

          /^case$/oi and do {
            $tag =~ /case:(.*?)\s+/i;
            $obj = $obj->new_child( TagX::TAG::NoBody::Case->new );
            last;
          };

          /^plugin$/oi and do {
            $tag =~ /plugin:(.*?)\s+/i;
            $obj = $obj->new_child( TagX::TAG::NoBody::Plugin->new );
            last;
          };

          /^sqlconnect$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::SQLConnect->new );
            last;
          };

          /^open$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Open->new );
            last;
          };

          /^iif$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Iif->new );
            last;
          };

          /^sql$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::SQL->new );
            last;
          };

          /^sqlcommit$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::SQLCommit->new );
            last;
          };

          /^sqlrollback$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::SQLRollback->new );
            last;
          };

          /^sqltable$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::SQLTable->new );
            last;
          };

          /^include$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Include->new );
            last;
          };

          /^foreach$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Loop::Foreach->new );
            last;
          };

          /^sink$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Sink->new );
            last;
          };

          /^snippet$/oi and do {
            die
"<snippet> is not enabled on your server. Set <scalar name='ALLOW_SNIPPET_TAG'>yes</scalar> in your tagx.xml file."
            unless $self->getoption('ALLOW_SNIPPET_TAG') =~ /^(yes|y|1)$/i;
            $obj = $obj->new_child( TagX::TAG::WithBody::Snippet->new );
            last;
          };

          /^sqlselect$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Loop::SQLSelect->new );
            last;
          };

          /^while$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Loop::While->new );
            last;
          };

          /^if$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::If->new );
            last;
          };
          /^unless$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Unless->new );
            last;
          };

          /^else?if$/oi and do {
            die "Tag is not valid here.\n" unless ref($obj) =~ /::(If|Unless)/;
            $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
            last;
          };

          /^else/oi and do {
            die "Tag is not valid here.\n" unless ref($obj) =~ /::(If|Unless)/;
            $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
            last;
          };

          /^trace$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Trace->new );
            last;
          };

          /^raise$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Raise->new );
            last;
          };

          /^try$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::Try->new );
            last;
          };

          /^catch$/oi and do {
            die "Tag is not valid here.\n"
            unless ref($obj) =~ /TagX::TAG::WithBody::(Try|Catch)/;
            $obj = $obj->catch( TagX::TAG::WithBody::Catch->new );
            last;
          };

          /^null$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::NULL->new );
            last;
          };

	  # the null tag = ?
          /^\?$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::NULL->new );
            last;
          };

          /^exec$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Pebble->new );
            last;
          };

          /^pebble$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Pebble->new );
            last;
          };

          /^pebbledef$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::PebbleDef->new );
            $raw = 1;
            last;
          };

          /^noexec$/oi and do {
            $obj = $obj->new_child( TagX::TAG::WithBody::NoExec->new );
            $raw = 1;
            last;
          };

          /^hash$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Hash->new );
            last;
          };

          /^array$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::Array->new );
            last;
          };

          /^recordset$/oi and do {
            $obj = $obj->new_child( TagX::TAG::NoBody::RecordSet->new );
            last;
          };

          die "Tag <$_> not implemented";
        }

        $obj->start_location( $file, $line );

        # After creating object of suitable type depending on the tag, check
        # if the tag ends on the same line. Tag ending is an un-escaped '>'.
        if (s/$Text::TagX::Options_expr//oi) {

	  if ( ref($obj) eq 'TagX::TAG::NoBody::Comment' && /$/ ) {
	    $_ = '';
	  }

          # The tag definition ended on same line -- all options specified on
          # one line
          my $options = $1;

          # Unescape the options
          $options =~ s/\\([^\\])/$1/g;
          $options =~ s/\\\\/\\/g;

          # And set the current object options
          $obj = $obj->options($options);

        # And rescan the string for more tags -- Note that $newscan is unchanged
        # from its value of 1, so we don't need to set it here
          redo MAIN;
        }
        else {

       # Tag definition did not end on one line -- Further input is consumed for
       # looking for the tag ending
          $newscan = 0;

          # Start collection of the options string
          $optstring = $_;
        }

      }
      elsif (s/$Text::TagX::Closetag_expr//oi) {

        my $end = lc($1);
        if ( $raw ) {
          if ( $end =~/\/(pebbledef|noexec)/ ) {
            $obj->text($text);
            $obj = $obj->end_child;
            $raw = 0;
	    $text = '';
          }
          else {
            $text .= '<' . $1 . '>';
          }
          redo MAIN;
        }
        else {
          die "Illegal tag-end encountered.\n" unless $obj->parent;
          $end = '/if' if $end eq '/unless';

          $self->improper_end( $obj, $end )
	    unless $obj->closure eq $end;

          # A tag has ended. The text before the '<' needs to be processed.
          if ( length($text) ) {
            $obj->text($text);
            $text = '';
          }

          # Check whether we have hit a tag-body-ending tag
          # and if so, end the current object
          $obj = $obj->end_child;

          # And rescan string for more tags
          redo MAIN;
        }
      }
      else {

        # Unsupported tag hit -- output the '<' since we don't consume it
        $text .= '<';

        # And rescan for more tags
        redo MAIN;
      }
    }
  }

  if ( $obj->parent ) {
    my ( $file, $line ) = $obj->start_location;
    die "Tag on line $line not closed properly.\n";
  }

  if ( length($text) ) {
    $obj->text($text);
    $text = '';
  }

  $obj->finalize;
}

sub improper_end {
  my $self    = shift;
  my $obj     = shift;
  my $endexpr = shift;

  my $iObj = $obj;
  while ( $iObj->parent ) {
    my $closure = $iObj->closure;
    if ( $endexpr eq $closure ) {
      my ( $file, $line ) = $obj->start_location;
      die "Tag on line $line should be closed here.\n";
    }
    $iObj = $iObj->parent;
  }

  die "Illegal tag-end encountered.\n";
}

sub output {
  my $self = shift;
  eval { $self->parse };
  $self->{'__input_opened'}->close if $self->{'__input_opened'};
  if ($@) {
    chomp $@;
    $self->error->mesg($@);
    die "$@\n";
  }
  else {
    $self->error->endLevel;
  }
}

sub show_error {
  my $self    = shift;
  my $errfile = shift;

  local (*FILE);

  unless ( open( FILE, $errfile ) ) {
    warn "Unable to open $errfile: $!\n";
    my $err                = $self->{error}->mesg;
    my $html_error_message = <<eot;
<html>
<head>
<title>Bedrock Error</title>
</head>
<body>
The following Bedrock error has been encountered:
<pre style="color:brown;">
$err
</pre>
<hr>
<div style="color:red;font-style:italic;">
Something's also wrong with your Bedrock configuration.  You've specfied an <b>ERROR_LOCATION</b> or 
<b>BEDROCK_ERROR_LOCATION</b> but it appears the file does not exist.  
Please check your <b><i>tagx.xml</i></b>.
</div>

<pre>
<b>$errfile</b> is empty or does not exist.
</pre>

</body>
</html>
eot
    my $fh = IO::Scalar->new( \$html_error_message );
    $self->{'input'} = $fh;
    $self->output;
    $fh->close;
  }
  else {
    eval {
      $self->{'input'} = *FILE;
      my $error = $self->{'error'};
      $self->{'error'} = TagX::Error->new($errfile);
      $self->param( 'ERROR' => $error );
      $self->output;
      close FILE;
    };
    if ($@) {
      warn "Error in error handler: $@";
    }
  }
}

sub error {
  $_[0]->{'error'};
}

sub define_name {
  my ( $self, $name, $value ) = @_;
  my @components = split /\./oi, $name;
  return unless @components;

  &log_message( undef, "$self: components are (@components)" );
  my $found = $self->{'VARS'};
  for (@components) {
    if (/^\Q[\E(\d+)\Q]\E/) {

      # array element
      if ( &isa( $found, 'ARRAY' ) ) {
        $found = $found->[$1];
        next;
      }
      else {
        &log_message( undef,
              "Cannot define [$_] component in $name: $found is not an array" );
        return;
      }
    }

    if (/^(\w+)/) {

      # hash element
      my $key = $1;
      if ( &isa( $found, 'HASH' ) ) {
        $found = $found->{$key};
      }
      else {

        # Support syntax for accessing hash contained in an array
        # if the array contains only one element
        unless ( &isa( $found, 'ARRAY' ) and @{$found} == 1 ) {
          &log_message(
              undef,
              "Cannot define [$_] component in [$name]: $found is an array\n"
              . "containing more than one element .. cannot access it as a hash"
          );
          return undef;
        }
        $found = $found->[0]->{$key};
      }
      next;
    }

    # illegal
    return;
  }
  &log_message( undef, "$self: finally found [$found]" );
  $found = $value;
}

sub define_pebble {
  my $self = shift;
  my %args = @_;
  my ( $name, $value );

  while ( ( $name, $value ) = each %args ) {
    if ( exists $self->pebble_cache->{$name} ) {
      &log_message( undef, "redefining pebble: [$name]" );
    }
    if ($value) {
      $self->store_pebble( $name, $value );
    }
    else {
      &log_message( undef, "WARNING: undefined pebble: [$name]" );
    }
  }
}

# return the pebble text or the pebble name from cache or file
sub pebble {
  my $self = shift;

  my $pebble;
  if ( ref( $_[0] ) ) {
    foreach $pebble ( keys %{ $self->pebble_cache } ) {
      return $pebble if $_[0] == $self->pebble_cache->{$pebble}->{handle};
    }
    return 'anonymous';
  }
  else {
    $pebble = $self->fetch_pebble( $_[0] );    # look in cache, first

    unless ($pebble) {
      my $file = $self->find_file( @_ );
      die "could not find pebble:" . $_[0] . "\n"
	unless $file;

      $pebble = $self->fetch_pebble( $_[0], $file );
    }
  }

  return $pebble;
}

# return a value from Bedrock's config or the config object
sub config {
  my $config = $_[0]->out_handle->{Handle}->{'CONFIG'};
  return $_[1] ? $config->{ $_[1] } : $config;
}

sub store_pebble {
  my $self = shift;
  my ( $name, $value ) = @_;

  $self->pebble_cache->{$name} = {} unless $self->pebble_cache->{$name};
  $self->pebble_cache->{$name}->{name} = $name;
  $self->pebble_cache->{$name}->{ ref($value) ? 'handle' : 'value' } = $value;
}

sub pebble_cache {
  $_[0]->{PEBBLE_CACHE} || do { $_[0]->{PEBBLE_CACHE} = {} };
}

sub fetch_pebble {
  my $self        = shift;
  my $pebble      = shift;
  my $pebble_file = shift;

  # see if pebble is in cache
  return $self->pebble_cache->{$pebble}->{value}
  if exists $self->pebble_cache->{$pebble};

  return undef
  unless "$pebble_file" && -s $pebble_file;

  open PEBBLE, "<$pebble_file";
  my $pebble_text = do { local $/; <PEBBLE> };
  close PEBBLE;

  # save in cache
  $self->store_pebble( $pebble, $pebble_text );

  $pebble_text;
}

# find a file using a progression locations to search
# returns the fqp or undef
sub find_file {
  my $self = shift;
  my $file = shift;
  my $ext  = shift;

  # ~ (tilde) means DOCUMENT_ROOT

  $file =~ s/^\~/$ENV{'DOCUMENT_ROOT'}\//;

  # if given an extension, then if the name does not have that
  # extension, add it
  if ( defined $ext && $file !~ /\.(.*?)$/ ) {
    $file .= $ext;
  }

  # @dirs is a list of directories to search
  my @dirs = @_;

  return -e $file ? $file : undef if $file =~ /^\//;
  my @all_dirs = map { split /:/ } @dirs;

  foreach ( map { $_ . '/' . $file } @all_dirs ) {
    return $_ if -e $_;
  }

  return undef;
}

sub param {
  my $self = shift;
  my %args = @_;
  my ( $name, $value );
  while ( ( $name, $value ) = each %args ) {
    if ( $name =~ /\./oi ) {

      # more expensive resolve operation
      $self->define_name( $name, $value );
    }
    else {
      $self->{'VARS'}->{$name} = $value;
    }
  }
}

sub out_handle {
  my $self = shift;
  $self->{'out_handle'} = shift if @_ == 1;
  $self->{'out_handle'};
}

#
# Constructor -- Invoked as follows
#    $Class_or_Object->new( $Input_Handle [, $Output_Handle [, $Error_Handler ] ] )
# Return the constructed object
#
sub new {
  my $proto         = shift;
  my $input         = shift;
  my $output        = shift;
  my $error_handler = shift;
  my %args          = @_;

  my ( $class, $self );
  if ( $class = ref($proto) ) {
    $self = bless { 'error' => {} }, $class;
    if   ($output) { $self->out_handle( TagX::Output->new($output) ) }
    else           { $self->out_handle( $proto->out_handle ) }
    $self->{'VARS'}    = $proto->{'VARS'};
    $self->{'error'}   = $proto->{'error'}->newLevel($input);
    $self->{'DB'}      = $proto->{'DB'} if exists $proto->{'DB'};
    $self->{'options'} = $proto->{'options'} if exists $proto->{'options'};
  }
  else {
    $self = bless {}, $proto;
    $self->out_handle( TagX::Output->new($output) );
    $self->{'VARS'}  = TagX::Symtab->new;
    $self->{'error'} = TagX::Error->new($input);
    $self->{'DB'}    = {};
  }

  unless ( ref($input) ) {
    my $file_or_fd = $input;
    $input =
    ref($file_or_fd)
    ? IO::Handle->new_from_fd($file_or_fd)
    : IO::File->new($file_or_fd);
    $self->{'__input_opened'} = $input;
    die "Unable to open [$file_or_fd] for input: $!\n" unless $input;
  }

  $self->{'input'} = $input;

  for ( keys %args ) {
    $self->{'VARS'}->{$_} = $args{$_};
  }

  $self;
}

#
# Hook for passing options to TagX.
# Takes an array which maps into a hash as arguments.
# valid options are
#   LOG_PREFIX          Directory and filename prefix for log file. An
#                       extension of `.log' is attached to this prefix
#   LOG_MAXSIZE         Maximum size of log file in bytes. If file is larger than
#                       this, it is truncated.
#   HEADER		Object for outputting headers.
# Returns: Nothing.
sub options {
  my $self = shift;

  # Setting options
  my %args = @_;

  if ( defined $args{'LOG_PREFIX'} ) {
    my $pre = delete $args{'LOG_PREFIX'};
    my $max = delete $args{'LOG_MAXSIZE'};
    $max = 100000 unless defined($max);
    &TagX::Log::start_logger( LOG_FILE    => $pre . '.log',
                              LOG_MAXSIZE => $max );
  }

  if ( exists $args{'HEADER'} ) {
    $self->out_handle->header( delete $args{'HEADER'} );
  }
  
  my %options;
  
  %options = %{$self->{options}} if 
    UNIVERSAL::isa( $self->{options}, 'HASH');

  # merge options
  map { $options{$_} = $args{$_}; } keys %args;

  $self->{'options'} = \%options 
    if keys %options > 0;
}

sub getoption {
  my $self = shift;
  return unless exists $self->{'options'};

  # Getting options
  my $name = shift;
  return $self->{'options'}->{$name};
}

sub close {
  my $self = shift;

  # Close any database handles left behind
  my @keys = keys %{ $self->{'DB'} };
  for my $name (@keys) {
    my $dbh = $self->{'DB'}->{$name};
    my $rc  = $dbh->disconnect;
    &log_message( undef,
         "Error shutting down db connection [$name]\n\t[" . $dbh->errstr . "]" )
    unless $rc;
    delete $self->{'DB'}->{$name};
  }

  # Clean up symbol table.
  $self->{'VARS'}->close;
  delete $self->{'VARS'};
}

#
# Revision 1.77  2013/10/30 16:55:35  rlauer
# - in options() checked if LOG_PREFIX is defined, not exists
#
# Revision 1.76  2013/01/04 02:08:24  rlauer
# - add <iif> tag
#
# Revision 1.75  2013/01/02 16:55:43  rlauer
# - implement true comments that are stripped out of source
#
# Revision 1.74  2012/07/29 16:37:54  lauerrc
# - added support for <recordset> tag
#
# Revision 1.73  2012/04/13 15:53:52  eutl420
# - die if pebble not found in any path
#
# Revision 1.72  2012/03/05 16:18:23  eutl420
# - merge options sent to options() method
#
# Revision 1.71  2012/02/24 19:36:45  eutl420
# - remove stray warns left over from debugging
#
# Revision 1.70  2012/02/07 14:34:08  eutl420
# - made <? synonymous with <null, could be crap
#
# Revision 1.69  2012/02/01 17:03:45  eutl420
# - added <sqlcommit>, <sqlrollback> tags
#
# Revision 1.68  2012/01/30 19:56:31  eutl420
# - add <noexec> tag parsing
#
# Revision 1.67  2011/12/01 15:42:00  eutl420
# - add sqltable to Opentag_expr to support new tag
# - case for <sqltable> tag in parse()
#
# Revision 1.66  2011/09/21 20:24:45  eutl420
# - reset $text object pebbledef (raw block) processed
#
# Revision 1.65  2011/09/15 15:43:41  eutl420
# - perltidy
# - remove tag <blm>
#
# Revision 1.64  2011/09/14 19:00:33  eutl420
# - parse method can now parse a tag a "raw" text - as in PebbleDef
# - <pebbledef> now added as a valid tag
# - added some functions to support pebble cacheing
# - find_file can be used to find a file given a path progression
#
# Revision 1.63  2011/09/09 18:35:11  eutl420
# *** empty log message ***
#
# Revision 1.62  2011/08/18 21:59:25  eutl420
# - added support for <unless> tag
#
# Revision 1.61  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.60  2011/07/12 19:10:36  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.59  2011/03/30 17:56:33  eutl420
# - ignore shebang line if first line
#
# Revision 1.58  2010/11/29 15:57:52  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.57  2010/11/08 03:17:36  rlauer
# - add support for <snippet> tag
#
# Revision 1.56  2010/10/30 21:44:46  rlauer
# - if the error file (error.roc typically) is not present then provide a default HTML page
#
# Revision 1.55  2010/01/03 19:11:01  rlauer
# forgot to replace Blm with Plugin
#
# Revision 1.54  2009/12/31 18:33:27  rlauer
# replace Blm->Plugin
#
# Revision 1.53  2009/12/31 12:43:23  rlauer
# log message if use of blm:
#
# Revision 1.52  2009/12/28 12:50:36  rlauer
# added <case> tag
#
# Revision 1.51  2009/12/15 13:07:42  rlauer
# array/hash tags added
#
# Revision 1.50  2009/12/15 12:48:29  rlauer
# add plugin tag
#
# Revision 1.49  2008/11/26 19:24:36  rlauer
# removed experimental Generic.pm
#
# Revision 1.48  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.47  2001/02/14 15:35:48  sridhar
# Added copyright and GPL notice
#
# Revision 1.46  2000/12/15 17:54:56  sridhar
# Yuck! Compile error after checking in.
#
# Revision 1.45  2000/12/15 16:42:21  sridhar
# 1. More error handling and reporting stuff -- catches and reports
# invalid tag ending etc.
# 2. New method `improper_end()' to do this.
# 3. Requires tag classes to implement method `closure()'
# 4. Moved version numbering to Bedrock::VERSION
#
# Revision 1.44  2000/11/30 14:36:08  sridhar
# Expressions:
# 1. Better error trapping.
# 2. Fixed error messages so exceptions don't have perl source code
#    locations in them.
# 3. Cleaned up implementation of `--exists' operator.
#
# Parser:
# 1. Had a bug in string parsing: was parsing successfully even though
#    there was no string terminator.
#
# 2.1. Cleaner error handling.
# 2.2. Fixed error messages so exceptions don't have perl source code
#      locations in them.
#
# Scalars:
# 1. Added method `isEmpty()'
# 2. Added method `urlencode()' to scalars
#
# <exec>:
# 1.1. Support for pebbles -- file to be included is taken from a
#      directory which is configured as PEBBLE_DIR
# 1.2. No expanding of arguments by default. --expand-args must be
#      specified to expand any array arguments.
#
# 2.1. Parameters can now be passed to <exec>.
# 2.2. Exec is more like a subroutine call in that a stack frame is
#      created on invocation which goes away when the exec is done. Variables
#      are created in the current stack frame and do not clobber global or
#      variables from parent's stack frames.
#
# 3. Fixed error messages so location of error in perl source is not
#     visible.
#
# 4. Yuck! Previous commit had a syntax error
#
# 5. Croaking if arg to --file is a directory
#
# 6. Bug fix: characters following the closing '>' after <exec> and <include>
#    were being discarded due to $_ being clobbered when `output()' was
#    reinvoked with new file.
#
# <include>
# 1. If the filename has a `~' at the beginning, it is replaced with
#    DOCUMENT_ROOT environment variable.
#
# 2. Fixed error messages so exceptions don't have perl source code
#    locations in them.
#
# 3.1. Croak if file argument turns out to be a directory
# 3.2. Removed --access-time, etc.
#
# 4. Bug fix: characters following the closing '>' after <exec> and <include>
#    were being discarded due to $_ being clobbered when `output()' was
#    reinvoked with new file.
#
#
# <null>:
# 1.1. Added option --create-object which takes the arguments and makes it
#      the properties of a newly created object.
# 1.2. If the there are odd number of arguments, the first or last
#      argument is expanded if it is an array
# 1.3. Throws exception if the object cannot be created due to invalid
#      arguments.
#
# 2. Fixed error messages so exceptions don't have perl source code
#    locations in them.
#
# <sql>
# 1.1. Support for passing a database handle using the option --db.
# 1.2. --dbname option deprecated.
#
# 2.1. Fixed error messages so exceptions don't have perl source code
#      locations in them.
# 2.2. Explicitly catching error code from DBI routine to show suitable
#      error message.
# 2.3. Checking for Incorrect number of bind vars being specified with
#      statement.
#
# 3. Argument to --bind can be an array. The array is expanded and used with
#    the other bind arguments appropriately.
#
# <sqlconnect>
# 1. Database connection exported to the script if --dbname option is used.
# 2.1. Fixed error messages so exceptions don't have perl source code
#      locations in them.
# 2.2. RaiseError and PrintError turned off -- we will explicitly check
#      for return code and show a suitable error message
#
# <trace>
# 1. `compact' option is default.
#
# <sqlselect>
# 1.1. Support for passing a database handle using the option --db.
# 1.2. Error messages cleaned.
# 1.3. More error checks.
# 1.4. --dbname option deprecated.
#
# 2. Argument to --bind can be an array. The array is expanded and used with
#    the other bind arguments appropriately.
#
# <sink>
# 1.1. Added --define-var option to <sink> for defining a variable with the
#      contents if <sink></sink>.
# 1.2. Added --HTMLEncode and --HTMLDecode options to encoding and
#      decoding the contents of <sink></sink>
#
# Revision 1.43  2000/11/29 21:02:47  sridhar
# Options passed to the module are available using the method
# `getoption()'
#
# Revision 1.42  2000/11/22 15:20:34  sridhar
# No longer need to invoked `handle_error()' on the symbol table before
# showing error page since the symbol table keeps separate lists for
# variables bound to code and variables which have been
# constructed. Variables bound to code are not available when doing a
# dump on the symbol table.
#
# Revision 1.41  2000/11/20 18:11:22  sridhar
# Need to invoke Symbol table's `handle_error()' method before showing
# error page since variables bound to code needs to be deleted.
#
# Revision 1.40  2000/11/16 20:02:10  sridhar
# 1. Using globals for storing the opentag, closing tag and options
# parsing regex so other modules can use it.
# 2. Method `output()' now invoked `parse()' which does the bulk of the
# work which was being done by `output()'. Now `output()' does more of
# exception handling.
# 3. Stream lined error reporting with a class TagX::Error which stores
# the call call stack and locations.
# 4. Have a `show_error()' method which can be passed a file to use as
# the error reporting page.
#
# Revision 1.39  2000/11/13 18:48:55  sridhar
# 1. Using TagX::TAG::WithBody::Cache as the outer container since this
# can cache the output, thus allowing header settings anywhere within
# the webpage.
# 2. Text is now accumulated in a variable and $obj-text invoked only
# when required to -- just before processing a bedrock tag.
#
# Revision 1.38  2000/11/07 14:00:05  sridhar
# 1. Using TagX::Symtab for the symbol tables instead of a plain
# hash. Allows us to not construct an object till it is needed.
# 2. invoke the symbol table's `close()' method at close.
#
# Revision 1.37  2000/10/19 21:05:11  sridhar
# Version 1.0502 with the following changes
# 1. <hush> renamed to <sink>
# 2. Can pass one parameter to <sink> which should be a handle which can
# be written to.
#
# Revision 1.36  2000/10/18 18:19:04  sridhar
# 1. Complain louder if unable to open log file.
# 2. Added format_time() method to scalars to treat a scalar as a UNIX
# timestamp and format it using strftime()
# 3. Support for <hush></hush> tag.
#
# Revision 1.35  2000/10/17 15:39:42  sridhar
# 1. Complains if some tag has not been ended.
# 2. Need to finalize object after processing the file. Was a bug which
# would have been triggered if the entire contents of the file was in
# one line which was not terminated with "\n"
# 3. Input object not being checked for any methods if it is a ref.
#
# Revision 1.34  2000/10/16 14:01:12  sridhar
# Moved out @INC modification to Bedrock.pm
#
# Revision 1.33  2000/09/25 20:50:52  sridhar
# General:
# 1. --verbose settings are passed to function args too to enable more
# effective debugging.
# 2. When verbose level is >= 2, calling stack is printed using
# Carp::cluck().
#
# Scalars:
# 1. Added align() and align_left(), align_center() and align_right()
# methods to scalars.
# 2. Added trim(), ltrim() and rtrim() methods to scalars.
# 3. Return value from split() is a SIS::Array object so methods can be
# invoked on it.
#
# <null>:
# 1. Have a --define-array option which makes an array of the arguments,
# if any are present. Defines an empty array, if no arguments
# 2. --define-var makes an empty object if no arguments. Also makes an
# array of the arguments if more than one argument present.
#
# <sql>:
# 1. Argument to <sql> is treated as statement to execute if --statement is
# not used.
#
# <sqlconnect>:
# 1. RaiseError defaults to 1 (on)
# 2. Argument if present is treated as the data source to connect to if
# --data-source is not used.
#
# <foreach>:
# 1. Default value for --start-index when there are no arguments to
# <foreach>.
# 2. Loop data is the index when there are no arguments to loop or the
# argument is undefined.
# 3. Bug fix -- since arrays of ordinary scalars are supported, need to
# make sure context array passed to children are all hashes.
# 4. If more than one arg to <foreach>, they are coerced into an array.
#
# <sqlselect>:
# Argument is treated as SQL select statement to execute if --statement
# is not present.
#
# <while>
# 1. Default name for var is $_
# 2. Condition for loop should evaluate to false for termination
# (earlier it was undef)
#
# Revision 1.32  2000/09/08 15:29:15  sridhar
# Updated versions of various modules
#
# Revision 1.31  2000/09/08 15:27:56  sridhar
# Changes in version 1.0404
# 1. Support for methods on scalars like split(), replace(), etc.
# 2. Added long-needed `--alias = "name"' option to <foreach>
# 3. If <foreach> is invoked on a non-array, the item appears as a
# single element in an anonymous array
#
# Revision 1.30  2000/08/31 17:46:19  sridhar
# 1. Support for Bedrock scalars. Methods can be invoked on any scalar.
# 2. --alias option for <foreach>
# 3. Can use <foreach> on scalars -- will execute the loop once, unless
# the argument is undefined.
#
# Revision 1.29  2000/08/22 18:08:33  sridhar
# Changes from previous version:
# 1. Broken interpretation of `$@' fixed.
# 2. <trace> takes an optional variable name to print contents.
# 3. Added --format option to <var>
# 4. Fixed input file handle leak.
#
# Revision 1.28  2000/08/22 17:38:17  sridhar
# Close input file if we opened it (and not trust IO:: to deal with it
# -- gave rise to a leak of file handles)
#
# Revision 1.27  2000/08/17 17:37:20  sridhar
# Streamlining of version numbers.
#
# Revision 1.26  2000/08/17 17:23:46  sridhar
# Added support for <exec>.
#
# Revision 1.25  2000/08/11 17:09:12  sridhar
# Removed a destroy which was closing all database connections since we
# cannot afford that -- many scripts due database open in include files.
# This was originally needed since some scripts threw exceptions which
# were not caught. Hence close() was not being invoked with the result
# that database connections were left open in the mod_perl version. This
# situation is better handled by the client of TagX by trapping uncaught
# errors.
#
# Revision 1.24  2000/08/04 17:08:59  sridhar
# 1. Have a DESTROY which calls close -- useful when exceptions are
# thrown and are not caught
# 2. close deletes database handles which were closed so they don't get
# closed again.
#
# Revision 1.23  2000/07/20 20:26:13  sridhar
# 1. Added <while> loop.
# 2. Added --HTMLEncode option to <var>
# 3. Removed --name option from <foreach>
# 4. Fixed handling of --meta-info in <sqlselect> for mySQL
#
# Revision 1.22  2000/07/05 18:10:57  sridhar
# 1. Support for registering a header BLM for manipulation of HTTP
# header fields.
# 2. Some tweaking of <foreach> for speed improvement
# 3. <foreach> has multiple verbose levels.
# 4. <foreach> no longer needs an array of hash references and can loop
# over start and end indices.
# 5. Added `meta-info' option to <sqlselect>.
# 6. More options to TagX: HEADER option to specify an object with a
# print_header() method, which is invoked for generation of headers, if
# required.
#
# Revision 1.21  2000/06/28 18:57:21  sridhar
# 1. Not invoking $obj->text() method if no text to send.
# 2. Have a new object for setting headers
#
# Revision 1.20  2000/06/26 17:52:31  sridhar
# 1. Tuned Output.pm for speed
# 2. Tuned Foreach.pm for speed and use of --verbose more than once
# means more logging
# 3. Used isa() to check reference instead of ref().
# 4. Added --meta-info option to <sqlselect> to include more information
# about query
#
# Revision 1.19  2000/06/07 18:36:21  sridhar
# Removed a debug log message
#
# Revision 1.18  2000/06/06 20:10:28  sridhar
# 1. Added new tag <null> for object method invocation
# 2. Support in <foreach> to iterate over an array of ordinary elements
# 3. <trace> fixed to recognize objects properly
# 4. Half-finished version of define_name
#
# Revision 1.17  2000/06/01 18:51:09  sridhar
# 1. Support for invoking object methods
# 2. Brand new parser for parsing expressions.
#
# Revision 1.16  2000/05/31 15:15:39  sridhar
# Rigorous version numbering enforced across all modules.
#
# Revision 1.15  2000/05/30 17:48:55  sridhar
# Added a `close' method which cleans up database handles left
# open. Especially useful for mod_perl versions which cause the
# destructor to be called only when the Apache server exits.
#
# Revision 1.14  2000/05/03 18:51:54  sridhar
# 1. Hack to include proper path in @INC right next to the path where TagX
# was found
# 2. New versioning scheme not dependent on CVS versioning scheme
#
# Revision 1.13  2000/05/02 12:47:29  sridhar
# BUG FIX: fixed support for escaping '>' within SQL statements.
#
# Revision 1.12  2000/04/27 19:58:53  sridhar
# Fixed a confess message which was logging a wrong file name when including
# a file.
#
# Revision 1.11  2000/04/24 12:44:54  sridhar
# 1. Using new TagX::Log class.
# 2. Logging input filename with location.
# 3. Kicked out __start_logger and log_message methods.
#
# Revision 1.10  2000/04/19 20:01:28  sridhar
# New internal logging mechanism and a method for specifying options to
# tagx.
#
# Revision 1.9  2000/04/13 15:04:46  sridhar
# 1. Input can be a filename, handle or IO::
# 2. Handlers for warn and die.
# 3. Input filename logged with message logging
#
# Revision 1.8  2000/03/21 16:07:16  sridhar
# 1. Moved handling for <else> into main loop with others
# 2. <elseif> and <elsif> are both supported.
#
# Revision 1.7  2000/03/13 15:41:57  sridhar
# Bug fix: Opening Database in include page was causing database to be
# closed outside that page.
#
# Revision 1.6  2000/03/09 14:10:38  sridhar
# 1. Added <try>, <catch>, and <raise>.
# 2. Output is now not always written to output handle. Output can now
# be buffered. Added a new class Output for this. Buffering can be
# turned off and on at will.
#
# Revision 1.5  2000/03/06 18:29:31  sridhar
# Added support for <trace>, a very useful tool in debugging.
#
# Revision 1.4  2000/03/02 14:43:00  sridhar
# New class (Loop) between WithBody and Foreach, SQLSelect
#
# Revision 1.3  2000/03/02 13:44:39  sridhar
# 1. Added support for keeping track of line number of input.
# 2. Logging includes line number of current line
#
# Revision 1.2  2000/02/23 13:40:33  sridhar
# 1. Rearragement of program control
# 2. Added support for escaped '>' (does not terminate tag definition).
# 3. Added support for defining names other than at global level.
#
# Revision 1.1  2000/02/08 15:24:56  sridhar
# Added TagX
#
#

1;
