#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package Text::TagX;

use strict;
use Carp;
use UNIVERSAL qw (isa);

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    use File::Basename;

    # Hack to get `???/Text/' in the right place in @INC
    my $txpath = $INC{'Text/TagX.pm'};
    if ( $txpath ) {
	my $act = dirname( dirname( $txpath ) );
	for (my $i = 0 ; $i < @INC ; $i++ ) {
	    if ( $act eq $INC[$i] ) {
		splice @INC, $i + 1, 0, dirname( $txpath );
		last;
	    }
	}
    }

    @ISA	= qw (Exporter);
}

#
# Version number is composed as follows:
#    x.yyzz
# where
#    x => Version identifier changes if major changes in TagX, like
#         design changes, changing how the parser works, etc.
#   yy => Identifier changes if semi-major changes in TagX, like
#         addition of new tags, removal of existing tags, major
#         changes in options to tags, etc. Change in this number
#         may indicate that older scripts will break or may cause
#         inconsistent behavior.
#   zz => This changes with each bug fix, small updates or enhancements,
#         changes which may not break existing scripts (though
#         nothing is guaranteed), etc.
#
$VERSION	= '1.0201';

use TagX::Output 1.02;
use TagX::Log 1.01;

use TagX::TAG::NoBody::Var 1.09;
use TagX::TAG::NoBody::Include 1.07;
use TagX::TAG::NoBody::SQL 1.08;
use TagX::TAG::NoBody::SQLConnect 1.07;
use TagX::TAG::NoBody::Trace 1.08;
use TagX::TAG::NoBody::Raise 1.04;
use TagX::TAG::NoBody::NULL 1.01;

use TagX::TAG::WithBody 1.06;
use TagX::TAG::WithBody::Loop::Foreach 1.06;
use TagX::TAG::WithBody::Loop::SQLSelect 1.08;
use TagX::TAG::WithBody::If 1.09;
use TagX::TAG::WithBody::If::Else 1.03;
use TagX::TAG::WithBody::Try 1.05;
use TagX::TAG::WithBody::Catch 1.05;

sub output
{
    my $self = shift;
    my $newscan = 1;

    my $obj = TagX::TAG::WithBody->new( $self );
    my $input = $self->{'input'};
    my $optstring = '';
    $self->{'__line'} = 0;

    my $tag_start = '^(var|include|sql|sqlconnect|trace|foreach|sqlselect|if|else?if|try|catch|raise|else|null)(?=\W)';
    my $tag_end   = '^(/sqlselect|/foreach|/doc|/if|/try)>';
    my $opt_esc   = '^\s*(([^>\\\\]|\\\\.)*)>';

  INPUT:
    while (<$input>) {
	$self->{'__line'}++;
      MAIN: {

	  #
	  # Check whether we are into a new scan or collecting options
	  # for a matched tag
	  #
	  unless ( $newscan ) {

	      # Collecting options for a matched tag -- Look for tag end which is
	      # an un-escaped '>'
	      if ( s/$opt_esc//o ) {

		  # Found an un-escaped '>', which terminates the current tag and its options
		  # $optstring contains the options collected so far
		  $optstring .= $1;

		  # Remove escapes from the option string
		  $optstring =~ s/\\([^\\])/$1/g;
		  $optstring =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $optstring );

		  # Start a new scan after this
		  $newscan = 1;

		  # Handle possible left over stuff after the '>'
		  redo MAIN;
	      } else {

		  # No terminating '>' in entire line -- start by reading input again
		  $optstring .= $_;
		  next INPUT;
	      }
	  }

	  # New scan from here -- scan afresh for tags.
	  # if no '<' found in line, skip line
	  unless ( s/^(.*?)<//oi ) {
	      $obj->text( $_ );
	      next INPUT;
	  }

	  # We did find a '<' -- could be we have a possible supported tag next
	  # The text before the '<' needs to be processed.
	  $obj->text ( $1 );

	  # Check if we have a supported tag
	  if ( s/$tag_start//oi ) {

	      # Yes we do
	      for ($1) {
		  /^var$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Var->new );
		      last;
		  };

		  /^sqlconnect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQLConnect->new );
		      last;
		  };

		  /^sql$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::SQL->new );
		      last;
		  };

		  /^include$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Include->new );
		      last;
		  };

		  /^foreach$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::Foreach->new );
		      last;
		  };

		  /^sqlselect$/oi	and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Loop::SQLSelect->new );
		      last;
		  };

		  /^if$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::If->new );
		      last;
		  };

		  /^else?if$/oi		and do {
		      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
		      last;
		  };

		  /^else/oi		and do {
		      $obj = $obj->else_obj( TagX::TAG::WithBody::If::Else->new );
		      last;
		  };

		  /^trace$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Trace->new );
		      last;
		  };

		  /^raise$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::Raise->new );
		      last;
		  };

		  /^try$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::WithBody::Try->new );
		      last;
		  };

		  /^catch$/oi		and do {
		      $obj = $obj->catch( TagX::TAG::WithBody::Catch->new );
		      last;
		  };

		  /^null$/oi		and do {
		      $obj = $obj->new_child( TagX::TAG::NoBody::NULL->new );
		      last;
		  };

		  die "Tag <$_> NYI";
	      }

	      $obj->start_location( "$self->{'__input'}($self->{'__line'})" );

	      # After creating object of suitable type depending on the tag, check
	      # if the tag ends on the same line. Tag ending is an un-escaped '>'.
	      if ( s/$opt_esc//oi ) {

		  # The tag definition ended on same line -- all options specified on
		  # one line
		  my $options = $1;

		  # Unescape the options
		  $options =~ s/\\([^\\])/$1/g;
		  $options =~ s/\\\\/\\/g;

		  # And set the current object options
		  $obj = $obj->options ( $options );

		  # And rescan the string for more tags -- Note that $newscan is unchanged
		  # from its value of 1, so we don't need to set it here
		  redo MAIN;
	      } else {

		  # Tag definition did not end on one line -- Further input is consumed for
		  # looking for the tag ending
		  $newscan = 0;

		  # Start collection of the options string
		  $optstring = $_;
	      }

	  } elsif ( s/$tag_end//oi ) {

	      # Check whether we have hit a tag-body-ending tag
	      # and if so, end the current object
	      $obj = $obj->end_child;

	      # And rescan string for more tags
	      redo MAIN;
	  } else {

	      # Unsupported tag hit -- output the '<' since we don't consume it
	      $obj->text( '<' );

	      # And rescan for more tags
	      redo MAIN;
	  }
      }
    }
}

sub define_name
{
    my ($self, $name, $value) = @_;
    my @components = split /\./oi, $name;
    return unless @components;

    &log_message( undef, "$self: components are (@components)" );
    my $found = $self->{'VARS'};
    for (@components) {
	if ( /^\Q[\E(\d+)\Q]\E/ ) {
	    # array element
	    if ( &isa( $found, 'ARRAY' ) ) {
		$found = $found->[$1];
		next;
	    } else {
		&log_message ( undef, "Cannot define [$_] component in $name: $found is not an array" );
		return;
	    }
	}

	if ( /^(\w+)/ ) {
	    # hash element
	    my $key = $1;
	    if ( &isa( $found, 'HASH' ) ) {
		$found = $found->{$key};
	    } else {
		# Support syntax for accessing hash contained in an array
		# if the array contains only one element
		unless ( &isa( $found, 'ARRAY' ) and @{$found} == 1 ) {
		    &log_message( undef, "Cannot define [$_] component in [$name]: $found is an array\n"
				  . "containing more than one element .. cannot access it as a hash" );
		    return undef;
		}
		$found = $found->[0]->{$key};
	    }
	    next;
	}

	# illegal
	return;
    }
    &log_message( undef, "$self: finally found [$found]" );
    $found = $value;
}

sub param
{
    my $self = shift;
    my %args = @_;
    my ( $name, $value );
    while ( ( $name, $value) = each %args ) {
	if ( $name =~ /\./oi ) {
	    # more expensive resolve operation
	    $self->define_name ( $name, $value );
	} else {
	    $self->{'VARS'}->{$name} = $value;
	}
    }
}

sub out_handle
{
    my $self = shift;
    $self->{'out_handle'} = shift if @_ == 1;
    $self->{'out_handle'};
}

#
# Constructor -- Invoked as follows
#    $Class_or_Object->new( $Input_Handle [, $Output_Handle [, $Error_Handler ] ] )
# Return the constructed object
#
sub new
{
    my $proto = shift;
    my $input = shift;
    my $output = shift;
    my $error_handler = shift;
    my %args = @_;

    my ($class, $self);
    if ( $class = ref( $proto ) ) {
	$self = bless {}, $class;
	$self->{'__input'} = $input;
	if ( $output ) {
	    $self->out_handle( TagX::Output->new( $output ) );
	} else {
	    $self->out_handle( $proto->out_handle );
	}
	$self->{'VARS'} = $proto->{'VARS'};
	$self->{'DB'} = $proto->{'DB'} if exists $proto->{'DB'};
    } else {
	$self = bless {}, $proto;
	$self->{'__input'} = $input;
	$self->out_handle( TagX::Output->new( $output ) );
	$self->{'VARS'} = {};
	$self->{'DB'} = {};
    }

    unless ( ref ($input) =~ /IO/o ) {
	my $file_or_fd = $input;
	$input = ref( $file_or_fd ) ? IO::Handle->new_from_fd( $file_or_fd ) : IO::File->new ( $file_or_fd );
	confess "Unable to open [$file_or_fd] for input: $!" unless $input;
    }

    $self->{'input'} = $input;

    for (keys %args) {
	$self->{'VARS'}->{$_} = $args{$_};
    }

    $self;
}

#
# Hook for passing options to TagX.
# Takes an array which maps into a hash as arguments.
# valid options are
#   LOG_PREFIX          Directory and filename prefix for log file. An
#                       extension of `.log' is attached to this prefix
#   LOG_MAXSIZE         Maximum size of log file in bytes. If file is larger than
#                       this, it is truncated.
# Returns: Nothing. 
sub options
{
    my $self = shift;
    my %args = @_;
    return unless exists $args{'LOG_PREFIX'};
    &TagX::Log::start_logger (LOG_FILE		=> $args{'LOG_PREFIX'} . '.log',
			      LOG_MAXSIZE	=> $args{'LOG_MAXSIZE'} || 100000);
}

sub close
{
    my $self = shift;
    
    # Close any database handles left behind
    for my $name (keys %{$self->{'DB'}}) {
	my $dbh = $self->{'DB'}->{$name};
	my $rc = $dbh->disconnect;
	&log_message( undef, "Error shutting down db connection [$name]\n\t[" . $dbh->errstr . "]" )
	    unless $rc;
    }
}

#
# Name of Release: $Name$
# $Log$
# Revision 1.19  2000/06/07 18:36:21  sridhar
# Removed a debug log message
#
# Revision 1.18  2000/06/06 20:10:28  sridhar
# 1. Added new tag <null> for object method invocation
# 2. Support in <foreach> to iterate over an array of ordinary elements
# 3. <trace> fixed to recognize objects properly
# 4. Half-finished version of define_name
#
# Revision 1.17  2000/06/01 18:51:09  sridhar
# 1. Support for invoking object methods
# 2. Brand new parser for parsing expressions.
#
# Revision 1.16  2000/05/31 15:15:39  sridhar
# Rigorous version numbering enforced across all modules.
#
# Revision 1.15  2000/05/30 17:48:55  sridhar
# Added a `close' method which cleans up database handles left
# open. Especially useful for mod_perl versions which cause the
# destructor to be called only when the Apache server exits.
#
# Revision 1.14  2000/05/03 18:51:54  sridhar
# 1. Hack to include proper path in @INC right next to the path where TagX
# was found
# 2. New versioning scheme not dependent on CVS versioning scheme
#
# Revision 1.13  2000/05/02 12:47:29  sridhar
# BUG FIX: fixed support for escaping '>' within SQL statements.
#
# Revision 1.12  2000/04/27 19:58:53  sridhar
# Fixed a confess message which was logging a wrong file name when including
# a file.
#
# Revision 1.11  2000/04/24 12:44:54  sridhar
# 1. Using new TagX::Log class.
# 2. Logging input filename with location.
# 3. Kicked out __start_logger and log_message methods.
#
# Revision 1.10  2000/04/19 20:01:28  sridhar
# New internal logging mechanism and a method for specifying options to
# tagx.
#
# Revision 1.9  2000/04/13 15:04:46  sridhar
# 1. Input can be a filename, handle or IO::
# 2. Handlers for warn and die.
# 3. Input filename logged with message logging
#
# Revision 1.8  2000/03/21 16:07:16  sridhar
# 1. Moved handling for <else> into main loop with others
# 2. <elseif> and <elsif> are both supported.
#
# Revision 1.7  2000/03/13 15:41:57  sridhar
# Bug fix: Opening Database in include page was causing database to be
# closed outside that page.
#
# Revision 1.6  2000/03/09 14:10:38  sridhar
# 1. Added <try>, <catch>, and <raise>.
# 2. Output is now not always written to output handle. Output can now
# be buffered. Added a new class Output for this. Buffering can be
# turned off and on at will.
#
# Revision 1.5  2000/03/06 18:29:31  sridhar
# Added support for <trace>, a very useful tool in debugging.
#
# Revision 1.4  2000/03/02 14:43:00  sridhar
# New class (Loop) between WithBody and Foreach, SQLSelect
#
# Revision 1.3  2000/03/02 13:44:39  sridhar
# 1. Added support for keeping track of line number of input.
# 2. Logging includes line number of current line
#
# Revision 1.2  2000/02/23 13:40:33  sridhar
# 1. Rearragement of program control
# 2. Added support for escaped '>' (does not terminate tag definition).
# 3. Added support for defining names other than at global level.
#
# Revision 1.1  2000/02/08 15:24:56  sridhar
# Added TagX
#
#

1;
