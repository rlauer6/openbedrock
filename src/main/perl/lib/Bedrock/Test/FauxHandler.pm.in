package Bedrock::Test::FauxHandler;

use strict;
use warnings;

use Bedrock qw(choose);
use Bedrock::Constants qw(:chars :booleans);
use Bedrock::Test::FauxLogger;

use Carp;
use Cwd qw(getcwd);
use Data::Dumper;
use English qw(_no_match_vars);
use File::Basename;
use IO::Scalar;
use List::Util qw(pairs);
use Scalar::Util qw(reftype);

__PACKAGE__->mk_accessors(
  qw(
    buffer
    content_type
    document_root
    filename
    headers_in
    headers_out
    log
    log_level
    method
    output_handle
    uri
  )
);

use parent qw(Class::Accessor);

caller or __PACKAGE__->main();

########################################################################
sub new {
########################################################################
  my ( $class, @args ) = @_;

  my %options = ref $args[0] ? %{ $args[0] } : @args;

  $options{content_type} //= 'text/html';
  $options{headers_out}  //= [];
  push @{ $options{headers_out} }, 'Content-type' => $options{content_type};

  $options{log_level}     //= 'error';
  $options{document_root} //= $ENV{DOCUMENT_ROOT} // getcwd;

  $options{method} //= $ENV{REQUEST_METHOD} // 'GET';
  $options{log} = Bedrock::Test::FauxLogger->new( $options{log_level} );
  $options{output_handle} //= *STDOUT;
  $options{headers_in} = _init_headers( $options{headers_in} );

  _init_output_handle( \%options );

  # order important here, we create a filename from the URI if we have
  # no filename and a URI
  _init_filename( \%options );

  # ...likewise we create a URI if we have no URI but we have a
  # filename and document root
  _init_uri( \%options );

  my $self = $class->SUPER::new( \%options );

  return $self;
}

########################################################################
sub _init_filename {
########################################################################
  my ($options) = @_;

  # If we already have a filename, don't touch it
  return if $options->{filename};

  # If we don't have a URI, set a default?
  if ( !$options->{uri} ) {
    $options->{filename} = $ENV{PATH_TRANSLATED} // $PROGRAM_NAME;
    return;
  }

  # Logic: Filename = DocRoot + URI
  # e.g. /var/www/html + /foo.roc = /var/www/html/foo.roc

  my $uri  = $options->{uri};
  my $root = $options->{document_root};

  # Clean up trailing slash on root to avoid //foo.roc
  $root =~ s{/$}{}xsm;

  # Clean up leading slash on URI to ensure join works
  $uri =~ s{^/}{}xsm;

  $options->{filename} = sprintf '%s/%s', $root, $uri;

  return;
}

########################################################################
# NOTE: buffer sent as an option is a flag that simply means 'buffer' the
# output for me, it is not an input parameter!
########################################################################
sub _init_output_handle {
########################################################################
  my ($options) = @_;

  if ( !$options->{buffer} ) {
    $options->{output_handle} = *STDOUT;
    return;
  }

  my $empty  = $EMPTY;
  my $buffer = \$empty;

  @{$options}{qw(buffer output_handle)} = ( $buffer, IO::Scalar->new($buffer) );

  return;
}

########################################################################
sub _init_uri {
########################################################################
  my ($options) = @_;

  return if $options->{uri};

  my ( $filename, $document_root ) = @{$options}{qw(filename document_root)};

  # Logic: URI = Filename - DocRoot

  # If the filename starts with the docroot, stripping it gives us the URI
  if ( index( $filename, $document_root ) == 0 ) {
    my $uri = substr $filename, length $document_root;
    $options->{uri} = $uri;
    return;
  }

  # Fallback: If filename is NOT inside docroot (e.g. /tmp/test.t),
  # we behave like the old logic or just default to basename
  my ( $name, $path, $ext ) = fileparse( $filename, qr/[.][^.]+$/xsm );
  $options->{uri} = sprintf '/%s%s', $name, $ext;

  return;
}

########################################################################
sub _init_headers {
########################################################################
  my ($headers_in) = @_;

  $headers_in //= [];

  # allow caller to send headers as hashref or array, but make it an array
  croak "headers_in must be an array or hash reference\n"
    if $headers_in && !ref $headers_in;

  if ( reftype($headers_in) eq 'HASH' ) {
    $headers_in = [ %{$headers_in} ];
  }

  my @headers = grep {/^HTTP_/xsm} keys %ENV;

  foreach my $h (@headers) {
    my ($k) = $h =~ /^HTTP_(.*)$/xsm;

    push @{$headers_in}, $k => $ENV{$h};
  }

  return $headers_in;
}

########################################################################
sub headers_in {
########################################################################
  my ( $self, @args ) = @_;

  my $headers_in = $self->get('headers_in');  # array ref

  return $headers_in
    if !@args;

  @args = choose {
    return %{ $args[0] }
      if ref $args[0] && reftype( $args[0] ) eq 'HASH';

    return @{ $args[0] }
      if ref $args[0] && reftype( $args[0] ) eq 'ARRAY';
  };

  foreach my $p ( pairs @args ) {
    my ( $header, $value ) = @{$p};
    push @{$headers_in}, uc($header) => $value;
  }

  return $headers_in;
}

########################################################################
sub content_type {
########################################################################
  my ( $self, @args ) = @_;

  my $content_type = $self->get('content_type');

  return $content_type
    if !@args;

  $self->set( content_type => $args[0] );

  $self->cgi_header_out( 'Content-type' => $args[0] );

  return $content_type;
}

########################################################################
sub cgi_header_out { goto &headers_out; }
sub header_out     { goto &headers_out; }
########################################################################
sub headers_out {
########################################################################
  my ( $self, @headers ) = @_;

  my $headers_out = $self->get('headers_out') // [];

  foreach my $p ( pairs @headers ) {
    my ( $header, $value ) = @{$p};

    die "no value for $header\n"
      if !defined $value;

    push @{$headers_out}, $header => $value;
  }

  return $headers_out;
}

########################################################################
sub print {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, $content ) = @_;

  my $fh = $self->output_handle;
  return CORE::print {$fh} $content;
}

########################################################################
sub send_http_header {
########################################################################
  my ($self) = @_;

  my @headers_out = @{ $self->headers_out || [] };

  return
    if !@headers_out;

  my %uniq_headers;
  my @headers;

  # headers were 'pushed' so first one wins
  foreach my $p ( pairs reverse @headers_out ) {
    my ( $v, $h ) = @{$p};

    next if $uniq_headers{$h};
    $uniq_headers{$h} = 1;

    unshift @headers, sprintf '%s: %s', $h, $v;
  }

  return $self->print( sprintf "%s\n\n", join "\n", @headers );
}

########################################################################
sub DESTROY {
########################################################################
  my ($self) = @_;

  $self->flush_output();

  return $self->log->close;
}

########################################################################
sub get_output_buffer {
########################################################################
  my ($self) = @_;

  my $buffer = $self->buffer;

  return $buffer ? ${$buffer} : $EMPTY;
}

########################################################################
sub flush_output {
########################################################################
  my ($self) = @_;

  my $buffer = $self->buffer;

  my $output = $buffer ? ${$buffer} : $EMPTY;

  return
    if !$output;

  $self->print($output);

  ${$buffer} = $EMPTY;

  return;
}

########################################################################
sub main {
########################################################################
  use Data::Dumper;

  my $handler = Bedrock::Test::FauxHandler->new( log_level => 'info', filename => 'foo' );

  $handler->log->debug('started');

  $handler->log->close;

  print {*STDERR} $handler->log->as_string;

  exit 0;
}

1;

## no critic

__END__

=pod

=head1 NAME

Bedrock::Test::FauxHandler - A mock Apache request handler for testing Bedrock

=head1 SYNOPSIS

  use Bedrock::Test::FauxHandler;

  # Basic usage mimics a GET request to a file
  my $r = Bedrock::Test::FauxHandler->new(
      filename => '/var/www/html/foo.roc',
      method   => 'GET'
  );

  # Capture output in a buffer instead of printing to STDOUT
my $r_buffered = Bedrock::Test::FauxHandler->new(
      filename => 'test.roc',
      buffer   => 1
  );
  
  # ... run your tests ...
  
  my $output = $r_buffered->get_output_buffer;

=head1 DESCRIPTION

C<Bedrock::Test::FauxHandler> provides a mocked interface compatible with
L<Apache2::RequestRec>. It is designed to allow testing of Bedrock modules
and handlers without requiring a running Apache server or C<mod_perl> environment.

It simulates the request lifecycle, including header management, content type
negotiation, and output buffering.

=head1 CONSTRUCTOR

=head2 new( %options )

Creates a new FauxHandler object. The following options are supported:

=over 4

=item B<buffer>

Boolean. If set to true, output sent via C<print()> is captured internally
rather than sent to STDOUT.
I<Default: false (output goes to STDOUT)>

=item B<content_type>

The initial response content type.
I<Default:> C<text/html>

=item B<document_root>

The root directory of the web server.
I<Default:> C<$ENV{DOCUMENT_ROOT}> or current working directory (C<getcwd>).

=item B<filename>

The absolute path to the file being requested.

If not provided, it is determined via the following logic:
1. If C<uri> is provided, it is constructed from C<document_root> + C<uri>.
2. Otherwise, it defaults to C<$ENV{PATH_TRANSLATED}> or C<$PROGRAM_NAME>.

=item B<headers_in>

A reference to a Hash or Array containing initial request headers.
Existing C<HTTP_*> environment variables are automatically merged into this list.

=item B<headers_out>

An array reference for storing response headers.
I<Default:> C<[]>

=item B<log_level>

The logging verbosity. Accepted values: C<debug>, C<info>, C<warn>, C<error>.
I<Default:> C<error>

=item B<method>

The HTTP request method (e.g., GET, POST, PUT).
I<Default:> C<$ENV{REQUEST_METHOD}> or C<GET>.

=item B<uri>

The requested URI.

If not provided, it is auto-calculated by removing the C<document_root>
from the C<filename>.

=back

=head1 METHODS

=head2 buffer

Returns the reference to the internal output buffer (if buffering is enabled).

=head2 cgi_header_out( $key, $value )

Alias for L</headers_out>.

=head2 content_type( [$type] )

Get or set the response Content-Type.
If C<$type> is provided, it updates the C<Content-type> header in C<headers_out>.

=head2 flush_output

Manually flushes the internal output buffer to the output handle (usually STDOUT)
and clears the buffer. This is called automatically during C<DESTROY>.

=head2 get_output_buffer

Returns the current contents of the output buffer as a string. Returns empty string
if buffering is disabled or empty.

=head2 header_out( $key, $value )

Alias for L</headers_out>.

=head2 headers_in

Returns an array reference containing the request headers as key-value pairs.
e.g., C<[ 'Host' => 'localhost', 'Accept' => '*/*' ]>

=head2 headers_out( [$key, $value] )

Get or set response headers.

=over 4

=item * B<No arguments:> Returns the array reference of current response headers.

=item * B<Arguments:> Pushes a new header key-value pair onto the stack.

=back

I<Note: This method supports multi-value headers. It does not overwrite existing
headers with the same key; it appends them.>

=head2 log

Returns the L<Bedrock::Test::FauxLogger> instance.

=head2 print( @content )

Simulates printing content to the client. If B<buffer> was enabled in the
constructor, content is appended to the internal buffer. Otherwise, it is
printed to the configured C<output_handle> (STDOUT).

=head2 send_http_header

Formats and prints the accumulated C<headers_out> to the output stream,
followed by a blank line.

B<Behavior:>
This method implements "Last Wins" logic. If multiple headers with the same
name exist (e.g., multiple C<Status> headers), only the I<last> one added
is output. The original order of distinct headers is preserved.

=head1 INTERNAL ACCESSORS

The following accessors are generated via L<Class::Accessor> and are primarily
for internal use, though available if needed:

=over 4

=item * document_root

=item * filename

=item * logger

=item * method

=item * output_handle

=item * uri

=back

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=head1 SEE ALSO

L<Bedrock::Test>, L<Bedrock::Test::FauxLogger>, L<Apache2::RequestRec>

=cut
