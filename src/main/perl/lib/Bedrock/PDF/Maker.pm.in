#/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package PDF::Maker;

use strict;

# This is a STUPID kludge and should be the nail in the coffin
# for this implementation. 
my $hanging_text = '';

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= 1.10;
    @ISA	= qw (Exporter);
}

use PDF::Create;

$PDF::Maker::page_types =
{ "letter" 	=> [8.5,11], 
  "legal" 	=> [8.5,14], 
  "executive" 	=> [7.5,10.5],
  "a4"		=> [8.27,11.69],
  "a5"		=> [5.83,8.27],
};

my %PDFDefaults =
(
   "PDFVersion"			=> 1.2, # This constant passed to PDF::Create
   "page_width"   		=> 8.5,
   "page_height"  		=> 11,
   "page_left_margin" 		=> 0.3,
   "font" 			=> "Helvetica",
   "font_size"  		=> 12,
   "header_font"  		=> "Times-Roman",
   "footer_font"  		=> "Times-Roman",
   "header_font_size"   	=> 10,
   "footer_font_size"   	=> 10,
   "header_margin"   		=> 0.5, # Half an inch 
   "default_font_color"		=> [0.0, 0.0, 0.0],
   "header_font_color"		=> [0.0, 0.0, 0.0],
   "footer_font_color"		=> [0.0, 0.0, 0.0],
   "header_valign"		=> "center",
   "footer_valign"		=> "center",
   "align"			=> "left",
);

my $verbose = 1;

sub verbose { $verbose = shift(); }
sub Log { warn shift if defined $verbose and $verbose; }

sub new
{
   my ($thisclass, $args) = (@_);
   my $data = {};
   my $pdf;
   my $title = $$args{'title'};
   $title = "Untitled" if !defined($title);
			    
   if( ref($$args{'file'}) )
   {
      $pdf = new PDF::Create('fh'       => $$args{'file'},
			     'Version'  => $PDFDefaults{"PDFVersion"},
			     'Title'    => $title);
   }
   else
   {
      $pdf = new PDF::Create('filename' => $$args{'file'},
			     'Version'  => $PDFDefaults{"PDFVersion"},
			     'Title'    => $title);
   }

   bless($data, $thisclass);

   $data->setOptions(\%PDFDefaults);
   $data->setOptions($args);
   
   $$data{'pdf'} 	= $pdf;

   # Set up the page size
   if( defined($$args{"page_size"}) )
   {
      my $page_type = "\L$$args{'page_size'}";
      $$data{"page_width"}  = $$PDF::Maker::page_types{$page_type}[0];
      $$data{"page_height"}  = $$PDF::Maker::page_types{$page_type}[1];
   }

   $$data{"page_width"}   = $PDFDefaults{"page_width"}
                            unless defined($$data{"page_width"});
   $$data{"page_height"}  = $PDFDefaults{"page_height"} 	 
			    unless defined($$data{"page_height"});
 
   # Convert into inches
   $$data{"page_width"}   *= 72;
   $$data{"page_height"}  *= 72;

   $$data{"page_left_margin"}  = $PDFDefaults{"page_left_margin"}
			    unless defined($$data{"page_left_margin"});

   $$data{"default_font"}  = $PDFDefaults{"font"}
			    unless defined($$data{"default_font"});
   $$data{"default_font_size"}  = $PDFDefaults{"font_size"}
			    unless defined($$data{"default_font_size"});
   $$data{"header_font"}  = $PDFDefaults{"header_font"}
			    unless defined($$data{"header_font"});
   $$data{"header_font_size"} = $PDFDefaults{"header_font_size"}
			        unless defined($$data{"header_font_size"});
   $$data{"header_margin"} = $PDFDefaults{"header_margin"}
			        unless defined($$data{"header_margin"});

   # Default the center header to the title
   $$data{'center_header'} = $title unless defined($$data{'center_header'});

   $data->page();
  
   return $data;
} # sub new

sub content
{
   my 	($this, $options) = (shift(), shift());
   my	($format, @args);

   if( ref($options) eq "HASH" )
   {
      ($format, @args) = @_;
   }
   else
   {
      ($format, @args) = ($options, @_);
      $options = {};
   }

   my   ($pdf, $page) = ($$this{'pdf'}, $$this{'active_page'});
   my 	$font_size = defined($$options{'font_size'}) ?
			     $$options{'font_size'} : 
			     $$this{"default_font_size"};

   my   $font_size_diff = $$this{'last_font_size'}-$font_size;
   $$this{'active_page_y'} += $font_size_diff if $font_size_diff < 0;
   $$this{'last_font_size'} = $font_size;

   Log("Font diff of $font_size_diff\n");

   my 	$font_name = defined($$options{'font'}) ?
			     $$options{'font'} : 
			     $$this{'default_font'};

   $$options{"margin"} = 0 if !defined($$options{"margin"});

   my 	$left_margin = ($$this{"page_left_margin"} + $$options{"margin"})*72;

   my 	$align = defined($$options{'align'}) ? "\L$$options{'align'}" : 
			 $$this{'align'};

   my   $font = $pdf->font('Subtype'  => 'Type1',
 	   	           'Encoding' => 'WinAnsiEncoding',
 		           'BaseFont' => $font_name );

   my $content = $format;

   my $color = $$options{'font_color'};
   my $default_color = $$this{'default_font_color'};
   $this->setFontColor(defined($color) ? @$color : @$default_color);

   # split() will truncate to the right, so we need to preserve 
   # trailing newlines.
   my $newlines = ($content =~ tr/\n//);
   if( !$newlines )
   {
      $hanging_text .= $content;
      return;
   }
   else
   {
      $content = "$hanging_text $content";
      $hanging_text = '';
   }
   
   Log("There are $newlines newlines\n");

   my @lines 	= split(/\n/, $content);
   Log("Split: [", $content, "] into ", scalar @lines, " lines\n");

   # Detect widows and orphans if specified, note that this
   # ignores trailing newlines by virtue of split() discarding them,
   # which is good.
   if(   (defined($$options{'page_upon_widow'}) && $$options{'page_upon_widow'})
      || (defined($$this{'page_upon_widow'}) && $$this{'page_upon_widow'}) )
   {
     # Ignore the option is paging will be futile, i.e. the paragraph
     # exceeds the size of the page.
     my $height_used = $font_size*scalar(@lines); 

     Log("Paragraph height of $height_used and page height of ".
	 "$$this{'page_height'}\n".
         "operation will ".($$this{'page_height'} >= $height_used) ?
	 "be considered" : "be ignored");

     
     if( $$this{'page_height'} >= $height_used &&
         $$this{'active_page_y'}-($font_size*scalar(@lines)) 
         <= $$this{'header_margin'}*72 )
     {
        $this->page;
        $page = $$this{'active_page'};
     }
   }

   foreach my $line (@lines)
   {
     if( $$this{"active_page_y"}-$font_size <= $$this{"header_margin"}*72 )
     {
        $this->page();
        $page = $$this{'active_page'};
     }

     $line =~ s.\(.\\50.g;
     $line =~ s.\).\\51.g;
     $line =~ s.<.\\74.g;
     $line =~ s.>.\\76.g;
     $line =~ s.\[.\\133.g;
     $line =~ s.\].\\135.g;
     $line =~ s.\{.\\174.g;
     $line =~ s.\}.\\176.g;
     $line =~ s.%.\\25.g;

     if( $align eq "right" )
     {
        $page->stringr($font, $font_size, $$this{'page_width'}+$$this{'active_page_x'},
                       $$this{'active_page_y'}, $line);
     }
     elsif( $align eq "center" )
     {
        my $center_x = ($$this{'page_width'}-
                        $page->string_width($font, $line))/2;

        $page->stringc($font, $font_size, $center_x+$$this{'active_page_x'},
                      $$this{'active_page_y'}, $line);
     }
     else # Left Align
     {
        $page->string($font, $font_size, $left_margin+$$this{'active_page_x'},
                      $$this{'active_page_y'}, $line);
     }
     $$this{'active_page_x'} += $page->string_width($font, $line)*$font_size;

     if( $newlines > 0 )
     {
        $$this{"active_page_y"} -= $font_size;
        $$this{'active_page_x'} = 0;
     }
     $newlines--;
   }

   # Append the trailing newlines
   while( $newlines-- > 0 ) 
   { 
      $$this{"active_page_y"} -= $font_size;
      $$this{'active_page_x'} = 0;
   }
} # sub content

sub close
{
   my $this 	= shift();

   if( length($hanging_text) )
   { $this->content($hanging_text . "\n"); }

   my $pdf 	= $$this{'pdf'};

   my $header_margin_height  = $$this{"header_margin"}*72;
   my $header_y = $$this{'page_height'}-$$this{'header_font_size'};
   my $footer_y = $$this{'header_font_size'};

   # Add headers and footers
   for( my $i = $$this{'pages'}; $i > 0; $i-- )
   {
      my $page = $$this{"page_$i"};

      my $leftheader 	= ($$this{'left_header'});
      my $leftfooter 	= $$this{'left_footer'};
      my $rightheader 	= $$this{'right_header'};
      my $rightfooter 	= $$this{'right_footer'};
      my $centerheader 	= $$this{'center_header'};
      my $centerfooter 	= $$this{'center_footer'};

      # These are local so we can access them by name (using a string)
      # in the variable context.

      $leftheader 	= "" if !defined($leftheader);
      $rightheader 	= "" if !defined($rightheader);
      $centerheader 	= "" if !defined($centerheader);
      $leftfooter 	= "" if !defined($leftfooter);
      $rightfooter 	= "" if !defined($rightfooter);
      $centerfooter 	= "" if !defined($centerfooter);
     
      # Replace %n with the current page number
      foreach my $var ($rightheader, $rightfooter, $leftheader, $leftfooter,
		       $centerheader, $centerfooter)
      {
	  next unless defined $var;
	  $var =~ s.%n.$i.e;
	  $var =~ s.%t.localtime.e;
	  $var =~ s.\(.\\50.g;
	  $var =~ s.\).\\51.g;
	  $var =~ s.<.\\74.g;
	  $var =~ s.>.\\76.g;
	  $var =~ s.\[.\\133.g;
	  $var =~ s.\].\\135.g;
	  $var =~ s.\{.\\174.g;
	  $var =~ s.\}.\\176.g;
	  $var =~ s.%.\\25.g;
      }

      my ($font, $size, $color, $align, @lines, $lines);

      my $set_header_y = sub
      {
	 my $height = $size*$lines;

         if( $align eq 'top' )
         {
            $header_y = $$this{'page_height'}-$size-1;
         }
         elsif( $align eq 'bottom' )
         {
            $header_y = $$this{'page_height'}-$header_margin_height+($size*$lines);
         }
         else # Center
         {
	    $header_y = $$this{'page_height'}-
	                (($header_margin_height-$height)/2+$size/2);
         }
      };

      my $set_footer_y = sub
      {
	 my $height = $size*$lines;

         if( $align eq 'top' )
         {
            $footer_y = $header_margin_height-$size;
         }
         elsif( $align eq 'bottom' )
         {
            $footer_y = $size*($lines-1);
         }
         else # Center
         {
	    $footer_y = ($header_margin_height-$height)/2+$size/2;
         }
      };

      #warn "Current options are\n";
      while( my ($key, $value) = each %$this )
      {
      #   warn "$key => $value";
      }

      my($header_i, $footer_i) = (0, 0);

      # Left Header
      $font = $this->getAltFont($$this{'left_header_font'}, 
                                $$this{'header_font'});
      $color = $$this{'left_header_font_color'};
      $color = $$this{'header_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'left_header_font_size'}; 
      $size = $$this{'header_font_size'} unless defined($size);
      $align = $$this{'left_header_valign'};
      $align = $$this{'header_valign'} unless defined($align);
      $align = "\L${align}";
      @lines = split "\n", $leftheader;
      $lines = @lines;


      foreach my $line (split "\n", $leftheader)
      {
	 $set_header_y->();
         $page->string($font, $size, 0, $header_y - $size*$header_i, " $line");
	 $header_i++;
      }

      # Left Footer
      $font = $this->getAltFont($$this{'left_footer_font'}, 
                                $$this{'footer_font'});
      $color = $$this{'left_footer_font_color'};
      $color = $$this{'footer_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'left_footer_font_size'};
      $size = $$this{'footer_font_size'} unless defined($size);
      $align = $$this{'left_footer_valign'};
      $align = $$this{'footer_valign'} unless defined($align);
      $align = "\L$align";
      $footer_i = 0;
      @lines = split "\n", $leftfooter;
      $lines = @lines;
      $set_footer_y->();

      foreach my $line (split "\n", $leftfooter)
      {
         $page->string($font, $size, 0, $footer_y - $size*$footer_i, " $line");
	 $footer_i++;
      }

      # Right Header
      $font = $this->getAltFont($$this{'right_header_font'}, 
                                $$this{'header_font'});
      $color = $$this{'right_header_font_color'};
      $color = $$this{'header_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'right_header_font_size'};
      $size = $$this{'header_font_size'} unless defined($size);
      $align = $$this{'right_header_valign'};
      $align = $$this{'header_valign'} unless defined($align);
      $align = "\L$align";
      @lines = split "\n", $rightheader;
      $lines = @lines;
      $header_i = 0;
      $set_header_y->();

      foreach my $line (split "\n", $rightheader)
      {
         $page->stringr($font, $size, $$this{'page_width'}, 
                        $header_y - $size*$header_i, "$line ");
	 $header_i++;
      }

      # Right Footer
      $font = $this->getAltFont($$this{'right_footer_font'}, 
                                $$this{'footer_font'});
      $color = $$this{'right_footer_font_color'};
      $color = $$this{'footer_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'right_footer_font_size'};
      $size = $$this{'footer_font_size'} unless defined($size);
      $align = $$this{'right_footer_valign'};
      $align = $$this{'footer_valign'} unless defined($align);
      $align = "\L$align";
      @lines = split "\n", $rightfooter;
      $lines = @lines;
      $footer_i = 0;
      $set_footer_y->();

      foreach my $line (split "\n", $rightfooter)
      {
         $page->stringr($font, $size, $$this{'page_width'} - $size*$footer_i, 
                        $footer_y, "$line ");
	 $footer_i++;
      }

      my $center_x = ($$this{'page_width'}-
	 	     $page->string_width($font,$centerheader))/2;

      # Center Header
      $font = $this->getAltFont($$this{'center_header_font'}, 
                                $$this{'footer_font'});
      $color = $$this{'center_header_font_color'};
      $color = $$this{'header_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'center_header_font_size'};
      $size = $$this{'header_font_size'} unless defined($size);
      $align = $$this{'center_header_valign'};
      $align = $$this{'header_valign'} unless defined($align);
      $align = "\L$align";
      @lines = split "\n", $centerheader;
      $lines = @lines;
      $header_i = 0;
      $set_header_y->();

      foreach my $line (split "\n", $centerheader)
      {
         $page->stringc($font, $size, $center_x, $header_y - $size*$header_i, $line);
         $header_i++;
      }

      # Center Footer
      $font = $this->getAltFont($$this{'center_footer_font'}, 
                                $$this{'footer_font'});
      $color = $$this{'center_footer_font_color'};
      $color = $$this{'footer_font_color'} unless defined $color;
      $this->setFontColor(@$color);
      $size = $$this{'center_footer_font_size'};
      $size = $$this{'footer_font_size'} unless defined($size);
      $align = $$this{'center_footer_valign'};
      $align = $$this{'footer_valign'} unless defined($align);
      $align = "\L$align";
      @lines = split "\n", $centerfooter;
      $lines = @lines;
      $footer_i = 0;
      $set_footer_y->();

      foreach my $line (@lines)
      {
         $page->stringc($font, $size, $center_x, 
                        $footer_y - $size*$footer_i, $line);
         $footer_i++;
      }
   }

   $pdf->close();
} # sub close

sub getAltFont
{
   my ($this, $primary, $alt) = @_;

   my $pdf 	= $$this{'pdf'};
   my $font = $pdf->font('Subtype'  => 'Type1',
 	             'Encoding' => 'WinAnsiEncoding',
 	             'BaseFont' => defined($primary) ? $primary : $alt);
   return $font;
} # sub getHeaderFont

sub page
{
   my $this 	= shift();
   my $pdf 	= $$this{'pdf'};
   my $pagenum	= ++$$this{'pages'};
   my $page	= $$this{'active_page'};

   # Place the beginning y position for the body text
   # down from the header text a reasonable distance.
   $$this{"active_page_y"} 	= $$this{"page_height"}-
				  $$this{"header_margin"}*72;
   $$this{"page_${pagenum}"} = $$this{'active_page'} = 
     $pdf->new_page('MediaBox' => [ 0, 0, $$this{"page_width"}, 
				          $$this{"page_height"} ]);

   # this is a stupid hack to ensure PDF::Create will
   # open the stream object in case PDF::Maker does some
   # pdf insertions (which must be inside stream .... endstream)
   my   $font = $pdf->font('Subtype'  => 'Type1',
                           'Encoding' => 'WinAnsiEncoding',
                           'BaseFont' => 'Times-Roman');
   $$this{'active_page'}->string($font, 0, 0, 0, " ");
   $$this{'last_font_size'} = $$this{'font_size'};
   $$this{'active_page_x'} = 0;
} # sub page

sub setFontColor
{
  my $this = shift();
  my ($r, $g, $b) = @_;
  my $pdf = $$this{'pdf'};
  $pdf->add("\n$r $g $b rg");
} # sub setFontColor


sub setOptions
{
   my ($this, $options) = @_;

   while( my ($key, $value) = each(%$options) )
   {
      $key = "\L$key";
      $$this{$key} = $value;

      # A nasty hack to allow multiple line headers
      if( $key =~ 'header$' )
      {
         my @lines = split "\n", $value;
 	 my $lines = @lines;

         my $needed_margin = int $$this{'header_font_size'} * $lines / 72 + 1;
         
         Log("$key => $value\n");
         Log("$needed_margin' needed to accomadate $lines line, $$this{'header_font_size'} ".
	     "point header\n");

         $$this{'header_margin'} = $needed_margin unless $$this{'header_margin'} 
                                   >= $needed_margin;
      }
   }
   # this is a nasty hack to unnaturally update options
   # variables that have side-effects on the output
   # If this has gets called after the first call to content()
   # for a page, this WILL BREAK. There is no clean way
   # to fix this without requiring a rewrite of either this
   # module or PDF::Create
   $$this{"active_page_y"}      = $$this{"page_height"}-
                                  $$this{"header_margin"}*72;
} # sub setOptions

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.11  2008/12/03 14:01:19  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.10  2001/02/14 15:35:47  sridhar
# Added copyright and GPL notice
#
# Revision 1.9  2000/10/11 16:52:48  aviert
# Added support for multiple line headers and footers.
#
# Revision 1.8  2000/09/20 16:10:27  aviert
# Corrected newline output problem.
#
# Revision 1.7  2000/09/19 21:11:34  aviert
# corrected bug where x was not reset to zero upon newline.
#
# Revision 1.6  2000/09/19 12:53:14  aviert
# Fixed horizontal and vertical control problems.
# The implementation supporting PDF::Create will
# no longer be supported after this version, but
# the PDF::Maker interface will not change.
#
# Revision 1.4  2000/09/14 19:08:50  aviert
# Added HACK in Maker.pm to allow header_margin to be
# set by 'setOptions' before the first call to 'content'
# after a page has been created.
#
# Revision 1.3  2000/09/14 18:21:08  aviert
# Committed the re-added Maker.pm
#
#
