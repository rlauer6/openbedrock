package BLM::PrefixCalculator;

my %float_funcs =
(
   '+'  => sub { $_[0] +  $_[1]; },
   '-'  => sub { $_[0] -  $_[1]; },
   '*'  => sub { $_[0] *  $_[1]; },
   '/'  => sub { $_[0] /  $_[1]; },
   '%'  => sub { $_[0] %  $_[1]; },
   '**' => sub { $_[0] ** $_[1]; },
);

my %int_funcs =
(
   '+'  => sub { int $_[0] +  int $_[1]; },
   '-'  => sub { int $_[0] -  int $_[1]; },
   '*'  => sub { int $_[0] *  int $_[1]; },
   '/'  => sub { int $_[0] /  int $_[1]; },
   '%'  => sub { int $_[0] %  int $_[1]; },
   '**' => sub { int $_[0] ** int $_[1]; },
);

sub new
{
   bless { 'funcs' => \%int_funcs,
           'expr'  => [],
	 }, shift;
} # sub new

sub TIEHASH
{
   new();
} # sub TIEHASH

sub perform_float_ops { ${_[0]}->{'funcs'} = \%float_funcs; }
sub perform_int_ops   { ${_[0]}->{'funcs'} = \%float_funcs; }
sub clear             { ${_[0]}->{'expr'}  = []; }

sub push              
{ 
   my $this = shift;
   push @{$this->{'expr'}}, @_;
} # sub push

sub evaluate
{
   my $this = shift;
   my @stack;
   my $expr = $this->{'expr'};

   while( 0 < @$expr )
   {
      my $val = pop @$expr;
      print "[$val]\n";

      if( $val =~ /^\d+$/ )
      {
	 push @stack, $val;
      }
      elsif( exists $this->{'funcs'}->{$val} )
      {
         die "Stack underflow" unless 2 <= @stack;
         push @stack, $this->{'funcs'}->{$val}->(pop @stack, pop @stack);
      }
      else
      {
         die "Invalid token: \"$val\"";
      }
   }
   die "Incomplete expression" unless 1 == @stack;
   pop @stack;
} # sub evaluate

1;
