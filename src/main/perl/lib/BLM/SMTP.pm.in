#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2023, TBC Development Group, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::SMTP;

use strict;
use warnings;

use Bedrock::Constants qw(:booleans :chars);
use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use List::Util qw(pairs any);
use Net::SMTP;
use Scalar::Util qw(reftype);

use parent qw(Bedrock::Handle);

########################################################################
sub can {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $args[0] eq 'new' ? undef : $self->SUPER::can( $args[0] );
}

########################################################################
sub choose(&) { return $_[0]->(); }  ## no critic
########################################################################

########################################################################
sub TIEHANDLE {
########################################################################
  my ( $class, @args ) = @_;

  die "usage: <plugin:SMTP parameters>\n"
    if !@args;

  my $self = bless {}, $class;

  my %options;

  my $host = choose {

    if ( ref $args[0] ) {
      my $params = shift @args;

      %options = ( %{$params}, @args );

      $self->{from} = delete $options{From};

      $self->{subject} = delete $options{Subject};

      if ( $options{To} ) {
        $self->{to} = [ delete $options{To} ];
      }

      if ( $options{CC} ) {
        $self->{cc} = [ delete $options{CC} ];
      }

      return delete $options{Host};
    }

    my ( $host, $sender, $to, $cc, $subject, @extra_options ) = @args;

    $self->{from} = $sender;

    $self->{subject} = $subject;

    if ($to) {
      $self->{to} = [$to];
    }

    if ($cc) {
      $self->{cc} = [$cc];
    }

    %options = ref $extra_options[0] ? $extra_options[0] : @extra_options;

    return $host;
  };

  die "no from address\n"
    if !$self->{from};

  carp "no host set...using localhost\n"
    if !$host;

  $host //= 'localhost';

  if ( $host =~ /:(\d+)$/xsml ) {
    $options{Port} = $1;
  }

  my $user = delete $options{AuthUser};
  my $pass = delete $options{AuthPass};
  my $sasl = delete $options{SASL};

  my $smtp = Net::SMTP->new( $host, %options );
  $self->{server} = $smtp;

  die "unable to connect to $host\n$EVAL_ERROR"
    if !$self->{server};

  if ( $user && $pass ) {
    $smtp->auth( $user, $pass );
  }
  elsif ($sasl) {
    $smtp->auth($sasl);
  }

  $smtp->mail( $self->{from} );

  return $self;
}

########################################################################
sub send_message {
########################################################################
  my ( $fd, $msg ) = @_;

  my $self = tied *{$fd};

  my $server = $self->{server};

  $self->{start_end} = 1;

  print {*STDERR} Dumper($self);

  $server->to( @{ $self->{to} || [] } );

  $server->data;
  $server->datasend($msg);
  $server->dataend;

  return;
}

########################################################################
sub WRITE {
########################################################################
  my ( $self, $buf, $len, $offset ) = @_;

  my $server = $self->{server};

  # If writing for first time, need to do some things
  if ( !exists $self->{start_send} ) {

    # croak if some required stuff not specified
    die ref($self), "->WRITE(): `to' address not specified.\n"
      if !$self->{to};

    # mark to indicate we are sending and no more headers accepted
    $self->{start_send} = $TRUE;

    # Set the to address -- this is the only header really required.
    $server->to( @{ $self->{to} || [] } );

    # Start sending the data.
    $server->data;

    # Need to write subject and cc headers now
    $server->datasend( sprintf "To: %s\n", join q{,}, @{ $self->{to} } );

    $server->datasend( sprintf "From: %s\n", $self->{from} );

    if ( $self->{subject} ) {
      $server->datasend( sprintf "Subject: %s\n", $self->{subject} );
    }

    my @cc_list = @{ $self->{cc} || [] };

    if (@cc_list) {
      local $LIST_SEPARATOR = ', ';

      $server->datasend( sprintf "CC: %s\n", @cc_list );
    }

    # Write the rest of the headers now
    if ( exists $self->{header} ) {

      for my $p ( pairs %{ $self->{header} } ) {
        my ( $key, $value ) = @{$p};

        $server->datasend("$key: $value\n");
      }
    }

    # End of all headers
    $server->datasend("\n");
  }

  return $server->datasend($buf);
}

# called if someone does a close();
########################################################################
sub CLOSE {
########################################################################
  my ($self) = @_;

  $self->{server}->dataend;
  $self->{server} = undef;

  return;
}

########################################################################
sub to {
########################################################################
  my ( $fd, $to ) = @_;

  return
    if !$to;

  my $self = tied *{$fd};

  die ref($fd), "->to(): cannot specify `to' address once message send has been started.\n"
    if exists $self->{start_send};

  $self->{to} //= [];

  push @{ $self->{to} }, $to;

  return $self->{to};
}

########################################################################
sub from {
########################################################################
  my ( $fd, $from ) = @_;

  return if !$from;

  my $self = tied *{$fd};

  die ref($fd), "->to(): cannot specify `from' address once message send has been started.\n"
    if exists $self->{start_send};

  $self->{from} = $from;

  return $self->{from};
}

########################################################################
sub recipient {
########################################################################
  my ( $self, $recipient ) = @_;

  return if !$recipient;

  return $self->to($recipient);
}

########################################################################
sub cc {
########################################################################
  my ( $fd, $cc ) = @_;

  return if !$cc;

  my $self = tied *{$fd};

  die ref($fd), "->cc(): cannot specify `CC' address once message send has been started.\n"
    if exists $self->{start_send};

  $self->{cc} //= [];

  push @{ $self->{cc} }, $cc;

  return $self->{cc};
}

########################################################################
sub subject {
########################################################################
  my ( $fd, @subject ) = @_;

  return if !@subject;

  my $self = tied *{$fd};

  die ref($fd), "->subject(): cannot specify `Subject' once message send has been started.\n"
    if exists $self->{start_send};

  $self->{subject} = "@subject";

  return $self->{subject};
}

########################################################################
sub header {
########################################################################
  my ( $fd, @args ) = @_;

  return if !@args;

  my $self = tied *{$fd};

  die ref($fd), "->header(): cannot specify any header(s) once message send has been started.\n"
    if exists $self->{start_send};

  my %args = @args;

  $self->{header} //= {};

  for my $p ( pairs @args ) {
    my ( $key, $value ) = @{$p};

    next if any { $key eq $_ } qw( cc to from subject );

    $self->{header}->{ ucfirst $key } = $value;
  }

  return;
}

########################################################################
sub DESTROY {
########################################################################
  my $self = shift;

  if ( ref($self) && reftype($self) eq 'HASH' ) {

    if ( $self->{server} ) {
      $self->{server}->dataend;
    }

    $self->{server} = undef;
  }

  return;
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 PUBLIC

BLM::SMTP - Bedrock interface to an SMTP server via L<Net::SMTP>.

=head1 SYNOPSIS

 <plugin:SMTP localhost fred@openbedrock.net barney@openbedrock.net>

 <null $SMTP.subject("Bowling tonight!")>

 <sink $SMTP>
 Grab your balls and let's go to the alley buddy!
 </sink>

=head1 DESCRIPTION

Plugin for sending mail using L<Net::SMTP>.

I<NOTE>: This module differs from C<BLM::Mail> in that it implements a
handle which can be used with the C<sink> tag.

=head2 Postional Parameters

=over 5

=item Host (required)

Host name to connect to. You can include a port suffix on the hostname
if you are using a port other than 25.

 email-smtp.us-east-1.amazonaws.com:465

default: localhost

=item From (required)

Send email address

=item To (required)

Recipient. You can later use the C<to()> method to add recipients.

=item CC

CC list. You can later use the C<cc()> method to add recipients.

=item Subject

Text to send as the subject of the email.

=item key/value pairs

When using positional arguments you can tack on additional key/value
pairs that will be sent to C<Net::SMTP>. For example:

 <plugin:SMTP localhost support@openbedrock.net someuser@example.com '' 'Your Inquiry' AuthUser fred AuthPass flintstone Debug 1>

=head2 Parameters Sent as Hash Object

You can pass the parameters to the the plugin using as hash as the
first argument. You can also follow that with key value pairs.

=head3 Example:

 <hash:config Host email-smtp.us-east-1.amazonaws.com:465 SSL AuthUser $user AuthPass $pass>
 <plugin:SMPT $config From fred@openbedrock.net To barney@openbedrock.net>

The keys below can be sent in addition to the parameters listed under
L<Positional Paramaters>.

=item Debug

Set B<Debug> to a true value to force debug output from L<Net::SMTP.

default: false

=item Port

Port to connect to.

default: 25

=item SSL

SSL parameter (see L<Net::SMTP> for a complete explanation). 

I<SSL - If the connection should be done from start with SSL, contrary
to later upgrade with "starttls". You can use SSL arguments as
documented in L<IO::Socket::SSL>, but it will usually use the right
arguments already.>

=item AuthUser

Username if authentication is used. Both AuthUser and AuthPass must be specified.

=item AutPass

Password if authentication is used. Both AuthUser and AuthPass must be specifed.

=item SASL

L<Authen::SASL> object if authentication is used and you have not
specified the AuthUser and AuthPass values.

=back

=head3 Use a Configuration File for Parameters

You might find it more convenient to create a configuration file
that you can drop in Bedrock's configuration path. For example:

 <object>
   <object name="smtp">
     <scalar name="Host">email-smtp.us-east-1.amazonaws.com:465</scalar>
     <scalar name="SSL">1</scalar>
     <scalar name="AuthUser">AJK**************IGB</scalar>
     <scalar name="AuthPass">ABp**************************************Iih</scalar>
   </object>
 </object>

...then

 <plugin:SMTP $config.smtp From fflintstone@openbedrock.net To brubble@openbedrock.net>

=head2 Notes

=over 5

=item * Set the object methods B<before> using the handle for sending data.

=item * The plugin will attempt to connect to the SMTP server during initialization.

Best practice is use the plugin when all of your content has been completely rendered.

 <sink:email>
   <!-- produce your content here -->
 </sink>

 <plugin:SMTP $config.smtp From fflintstone@openbedrock.net To brubble@openbedrock.net>
 <sink $SMTP><var $email></sink>

=back

=head1 METHODS AND SUBROUTINES

In addition to passing parameters when you initialize the plugin, you
can use methods on the plugin to set parameters.

=head2 to( address, address, ... )

Specify one or more addresses to send the message to.

=head2 cc( address, address, ... )

Specify one more addresses to be included as C<CC:>

=head2 subject( subject )

Set the subject header of the message

=head2 header( header-name, header-value, .. )

Specify key/value pairs for the SMTP header value which are set in the
outgoing message. These headers are not parsed.

For example, use the following to specify that message body contains HTML

 <null $SMTP.header( "Content-type", "text/html")>

=head1 EXAMPLES

Use the object returned when you invoke the C<plugin> tag as the
argument to the C<sink> tag. The body of the C<sink> tag becomes the
body of the message.

 <plugin:SMTP localhost fred@openbedrock.net barney@openbedrock.net>

 <sink $SMTP>
   message body here
 </sink>

I<Note that the C<E<lt>sinkE<gt>> tag accepts a tied handle as an
argument, so all output is written to that handle.>

=head2 Error Notifications

 <try>
   <raise 'some error'>
 <catch>
   <plugin:SMTP localhost support@openbedrock.net support@openbedrock.net>

   <null $SMTP.subject('an error has occurred')>

   <sink $SMTP>
     Something went wrong:

     <var $@>
   </sink>
 </try>

=head1 AUTHOR

J. Sridhar, Rob Lauer

=head1 SEE ALSO

L<BLM::Mail>

=cut
