#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::UserSession;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= 1.07;
}

use Carp;
use DBI;
use Bedrock::Hash;
use TagX::Log;
use Digest::MD5;
use POSIX qw(strftime);

@ISA = qw(Bedrock::Hash);

=pod

=head1 PUBLIC

C<BLM::Startup::UserSession> - provides a persistent store for Bedrock applications.

=head1 SYNOPSIS

 <var $session.set('foo', 'bar')>

=head1 DESCRIPTION

Implements stateful sessions stored to a MySQL database.  The session
is accessed via the Bedrock object C<$session> (or by whatever binding
name you might configure in F<tagx.xml>.

Sessions can be based on a session identifier stored as a B<cookie> on the user's browser or by using a
CGI variable named C<session>.

=head1 CONFIGURING Bedrock FOR SESSIONS

The C<BLM::Startup::UserSession> is typically the mechanism Bedrock
web applications use to maintain persitence. It uses a MySQL table to
store the user's session information.  A database and table need to be
created before you can use the C<$session> object.

First you'll want to create a MySQL database or if you already have
one that you are going to use to hold user session data then skip this
part.

  $ mysqladmin create berock -u root -p
  $ cat > create_session.sql
 drop table if exists session;

 create table session
  (
   id           int(11)      not null auto_increment,
   session      varchar(50)  not null default '',
   login_cookie varchar(50)  not null default '',
   username     varchar(50)  not null default '',
   password     varchar(30)  default null,
   firstname    varchar(30)  default null,
   lastname     varchar(50)  default null,
   email        varchar(100) default null,
   prefs        text,
   updated      timestamp    not null default current_timestamp on update current_timestamp,
   added        datetime     default null,
   expires      datetime     default null,
   primary      key  (id)
 );
 
 grant all privileges on bedrock.* to fred@localhost identified by 'flintstone';
 ^D
 $ cat create_session.sql | mysql -u root -p bedrock

At this point you should have a database named B<bedrock> and a table name B<session>.

Now you need to configure the C<BLM::Startup::UserSession> module in F<tagx.xml>.

In the C<MODULES> array add the C<BLM::Startup::UserSession> module:

   <array name="MODULES">

    <object>

     <scalar name="binding">session</scalar>
     <scalar name="module">BLM::Startup::UserSession</scalar>

     <object name="config">
      <scalar name="verbose">2</scalar>
      <scalar name="param">session</scalar>
      <scalar name="login_cookie_name">usession_login</scalar>
      <scalar name="login_cookie_expiry_days">365</scalar>
      <scalar name="data_source">dbi:mysql:bedrock</scalar>
      <scalar name="username">bedrock</scalar>
      <scalar name="password">fred</scalar>
      <scalar name="table_name">session</scalar>
      <scalar name="purge_user_after">30</scalar>
      <scalar name="cookieless_sessions></scalar>
      <object name="cookie">
 	<scalar name="path">/</scalar>
 	<scalar name="expiry_secs">3600</scalar>
 	<scalar name="domain"></scalar>
      </object>

     </object>

    </object>

   </array>

You now can use the C<$session> object in your Bedrock applications.
Note that users should have cookies enabled on their web browser in
order to support cookie based sessions.

=head1 COOKIELESS SESSIONS

By default user session require that cookies are enabled on the user's
web browser.  This is because the C<$session> object will use the
value of a cookie (C<session>) to identify the user's session.  If you
need to run in an environment where cookies cannot be enabled, then
you can use cookieless sessions. In that case, the
C<BLM::Startup::UserSession> will use a CGI variable by the same name
to hold the session value.  It is the responsibility then of the
application to carry around the session identifier from page to page.

To enable I<cookieless> sessions, first set the configuration value
C<cookieless_sessions> to 1 in F<tagx.xml> in the
C<BLM::Startup::UserSession> section.

In your application...

 <if $input.session>
   <null $session.cookieless_session($input.session)>
 <else>
   <null $input.set('session', $session.session)>
 </if>

This either starts a new session or tells C<BLM::Startup::UserSession>
to use an existing session.  You'll then want to carry around that
session identifier in your web pages either as part of a form or in a
URL.

 <input type="hidden" name="session" value="<var $input.session>">

 <a href="/index.roc?session=<var $input.session>">link to another page in application...</a>

=head1 METHODS

=cut

sub digest
{
    my $md5 = Digest::MD5->new;
    $md5->add( sprintf("%012d:%20s:%08d:%.10f", time, $ENV{REMOTE_ADDR}, $$, rand) );
    $md5->hexdigest;
}

# 
# Convenience routine for setting a cookie.
# Invoked as follows:
# $self->cookie($cookie_name, param, value, ..)
# where the valid params are
#   value	=> value for the cookie
#   expires	=> time for cookie expiration in seconds
#   domain	=> value for domain
#   path	=> value for path
#
sub cookie
{
    my $self = shift;
    my $name = shift;

    $self->{'cookies'} = {} unless $self->{'cookies'};
    $self->{'cookies'}->{$name} = {} unless $self->{'cookies'}->{$name};
    my $cref = $self->{'cookies'}->{$name};
    if ( ref($_[0]) ) {
	for my $param (keys %{$_[0]}) {
	    $cref->{$param} = $_[0]->{$param};
	}
    } else {
	my %args = @_;
	for my $param (keys %args) {
	    $cref->{$param} = $args{$param};
	}
    }
}

sub send_cookie
{
    my $self = shift;
    return unless $self->{'cookies'};

    my $config = $self->{'config'};
    my ($cref, $header);

    for my $name (keys %{$self->{'cookies'}}) {
	$cref = $self->{'cookies'}->{$name};
	$header = $name . '=' . $cref->{'value'} . '; ';

	$header .= 'path=' . ($cref->{'path'} || $config->{'cookie'}->{'path'} || '/') . '; ';

	my $domain = $config->{'cookie'}->{'domain'};
	$header .= 'domain=' . $domain . '; ' if length( $domain );

	if ( exists $cref->{'expires'} ) {
	    my $expiry = POSIX::strftime("%a, %d-%b-%Y %T GMT", gmtime(time + $cref->{'expires'}));
	    $header .= 'expires=' . $expiry . '; ';
	}

	$self->{'ctx'}->cgi_header_out('Set-Cookie', $header);
	&log_message( undef, "Set cookie header: [Set-Cookie => $header]" ) if $self->{'verbose'} > 1;
    }
}

sub startSession
{
    my ($self, $config) = @_;

    $self->{'config'} = $config;

    # Get the required database params
    my $dsn = $config->{'data_source'};
    die ref($self), "->startSession(): param `data_source' must be specified in config\n"
	unless $dsn;

    my $table = $config->{'table_name'};
    die ref($self), "->readData(): param `table_name' must be specified in config\n"
	unless $table;

    my $u = $config->{'username'};
    my $p = $config->{'password'};

    # And do the connect
    my $dbh = DBI->connect ( $dsn, $u, $p );
    die "Could not connect to database `$dsn': ", $DBI::errstr, "\n" unless $dbh;
    $self->{'dbh'} = $dbh;
}

sub newLoginCookie
{
    my $self = shift;

    my $config = $self->{'config'};
    my $ctx = $self->{'ctx'};
    my $id = &digest;

    unless ($config->{'cookieless_sessions'}) {
      # Set the cookie header
      $self->cookie($config->{'login_cookie_name'},
		    'value'	=> $id,
		    'expires'	=> ( $config->{'login_cookie_expiry_days'} || 30 ) * 86400 );
      $self->send_cookie;
    }
    
    $id;
}

sub newSessionID
{
    my $self = shift;

    my $config = $self->{'config'};
    my $ctx = $self->{'ctx'};
    my $id = $self->{'session'} = &digest;
    
    my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400; $self->{'expires'} = $secs;
    
    unless ($config->{'cookieless_sessions'}) {
      # Set the cookie header
      $self->cookie($self->{'name'},
		    'value'	=> $id,
		    'expires'	=> $secs);
      $self->send_cookie;
    }

    $id;
}

sub do_select
{
    my $self = shift;
    my $stm = shift;
    my $dbh = $self->{'dbh'};

    my $sth = $dbh->prepare($stm);
    die "Unable to prepare SQL query: $stm\n", $dbh->errstr, "\n" unless $sth;

    for (my $i = 1 ; $i <= @_ ; $i++ ) {
	$sth->bind_param ( $i, $_[$i-1] ) || die "Could not bind parameter $i ($_[$i-1]): ", $sth->errstr, "\n";
    }

    my $rows = $sth->execute;
    die "Error executing SQL statement: $stm\n", $sth->errstr, "\n" unless defined $rows;

    my ($aref, $n);
    $n = 0;
    while ( $_ = $sth->fetch ) {
	$aref = $_;
	$n++;
    }
    die "Error extracting data from SQL query: ", $sth->errstr, "\n" if $sth->err;
    die "Query found more than 1 row (found $n rows).\n" if $n > 1;
    $aref;
}

sub do_sql
{
    my $self = shift;
    my $stm = shift;
    my $dbh = $self->{'dbh'};

    my $sth = $dbh->prepare($stm);
    die "Unable to prepare SQL statement: $stm\n", $dbh->errstr, "\n" unless $sth;

    for (my $i = 1 ; $i <= @_ ; $i++ ) {
	$sth->bind_param ( $i, $_[$i-1] ) || die "Could not bind parameter $i ($_[$i-1]): ", $sth->errstr, "\n";
    }

    my $rows = $sth->execute;
    die "Error executing SQL statement: $stm\n", $sth->errstr, "\n" unless defined $rows;
    $rows;
}

sub newSession
{
    my $self = shift;

    $self->newSessionID;
    $self->{'new_session'} = 1;
    $self->{'data'} = {'prefs' => {}};
    $self->{'session'};
}

sub init_session
{
    my $self = shift;
    my $aref = shift;

    my ($verbose) = @{$self}{qw(verbose)};
    if ( $aref ) {
	&log_message( undef, "Initializing session\nusername = ($aref->[0])\nfirstname = ($aref->[1])\nlastname = ($aref->[2])\nemail = ($aref->[3])" ) if $verbose;
	&log_message( undef, "Session prefs are\n$aref->[-1]" ) if $verbose > 1;
	my $data = {};
	@{$data}{qw(username firstname lastname email)} = (@{$aref}[0,1,2,3]);
	$data->{'prefs'} = Bedrock::XML->newFromString( $aref->[-1] ) if length( $aref->[-1] );
	$data->{'prefs'} = {} unless $data->{'prefs'};

	$self->{'data'} = $data;
    } else {
	&log_message( undef, "Initializing new session" ) if $verbose;
	$self->newSession;
    }
}

#
# `session' is stored under $self
# `username', `password', `firstname', `lastname', `email' if stored under $self->{'data'}
# `new_session' is set to 1 if no previous session info found for user
# Other than these are stored under $self->{'data'}->{'prefs'}
#
sub readData
{
    my ($self, $id) = @_;

    my ($config, $verbose) = @{$self}{qw(config verbose)};

    &log_message( undef, "Reading data for session [$id]" ) if $verbose;
    my $t = $config->{'table_name'};
    my $aref = $self->do_select(qq(select username, firstname, lastname, email, prefs
				   from $t where session = ? and expires > now()),
				$id);
    unless ( $aref ) {
	&log_message( undef, "Unable to read data for session [$id]" ) if $verbose;
	return;
    }

    unless ($config->{'cookieless_sessions'}) {
      my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400; $self->{'expires'} = $secs;
      $self->cookie($self->{'name'},
		    'value'	=> $id,
		    'expires'	=> $secs);
      $self->send_cookie;
    }

    $self->{'session'} = $id;
    $self->init_session($aref);
    $self->{'session'};
}

sub newLoginSession
{
    my $self = shift;
    my $login_id = shift;

    my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};
    my $t = $config->{'table_name'};
    my $aref = $self->do_select(qq(select username, firstname, lastname, email, prefs
				   from $t where login_cookie = ?),
				$login_id);

    unless ( $aref ) {
	&log_message( undef, "Login session [$login_id] not found" ) if $verbose;
	return;
    }

    my $data = {};
    &log_message( undef, "Found login session [$login_id]\nusername = ($aref->[0])\nfirstname = ($aref->[1])\nlastname = ($aref->[2])\nemail = ($aref->[3])" ) if $verbose;
    &log_message( undef, "Saved session info for login session [$login_id] is\n$aref->[-1]" ) if $verbose > 1;
    @{$data}{qw(username firstname lastname email)} = (@{$aref}[0,1,2,3]);
    $data->{'prefs'} = Bedrock::XML->newFromString( $aref->[-1] ) if length( $aref->[-1] );

    # Create new session id
    my $id = $self->newSessionID;

    # Prepare SQL statement to save the session id in the database.
    my $stm = qq{update $t set session = ?};
    my @bind = ($id);

    if ( $self->{'expires'} ) {
	$stm .= ", expires = date_add(now(), interval ? second)";
	push @bind, $self->{'expires'};
    }

    $stm .= " where login_cookie = ?";
    push @bind, $login_id;
    my $rows = $self->do_sql($stm, @bind);
    &log_message( undef, "Updating session = [$id] for login session [$login_id]: rows = [$rows]\n$stm" ) if $verbose;

    $data->{'prefs'} = {} unless $data->{'prefs'};
    $self->{'data'} = $data;
    $self->{'session'};
}

sub TIEHASH
{
    my ($class, $ctx, $config) = @_;

    # What is the name of the session variable being used?
    my $name = $config->{'param'};
    die "$class->TIEHASH(): `param' not set in config\n" unless $name;

    # Create session object
    my $self = bless {}, $class;
    $self->{'ctx'} = $ctx;
    $self->{'name'} = $name;
    $self->{'config'} = $config;

    my $verbose = $self->{'verbose'} = $config->{'verbose'};

    # Initialize session
    $self->startSession($config);

    # Check for an existing session
    my $id = $config->{'cookieless_sessions'} ? $ctx->getInputValue($name) : $ctx->getCookieValue($name);

    # Get the session data only if a session exists
    if ( defined( $id ) ) {
      &log_message( undef, "Read user's session: [$id]" ) if $verbose;
      my $session = $self->readData($id);
      &log_message( undef, "User has session [$session]" ) if $session and $verbose;
      return $self if $session;
    }

    # No session cookie -- check to see if login cookie present
    my $login_cookie_name = $config->{'login_cookie_name'};
    my $login_id  = $config->{'cookieless_sessions'} ? $ctx->getInputValue($login_cookie_name) : $ctx->getCookieValue($login_cookie_name);

    if ( $login_id ) {
	my $session = $self->newLoginSession($login_id);
	&log_message( undef, "User has login session [$login_id] -- session is [$session]" ) if $session and $verbose;
	return $self if $session;
    }

    # everything failed -- need to create a new session
    my $session = $self->newSession;
    &log_message( undef, "User does not have anonmous session or login session -- using [$session]" ) if $verbose;

    $self->{'data'}->{'prefs'}->{expiry_secs} = $self->{'config'}->{'cookie'}->{'expiry_secs'};

    # And return the session object
    $self;
}

sub FETCH
{
    my ($self, $key) = @_;
    if ( $key eq 'session' ) { return $self->{$key} }
    elsif ( $key =~ /^(username|firstname|lastname|email|config)$/ ) { return $self->{'data'}->{$key} }
    elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) { $self->{'data'}->{'prefs'}->{$key} }
    else { return $self->{'config'}->{'default_prefs'}->{$key} }
}

# Just store the value in the session and return the value
sub STORE
{
    my ($self, $key, $value) = @_;
    if ( $key =~ /^(session|username)$/ ) {
	die "Cannot set `$key': attribute is read-only.\n";
    } elsif ( $key eq 'password' ) {
	die "Cannot set `password': Use `change_password()' instead.\n";
    } elsif ( $key =~ /^(firstname|lastname|email)$/ ) {
	die "Cannot set `$key' -- no username: use `login()' or `register()' first.\n"
	    unless $self->{'data'}->{'username'};
	die "Cannot store empty string in `$key'.\n" if $key =~ /^(firstname|lastname)$/ and length($value) == 0;
	&log_message( undef, "Storing [$key] = [$value]" ) if $self->{'verbose'};
	return $self->{'data'}->{$key} = $value;
    } else {
	&log_message( undef, "Stored [$key] = [$value] into prefs" )
	    if $self->{'verbose'};
	return $self->{'data'}->{'prefs'}->{$key} = $value;
    }
}

# Invoked to loop over the properties of the session
sub FIRSTKEY
{
    my $self = shift;

    delete $self->{'keys'};

    my $k = {'session' => $self->{'session'},
	     'username' => $self->{'data'}->{'username'},
	     'firstname' => $self->{'data'}->{'firstname'},
	     'lastname' => $self->{'data'}->{'lastname'},
	     'email' => $self->{'data'}->{'email'}};

    my %keys;
    @keys{keys %{$self->{'data'}->{'prefs'}}, keys %{$self->{'config'}->{'default_prefs'}}} = ();
    for my $key (keys %keys) {
	if ( exists $self->{'data'}->{'prefs'}->{$key} ) {
	    $k->{$key} = $self->{'data'}->{'prefs'}->{$key};
	} else {
	    $k->{$key} = $self->{'config'}->{'default_prefs'}->{$key};
	}
    }
    $self->{'keys'} = $k;
    each %{$self->{'keys'}};
}

sub NEXTKEY
{
    each %{shift->{'keys'}};
}

sub EXISTS
{
    my ($self, $key) = @_;
    if ( $key eq 'session' ) { return 1 }
    elsif ( $key =~ /^(username|password|firstname|lastname|email)$/ ) { return exists $self->{'data'}->{$key} }
    elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) { return 1 }
    else { exists $self->{'config'}->{'default_prefs'}->{$key} }
}

sub DELETE
{
    my ($self, $key) = @_;
    if ( $key =~ /^(session|username|firstname|lastname|email|password)$/ ) {
	die "Cannot delete `$key': illegal operation.\n";
    } else {
	return delete $self->{'data'}->{'prefs'}->{$key};
    }
}

sub CLEAR
{
    my $self = shift;
    %{$self->{'data'}->{'prefs'}} = ();
}

sub db_handle
{
    my $obj = shift;
    my $self = tied(%{$obj});
    $self->{'dbh'};
}

sub closeBLM
{
    my $obj = shift;
    my $self = tied(%{$obj});

    my ($verbose, $session) = @{$self}{qw(verbose session)};
    my $prefs = $self->{'data'}->{'prefs'};
    $prefs = $self->{'config'}->{'default_prefs'} if keys %{$prefs} == 0;
    my $xml = Bedrock::XML::writeXMLString($prefs);
    &log_message( undef, "Saving session [$session] data\n$xml" ) if $verbose > 1;

    my $t = $self->{'config'}->{'table_name'};
    if ( $self->{'new_session'} ) {
	# Insert anon session
	my $rows = $self->do_sql("insert into $t (added, session, prefs) values(now(), ?, ?)",
				 $session, $xml);
	&log_message( undef, "Inserting session [$session]: rows = [$rows]" ) if $verbose;

	if ( $self->{'expires'} ) {
	    my $rows = $self->do_sql(qq(update $t set updated = null, expires = date_add(now(), interval ? second)
					where session = ?),
				     $self->{'expires'}, $session);
	    &log_message( undef, "Updated expiry date for session [$session]: rows = [$rows]" ) if $verbose;
	}
    } else {
	# Build statement for updating session
	my $stm = "update $t set updated = null, prefs = ?";
	my @bind = ($xml);
	my $data = $self->{'data'};
	for my $name (qw(firstname lastname email)) {
	    next unless exists $data->{$name};
	    $stm .= ", $name = ?";
	    push @bind, $data->{$name};
	}

	$stm .= ", expires = date_add(now(), interval ? second)";
	if ( exists $self->{'expires'} ) {
	    push @bind, $self->{'expires'};
	} else {
	    push @bind, $self->{'config'}->{'cookie'}->{'expiry_secs'} || 86400;
	}

	$stm .= " where session = ?";
	push @bind, $session;
	my $rows = $self->do_sql($stm, @bind);
	&log_message( undef, "Updated session [$session] with\n$stm\nBind values are (@bind)" ) if $verbose;
    }

    # Table cleanup
    $self->do_sql("delete from $t where expires < now() and (username = '' or username is null)");
    $self->{'dbh'}->disconnect;
}

=pod

=head2 clear

Clear the session object.

=cut

sub clear
{
    my $obj = shift;
    %{$obj} = ();
}


=pod

=head2 register(username, password, firstname, lastname, email)

Register a new user in the session table (login sessions).  The new user's information is written to the session table.

=cut

sub register
{
    my $obj = shift;
    my $self = tied(%{$obj});
    my ($username, $password, $firstname, $lastname, $email) = @_;
    
    if ($self->do_select(qq(select username from $self->{'config'}->{'table_name'} where username = ?), $username)) {
	die "username exists";
    }

    my $verbose = $self->{'verbose'};
    my $rows = $self->do_sql(qq(insert into $self->{'config'}->{'table_name'}
				(username, password, firstname, lastname, email, added)
				values( ?, encrypt(?), ?, ?, ?, now())),
			     $username, $password, $firstname, $lastname, $email);
    &log_message( undef, "Registering user ($username, $password, $firstname, $lastname, $email): rows = [$rows]" )
	if $verbose;
}


=pod

=head2 login(username, password)

C<username> is looked up in the session table and given a new session
identifier.  If the password is incorrect an exception is thrown.

=cut

sub login
{
    my $obj = shift;
    my $self = tied(%{$obj});

    my ($username, $password) = @_;

    my ($verbose) = @{$self}{qw(verbose)};
    &log_message( undef, "Attempting to log in user ($username, $password)" ) if $verbose;

    my $aref = $self->do_select(qq(select username, firstname, lastname, email, prefs
                                   from $self->{'config'}->{'table_name'}
                                   where username = ? and
                                   (password = encrypt(?, substring(password, 1, 2)) or
                                   password = password(?))),
                                $username, $password, $password);
    die "Unable to login `$username': invalid username/password.\n" unless defined($aref);

    $self->init_session($aref);

    # The merged prefs
    my $xml = Bedrock::XML::writeXMLString($self->{'data'}->{'prefs'});

    # Create a new session id for the user
    my $session = $self->newSessionID;

    # Delete the `new_session' flag
    delete $self->{'new_session'};

    # Save the merged prefs and the session id in the database.
    my $stm = "update $self->{'config'}->{'table_name'} set session = ?, prefs = ? ";
    my @bind = ($session, $xml);

    if ( $self->{'expires'} ) {
	$stm .= ", expires = date_add(now(), interval ? second)";
	push @bind, $self->{'expires'};
    }

    $stm .= " where username = ?";
    push @bind, $username;
    $self->do_sql($stm, @bind);
}


=pod

=head2 cookieless_session(session-id)

Retrieve an anonymous cookieless session.  This is required to tell
C<BLM::Startup::UserSession> to use the session identified by the
session-id that is passed.

=cut

sub cookieless_session {
    my $obj = shift;
    my $self = tied(%{$obj});

    my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};

    my $id = shift;
    $self->{'new_session'} = 0 if $id;
    $self->{'session'} = $id || $self->{'session'};
    $self->readData($id);

    $config->{'cookieless_sessions'} = 1;

# kill the cookie if cookies are enabled, since on instantiation, UserSession ($session) will create a cookie
    $self->cookie($self->{'name'},
		  'value'	=> 'killed',
		  'expires'	=> -864000);
    $self->send_cookie;
}

=pod

=head2 logout

Logout and kill session.

=cut

sub logout {
  my $obj = shift;
  my $self = tied(%{$obj});
  
  my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};

  my $t = $config->{'table_name'};

  # Expire the session (either login or anonymous)
  if ($self->{'data'}->{'username'}) {
    $self->do_sql("update $t set session = null, expires = now() where username = ?", $self->{'data'}->{'username'});
  } else {
    $self->do_sql("update $t set session = null, expires = now() where session = ? and username is null", $self->{'session'});
  }

  # Reset data
  $self->{'data'} = {};

  unless ($config->{'cookieless_sessions'}) {
    # Delete the cookie
    $self->cookie($self->{'name'},
		  'value'	=> 'killed',
		  'expires'	=> -864000);
    $self->send_cookie;
  }
}


=pod

=head2 change_passwd(oldpassword, newpassword)

Change a user's password in the session table.

=cut


sub change_passwd
{
    my $obj = shift;
    my $self = tied(%{$obj});
    my ($opasswd, $npasswd) = @_;

    my $username = $self->{'data'}->{'username'};
    die "Cannot change password: user not logged in.\n" unless length($username);

    my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};
    my $t = $config->{'table_name'};

    &log_message( undef, "Attempting to change password to `$npasswd' from `$opasswd' for `$username'" )
	if $verbose;
    my $rows = $self->do_sql(qq(update $t set password = password(?), updated = null
				where username = ? and password = password(?)),
			     $npasswd, $username, $opasswd);
    die "Cannot change password for `$username': could not authenticate user.\n" unless $rows == 1;
    &log_message( undef, "Changed password returned [$rows]") if $verbose;
}


# FIXME: figure out what this subroutine actually does.
#
#=pod
#
#=head2 remember_user
#
#=cut
#
sub remember_user
{
    my $obj = shift;
    my $self = tied(%{$obj});

    return 0 unless length($self->{'data'}->{'username'});
    my $username = $self->{'data'}->{'username'};

    my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};
    my $t = $config->{'table_name'};

    my $login_cookie_name = $config->{'login_cookie_name'};
    my $login_id = $ctx->getCookieValue($login_cookie_name);

    return length($login_id) ? 1 : 0 unless @_ > 0;

    my ($stm, @bind);
    if ( $_[0] =~ /on/i ) {
	$login_id = $self->newLoginCookie;
	$stm = "update $t set login_cookie = ? where username = ?";
	push @bind, $login_id, $username;
    } else {
	# Delete the login cookie
	$self->cookie($login_cookie_name,
		      'value'	=> 'killed',
		      'expires'	=> -864000);
	$stm = "update $t set login_cookie = null where username = ?";
	push @bind, $username;
    }

    my $rows = $self->do_sql($stm, @bind);
    die "Could not update `remember_user' setting for user `$username'\n" unless $rows == 1;
}


=pod

=head2 encrypt(password, salt)

Encrypt a password suitable for storage in a file or database.

=cut


sub encrypt {
  my $obj = shift;
  my $self = tied(%{$obj});

  my $password = shift;
  my $salt = shift;

  if ($salt) {
      $self->do_select("select encrypt(?,?) passwd", $password, $salt)->[0];
  }
  else {
      $self->do_select("select encrypt(?) passwd", $password)->[0];
  }
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.15  2010/11/16 00:18:54  rlauer
# - added more documentation about required table and cookieless sessions
#
# Revision 1.14  2010/11/15 02:12:10  rlauer
# - make PUBLIC
# - minor documentation tweaks
#
# Revision 1.13  2010/01/11 22:43:48  rlauer
# fix some redeclared locals causing warnings
#
# Revision 1.12  2009/12/28 20:32:33  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.11  2009/03/18 19:50:02  cvera
# Adding the expiry_secs configuration value to the session object. This will allow a Bedrock page to grab this value by using $session.expiry_secs
#
# Revision 1.10  2009/03/12 20:17:45  cvera
# Fixing delete statement to take into account "NULL" values in the username fields.
#
# Revision 1.9  2009/02/09 20:56:22  cvera
# 1. sub login()
# Added a check for a match against the password() or the encrypt() database functions. Some of table entries used the password and/or encrypt functions to store the passwords.
#
# 2. sub logout()
# Bug fix. The sql statement was not recognizing the '' (single quotes) as null.
#
# Revision 1.8  2008/12/03 14:01:19  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.7  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
# Revision 1.6  2008/02/28 18:14:36  rlauer
# Applying Rob's patches to make Bedrock work on Apache 2.x
# (plus a few other obvious bug fixes).
#
# Revision 1.5  2001/02/14 15:35:47  sridhar
# Added copyright and GPL notice
#
# Revision 1.4  2001/01/18 19:23:32  sridhar
# 1. Properly returning a value from default_prefs if the value not set
# in the session prefs.
# 2. Writes default prefs in the database as the user prefs the first
# time a user hits the page. On subsequent hits, these prefs are picked
# up.
# 3. No more merging of user prefs after the user logs in.
#
# Revision 1.3  2001/01/09 20:09:56  sridhar
# Major changes
# 1. Using Digest::MD5 for the session identifier.
# 2. Supports login cookies
# 3. Setting expiry date, can be specified in the config file
# 4. Added `change_passwd()' and `remember_user()' methods.
#
# Revision 1.2  2000/11/21 19:28:24  sridhar
# Export the database handle with the method `db_handle()'.
#
# Revision 1.1  2000/11/20 18:19:10  sridhar
# UserSession -- sessions where user can register, login, etc.
#
#
