package BLM::Startup::SQLSession;

use strict;
use warnings;

use BLM::Startup::SessionManager;
use Bedrock::Constants qw{:magic_numbers :booleans};
use Bedrock::Dump;
use DBI;
use English qw{-no_match_vars};
use File::Path;
use Log::Log4perl;
use TagX::Log;

use parent qw( BLM::Startup::SessionManager );

# SQL queries or this class variable should be supplied by the subclass...

our %SQL;

use Readonly;

Readonly our $BAD_QUERY   => "Unable to prepare SQL statement: %s\n%s";
Readonly our $SQL_ERROR   => "Error executing SQL statement: %s\n%s";
Readonly our $NOT_UNIQUE  => "Query found more than 1 row (found %s rows).\n";
Readonly our $BIND_ERROR  => "Could not bind parameter %d (%s): %s\n";
Readonly our $FETCH_ERROR => "Error extracting data from SQL query: %s\n";
Readonly our $BAD_LOGIN   => "Unable to login user: %s\n";
Readonly our $UPDATE_ERROR  => "Could not update settings for user [%s]\n";
Readonly our $CONNECT_ERROR => "Could not connect to database %s:\n%s\n";
Readonly our $DUPLICATE_USERNAME => "username exists\n";
Readonly our $USERNAME_NOT_FOUND => "username does not exist\n";

Readonly our $NO_DATASOURCE =>
  "%s->CONNECT(): param 'data_source' must be specified in config\n";

Readonly our $PASSWORD_CHANGE_ERROR =>
  "Cannot change password for '%s': could not authenticate user.\n";

########################################################################
sub startSession {
########################################################################
  my ( $self, $config ) = @_;

  # we copy the SQL statements over from the subclass which defines
  # them and store them in this class instance...
  my $sql = {};

  foreach ( keys %SQL ) {
    $sql->{$_}->{sql}  = sprintf $SQL{$_}->{sql}, $config->{table_name};
    $sql->{$_}->{args} = $SQL{$_}->{args};
  }

  $self->{'sql'} = $sql;

  return $self->SUPER::startSession($config);
}

########################################################################
sub do_sql {
########################################################################
  my ( $self, $what, %options ) = @_;

  my $sql = $self->{'sql'}->{$what}->{sql};
  return 0 if !$sql;

  my @args = @options{ @{ $self->{'sql'}->{$what}->{args} } };

  #DEBUG sub { "do_sql: $sql bindvars: " . join( ",", @args ) };

  return $self->_do_sql( $sql, @args );
}

########################################################################
sub do_select_set {
########################################################################
  my ( $self, $what, %options ) = @_;
  my $sql = $self->{'sql'}->{$what}->{sql};

  my @args = @options{ @{ $self->{'sql'}->{$what}->{args} } };

  return $self->_do_select_set( $sql, @args );
}

########################################################################
sub do_select {
########################################################################
  my ( $self, $what, %options ) = @_;

  my $sql = $self->{'sql'}->{$what}->{sql};

  my @args = @options{ @{ $self->{'sql'}->{$what}->{args} } };

  return $self->_do_select( $sql, @args );
}

########################################################################
sub _do_sql {
########################################################################
  my ( $self, $stm, @args ) = @_;

  my $dbh = $self->{'dbh'};

  my $sth = $dbh->prepare($stm);

  die sprintf $BAD_QUERY, $stm, $dbh->errstr
    if !$sth;

  _bind_args( $sth, @args );

  my $rows = $sth->execute;

  die sprintf $SQL_ERROR, $stm, $sth->errstr
    if !defined $rows;

  return $rows;
}

########################################################################
sub db_handle {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj};

  return $self->{'dbh'};
}

########################################################################
sub _do_select {
########################################################################
  my ( $self, @args ) = @_;

  my $rows  = $self->_do_select_set(@args);
  my $nrows = scalar @{$rows};

  die sprintf $NOT_UNIQUE, $nrows
    if $nrows > 1;

  return $rows->[0];
}

########################################################################
sub _bind_args {
########################################################################
  my ( $sth, @bind_args ) = @_;

  my $bind_idx = 1;

  foreach my $bind_arg (@bind_args) {
    $sth->bind_param( $bind_idx, $bind_arg )
      or die sprintf $BIND_ERROR, $bind_idx, $bind_arg, $sth->errstr;

    $bind_idx++;
  }

  return;
}

########################################################################
sub _do_select_set {
########################################################################
  my ( $self, $stm, @args ) = @_;

  my $dbh = $self->{'dbh'};

  my $sth = $dbh->prepare($stm);

  die $BAD_QUERY, $stm, $dbh->errstr
    if !$sth;

  Log::Log4perl->get_logger( ref $self )->debug("statement: $stm\n");

  _bind_args( $sth, @args );

  my $success = $sth->execute;

  die $SQL_ERROR, $stm, $sth->errstr
    if !defined $success;

  my @rows;

  while ( my $ref = $sth->fetchrow_arrayref ) {
    push @rows, $ref;
  }

  die $FETCH_ERROR, $sth->errstr
    if $sth->err;

  return \@rows;
}

# +---------------------------------------------------------------+
# | ->CONNECT( %options )                                         |
# |                                                               |
# | config      => configuration object                           |
# |                                                               |
# | Purpose: perform any database connection ritual required.     |
# |          This method will be called when the session object   |
# |          is instantiated.                                     |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub CONNECT {
  my ( $self, %options ) = @_;

  my %config = %{ $options{config} };

  my $dsn = $config{data_source};

  # Get the required database params
  die sprintf $NO_DATASOURCE, ref $self
    if !$dsn;

  $self->{dbh} = eval {
    return DBI->connect(
      $dsn,
      @config{qw(username password)},
      { RaiseError => 1, AutoCommit => 1 }
    );
  };

  die sprintf $CONNECT_ERROR, $dsn, $EVAL_ERROR
    if !$self->{dbh} || $EVAL_ERROR;

  return;
}

# +---------------------------------------------------------------+
# | ->DISCONNECT( %options )                                      |
# |                                                               |
# | config      => configuration object                           |
# |                                                               |
# | Purpose: perform any database disconnect ritual required.     |
# |          This function will be called from the DESTROY        |
# |          method of the session object.                        |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub DISCONNECT {
  my ($self) = @_;

  if ( $self->{dbh} && $self->{dbh}->ping ) {
    $self->{dbh}->disconnect;
  }

  return;
}

# +---------------------------------------------------------------+
# | ->FETCH_LOGIN_SESSION( %options )                             |
# |                                                               |
# | login_id => login-id                                          |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: read row from the session table based on a login     |
# |          identifier (usually a cookie value)                  |
# | Returns: reference to session data                            |
# +---------------------------------------------------------------+
sub FETCH_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  return $self->do_select( 'FETCH_LOGIN_SESSION', %options );
}

# +---------------------------------------------------------------+
# | ->FETCH_LOGIN_SESSION_BY_USERNAME( %options )                 |
# |                                                               |
# | username => username                                          |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: read row from the session table based on a login     |
# |          identifier (usually a cookie value)                  |
# | Returns: reference to session data                            |
# +---------------------------------------------------------------+
sub FETCH_LOGIN_SESSION_BY_USERNAME {
  my ( $self, %options ) = @_;

  return $self->do_select( 'FETCH_LOGIN_SESSION_BY_USERNAME', %options );
}

# +---------------------------------------------------------------+
# | ->KILL_SESSION( %options )                                    |
# |                                                               |
# | session => session-id                                         |
# | config  => configuration object                               |
# |                                                               |
# | Purpose: delete a session from table                          |
# | Returns: 1 if delete is successful                            |
# +---------------------------------------------------------------+
sub KILL_SESSION {
  my ( $self, %options ) = @_;

  return $self->do_sql( 'KILL_SESSION', %options );
}

# +---------------------------------------------------------------+
# | ->STORE_LOGIN_SESSION( %options )                             |
# |                                                               |
# | session  => session-id                                        |
# | login_id => login-id                                          |
# | expires  => expiry-time                                       |
# | username => username                                          |
# | data     => ref(session-data)                                 |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: This function should be prepared to update the       |
# |          session table based on username or login_id          |
# |          depending on which one is passed.  You should        |
# |          update the expiration time of the session data.      |
# |          You are also responsible for storing the data        |
# |          which is passed as a reference to a hash             |
# |                                                               |
# |            $options{data}->{prefs}                            |
# |                                                               |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub STORE_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  if ( !exists $options{expires} ) {
    $options{expires} = 0;
  }

  if ( $options{username} ) {
    return $self->do_sql( 'STORE_LOGIN_SESSION_BY_USERNAME', %options );
  }
  else {
    return $self->do_sql( 'STORE_LOGIN_SESSION_BY_LOGIN_ID', %options );
  }
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_SESSION( %options )                            |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | login_id => login-id                                          |
# |                                                               |
# | Purpose: This function gives the implementation the login-id  |
# |          associated with this session.  You should probably   |
# |          save this to the session in the 'login_cookie'       |
# |          column. This column is then used to identify this    |
# |          user's session.                                      |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  my $rows = $self->do_sql( 'UPDATE_LOGIN_SESSION', %options );

  die sprintf $UPDATE_ERROR, $options{username}
    if !$rows == 1;

  return $rows;
}

# +---------------------------------------------------------------+
# | ->FETCH_SESSION( %options )                                   |
# |                                                               |
# | config   => configuration object                              |
# | session  => session-id                                        |
# |                                                               |
# | Purpose: This function retrieves the session data base on a   |
# |          session identifier.                                  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub FETCH_SESSION {
  my ( $self, %options ) = @_;

  Log::Log4perl->get_logger( ref $self )->debug("fetching session\n");

  return $self->do_select( 'FETCH_SESSION', %options );
}

# +---------------------------------------------------------------+
# | ->SESSION_CLEANUP( %options )                                 |
# |                                                               |
# | config => configuration object                                |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to clean up stale sessions.                          |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub SESSION_CLEANUP {
  my ( $self, %options ) = @_;

  #DEBUG sub {
  #  Bedrock::Dump::compact( $options{config} );
  #};

  if ( $self->cleanup_session_dir ) {
    my $session_dir = $self->{'ctx'}->{'CONFIG'}->{'SESSION_DIR'};

    # DEBUG "Session dir: $session_dir";

    if ( -d "$session_dir" ) {
      my $session_ids = $self->FETCH_EXPIRED_SESSIONS(%options);

      foreach my $session ( @{$session_ids} ) {
        my $id = $session->[0];
        next if !$id;

        #DEBUG "Removing $session_dir/$id";

        if ( -d "$session_dir/$id" ) {
          rmtree("$session_dir/$id");
        }
      }
    }
  }

  # remove data from login sessions
  if ( exists $options{config}->{cleanup_login_sessions}
    && $options{config}->{cleanup_login_sessions} =~ /y/xsmi ) {
    $self->do_sql( 'LOGIN_SESSION_SANITIZE', %options );
  }
  else {
    $self->do_sql( 'LOGIN_SESSION_CLEANUP', %options );
  }

  return $self->do_sql( 'SESSION_CLEANUP', %options );
}

# +---------------------------------------------------------------+
# | ->FETCH_EXPIRED_SESSIONS( %options )                          |
# |                                                               |
# | config => configuration object                                |
# |                                                               |
# | Purpose: This function is called to retrieve the sessin ids   |
# |          of expired sessions.                                 |
# | Returns: reference to array of session ids if successful      |
# +---------------------------------------------------------------+
sub FETCH_EXPIRED_SESSIONS {
  my ( $self, %options ) = @_;

  return $self->do_select_set( 'FETCH_EXPIRED_SESSIONS', %options );
}

# +---------------------------------------------------------------+
# | ->STORE_SESSION( %options )                                   |
# |                                                               |
# | session => session-id                                         |
# | new     => 1 indicates that the session is new                |
# | expires => expiry-time                                        |
# | data    => session-data                                       |
# | config  => configuration object                               |
# | verbose => >= 0                                               |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to save the session data.                            |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub STORE_SESSION {
  my ( $self, %options ) = @_;

  $options{expires}
    = $options{expires}
    || $options{config}->{'cookie'}->{'expiry_secs'}
    || $SECONDS_IN_A_DAY;

  $options{prefs}     = $options{prefs}     || $options{data}->{prefs};
  $options{firstname} = $options{firstname} || $options{data}->{firstname};
  $options{lastname}  = $options{lastname}  || $options{data}->{lastname};
  $options{email}     = $options{email}     || $options{data}->{email};

  if ( $options{new} ) {
    my $rows = $self->do_sql( 'STORE_SESSION_INSERT', %options );

    #DEBUG
    #  sub { "Inserting session [" . $options{session} . "]: rows = [$rows]" };

    if ( $options{'expires'} ) {
      my $rows = $self->do_sql( 'UPDATE_SESSION', %options );
      # DEBUG sub {
      #   "Updated expiry date for session ["
      #     . $options{session}
      #     . "]: rows = [$rows]";
      # };

    }
  }
  else {
    my $rows = $self->do_sql( 'STORE_SESSION_UPDATE', %options );

    #DEBUG sub {
    #  'Updated session ['
    #    . $options{session}
    #    . "] with\n"
    #    . $self->{'sql'}->{STORE_SESSION_UPDATE}->{sql}
    #    . "\nBind values are ("
    #    . @options{qw{expires prefs firstname lastname email session}} . "]";
    #};

  }

  return;
}

# +---------------------------------------------------------------+
# | ->REGISTER( %options )                                        |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# | firstname => first name                                       |
# | lastname  => last name                                        |
# | email     => email address                                    |
# |                                                               |
# | Purpose:  Register a new user.  Usually involves writing the  |
# |           user's information to a database so they can login  |
# |           later.                                              |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub REGISTER {
  my ( $self, %options ) = @_;

  if ( $self->do_select( 'LOOKUP_USER', %options ) ) {
    die $DUPLICATE_USERNAME;
  }

  return $self->do_sql( 'REGISTER', %options );
}

# +---------------------------------------------------------------+
# | ->REMOVE_USER( %options )                                     |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# |                                                               |
# | Purpose:  Remove user from system.                            |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub REMOVE_USER {
  my ( $self, %options ) = @_;

  if ( !$self->do_select( 'LOOKUP_USER', %options ) ) {
    die $USERNAME_NOT_FOUND;
  }

  return $self->do_sql( 'REMOVE_USER', %options );
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_PASSWORD( %options )                           |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => [new-password, old-password                      |
# | session   => session-id                                       |
# |                                                               |
# | Purpose:  Change a user's password. Note that                 |
# |           $options{password} is an array reference where      |
# |           element 0 is the new password and element 1 is the  |
# |           old password.                                       |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_PASSWORD {
  my ( $self, %options ) = @_;

  $options{password} = $options{password}->[0];

  my $rows = $self->do_sql( 'UPDATE_LOGIN_PASSWORD', %options );

  die $PASSWORD_CHANGE_ERROR, $options{username}
    if $rows != 1;

  return $rows;
}

# +---------------------------------------------------------------+
# | ->LOGOUT( %options )                                          |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | session  => session-id                                        |
# |                                                               |
# | Purpose:  Log a user out of the session.  This method is      |
# |           called when the logout() session method is called.  |
# |           You probably want to indicate that the session is   |
# |           expired.  Note that if the method is called with    |
# |           $options{username} set then this is a login session,|
# |           otherwise it is an anonymous session.               |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub LOGOUT {
  my ( $self, %options ) = @_;

  # Expire the session (either login or anonymous)
  if ( $options{username} ) {
    $self->do_sql( 'LOGOUT_USER', %options );
  }
  else {
    $self->do_sql( 'LOGOUT_ANON', %options );
  }

  return;
}

# +---------------------------------------------------------------+
# | ->LOGIN( %options )                                           |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | password => password                                          |
# |                                                               |
# | Purpose:  Log in and start a login session.                   |
# |           called when the logout() session method is called.  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub LOGIN {
  my ( $self, %options ) = @_;

  my $aref = $self->do_select( 'LOGIN', %options );

  die $BAD_LOGIN, $options{username}
    if !defined $aref;

  return $aref;
}

1;

__DATA__


