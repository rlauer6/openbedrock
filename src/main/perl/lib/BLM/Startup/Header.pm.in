#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::Header;

use strict;
use MIME::Base64;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log;
use Bedrock::Hash;
use Bedrock::Dump;
use Text::URLEncode qw/Encode/;

@ISA = qw(Bedrock::Hash);

sub TIEHASH
{
    my $class = shift;
    my $ctx = shift;
    my $config = shift;

    my $self = bless Bedrock::Hash->new, $class;

    # Get the headers and store them
    my %headers = $ctx->cgi_header_in;
    $self->{'input'} = \%headers;
    $self->{'config'} = $config;
    $self->{'verbose'} = $config->{'verbose'};
    $self->{APACHE_HANDLER} = $ctx->{APACHE_HANDLER};

    # Special processing of some headers
    if ( exists $headers{'Authorization'} ) {
	my ($realm, $ident) = split(' ', $headers{'Authorization'} );
	$self->{'realm'} = $realm;
	@{$self}{qw(auth_user auth_passwd)} = split(':', decode_base64($ident));
    }

    $self;
}

sub FETCH
{
    my ($self, $key) = @_;
    return $self->{'input'}->{$key} if exists $self->{'input'}->{$key};
    my $lckey = lc($key);
    return $self->{'input'}->{$lckey} if exists $self->{'input'}->{$lckey};
    undef;
}

sub FIRSTKEY
{
    my $self = shift;
    my $a = scalar keys %{$self->{'input'}};
    each %{$self->{'input'}};
}

sub NEXTKEY
{
    each %{$_[0]->{'input'}};
}

sub STORE
{
    my $self = shift;

    $self->{'output'} = {} unless exists $self->{'output'};
    my $output = $self->{'output'};

    while ( @_ ) {
	my $header = ucfirst(shift);
	my $value = shift;
	if ( exists $output->{$header} && $header !~ m/location:/i ) {
	    $output->{$header} = [ $output->{$header} ] unless ref( $output->{$header} );
	    push @{$output->{$header}}, $value;
	} else {
	    $output->{$header} = $value;
	}
    }
}

sub DELETE
{
    my $self = shift;
    return undef unless exists $self->{'output'};
    delete $self->{'output'}->{ucfirst(shift)};
}

sub EXISTS
{
    exists $_[0]->{'input'}->{$_[1]};
}

sub CLEAR
{
    my $self = shift;
    return unless exists $self->{'output'};
    %{$self->{'output'}} = ();
}

sub no_cache
{
    my $obj = shift;
    # Set in two separate calls since args are assigned to a hash thus
    # clobbering one of the cache-control directives.
    $obj->set("Pragma", "no-cache",
	      "Cache-control", "no-cache");
    $obj->set("Cache-control", "no-store");
}

sub content_type {
  my $self = shift;

  $self->set("Content-type", $_[0]);
}

sub see_other
{
    my $obj = shift;
    my $url = shift;
    $obj->set("Status", "302 See Other",
	      "Location", $url);
}

sub location
{
    my $obj = shift;
    my $url = shift;
    $obj->set("Location", $url);
}

sub build_get_url {
  my $self = shift;
  my $file = shift;
  my $parms = shift;

  die "usage: build_get_url(file, hash)\n"
    unless $file && UNIVERSAL::isa($parms, 'HASH');

  return $file . '?' . join("&", map { $_ . '=' . Encode( $parms->{$_} ) } keys %$parms);
}

sub print_header
{
    my $obj = shift;
    my $self = tied(%{$obj});
    my $fd = shift;

    my $output = delete $self->{'output'} || {};
    my $mime_type = $self->{'config'}->{'default_mime_type'} || 'text/html';
    $output->{'Content-type'} = $mime_type unless exists $output->{'Content-type'};

    if ($ENV{MOD_PERL}) {
      $self->{APACHE_HANDLER}->content_type($output->{'Content-type'});
    }

    my ($key, $value, $str);
    while (($key, $value) = each %{$output}) {
	if ( &UNIVERSAL::isa( $value, 'ARRAY' ) ) {
	    for my $item (@{$value}) {
		$str .= "$key: $item\r\n";
		$fd->cgi_header_out( $key => $item );
	    }
	} else {
	    $str .= "$key: $value\r\n";
	    $fd->cgi_header_out( $key => $value );
	}
    }
    $str .= "\r\n";
    &log_message( undef, "Headers are\n$str" ) if $self->{'verbose'};
    $fd->send_http_header;
}

1;


=pod

=head1 PUBLIC

C<BLM::Startup::Header> - HTTP header support.

=head1 SYNOPSIS

 <null $header.see_other("/foo")>

 <null $header.location("/index.roc?error=4")>

 <null $header.content_type("application/xml")>

=head1 DESCRIPTION

This module provide HTTP header support for core Bedrock.  It also contains some methods that can be used by the Bedrock developer.

=head1 METHODS

=head2 content_type(mime-type)

Sets the 'Content-type' header to the mime-type given.  Typically you
shouldn't muck with this, but you can serve up XML documents or even
PDFs using Bedrock.

=head2 build_get_url(file, parms)

Builds a URL of the form:

  filename?parm=val&..

=over 5

=item file 

Name of the GET target

=item parms

Hash that contains name value pairs that represent the CGI variables
to pass in the URL

=back

Example:

  <null:parms foo bar baz buz>
  <null:url $header.build_get_url("index.rock", $parms)>

This would produce:

  /index.rock?foo=bar&baz=buz

Note that the values are URL encoded for you as well.

=head2 location(url)

Sets the 'Location' header to the specified URL.

=head2 no_cache

Sets the header values of 'Pragma' and 'Cache-control' to 'no-cache'.

=head2 see_other

Set the 'Status' to '302 See Other'.  The RFC states that browsers
should correctly interpret either a status code 303 or 302.  Some
browsers only interpretted 302.

=head1 AUTHOR

J. Sridhar

Rob Lauer - rlauer@signatureinfo.com

=cut


#
# Name of Release: $Name$
# $Log$
# Revision 1.19  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.18  2011/07/15 15:30:25  laytonax
# Minor changes to Startup/Header.pm and Bedrock/Context.pm, both of which were exposed when the application stack has multiple Cookie: headers (as is the case when sitting behind an application pool such as an F5 or Varnish).
#
# Revision 1.17  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.16  2011/03/15 13:35:39  eutl420
# - added a method for building a url encoded GET string 'build_get_url()'
#
# Revision 1.15  2010/12/12 21:43:33  eutl420
# - save APACHE_HANDLER from context object
# - use APAACHE_HANDLER (request object) to set content type if running under mod_perl
#
# Revision 1.14  2010/11/29 15:57:51  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.13  2010/11/15 02:23:24  rlauer
# - make PUBLIC
# - document methods
#
# Revision 1.12  2010/01/03 19:11:33  rlauer
# added content_type method
#
# Revision 1.11  2009/12/28 20:32:33  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.10  2008/12/03 14:01:19  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.9  2001/02/14 15:35:46  sridhar
# Added copyright and GPL notice
#
# Revision 1.8  2000/12/19 13:54:25  sridhar
# Error in FETCH(); reading from wrong place
#
# Revision 1.7  2000/12/15 15:47:28  sridhar
# 1. Overrides FIRSTKEY() and NEXTKEY() so that we don't see no junk
# when doing a trace
# 2. Property `input' stores input header, `config' stores module
# configuration, and `output' stores output headers
# 3. Default mime can come from config file
# 4. Methods for common header operations: `no_cache()', `see_other()',
# and `location()'
# 5. Removed `set()': moved the stuff to `STORE()'
#
# Revision 1.6  2000/09/18 14:43:38  sridhar
# Fix needed to successfully compile under Perl/ after moving Perl/Text to
# Perl/Bedrock/Text and some modules from Perl/SIS to Perl/Bedrock/SIS
#
# Revision 1.5  2000/08/23 17:28:27  sridhar
# Can access HTTP headers now (only in the mod_perl version,
# though). The header fields are properties of the object.
# Special treatment to Authorization header. This header in unpacked
# into 'realm', 'auth_user' and 'auth_passwd'.
#
# Revision 1.4  2000/07/06 18:34:06  sridhar
# More uniformity: no need to handle separately for CGI and mod_perl
# since the output handle has methods for sending headers for both
# environments.
#
# Revision 1.3  2000/07/06 17:59:36  sridhar
# Using cgi_header_out() instead of header_out() with mod_perl.
#
# Revision 1.2  2000/07/06 17:25:56  sridhar
# Verifying whether argument to print_header supports a `header_out'
# method which is used for setting headers. Used for supporting mod_perl
# version.
#
# Revision 1.1  2000/07/05 17:55:31  sridhar
# HTTP Header management is now a BLM.
#
#
