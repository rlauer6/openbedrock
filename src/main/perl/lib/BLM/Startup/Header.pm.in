#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package BLM::Startup::Header;

use strict;
use MIME::Base64;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log 1.01;
use SIS::Hash 1.02;
@ISA = qw(SIS::Hash);

sub TIEHASH
{
    my $class = shift;
    my $ctx = shift;

    my $self = bless SIS::Hash->new, $class;
    my $private = {};
    $self->{'__private'} = \$private;

    # Get the headers and store them
    my %headers = $ctx->cgi_header_in;
    for my $key (keys %headers) {
	$self->{lc($key)} = $headers{$key};
    }

    # Special processing of some headers
    if ( exists $self->{'authorization'} ) {
	my ($realm, $ident) = split(' ', $self->{'authorization'} );
	$self->{'realm'} = $realm;
	@{$self}{qw(auth_user auth_passwd)} = split(':', decode_base64($ident));
    }

    $self;
}

sub FETCH
{
    my $self = shift;
    my $key = shift;
    return $self->{$key} if exists $self->{$key};
    my $lckey = lc($key);
    return $self->{$lckey} if exists $self->{$lckey};
    undef;
}

sub print_header
{
    my $self = shift;
    my $fd = shift;

    my $private_ref = $self->{'__private'};
    my $private = $$private_ref;
    $private->{'Content-type'} = 'text/html' unless exists $private->{'Content-type'};
    my ($key, $value, $str);
    while (($key, $value) = each %{$private}) {
	if ( &UNIVERSAL::isa( $value, 'ARRAY' ) ) {
	    for my $item (@{$value}) {
		$str .= "$key: $item\r\n";
		$fd->cgi_header_out( $key => $item );
	    }
	} else {
	    $str .= "$key: $value\r\n";
	    $fd->cgi_header_out( $key => $value );
	}
    }
    $str .= "\r\n";
    $fd->send_http_header;
    delete $self->{'__private'};
}

sub set
{
    my $self = shift;
    die "Error: Cannot set header(s) in content generation phase.\n"
	unless exists $self->{'__private'};

    my $private_ref = $self->{'__private'};
    my $private = $$private_ref;
    while ( @_ ) {
	my $header = ucfirst(shift);
	my $value = shift;
	if ( exists $private->{$header} ) {
	    $private->{$header} = [$private->{$header}] unless ref( $private->{$header} );
	    push @{$private->{$header}}, $value;
	} else {
	    $private->{$header} = $value;
	}
    }
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.5  2000/08/23 17:28:27  sridhar
# Can access HTTP headers now (only in the mod_perl version,
# though). The header fields are properties of the object.
# Special treatment to Authorization header. This header in unpacked
# into 'realm', 'auth_user' and 'auth_passwd'.
#
# Revision 1.4  2000/07/06 18:34:06  sridhar
# More uniformity: no need to handle separately for CGI and mod_perl
# since the output handle has methods for sending headers for both
# environments.
#
# Revision 1.3  2000/07/06 17:59:36  sridhar
# Using cgi_header_out() instead of header_out() with mod_perl.
#
# Revision 1.2  2000/07/06 17:25:56  sridhar
# Verifying whether argument to print_header supports a `header_out'
# method which is used for setting headers. Used for supporting mod_perl
# version.
#
# Revision 1.1  2000/07/05 17:55:31  sridhar
# HTTP Header management is now a BLM.
#
#
