#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package BLM::Startup::Header;

use strict;
use MIME::Base64;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log 1.01;
use SIS::Hash;
@ISA = qw(SIS::Hash);

sub TIEHASH
{
    my $class = shift;
    my $ctx = shift;
    my $config = shift;

    my $self = bless SIS::Hash->new, $class;

    # Get the headers and store them
    my %headers = $ctx->cgi_header_in;
    $self->{'input'} = \%headers;
    $self->{'config'} = $config;
    $self->{'verbose'} = $config->{'verbose'};

    # Special processing of some headers
    if ( exists $headers{'Authorization'} ) {
	my ($realm, $ident) = split(' ', $headers{'Authorization'} );
	$self->{'realm'} = $realm;
	@{$self}{qw(auth_user auth_passwd)} = split(':', decode_base64($ident));
    }

    $self;
}

sub FETCH
{
    my ($self, $key) = @_;
    return $self->{'input'}->{$key} if exists $self->{'input'}->{$key};
    my $lckey = lc($key);
    return $self->{'input'}->{$lckey} if exists $self->{'input'}->{$lckey};
    undef;
}

sub FIRSTKEY
{
    my $self = shift;
    my $a = scalar keys %{$self->{'input'}};
    each %{$self->{'input'}};
}

sub NEXTKEY
{
    each %{$_[0]->{'input'}};
}

sub STORE
{
    my $self = shift;

    $self->{'output'} = {} unless exists $self->{'output'};
    my $output = $self->{'output'};

    while ( @_ ) {
	my $header = ucfirst(shift);
	my $value = shift;
	if ( exists $output->{$header} ) {
	    $output->{$header} = [ $output->{$header} ] unless ref( $output->{$header} );
	    push @{$output->{$header}}, $value;
	} else {
	    $output->{$header} = $value;
	}
    }
}

sub DELETE
{
    my $self = shift;
    return undef unless exists $self->{'output'};
    delete $self->{'output'}->{ucfirst(shift)};
}

sub EXISTS
{
    exists $_[0]->{'input'}->{$_[1]};
}

sub CLEAR
{
    my $self = shift;
    return unless exists $self->{'output'};
    %{$self->{'output'}} = ();
}

sub no_cache
{
    my $obj = shift;
    # Set in two separate calls since args are assigned to a hash thus
    # clobbering one of the cache-control directives.
    $obj->set("Pragma", "no-cache",
	      "Cache-control", "no-cache");
    $obj->set("Cache-control", "no-store");
}

sub see_other
{
    my $obj = shift;
    my $url = shift;
    $obj->set("Status", "302 See Other",
	      "Location", $url);
}

sub location
{
    my $obj = shift;
    my $url = shift;
    $obj->set("Location", $url);
}

sub print_header
{
    my $obj = shift;
    my $self = tied(%{$obj});
    my $fd = shift;

    my $output = delete $self->{'output'} || {};
    my $mime_type = $self->{'config'}->{'default_mime_type'} || 'text/html';
    $output->{'Content-type'} = $mime_type unless exists $output->{'Content-type'};
    my ($key, $value, $str);
    while (($key, $value) = each %{$output}) {
	if ( &UNIVERSAL::isa( $value, 'ARRAY' ) ) {
	    for my $item (@{$value}) {
		$str .= "$key: $item\r\n";
		$fd->cgi_header_out( $key => $item );
	    }
	} else {
	    $str .= "$key: $value\r\n";
	    $fd->cgi_header_out( $key => $value );
	}
    }
    $str .= "\r\n";
    &log_message( undef, "Headers are\n$str" ) if $self->{'verbose'};
    $fd->send_http_header;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.8  2000/12/19 13:54:25  sridhar
# Error in FETCH(); reading from wrong place
#
# Revision 1.7  2000/12/15 15:47:28  sridhar
# 1. Overrides FIRSTKEY() and NEXTKEY() so that we don't see no junk
# when doing a trace
# 2. Property `input' stores input header, `config' stores module
# configuration, and `output' stores output headers
# 3. Default mime can come from config file
# 4. Methods for common header operations: `no_cache()', `see_other()',
# and `location()'
# 5. Removed `set()': moved the stuff to `STORE()'
#
# Revision 1.6  2000/09/18 14:43:38  sridhar
# Fix needed to successfully compile under Perl/ after moving Perl/Text to
# Perl/Bedrock/Text and some modules from Perl/SIS to Perl/Bedrock/SIS
#
# Revision 1.5  2000/08/23 17:28:27  sridhar
# Can access HTTP headers now (only in the mod_perl version,
# though). The header fields are properties of the object.
# Special treatment to Authorization header. This header in unpacked
# into 'realm', 'auth_user' and 'auth_passwd'.
#
# Revision 1.4  2000/07/06 18:34:06  sridhar
# More uniformity: no need to handle separately for CGI and mod_perl
# since the output handle has methods for sending headers for both
# environments.
#
# Revision 1.3  2000/07/06 17:59:36  sridhar
# Using cgi_header_out() instead of header_out() with mod_perl.
#
# Revision 1.2  2000/07/06 17:25:56  sridhar
# Verifying whether argument to print_header supports a `header_out'
# method which is used for setting headers. Used for supporting mod_perl
# version.
#
# Revision 1.1  2000/07/05 17:55:31  sridhar
# HTTP Header management is now a BLM.
#
#
