#!/usr/local/bin/perl -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

package BLM::Startup::Bedrock;

use strict;
use Symbol;
use File::Basename;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use VERSION;
use TagX::Log 1.01;
use SIS::Hash;
@ISA = qw(SIS::Hash);

my @keys = qw (version script_fullpath script_file script_dir script_relative_uri script_absolute_uri);

sub TIEHASH
{
    my ($class, $ctx, $config) = shift;
    my $self = bless {}, $class;
    $self->{'config'} = $config;
    $self->{'version'} = $Bedrock::VERSION::ID;

    if ( exists $ENV{'HTTP_HOST'} ) {
	if ( $ENV{'MOD_PERL'} ) {
	    $self->{'script_fullpath'} = $ENV{'SCRIPT_FILENAME'};
	} else {
	    $self->{'script_fullpath'} = $ENV{'PATH_TRANSLATED'};
	}
	$self->{'script_file'} = basename($self->{'script_fullpath'});
	$self->{'script_dir'} = dirname($self->{'script_fullpath'});
	$self->{'script_relative_uri'} = $ENV{'SCRIPT_NAME'} || $ENV{'REQUEST_URI'} || $ENV{'SCRIPT_URL'};
	my $proto = $ENV{'HTTPS'} eq 'on' ? 'https' : 'http';
	$self->{'script_absolute_uri'} = $proto . '://' . $ENV{'HTTP_HOST'} . $self->{'script_relative_uri'};
    }

    $self;
}

sub FIRSTKEY
{
    my $self = shift;
    $self->{'keys'} = [@keys];
    my $key = shift @{$self->{'keys'}};
    wantarray ? ($key, $self->{$key}) : $key;
}

sub NEXTKEY
{
    my $self = shift;
    my $key = shift @{$self->{'keys'}};
    wantarray ? ($key, $self->{$key}) : $key;
}

sub require_version
{
    my $self = shift;
    my $version = shift;
    my @v = ($version =~ /\d+/g);
    my @V = ($Bedrock::VERSION::ID =~ /\d+/g);
    my $v = ( @v == 2 ? $version : sprintf("%d.%d"."%02d" x ($#v - 1), @v) );
    my $V = ( @V == 2 ? $Bedrock::VERSION::ID : sprintf("%d.%d"."%02d" x ($#V - 1), @V) );
    die "Require version $version. This version is only $Bedrock::VERSION::ID\n"
	unless $V >= $v;
    $Bedrock::VERSION::ID;
}

sub makeHash
{
    goto &new;
}

sub makeArray
{
    goto &newArray;
}

sub module_symbol
{
    my $class = shift;
    my $symbol = shift;
    my $symtype = shift;
    no strict;
    local *stab = *{$class . '::' };
    return $stab{$symbol} if defined($symtype);
    return *{$stab{$symbol}}{$symtype};
    use strict;
}

sub new
{
    my $self = shift;
    my $class = shift;
    $class = 'BLM::' . $class unless $class =~ /^BLM::/;
    my $verbose = $self->{'config'}->{'verbose'};
    $self->loadModule( $class );

    if ( &UNIVERSAL::can( $class, 'TIEHASH' ) ) {
	&log_message( undef, "$self: creating an object of class $class" ) if $verbose;
	my $href = {};
	tie %{$href}, $class, @_;
	return bless $href, $class;
    } elsif ( &UNIVERSAL::can( $class, 'TIEARRAY' ) ) {
	&log_message( undef, "$self: creating an array of class $class" ) if $verbose;
	my $aref = [];
	tie @{$aref}, $class, @_;
	return bless $aref, $class;
    } elsif ( &UNIVERSAL::can( $class, 'TIEHANDLE' ) ) {
	&log_message( undef, "$self: creating a handle of class $class" ) if $verbose;
	my $fd = gensym;
	tie *{$fd}, $class, @_;
	return bless $fd, $class;
    } else {
	die "Attempt to load invalid module: $class.\n";
    }
}

sub newArray
{
    my $self = shift;
    my $class = shift;
    $self->loadModule( $class );
    my $aref = [];
    tie @{$aref}, $class, @_;
    bless $aref, $class;
}

sub newHandle
{
    my $self = shift;
    my $class = shift;
    $self->loadModule( $class );
    my $fd = gensym;
    tie *{$fd}, $class, @_;
    bless $fd, $class;
    $fd;
}

sub isObject
{
    my $self = shift;
    my $arg = shift;
    return undef unless defined($arg);
    if ( &UNIVERSAL::isa( $arg, 'SIS::Hash' ) ) {
	return 1;
    } else {
	die "@_" if @_;
	return 0;
    }
}

sub isArray
{
    my $self = shift;
    my $arg = shift;
    return undef unless defined($arg);
    if ( &UNIVERSAL::isa( $arg, 'SIS::Array' ) ) {
	return 1;
    } else {
	die "@_" if @_;
	return 0;
    }
}

sub isScalar
{
    my $self = shift;
    my $arg = shift;
    return undef unless defined($arg);
    if ( ref($arg) ) {
	die "@_" if @_;
	return 0;
    } else {
	return 1;
    }
}

sub isHandle
{
    my $self = shift;
    my $arg = shift;
    return undef unless defined($arg);
    if ( &UNIVERSAL::isa( $arg, 'SIS::Handle' ) ) {
	return 1;
    } else {
	die "@_" if @_;
	return 0;
    }
}

sub loadModule
{
    my $self = shift;
    my @mods = @_;

    my $verbose = $self->{'config'}->{'verbose'};
    for my $class (@mods) {
	$class =~ s!::!/!g;
	$class =~ s!$!.pm! unless $class =~ /\.pm$/;
	next if $INC{$class};
	require $class;
	&log_message( undef, "$class loaded successfully" ) if $verbose;
    }
}

sub BLMDoc
{
    my $self = shift;
    my $class = shift;
    $self->loadModule( $class );
    no strict;
    local *stab = *{$class . '::' };
    my $handle = $stab{DATA};
    return "Sorry! Class $class has no documentation." unless $handle;
    my $ioref = *{$handle}{IO};
    use strict;
    my $doc;
    while (<$ioref>) {
	$doc .= $_;
    }
    $doc;
}

1;

#
# Name of Release: $Name$
# $Log$
# Revision 1.13  2000/12/15 16:19:28  sridhar
# Using Bedrock::VERSION for version instead of Text::TagX::VERSION
#
# Revision 1.12  2000/12/15 15:41:10  sridhar
# 1. Method `new()' can examine the specified class and create a new
# object, array or handle as required.
# 2. Prefix `BLM::' is optional.
#
# Revision 1.11  2000/12/11 15:07:07  sridhar
# 1. Defined FIRSTKEY() and NEXTKEY() methods.
# 2. Can specify `verbose' under `config' in config file
# 3. Added `BLMDoc()' method.
#
# Revision 1.10  2000/11/30 15:44:07  sridhar
# Fixed `require_version()' to handle previous single-period version
# numbering and present double-period version numbering.
#
# Revision 1.9  2000/11/29 21:04:35  sridhar
# 1. Added methods `isObject()', `isArray()', `isScalar()' and
# `isHandle()'.
# 2. Method `require_version()' returns the current version
#
# Revision 1.8  2000/10/16 13:57:04  sridhar
# Changes to accomodate Bedrock shell.
#
# Revision 1.7  2000/08/21 21:00:59  sridhar
# Recomputation of script_* properties of bedrock object.
#
# Revision 1.6  2000/08/18 19:27:36  sridhar
# Added properties 'script_(file|dir|(absolute|relative)_uri)' to
# bedrock object.
#
# Revision 1.5  2000/08/17 16:59:43  sridhar
# 1. Added method `newHandle()' for creating a new handle
# 2. Removed method `reloadModule()'
#
# Revision 1.4  2000/06/26 14:00:09  sridhar
# 1. Added methods loadModule() and reloadModule() for loading modules
# on the fly.
# 2. Replaced FETCH with TIEHASH which initialized needed variables
# during construction
#
# Revision 1.3  2000/06/14 13:59:45  sridhar
# Added new() and newArray() as synonyms for makeHash() and makeArray().
#
# Revision 1.2  2000/06/07 18:35:21  sridhar
# Removed a debug log message
#
# Revision 1.1  2000/06/06 20:42:08  sridhar
# Bedrock loadable modules for startup
#
#
