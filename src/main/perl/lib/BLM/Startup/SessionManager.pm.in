#!@PERL@ -w

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::SessionManager;

use strict;

BEGIN {
  use Exporter ();
  use vars qw($VERSION @ISA);
}

use Carp;
use Digest::MD5;
use POSIX qw(strftime);
use File::Basename;
use File::Copy;
use File::Path;
use File::Temp qw/tempfile/;
use IO::Handle;

use TagX::Log;
use Bedrock::XML;
use Bedrock::Hash;

@ISA = qw( Bedrock::Hash );

=pod

=head1 PUBLIC 

C<BLM::Startup::SessionManager> - Base class for implementing Bedrock sessions.

=head1 DESCRIPTION

This is a base class that you can use as a starting point when
implementing a custom Bedrock session manager.  For an example
implementations, see: C<BLM::Startup::MySQLSession>,
C<BLM::Startup::PostgreSQLSession> and C<BLM::Startup::SQLiteSession>.

You are expected to implement several methods to create a valid
session manager.  You can also provide implementations for a few other
B<optional> methods that are called at various points during session
handling.  These methods may or may not be necessary for your
implmentations.  YMMV.

=head1 METHODS

The methods described below are categorized as either B<optional> or
B<required>. Required means, if you want the class to do something
useful, you more or less need to do something and return something.
Only death and taxes are actually required. 

All of the methods take a hash as an argument.  The hash members
passed are described in general and each methodE<039>s documentation will
then indicate which of these is passed to you for this call.

Your implementation may or may not require these arguments to
implement the functionality you are providing.

=head2 Writing Your Implementation

The purpose of your implementation is to store a userE<039>s data to a
permanent data store.  Permanence is defined based on the type of
session that is being created by the calls to your handlers.  Login
sessions should save a userE<039>s data for access any time the user
I<logs in> using the session objectE<039>s C<login()> method.

I<Note: if you are not particularly interested in login sessions, then
donE<039>t bother implementing the method. It is certanly conceivable
that you may want to provide transient sessions for your application
and your implementation is not interested in persisting data for
particular users across session instances.  It is totally up to you
whether or not you want to provide that functionality.  If you choose
not to, it might be nice to throw an exception or something to
indicate that this feature is not provided in your session
implementation.>

 sub LOGIN {
   die "method not provided in this implementation\n";
 }

Anonymous sessions on the other hand, tend to expire based on some
setting in your configuration file.  That expiration is translated
into the expiry date of a cookie, thus cookie based session ids become
unavailable after that time and thus the session associated with that
id becomes inaccessible.  Likewise, with login sessions the cookie
expires the session, but not the data in the session store.  Once a
login session expires, the user must login in again to reactivate the
session, but their data is still in tact - assumming you implement
things properly.

=head3 Selecting Your Storage Method

The description of the API is generic enough such that you should be
able to design your own storage mechanism in whatever fashion you
please.  The calls made to methods you write provide the relevant
pieces of information needed to store or retrieve a particular
session, including the C<config> object that is defined in your
F<tagx.xml> entry for this Application Plugin.  Since you have control
over what goes in that configuration section you should provide
whatever additional settings or configuration values you need to
implement your session manager.

The storage and retrieval mechanism might involve an SQL table for
example, or it might be involve some other way to store and retrieve
data based on a unique key.  The only real requirement is that the API
provide a way to store and retrieve data using a unique key.
Typically this means a database table and a unique key, however there
is a variety ways you can skin that cat.

Requests to store and retrieve session data will occur across
different client requests implying a different Apache process will
service different requests.  That means you must have a way to persist
the data across these requests, i.e. you canE<039>t simply store things in
a hash for the current request for example.

Sessions are generally not meant to last forever (unless we are
talking about login sessions) and are not usually large, however your
application needs will dictate much of that.

If you decide to implement sessions using a database table, the
reference implemenation documented in C<BLM::Startup::MySQLSession>
should give you some clues as to what a table might look like and one
way to provide persistence.  ItE<039>s not the only way, and probably not
the most efficient way one could construct.  Again, YMMV.

=head3 Storing and Retrieving the Session Data

YouE<039>ll be implementing a set of methods for storing and retrieving
session data.

  ->FETCH_SESSION( )
  ->STORE_SESSION( )
  ->FETCH_LOGIN_SESSION( )
  ->STORE_LOGIN_SESSION( )

The C<FETCH_*> methods you implement should return a reference to a
hash object that minimally contains a member named C<prefs>.  The
C<prefs> object is a text blob that was sent to you to save via one of
the C<STORE_*> methods.

Technically speaking you donE<039>t need to know too much more than that,
however the object that you stored is a Bedrock XML object.  It will
be converted to its internal representation (a hash reference) by the
calling functions and eventually will be accessible to the Bedrock
page via the C<$session> object.

Likewise, the C<STORE_*> methods expect you to take a hash reference
which is passed as the hash member C<data> and store the session data
I<somewhere>.  Other arguments to C<STORE_*> will tell you what
session or user this data belongs to so you can store the data in such
as way as to allow for later retrieval using that same information as
a key or index.

So, to clarify a bit - you are B<NOT> responsible for serializing and
deserializing the session information!  Your implementation is only
responsible for fetchinng and storing a serialized representation of a
userE<039>s session.  The rest of the plumbing takes care of the
actual process of serialization and deserialization.

=head3 Arguments to Methods

The argument to the methods that you will implement is a hash.  The
members can be any of those described below depending on the particular
method being invoked.

=over 5

=item config

This is a hash reference to the configuration information you defined
in your F<tagx.xml> entry for this Application Plugin. HereE<039>s what he
configuration object looks like for the reference implementation.

      <object name="config">

        <scalar name="verbose">2</scalar>
        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>
        <scalar name="data_source">dbi:mysql:bedrock</scalar>
        <scalar name="username">fred</scalar>
        <scalar name="password">flintstone</scalar>
        <scalar name="table_name">session</scalar>
        <scalar name="purge_user_after">30</scalar>
        <scalar name="cookieless_sessions"></scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>

Your configuration object can have whatever information is necessary
to implement your session manager, however you should have these
elements at a minimum to provide for cookie based sessions.

      <object name="config">

        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>


=item data

A reference to a hash that possibly contains various members including
C<prefs> which is a text represenation of the userE<039>s session data.
You should save that data so you can return it via one of the
C<FETCH_*> methods for the given session or login identifier.

Possible members that may appear in the hash reference as well and
that you may or may not need or wish to store include (see descriptions
below):

=over 5

=item username

=item password

=item email

=item firstname

=item lastname

=item prefs

=back

=item email

The email address of a user.  Used as an argument to the C<register()> method of the session object.

=item expires

The session expiration time in seconds.

=item firstname

The first name of a user.  Used as an argument to the C<register()> method of the session object.

=item lastname

The last name of a user.  Used as an argument to the C<register()> method of the session object.

=item login_id

=item new 

A flag that indicates if the session is new.

=item password

The password associated with the username of a registered user.  Used
as an argument to the C<register()> and C<login()> methods of the
session object.

=item prefs

This is the payload that contains the session data that you should
store or retrieve.  It is a serialized representation of the session
object.

=item session

A unique session identifier based on an MD5 digest value.

=item username

The username associated with a registered user.  Used as an argument
to the C<register()> and C<login()> methods of the session object.

=item verbose

An integer, possibly >=0 that indicates the verbosity level desired.

=back

=head2 OPTIONAL METHODS

The method descriptions below include an indication of which hash
elements are passed and a brief explanation of what the method is
required to do and/or return.  Your method should access the arguments
in a similar manner as shown in the stub below:

  sub CONNECT {
    my $self = shift;
    my %options = @_;
   
    my $table_name = $options{config}->{table};
    ...
  }

=head3 CONNECT

 config => configuration object

This method is called when the session object is instantiated and
gives your method an opportunity to do any initialization rituals
necessary prior to being asked to fetch or store any data.  Typically,
this means connecting to a database, like so:

  $self->{dbh} = DBI->connect( $options{config}->{data_source},
                               $options{config}->{username},
                               $options{config}->{password}
                             );

You can save state to the object, but be careful.  A better approach
is to create your own reference to data you need to keep track of.
The element C<_manager_state> is reserved for this purpose.  So
C<CONNECT> might be better written:

  my $dbh = DBI->connect( $options{config}->{data_source},
                          $options{config}->{username},
                          $options{config}->{password}
                        );

  $self->{_manager_state} = { dbh => $dbh };


=head3 DISCONNECT

 config => configuration object

This method is called when the session object is destroyed. You should
do whatever is necessary to close files, database, etc.

=head3 SESSION_CLEANUP

 config  => configuration object

This method is called when the session object is destroyed prior to
the call to C<DISCONNECT>.  You can use this opportunity to clear out
stale sessions if necessary.

Just a quick note about stale sessions.  If you don't have a way to
clear out expired sessions, you will quickly start collecting them
like beer cans in the recycle bin.  There are three obvious ways to
cleanup sessions, however depending on your implementation you may not
care, or there may be some magic in your implementation that obviates
the need for cleanup.  The three obvious ways I know of to cleanup
sessions are:

=over 5

=item * Look for stales sessions during the SESSION_CLEANUP() method.

This works, as long as some active session is running, otherwise you
would never have been called.  This implies your session store will
always include at least 1 stale session.

=item * Run a scheduled job and clean up stale sessions

This works, and is the approach that seems logical.  But who wants to
write more software than they have to?

=item * Use magic

This is the best approach, if you pull it off.  By magic, I really
mean use some technology that expires itself, in the background,
without any intervention from you.  An example of this might be using
Redis which includes the ability the expire objects.  Just make sure
that you are renewing the lease on these objects.

=back

Finally, you can ignore the problem - if itE<039>s not a problem for you.
If you have an infinite amount of storage and access times to your
session are not impacted by the number of objects you store, then
ignore the problem by all means.  Again, YMMV.


=head3 LOGOUT

 username => username
 session  => session-id
 config   => configuration-object

This method is called in response to the session object method
C<logout()>.  Typically, userE<039>s like to logout of applications
for a variety of reasons including security.  This is an opportunity
for you to expire the session in some manner.

=head2 REQUIRED METHODS

=head3 FETCH_LOGIN_SESSION

 login_id => login-id                             
 config   => configuration object

Return a hash reference that minimally includes the member C<prefs>
representing the session associated with the given C<login-id>.

=head3 STORE_LOGIN_SESSION

 session  => session-id                                        
 login_id => login-id                                          
 expires  => expiry-time                                       
 username => username                                          
 data     => ref(session-data)                                 
 config   => configuration object                              

You should save the session associated with the C<login-id> given.
Return 1 if the session has successfully been saved.

=head3 UPDATE_LOGIN_SESSION

 username => username                                          
 config   => configuration object                              
 login_id => login-id                                          

Update the currency of the login session and the username associated
with the session (if you are keeping track of things like that a wish
to be able to expire sessions or identify them as belonging to a
particular user).

=head3 FETCH_SESSION

 config   => configuration object                              
 session  => session-id

Return a reference to a hash that minimally contains the member
C<prefs> representing the session data associated with the given
C<session-id>.

=head3 STORE_SESSION

 session => session-id                         
 new     => 1 indicates that the session is new
 expires => expiry-time                        
 data    => ref(session-data)                  
 config  => configuration object               
 verbose => 0/1                                

Store the session data and return a 1 if the session has successfully
been stored.  The session data is passed in the hash reference C<data>
as member C<prefs>.

  $options{data}->{prefs}


=head3 REGISTER

 config    => configuration object
 username  => username            
 password  => password            
 firstname => first name          
 lastname  => last name           
 email     => email address       

For login sessions you might want to provide an implementation of
C<REGISTER> that enables the session method C<register()> to add a user
to your store of registered users.

Return a 1 if the operation is successful.

=head3 UPDATE_LOGIN_PASSWORD

 config    => configuration object        
 username  => username                    
 password  => [new-password, old-password 
 session   => session-id

Update password associated with the username given.  Return a 1 if the
update is successful.

=cut

# +---------------------------------------------------------------+
# | You should implement the functions below if you want to create|
# | a session manager.  For examples see:                         |
# |                                                               |
# |  BLM::Startup::MySQLSession                                   |
# |  BLM::Startup::PostgreSQLSession                              |
# |  BLM::Startup::SQLiteSession                                  |
# |                                                               |
# +---------------------------------------------------------------+

# +---------------------------------------------------------------+
# | ->CONNECT( %options )                                         |
# |                                                               |
# | config      => config object from tagx.xml                    |
# |                                                               |
# | Purpose: perform any database connection ritual required.     |
# |          This method will be called when the session object   |
# |          is instantiated.                                     |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub CONNECT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->DISCONNECT( %options )                                      |
# |                                                               |
# | config => configuration object                                |
# |                                                               |
# | Purpose: perform any database disconnect ritual required.     |
# |          This function will be called from the DESTROY        |
# |          method of the session object.                        |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub DISCONNECT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->FETCH_LOGIN_SESSION( %options )                             |
# |                                                               |
# | login_id => login-id                                          |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: read row from the session table based on a login     |
# |          identifier (usually a cookie value)                  |
# | Returns: reference to session data                            |
# +---------------------------------------------------------------+
sub FETCH_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->STORE_LOGIN_SESSION( %options )                             |
# |                                                               |
# | session  => session-id                                        |
# | login_id => login-id                                          |
# | expires  => expiry-time                                       |
# | username => username                                          |
# | data     => ref(session-data)                                 |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: This function should be prepared to update the       |
# |          session table based on username or login_id          |
# |          depending on which one is passed.  You should        |
# |          update the expiration time of the session data.      |
# |          You are also responsible for storing the data        |
# |          which is passed as a reference to a hash object      |
# |                                                               |
# |            $options{data}->{prefs}                            |
# |                                                               |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub STORE_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_SESSION( %options )                            |
# |                                                               |
# | username => username                                          |
# | config   => configuration object                              |
# | login_id => login-id                                          |
# |                                                               |
# | Purpose: This function gives the implementation the login-id  |
# |          associated with this session.  You should probably   |
# |          save this to the session in the 'login_cookie'       |
# |          column. This column is then used to identify this    |
# |          user's session.                                      |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->FETCH_SESSION( %options )                                   |
# |                                                               |
# | config   => configuration object                              |
# | session  => username                                          |
# |                                                               |
# | Purpose: This function retrieves the session data based on a  |
# |          session identifier.                                  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub FETCH_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->SESSION_CLEANUP( %options )                                 |
# |                                                               |
# | config   => configuration object                              |
# | session  => session-id                                        |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to clean up stale sessions.                          |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub SESSION_CLEANUP {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->STORE_SESSION( %options )                                   |
# |                                                               |
# | session => session-id                                         |
# | new     => 1 indicates that the session is new                |
# | expires => expiry-time                                        |
# | data    => ref(session-data)                                  |
# | config  => configuration object                               |
# | verbose => 0/1                                                |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to save the session data.                            |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub STORE_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->REGISTER( %options )                                        |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# | firstname => first name                                       |
# | lastname  => last name                                        |
# | email     => email address                                    |
# |                                                               |
# | Purpose:  Register a new user.  Usually involves writing the  |
# |           user's information to a database so they can login  |
# |           later.                                              |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub REGISTER {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->REMOVE_USER( %options )                                     |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# |                                                               |
# | Purpose:  Remove a user from system.                          |
# | Returns: 1 if successfully removed user                       |
# +---------------------------------------------------------------+
sub REMOVE_USER {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_PASSWORD( %options )                           |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => [new-password, old-password                      |
# |                                                               |
# | Purpose:  Change a user's password. Note that                 |
# |           $options{password} is an array reference where      |
# |           element 0 is the new password and element 1 is the  |
# |           old password.                                       |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_PASSWORD {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->KILL_SESSION( %options )                                    |
# |                                                               |
# | session => session-id                                         |
# | config  => configuration object                               |
# |                                                               |
# | Purpose: delete a session from table                          |
# | Returns: 1 if delete is successful                            |
# +---------------------------------------------------------------+
sub KILL_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->LOGOUT( %options )                                          |
# |                                                               |
# | username => username                                          |
# | session  => session-id                                        |
# | config   => configuration object                              |
# |                                                               |
# | Purpose:  Log a user out of the session.  This method is      |
# |           called when the logout() session method is called.  |
# |           You probably want to indicate that the session is   |
# |           expired.  Note that if the method is called with    |
# |           $options{username} set then this is a login session,|
# |           otherwise it is an anonymous session.               |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub LOGOUT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->LOGIN( %options )                                           |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | password => password                                          |
# |                                                               |
# | Purpose:  Log in and start a login session.                   |
# |           called when the logout() session method is called.  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub LOGIN {
  my $self    = shift;
  my %options = @_;
}

sub clear {
  my $obj = shift;
  %{$obj} = ();
}

sub remove_user {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password ) = @_;

  if ( $self->{data}->{username} eq $username ) {
    $obj->logout();
  }

  my $rows = $self->REMOVE_USER( config   => $self->{config},
                                 username => $username,
                                 password => $password
                               );
}

sub lookup_user {
  my $obj  = shift;
  my $self = tied( %{$obj} );
  my $username = shift;

  return $self->do_select( 'LOOKUP_USER', 'username', $username );
}

sub register {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password, $firstname, $lastname, $email ) = @_;

  my $verbose = $self->{'verbose'};

  my $rows = $self->REGISTER( username  => $username,
                              config    => $self->{config},
                              password  => $password,
                              firstname => $firstname,
                              lastname  => $lastname,
                              email     => $email
                            );

  &log_message(
    undef,
"Registering user ($username, $password, $firstname, $lastname, $email): rows = [$rows]"
  ) if $verbose;
}

sub kill_session {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config, $session ) =
  @{$self}{qw(verbose ctx config session)};

  $self->{data} = {};

  unless ( $config->{'cookieless_sessions'} ) {

    # Delete the cookie
    $self->cookie( $self->{'name'},
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $self->send_cookie;
  }

  $self->KILL_SESSION( session => $session,
                       config  => $config );
}

sub login {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password ) = @_;

  my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};

  &log_message( undef, "Attempting to log in user ($username, $password)" )
    if $verbose;

  my $aref = $self->LOGIN( username => $username,
                           password => $password,
                           config   => $self->{config}
                         );

  # cleanup session directory if one exists
  if ( $aref->[5] && $self->cleanup_session_dir ) {
    my $session_dir = sprintf(
			      "%s/%s", 
			      $ctx->{CONFIG}->{SESSION_DIR},
			      $aref->[5]
			     );

    rmtree $session_dir
      if -d $session_dir
  }

  $self->init_session( $aref );

  # Create a new session id for the user
  my $session = $self->newSessionID;

  # Delete the `new_session' flag
  delete $self->{'new_session'};

  # Save the merged prefs and the session id
  $self->STORE_LOGIN_SESSION(
    session => $session,
    data => { prefs => Bedrock::XML::writeXMLString( $self->{data}->{prefs} ) },
    expires  => $self->{'expires'},
    username => $username,
    config   => $self->{config}
  );
}

sub logout {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  $self->LOGOUT( config   => $config,
                 session  => $self->{session},
                 username => $self->{data}->{username}
               );

  # Reset data
  $self->{'data'} = {};

  unless ( $config->{'cookieless_sessions'} ) {

    # Delete the cookie
    $self->cookie( $self->{'name'},
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $self->send_cookie;
  }
}


sub change_passwd {
  my $obj  = shift;
  my $self = tied( %{$obj} );
  my ( $opasswd, $npasswd ) = @_;

  my $username = $self->{'data'}->{'username'};
  die "Cannot change password: user not logged in.\n" unless length($username);

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};
  my $t = $config->{'table_name'};

  &log_message(
    undef,
"Attempting to change password to `$npasswd' from `$opasswd' for `$username'"
  ) if $verbose;

  $self->UPDATE_LOGIN_PASSWORD( table    => $config->{table_name},
                                username => $username,
                                password => [ $npasswd, $opasswd ],
				session  => $self->{session}
                              );
}

sub remember_user {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  die "No user logged in to remember\n"
  unless length( $self->{'data'}->{'username'} );

  my $username = $self->{'data'}->{'username'};

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $login_cookie_name = $config->{'login_cookie_name'};
  my $login_id          = $ctx->getCookieValue($login_cookie_name);

  return length($login_id) ? 1 : 0 unless @_ > 0;

  if ( $_[0] =~ /on/i ) {
    $login_id = $self->newLoginCookie;
  }
  else {

    # Delete the login cookie
    $self->cookie( $login_cookie_name,
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $login_id = '';
    $self->send_cookie;
  }

  $self->UPDATE_LOGIN_SESSION( config   => $config,
                               username => $username,
                               login_id => $login_id
                             );
}

sub encrypt {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  return crypt( $_[0], $_[1] );
}

sub create_temp_login_session {
  my $obj = shift;
  my $self = tied( %{$obj} );

  my $username = shift;
  my $time = shift || '15m';
  my $recycle = shift;

  # calculate expiry in seconds
  my $seconds;

  if ( $time =~/^(\d+)([smdh])?$/i ) {
    $time = $1;
    my $unit = lc($2);

    if ( $unit eq 'm' ) {
      $seconds = $time * 60;
    }
    elsif ( $unit eq 's' ) {
      $seconds = $time;
    }
    elsif ( $unit eq 'h' ) {
      $seconds = $time * 60 * 60;
    }
    elsif ( $unit eq 'd' ) {
      $seconds = $time * 24 * 60 * 60;
    }
    else {
      $seconds = $time * 60;
    }
  }
  else {
    die "invalid expiry time\n";
  }

  my ($verbose) = @{$self}{qw(verbose)};
  &log_message( undef, "Attempting to create temporary log-in session for user: $username" )
    if $verbose;

  my $default_expiry = $seconds || $self->{config}->{cookie}->{expiry_secs};
  $self->{config}->{cookie}->{expiry_secs} = $default_expiry; 

  # Create a new session id for the user
  my $session;
  # Delete the `new_session' flag
  delete $self->{'new_session'};

  my $data;
  
  if ( $recycle ) {
    # do we have an active session for this user? If so, then use this token
    eval {
      $data = $self->FETCH_LOGIN_SESSION_BY_USERNAME(
						     config   => $self->{config},
						     username => $username
						    );
      $session = $data->[5];
    };
  }

  if ( $@ || ! $session ) {
    $session = $self->newSessionID;

    $self->UPDATE_LOGIN_SESSION(
				config   => $self->{config},
				username => $username,
				login_id => $session
			       );

    $data = $self->FETCH_LOGIN_SESSION(
				       config   => $self->{config},
				       login_id => $session
				      );
  }

  $self->init_session( $data );

  # this resets the expiry time
  $self->STORE_LOGIN_SESSION(
			     session  => $session,
			     expires  => $seconds,
			     data     => $data,
			     username => $username,
			     config   => $self->{config}
			    );

  $self->UPDATE_LOGIN_SESSION(
			      config   => $self->{config},
			      username => $username,
			      login_id => undef
			     );

  $obj->closeBLM;

  # new session
  $self->startSession($self->{config});
  $self->newSession;
  $self->{'data'}->{'prefs'}->{expiry_secs} = $default_expiry;

  $session;
}


=pod

=head2 create_session_dir

 create_session_dir([sub-dir])

Creates a session directory with a corresponding subdirectory if
requested. Session directories are subdirectories that are identified
by the session cookie value and typically used in conjunction with
C<Apache::BedrockSessionFiles>.

Your F<tagx.xml> file should define a C<SESSION_DIR> value that
provides the root for the session directory.

 <scalar name="SESSION_DIR">/var/www/vhosts/mydomain.com/session</scalar>


=cut

sub create_session_dir {
  my $obj     = shift;
  my $sub_dir = shift;

  my $self = tied( %{$obj} );

  my $session_id = $self->{'session'};

  my ($verbose, $ctx, $config) = @{$self}{qw(verbose ctx config)};
  my $session_dir = $ctx->{'CONFIG'}->{'SESSION_DIR'};

  die "No SESSION_DIR defined.\n"
  unless $session_dir;

  $session_dir .= "/$session_id";

  unless ( -d "$session_dir/$sub_dir" ) {
    &log_message(undef, "creating directory $session_dir/$sub_dir")
      if $verbose;

    eval { mkpath("$session_dir/$sub_dir"); };

    if ( $@ ) {
      &log_message(undef, "Unable to create $session_dir/$sub_dir\n$@\n");
      die "Unable to create $session_dir/$sub_dir\n";
    }

  }

  return "$session_dir/$sub_dir";
}

=pod

=head2 cleanup_session_dir

 cleanup_session_dir( 0 | 1 )

Indicate whether or not the C<login()> method should attempt to
cleanup session directories.

=cut

sub cleanup_session_dir {
  my $self = shift;

  my @args = 'cleanup_session_dir';

  if ( @_ > 0 ) {
    push @args, $_[0] ? 'yes' : 'no';
  }

  my $cleanup_flag = $self->config(@args);

  return $cleanup_flag =~/y/i;
}


=pod

=head2 create_session_tempfile

 create_session_tempfile(template, options)

Creates a temporary file in the current session directory.

 <null $session.create_session_tempfile('fooXXXX', 'SUFFIX', '.html')>

=over 5

=item template

Template to use for file creation (see C<tempfile>). Use at least 4 X's.

=item options

=over 10

=item DIR

Sub directory under the C<session> directory to create.

=item SUFFIX

Suffix (extension).

=back

=back

=cut

sub create_session_tempfile {
  my $obj      = shift;
  my $template = shift;
  my %options  = @_;

  return Bedrock::Array->new(tempfile($template, DIR => $obj->create_session_dir($options{DIR}), SUFFIX => $options{SUFFIX}));
}


=pod

=head2 copy2session

 copy2session(path)

Copies the file indicated by C<path> to the session directory.  Throws
an exception of the file does not exist, is empty or is unreadable. If
the path is the name of a file, it is assumed to be in the document
root.

=cut

sub copy2session {
  my ($obj, $file ) = @_;

  die "usage: copy2session(file)\n" 
    unless $file;

  my $self = tied %{$obj};

  my ($name, $path, $ext) = fileparse( $file, qr/.[^.]*$/ );

  if ( $path eq './' ) {
    $file = $ENV{DOCUMENT_ROOT} . '/' . $file;
  }

  my $dest = sprintf("%s/%s%s", $obj->create_session_dir, $name, $ext);

  if ( -s $file ) {
    unless ( copy( $file, $dest ) ) {
      die "could not copy file [$file] to [$dest]\n";
    }
  }
  elsif ( ! -r $file ) {
    die "insufficient privileges to read " . $file . "\n";
  }
  elsif ( ! -s $file ) {
    die "file " . $file . " is empty\n";
  }
  else {
    die "file not found " . $file . "\n";
  }
}

sub config {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  if ( @_ > 1 ) {
    $config->{ $_[0] } = $_[1];
  }
  else {
    return $config->{ $_[0] };
  }
}

sub cookieless_session {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  # don't allow someone to access a stale session...iow...if the
  # session identifier being passed is associated with a stale
  # session, the call below will remove that identifier.
  $self->SESSION_CLEANUP( config => $self->{config} );

  my $id = shift;

  $self->{'new_session'} = 0 if $id;
  $self->{'session'} = $id || $self->{'session'};
  $self->readData($id);

  my $do_not_kill_cookie = shift;
  $config->{'cookieless_sessions'} = ! $do_not_kill_cookie;

# kill the cookie if cookies are enabled, since on instantiation,
# UserSession ($session) will create a cookie.

# You might want to set the do-not-kill-cookie flag if you are
# injecting a session id using the cookieless_session() method.
#
#  <null $session.cookieless_session( $input.session, 1 )>
#
#  This would then permanently log your user in for example, or allow
#  you to inject a pre-fabricated session environment for the user
#  that is now persistent without now having to carry around the
#  session variable...in otherwords 'cookieless_session' becomes a
#  misnomer, since you'll now have a session cookie, but with the
#  session you built.
#

  $self->cookie( 
		$self->{'name'},
		'value'   => $do_not_kill_cookie ? $id : 'killed',
		'expires' => $do_not_kill_cookie ? $self->{expires} : -864000
	       );

  $self->send_cookie;
}

sub resend_cookie {
  my $obj = shift;
  my $self = tied( %{$obj} );

  $self->send_cookie(shift);
}

sub cookie {
  my $self = shift;
  my $name = shift;

  $self->{'cookies'} = {} unless $self->{'cookies'};
  $self->{'cookies'}->{$name} = {} unless $self->{'cookies'}->{$name};
  my $cref = $self->{'cookies'}->{$name};
  if ( ref( $_[0] ) ) {
    for my $param ( keys %{ $_[0] } ) {
      $cref->{$param} = $_[0]->{$param};
    }
  }
  else {
    my %args = @_;
    for my $param ( keys %args ) {
      $cref->{$param} = $args{$param};
    }
  }
}

sub digest {
  my $md5 = Digest::MD5->new;
  $md5->add(
        sprintf( "%012d:%20s:%08d:%.10f", time, $ENV{REMOTE_ADDR}, $$, rand ) );
  $md5->hexdigest;
}

sub send_cookie {
  my $self = shift;
  return unless $self->{'cookies'};

  my $expires = shift;

  my $config = $self->{'config'};
  my ( $cref, $header );

  for my $name ( keys %{ $self->{'cookies'} } ) {
    $cref   = $self->{'cookies'}->{$name};
    $header = $name . '=' . $cref->{'value'} . '; ';

    $header .= 'path='
    . ( $cref->{'path'} || $config->{'cookie'}->{'path'} || '/' ) . '; ';

    my $domain = $config->{'cookie'}->{'domain'};
    $header .= 'domain=' . $domain . '; ' if length($domain);

    if ( exists $cref->{'expires'} ) {
      my $expiry = POSIX::strftime( "%a, %d-%b-%Y %T GMT",
                                    gmtime( time + ($expires || $cref->{'expires'}) ) );
      $header .= 'expires=' . $expiry . '; ';
    }

    $self->{'ctx'}->cgi_header_out( 'Set-Cookie', $header );
    &log_message( undef, "Set cookie header: [Set-Cookie => $header]" )
    if $self->{'verbose'} > 1;
  }
}

sub startSession {
  my ( $self, $config ) = @_;

  $self->{'config'} = $config;

  die ref($self),
  "->startSession(): param `table_name' must be specified in config\n"
  unless $config->{table_name};

  $self->CONNECT( config => $config );
  $self->SESSION_CLEANUP( config => $config );
}

sub newLoginCookie {
  my $self = shift;

  my $config = $self->{'config'};
  my $ctx    = $self->{'ctx'};
  my $id     = &digest;

  unless ( $config->{'cookieless_sessions'} ) {

    # Set the cookie header
    $self->cookie(
            $config->{'login_cookie_name'},
            'value'   => $id,
            'expires' => ( $config->{'login_cookie_expiry_days'} || 30 ) * 86400
    );
    $self->send_cookie;
  }

  $id;
}

sub newSessionID {
  my $self = shift;

  my $config = $self->{'config'};
  my $ctx    = $self->{'ctx'};
  my $id     = $self->{'session'} = &digest;

  my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400;
  $self->{'expires'} = $secs;

  unless ( $config->{'cookieless_sessions'} ) {

    # Set the cookie header
    $self->cookie( $self->{'name'},
                   'value'   => $id,
                   'expires' => $secs
                 );
    $self->send_cookie;
  }

  $id;
}

sub newSession {
  my $self = shift;

  $self->newSessionID;
  $self->{'new_session'} = 1;
  $self->{'data'} = { 'prefs' => {} };
  $self->{'session'};
}

sub init_session {
  my $self = shift;
  my $aref = shift;

  my ($verbose) = @{$self}{qw(verbose)};

  if ( $aref ) {
    &log_message(
		 undef,
		 "Initializing session\n" .
		 "username = ($aref->[0])\n" .
		 "firstname = ($aref->[1])\n".
		 "lastname = ($aref->[2])\n" .
		 "email = ($aref->[3])"
		) if $verbose;

    &log_message( undef, "Session prefs are\n$aref->[4]" ) 
      if $verbose > 1;

    my $data = {};

    @{$data}{qw(username firstname lastname email)} =
    ( @{$aref}[ 0, 1, 2, 3 ] );

    $data->{'prefs'} = Bedrock::XML->newFromString( $aref->[4] )
      if length( $aref->[4] );

    $data->{'prefs'} = {} unless $data->{'prefs'};

    $self->{'data'} = $data;
  }
  else {
    &log_message( undef, "Initializing new session" ) if $verbose;
    $self->newSession;
  }
}

#
# `session' is stored under $self
# `username', `password', `firstname', `lastname', `email' if stored under $self->{'data'}
# `new_session' is set to 1 if no previous session info found for user
# Other than these are stored under $self->{'data'}->{'prefs'}
#
sub readData {
  my ( $self, $id ) = @_;

  my ( $config, $verbose ) = @{$self}{qw(config verbose)};

  &log_message( undef, "Reading data for session [$id]" ) if $verbose;
  my $aref = $self->FETCH_SESSION( 
				  config  => $config,
				  session => $id 
				 );

  unless ( $aref ) {
    &log_message( undef, "Unable to read data for session [$id]" ) 
      if $verbose;
    return;
  }

  my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400;

  unless ( $config->{'cookieless_sessions'} ) {
    $self->cookie( $self->{'name'},
                   'value'   => $id,
                   'expires' => $secs
                 );
    $self->send_cookie;
  }

  $self->{'expires'} = $secs;

  $self->{'session'} = $id;

  $self->init_session($aref);

  $self->{'session'};
}

sub newLoginSession {
  my $self     = shift;
  my $login_id = shift;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $aref =
  $self->FETCH_LOGIN_SESSION( config => $config, login_id => $login_id );

  unless ($aref) {
    &log_message( undef, "Login session [$login_id] not found" ) if $verbose;
    return;
  }

  my $data = {};

  &log_message(
    undef,
"Found login session [$login_id]\nusername = ($aref->[0])\nfirstname = ($aref->[1])\nlastname = ($aref->[2])\nemail = ($aref->[3])"
  ) if $verbose;
  &log_message( undef,
            "Saved session info for login session [$login_id] is\n$aref->[-1]" )
  if $verbose > 1;

  @{$data}{qw(username firstname lastname email)} = ( @{$aref}[ 0, 1, 2, 3 ] );
  $data->{'prefs'} = Bedrock::XML->newFromString( $aref->[-1] )
  if length( $aref->[-1] );

  # Create new session id
  my $id = $self->newSessionID;

  my $rows = $self->STORE_LOGIN_SESSION( session  => $id,
                                         login_id => $login_id,
                                         expires  => $self->{expires},
                                         config   => $config
                                       );

  &log_message(
      undef,
      "Updating session = [$id] for login session [$login_id]: rows = [$rows]\n"
  ) if $verbose;

  $data->{'prefs'} = {} unless $data->{'prefs'};
  $self->{'data'} = $data;
  $self->{'session'};
}

sub TIEHASH {
  my ( $class, $ctx, $config ) = @_;

  # What is the name of the session variable being used?
  my $name = $config->{'param'};
  die "$class->TIEHASH(): `param' not set in config\n" unless $name;

  # Create session object
  my $self = bless {}, $class;
  $self->{'ctx'}    = $ctx;
  $self->{'name'}   = $name;
  $self->{'config'} = $config;

  my $verbose = $self->{'verbose'} = $config->{'verbose'};

  # Initialize session 
  $self->startSession($config);

  # Check for an existing session
  my $id = $config->{'cookieless_sessions'} ? $ctx->getInputValue($name) : $ctx->getCookieValue($name);

  # Get the session data only if a session exists
  if ( defined($id) ) {
    &log_message( undef, "Read user's session: [$id]" ) if $verbose;
    my $session = $self->readData($id);

    &log_message( undef, "User has session [$session]" )
      if $session and $verbose;

    return $self if $session;
  }

  # No session cookie -- check to see if login cookie present
  my $login_cookie_name = $config->{'login_cookie_name'};
  my $login_id =
    $config->{'cookieless_sessions'}
  ? $ctx->getInputValue($login_cookie_name)
  : $ctx->getCookieValue($login_cookie_name);

  if ($login_id) {
    my $session = $self->newLoginSession($login_id);
    &log_message( undef,
                 "User has login session [$login_id] -- session is [$session]" )
    if $session and $verbose;
    return $self if $session;
  }

  # everything failed -- need to create a new session
  my $session = $self->newSession;
  &log_message(
     undef,
     "User does not have anonymous session or login session -- using [$session]"
  ) if $verbose;

  $self->{'data'}->{'prefs'}->{expiry_secs} =
  $self->{'config'}->{'cookie'}->{'expiry_secs'};

  # And return the session object
  $self;
}

sub FETCH {
  my ( $self, $key ) = @_;
  if ( $key eq 'session' ) { return $self->{$key} }
  elsif ( $key =~ /^(username|firstname|lastname|email|config)$/ ) {
    return $self->{'data'}->{$key};
  }
  elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) {
    $self->{'data'}->{'prefs'}->{$key};
  }
  else { return $self->{'config'}->{'default_prefs'}->{$key} }
}

# Just store the value in the session and return the value
sub STORE {
  my ( $self, $key, $value ) = @_;
  if ( $key =~ /^(session|username)$/ ) {
    die "Cannot set `$key': attribute is read-only.\n";
  }
  elsif ( $key eq 'password' ) {
    die "Cannot set `password': Use `change_password()' instead.\n";
  }
  elsif ( $key =~ /^(firstname|lastname|email)$/ ) {
    die
    "Cannot set `$key' -- no username: use `login()' or `register()' first.\n"
    unless $self->{'data'}->{'username'};
    die "Cannot store empty string in `$key'.\n"
    if $key =~ /^(firstname|lastname)$/ and length($value) == 0;
    &log_message( undef, "Storing [$key] = [$value]" ) if $self->{'verbose'};
    return $self->{'data'}->{$key} = $value;
  }
  else {
    &log_message( undef, "Stored [$key] = [$value] into prefs" )
    if $self->{'verbose'};
    return $self->{'data'}->{'prefs'}->{$key} = $value;
  }
}

# Invoked to loop over the properties of the session
sub FIRSTKEY {
  my $self = shift;

  delete $self->{'keys'};

  my $k = { 'session'   => $self->{'session'},
            'username'  => $self->{'data'}->{'username'},
            'firstname' => $self->{'data'}->{'firstname'},
            'lastname'  => $self->{'data'}->{'lastname'},
            'email'     => $self->{'data'}->{'email'}
          };

  my %keys;
  @keys{
    keys %{ $self->{'data'}->{'prefs'} },
    keys %{ $self->{'config'}->{'default_prefs'} }
  }
  = ();
  for my $key ( keys %keys ) {
    if ( exists $self->{'data'}->{'prefs'}->{$key} ) {
      $k->{$key} = $self->{'data'}->{'prefs'}->{$key};
    }
    else {
      $k->{$key} = $self->{'config'}->{'default_prefs'}->{$key};
    }
  }
  $self->{'keys'} = $k;
  each %{ $self->{'keys'} };
}

sub NEXTKEY {
  each %{ shift->{'keys'} };
}

sub EXISTS {
  my ( $self, $key ) = @_;
  if ( $key eq 'session' ) { return 1 }
  elsif ( $key =~ /^(username|password|firstname|lastname|email)$/ ) {
    return exists $self->{'data'}->{$key};
  }
  elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) { return 1 }
  else { exists $self->{'config'}->{'default_prefs'}->{$key} }
}

sub DELETE {
  my ( $self, $key ) = @_;
  if ( $key =~ /^(session|username|firstname|lastname|email|password)$/ ) {
    die "Cannot delete `$key': illegal operation.\n";
  }
  else {
    return delete $self->{'data'}->{'prefs'}->{$key};
  }
}

sub CLEAR {
  my $self = shift;
  %{ $self->{'data'}->{'prefs'} } = ();
}

sub closeBLM {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $session ) = @{$self}{qw(verbose session)};

  my $prefs = $self->{data}->{prefs};

  # this is a very implementation specific session rule that says, if
  # there is no session, then if there is a 'default_prefs' set in the
  # session configuration, then map that to the session data...
  $prefs = $self->{config}->{default_prefs} if keys %{$prefs} == 0;

  my $xml = Bedrock::XML::writeXMLString($prefs || {});
  &log_message( undef, "Saving session [" . $session . "] data\n$xml" )
    if $verbose > 1;

  # there are certain situations where Bedrock may call closeBLM() more than once
  # if that happens, we don't want to alter the object since the second call will fail
  # because the prefs object was already converted to XML...so we create a clone
  # object that is written to the database
  my $data = {};
  map { $data->{$_} =  $self->{data}->{$_} unless $_ eq 'prefs'; } keys %{$self->{data}};
  $data->{prefs} = $xml;

  $self->STORE_SESSION( verbose => $verbose,
                        session => $session,
                        data    => $data,
                        expires => $self->{expires},
                        new     => $self->{new_session},
                        config  => $self->{config}
                      );

  my $nrows = $self->SESSION_CLEANUP( config => $self->{config} );
  &log_message( undef, sprintf( "Cleaned up %s rows", $nrows ) )
    if $verbose;

  $self->DISCONNECT( config => $self->{config} );
}

=head1 SEE ALSO

C<BLM::Startup::UserSession>

=head1 AUTHOR

Rob Lauer <rlauer6@comcast.net>

=cut


1;
