#!@PERL@ -w

# ident "@(#) $Header$
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::SessionManager;

use strict;

BEGIN {
  use Exporter ();
  use vars qw($VERSION @ISA);
  $VERSION = do { my @r = ( q$Revision$ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
}

use Carp;
use Digest::MD5;
use POSIX qw(strftime);
use File::Path;
use File::Temp qw/tempfile/;
use IO::Handle;

use Bedrock::XML;
use Bedrock::Hash;
use TagX::Log;

@ISA = qw( Bedrock::Hash );

=pod

=head1 PUBLIC 

C<BLM::Startup::SessionManager> - Base class for implementing Bedrock sessions.

=head1 DESCRIPTION

This is a base class that you can use as a starting point when
implementing a custom Bedrock session manager.  For example
implementations, see: C<BLM::Startup::MySQLSession>,
C<BLM::Startup::PostgreSQLSession> and C<BLM::Startup::SQLiteSession>.

You are expected to implement several methods to create a valid
session manager.  You can also provide implementations for a few other
B<optional> methods that are called at various points during session
handling.  These methods may or may not be necessary for your
implmentations.  YMMV.

=head1 METHODS

The methods described below are categorized as either B<optional> or
B<required>. Required means, if you want the class to do something
useful, you more or less need to do something and return something.
Only death and taxes are actually required. 

All of the methods take a hash as an argument.  The hash members
passed are described in general and each methodE<039>s documentation will
then indicate which of these is passed to you for this call.

Your implementation may or may not require these arguments to
implement the functionality you are providing.

=head2 Writing Your Implementation

The purpose of your implementation is to store a userE<039>s data to a
permanent data store.  Permanence is defined based on the type of
session that is being created by the calls to your handlers.  Login
sessions should save a userE<039>s data for access any time the user I<logs
in> using the session objectE<039>s C<login()> method.

Anonymous sessions on the other hand tend to expire based on some
setting in your configuration file.  That expiration is translated
into the expiry date of a cookie, thus cookie based session ids become
unavailable after that time and thus the session associated with that
id becomes inaccessible.

=head3 Selecting Your Storage Method

The description of the API is generic enough such that you should be
able to design your own storage mechanism in whatever fashion you
please.  The calls made to methods you write are provided the relevant
pieces of information needed to store or retrieve a particular
session, including the C<config> object that is defined in your
F<tagx.xml> entry for this Application Plugin.  Since you have control
over what goes in that configuration section you should have what you
need to implement your session manager.

The storage and retrieval mechanism might involve an SQL table for
example, or it might be involve some other way to store and retrieve
data based on a unique key.  The only real requirement is that the API
provide a way to store and retrieve data using a unique key.
Typically this means a database table and a unique key.

Requests to store and retrieve session data will occur across
different client requests implying a different Apache process will
service different requests.  That means you must have a way to persist
the data across these requests, i.e. you canE<039>t simply store things in
a hash for the current request for example.

Sessions are generally not meant to last forever and are not usually
large. Your application needs will dictate much of that.

If you decide to implement sessions using a database table, the
reference implemenation documented in C<BLM::Startup::MySQLSession>
should give you some clues as to what a table might look like and one
way to provide persistence.  ItE<039>s not the only way, and probably not
the most efficient way one could construct.  Again, YMMV.

=head3 Storing and Retrieving the Session Data

YouE<039>ll be implementing a set of methods for storing and retrieving
session data.

  ->FETCH_SESSION( )
  ->STORE_SESSION( )
  ->FETCH_LOGIN_SESSION( )
  ->STORE_LOGIN_SESSION( )

The C<FETCH_*> methods you implement should return a reference to a
hash object that minimally contains a member named C<prefs>.  The
C<prefs> object is a text blob that was sent to you to save via one of
the C<STORE_*> methods.

Technically speaking you donE<039>t need to know too much more than that,
however the object that you stored is a Bedrock XML object.  It will
be converted to its internal representation (a hash reference) by the
calling functions and eventually will be accessible to the Bedrock
page via the C<$session> object.

Likewise, the C<STORE_*> methods expect you to take a hash reference
which is passed as the hash member C<data> and store the session data
I<somewhere>.  Other arguments to C<STORE_*> will tell you what
session or user this data belongs to so you can store the data in such
as way as to allow for later retrieval using that same information as
a key or index.

=head3 Arguments to Methods

The argument to the methods that you will implement is a hash.  The
members can be any of those described below depending on the particular
method being invoked.

=over 5

=item config

This is a hash reference to the configuration information you defined
in your F<tagx.xml> entry for this Application Plugin. HereE<039>s what he
configuration object looks like for the reference implementation.

      <object name="config">

        <scalar name="verbose">2</scalar>
        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>
        <scalar name="data_source">dbi:mysql:bedrock</scalar>
        <scalar name="username">fred</scalar>
        <scalar name="password">flintstone</scalar>
        <scalar name="table_name">session</scalar>
        <scalar name="purge_user_after">30</scalar>
        <scalar name="cookieless_sessions"></scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>

Your configuration object can have whatever information is necessary
to implement your session manager, however you should have these
elements at a minimum to provide for cookie based sessions.

      <object name="config">

        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>


=item data

A reference to a hash that possibly contains various members including
C<prefs> which is a text represenation of the userE<039>s session data.
You should save that data so you can return it via one of the
C<FETCH_*> methods for the given session or login identifier.

Possible members that may appear in the hash reference as well and
that you may or may not need or wish to store include (see descriptions
below):

=over 5

=item username

=item password

=item email

=item firstname

=item lastname

=item prefs

=back

=item email

The email address of a user.  Used as an argument to the C<register()> method of the session object.

=item expires

The session expiration time in seconds.

=item firstname

The first name of a user.  Used as an argument to the C<register()> method of the session object.

=item lastname

The last name of a user.  Used as an argument to the C<register()> method of the session object.

=item login_id

=item new 

A flag that indicates if the session is new.

=item password

The password associated with the username of a registered user.  Used as an argument to the C<register()> and C<login()> methods of the session object.

=item prefs

This is the payload that contains the session data that you should store or retrieve.

=item session

A unique session identifier based on an MD5 digest value.

=item username

The username associated with a registered user.  Used as an argument to the C<register()> and C<login()> methods of the session object.

=item verbose

An integer, possibly >=0 that indicates the verbosity level desired.

=back

=head2 OPTIONAL METHODS

The method descriptions below include an indication of which hash
elements are passed and a brief explanation of what the method is
required to do and/or return.  Your method should access the arguments
similar to the following stub:

  sub CONNECT {
    my $self = shift;
    my %options = @_;
   
    my $table_name = $options{config}->{table};
    ...
  }

=head3 CONNECT

 config => configuration object

This method is called when the session object is instantiated and
gives your method an opportunity to do any initialization rituals
necessary prior to being asked to fetch or store any data.  Typically,
this means connecting to a database, like so:

  $self->{dbh} = DBI->connect( $options{config}->{data_source},
                               $options{config}->{username},
                               $options{config}->{password}
                             );

You can save state to the object, but be careful.  A better approach
is to create your own reference to data you need to keep track of.
The element C<_manager_state> is reserved for this purpose.  So
C<CONNECT> might be better written:

  my $dbh = DBI->connect( $options{config}->{data_source},
                          $options{config}->{username},
                          $options{config}->{password}
                        );

  $self->{_manager_state} = { dbh => $dbh };


=head3 DISCONNECT

 config => configuration object

This method is called when the session object is destroyed. You should
do whatever post necessary to close files, database, etc.

=head3 SESSION_CLEANUP

 config  => configuration object

This method is called when the session object is destroyed prior to
the call to C<DISCONNECT>.  You can use this opportunity to clear out
stale sessions if necessary.

=head3 LOGOUT

 username => username
 session  => session-id
 config   => configuration-object

This method is called in response to the session object method
C<logout()>.

=head2 REQUIRED METHODS

=head3 FETCH_LOGIN_SESSION

 login_id => login-id                             
 config   => configuration object

Return a hash reference that minimally includes the member C<prefs>
representing the session associated with the given C<login-id>.

=head3 STORE_LOGIN_SESSION

 session  => session-id                                        
 login_id => login-id                                          
 expires  => expiry-time                                       
 username => username                                          
 data     => ref(session-data)                                 
 config   => configuration object                              

You should save the session associated with the C<login-id> given.
Return 1 if the session has successfully been saved.

=head3 UPDATE_LOGIN_SESSION

 username => username                                          
 config   => configuration object                              
 login_id => login-id                                          

Update the currency of the login session and the username associated
with the session (if you are keeping track of things like that a wish
to be able to expire sessions or identify them as belonging to a
particular user).

=head3 FETCH_SESSION

 config   => configuration object                              
 session  => session-id

Return a reference to a hash that minimally contains the member
C<prefs> representing the session data associated with the given
C<session-id>.

=head3 STORE_SESSION

 session => session-id                         
 new     => 1 indicates that the session is new
 expires => expiry-time                        
 data    => ref(session-data)                  
 config  => configuration object               
 verbose => 0/1                                

Store the session data and return a 1 if the session has successfully
been stored.  The session data is passed in the hash reference C<data>
as member C<prefs>.

  $options{data}->{prefs}


=head3 REGISTER

 config    => configuration object
 username  => username            
 password  => password            
 firstname => first name          
 lastname  => last name           
 email     => email address       

For login sessions you might want to provide an implementation of
C<REGISTER> that enables the session method C<register()> to add a user
to your store of registered users.

Return a 1 if the operation is successful.

=head3 UPDATE_LOGIN_PASSWORD

 config    => configuration object        
 username  => username                    
 password  => [new-password, old-password 
 session   => session-id

Update password associated with the username given.  Return a 1 if the
update is successful.

=head1 SEE ALSO

C<BLM::Startup::UserSession>

=head1 AUTHOR

Rob Lauer <rlauer@signatureinfo.com>

=cut

# +---------------------------------------------------------------+
# | You should implement the functions below if you want to create|
# | a session manager.  For examples see:                         |
# |                                                               |
# |  BLM::Startup::MySQLSession                                   |
# |  BLM::Startup::PostgreSQLSession                              |
# |  BLM::Startup::SQLiteSession                                  |
# |                                                               |
# +---------------------------------------------------------------+

# +---------------------------------------------------------------+
# | ->CONNECT( %options )                                         |
# |                                                               |
# | config      => config object from tagx.xml                    |
# |                                                               |
# | Purpose: perform any database connection ritual required.     |
# |          This method will be called when the session object   |
# |          is instantiated.                                     |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub CONNECT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->DISCONNECT( %options )                                      |
# |                                                               |
# | config => configuration object                                |
# |                                                               |
# | Purpose: perform any database disconnect ritual required.     |
# |          This function will be called from the DESTROY        |
# |          method of the session object.                        |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub DISCONNECT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->FETCH_LOGIN_SESSION( %options )                             |
# |                                                               |
# | login_id => login-id                                          |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: read row from the session table based on a login     |
# |          identifier (usually a cookie value)                  |
# | Returns: reference to session data                            |
# +---------------------------------------------------------------+
sub FETCH_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->STORE_LOGIN_SESSION( %options )                             |
# |                                                               |
# | session  => session-id                                        |
# | login_id => login-id                                          |
# | expires  => expiry-time                                       |
# | username => username                                          |
# | data     => ref(session-data)                                 |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: This function should be prepared to update the       |
# |          session table based on username or login_id          |
# |          depending on which one is passed.  You should        |
# |          update the expiration time of the session data.      |
# |          You are also responsible for storing the data        |
# |          which is passed as a reference to a hash object      |
# |                                                               |
# |            $options{data}->{prefs}                            |
# |                                                               |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub STORE_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_SESSION( %options )                            |
# |                                                               |
# | username => username                                          |
# | config   => configuration object                              |
# | login_id => login-id                                          |
# |                                                               |
# | Purpose: This function gives the implementation the login-id  |
# |          associated with this session.  You should probably   |
# |          save this to the session in the 'login_cookie'       |
# |          column. This column is then used to identify this    |
# |          user's session.                                      |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->FETCH_SESSION( %options )                                   |
# |                                                               |
# | config   => configuration object                              |
# | session  => username                                          |
# |                                                               |
# | Purpose: This function retrieves the session data base on a   |
# |          session identifier.                                  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub FETCH_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->SESSION_CLEANUP( %options )                                 |
# |                                                               |
# | config   => configuration object                              |
# | session  => session-id                                        |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to clean up stale sessions.                          |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub SESSION_CLEANUP {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->STORE_SESSION( %options )                                   |
# |                                                               |
# | session => session-id                                         |
# | new     => 1 indicates that the session is new                |
# | expires => expiry-time                                        |
# | data    => ref(session-data)                                  |
# | config  => configuration object                               |
# | verbose => 0/1                                                |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to save the session data.                            |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub STORE_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->REGISTER( %options )                                        |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# | firstname => first name                                       |
# | lastname  => last name                                        |
# | email     => email address                                    |
# |                                                               |
# | Purpose:  Register a new user.  Usually involves writing the  |
# |           user's information to a database so they can login  |
# |           later.                                              |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub REGISTER {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->REMOVE_USER( %options )                                     |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# |                                                               |
# | Purpose:  Remove a user from system.                          |
# | Returns: 1 if successfully removed user                       |
# +---------------------------------------------------------------+
sub REMOVE_USER {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_PASSWORD( %options )                           |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => [new-password, old-password                      |
# |                                                               |
# | Purpose:  Change a user's password. Note that                 |
# |           $options{password} is an array reference where      |
# |           element 0 is the new password and element 1 is the  |
# |           old password.                                       |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_PASSWORD {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->KILL_SESSION( %options )                                    |
# |                                                               |
# | session => session-id                                         |
# | config  => configuration object                               |
# |                                                               |
# | Purpose: delete a session from table                          |
# | Returns: 1 if delete is successful                            |
# +---------------------------------------------------------------+
sub KILL_SESSION {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->LOGOUT( %options )                                          |
# |                                                               |
# | username => username                                          |
# | session  => session-id                                        |
# | config   => configuration object                              |
# |                                                               |
# | Purpose:  Log a user out of the session.  This method is      |
# |           called when the logout() session method is called.  |
# |           You probably want to indicate that the session is   |
# |           expired.  Note that if the method is called with    |
# |           $options{username} set then this is a login session,|
# |           otherwise it is an anonymous session.               |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub LOGOUT {
  my $self    = shift;
  my %options = @_;
}

# +---------------------------------------------------------------+
# | ->LOGIN( %options )                                           |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | password => password                                          |
# |                                                               |
# | Purpose:  Log in and start a login session.                   |
# |           called when the logout() session method is called.  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub LOGIN {
  my $self    = shift;
  my %options = @_;
}

sub clear {
  my $obj = shift;
  %{$obj} = ();
}

sub remove_user {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password ) = @_;

  if ( $self->{data}->{username} eq $username ) {
    $obj->logout();
  }

  my $rows = $self->REMOVE_USER( config   => $self->{config},
                                 username => $username,
                                 password => $password
                               );
}

sub register {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password, $firstname, $lastname, $email ) = @_;

  my $verbose = $self->{'verbose'};

  my $rows = $self->REGISTER( username  => $username,
                              config    => $self->{config},
                              password  => $password,
                              firstname => $firstname,
                              lastname  => $lastname,
                              email     => $email
                            );

  &log_message(
    undef,
"Registering user ($username, $password, $firstname, $lastname, $email): rows = [$rows]"
  ) if $verbose;
}

sub kill_session {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config, $session ) =
  @{$self}{qw(verbose ctx config session)};

  $self->{data} = {};

  unless ( $config->{'cookieless_sessions'} ) {

    # Delete the cookie
    $self->cookie( $self->{'name'},
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $self->send_cookie;
  }

  $self->KILL_SESSION( session => $session,
                       config  => $config );
}

sub login {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $username, $password ) = @_;

  my ($verbose) = @{$self}{qw(verbose)};
  &log_message( undef, "Attempting to log in user ($username, $password)" )
  if $verbose;

  my $aref = $self->LOGIN( username => $username,
                           password => $password,
                           config   => $self->{config}
                         );

  $self->init_session($aref);

  # Create a new session id for the user
  my $session = $self->newSessionID;

  # Delete the `new_session' flag
  delete $self->{'new_session'};

  # Save the merged prefs and the session id
  $self->STORE_LOGIN_SESSION(
    session => $session,
    data => { prefs => Bedrock::XML::writeXMLString( $self->{data}->{prefs} ) },
    expires  => $self->{'expires'},
    username => $username,
    config   => $self->{config}
  );
}

sub logout {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  $self->LOGOUT( config   => $config,
                 session  => $self->{session},
                 username => $self->{data}->{username}
               );

  # Reset data
  $self->{'data'} = {};

  unless ( $config->{'cookieless_sessions'} ) {

    # Delete the cookie
    $self->cookie( $self->{'name'},
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $self->send_cookie;
  }
}


sub change_passwd {
  my $obj  = shift;
  my $self = tied( %{$obj} );
  my ( $opasswd, $npasswd ) = @_;

  my $username = $self->{'data'}->{'username'};
  die "Cannot change password: user not logged in.\n" unless length($username);

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};
  my $t = $config->{'table_name'};

  &log_message(
    undef,
"Attempting to change password to `$npasswd' from `$opasswd' for `$username'"
  ) if $verbose;

  $self->UPDATE_LOGIN_PASSWORD( table    => $config->{table_name},
                                username => $username,
                                password => [ $npasswd, $opasswd ],
				session  => $self->{session}
                              );
}

sub remember_user {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  die "No user logged in to remember\n"
  unless length( $self->{'data'}->{'username'} );

  my $username = $self->{'data'}->{'username'};

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $login_cookie_name = $config->{'login_cookie_name'};
  my $login_id          = $ctx->getCookieValue($login_cookie_name);

  return length($login_id) ? 1 : 0 unless @_ > 0;

  if ( $_[0] =~ /on/i ) {
    $login_id = $self->newLoginCookie;
  }
  else {

    # Delete the login cookie
    $self->cookie( $login_cookie_name,
                   'value'   => 'killed',
                   'expires' => -864000
                 );
    $login_id = '';
    $self->send_cookie;
  }

  $self->UPDATE_LOGIN_SESSION( config   => $config,
                               username => $username,
                               login_id => $login_id
                             );
}

sub encrypt {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  return crypt( $_[0], $_[1] );
}

sub create_temp_login_session {
  my $obj = shift;
  my $self = tied( %{$obj} );

  my $username = shift;
  my $minutes = shift;

  my ($verbose) = @{$self}{qw(verbose)};
  &log_message( undef, "Attempting to create temporary log-ing session for user: $username" )
    if $verbose;

  # Create a new session id for the user
  my $session = $self->newSessionID;

  # Delete the `new_session' flag
  delete $self->{'new_session'};

  my $default_expiry = $self->{config}->{cookie}->{expiry_secs};
  $self->{config}->{cookie}->{expiry_secs} = $minutes || 900;

  $self->UPDATE_LOGIN_SESSION(
			      config   => $self->{config},
			      username => $username,
			      login_id => $session
			     );

  my $data = $self->FETCH_LOGIN_SESSION(
					config   => $self->{config},
					login_id => $session

				       );

  $self->init_session( $data );

#  $self->{data} = {};
#  $self->{data}->{'username'}  = $data->[0];
#  $self->{data}->{'firstname'} = $data->[1];
#  $self->{data}->{'lastname'}  = $data->[2];
#  $self->{data}->{'email'}     = $data->[3];
#  $self->{data}->{'prefs'}     = $data->[4];
#  $self->{data}->{'prefs'}     = $data->[4] ? Bedrock::XML->newFromString( $data->[4] ) : undef;

  $self->STORE_LOGIN_SESSION(
			     session  => $session,
			     expires  => $minutes,
			     data     => $data,
			     username => $username,
			     config   => $self->{config},
			    );

  $self->UPDATE_LOGIN_SESSION(
			      config   => $self->{config},
			      username => $username,
			      login_id => undef
			     );

  $obj->closeBLM;

  # new sesion
  $self->startSession($self->{config});
  $self->newSession;
  $self->{'data'}->{'prefs'}->{expiry_secs} = $default_expiry;

  $session;
}



sub create_session_dir {
  my $obj     = shift;
  my $sub_dir = shift;

  my $self = tied( %{$obj} );

  my $session_id = $self->{'session'};

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};
  my $session_dir = $ctx->{'CONFIG'}->{'SESSION_DIR'};

  die "No SESSION_DIR defined.\n"
  unless $session_dir;

  $session_dir .= "/$session_id";

  unless ( -d "$session_dir/$sub_dir" ) {
    &log_message( undef, "creating directory $session_dir/$sub_dir" )
    if $verbose;

    eval { mkpath("$session_dir/$sub_dir"); };

    &log_message( undef, "Unable to create $session_dir/$sub_dir\n$@\n" )
    if $@;

    die "Unable to create $session_dir/$sub_dir\n"
    if $@;
  }

  return "$session_dir/$sub_dir";
}

sub cleanup_session_dir {
  my $self = shift;

  my @args = 'session_cleaup_dir';

  if ( @_ > 0 ) {
    push @args, $_[0] ? 'yes' : 'no';
  }

  return $self->config(@args);
}

sub create_session_tempfile {
  my $obj      = shift;
  my $template = shift;
  my %options  = @_;

  my $self       = tied( %{$obj} );
  my $session_id = $self->{'session'};

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $session_dir = $ctx->{'CONFIG'}->{'SESSION_DIR'};

  die "No SESSION_DIR defined.\n"
  unless $session_dir;

  $session_dir .= "/$session_id";

  $obj->create_session_dir($session_dir)
  unless -d $session_dir;

  my %local_options;

  if ( $options{DIR} ) {
    $session_dir .= $options{DIR};
  }

  $local_options{DIR} = $session_dir;
  $local_options{SUFFIX} = $options{SUFFIX} if exists $options{SUFFIX};

  my ( $fh, $filename ) = tempfile( $template, %local_options );

  return Bedrock::Array->new( $fh, $filename );
}

sub config {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  if ( @_ > 1 ) {
    $config->{ $_[0] } = $_[1];
  }
  else {
    return $config->{ $_[0] };
  }
}

sub cookieless_session {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  # don't allow someone to access a stale session
  $self->SESSION_CLEANUP( config => $self->{config} );

  my $id = shift;
  $self->{'new_session'} = 0 if $id;
  $self->{'session'} = $id || $self->{'session'};
  $self->readData($id);

  $config->{'cookieless_sessions'} = 1;

# kill the cookie if cookies are enabled, since on instantiation,
# UserSession ($session) will create a cookie
  $self->cookie( $self->{'name'},
                 'value'   => 'killed',
                 'expires' => -864000
               );

  $self->send_cookie;
}

sub cookie {
  my $self = shift;
  my $name = shift;

  $self->{'cookies'} = {} unless $self->{'cookies'};
  $self->{'cookies'}->{$name} = {} unless $self->{'cookies'}->{$name};
  my $cref = $self->{'cookies'}->{$name};
  if ( ref( $_[0] ) ) {
    for my $param ( keys %{ $_[0] } ) {
      $cref->{$param} = $_[0]->{$param};
    }
  }
  else {
    my %args = @_;
    for my $param ( keys %args ) {
      $cref->{$param} = $args{$param};
    }
  }
}

sub digest {
  my $md5 = Digest::MD5->new;
  $md5->add(
        sprintf( "%012d:%20s:%08d:%.10f", time, $ENV{REMOTE_ADDR}, $$, rand ) );
  $md5->hexdigest;
}

sub send_cookie {
  my $self = shift;
  return unless $self->{'cookies'};

  my $config = $self->{'config'};
  my ( $cref, $header );

  for my $name ( keys %{ $self->{'cookies'} } ) {
    $cref   = $self->{'cookies'}->{$name};
    $header = $name . '=' . $cref->{'value'} . '; ';

    $header .= 'path='
    . ( $cref->{'path'} || $config->{'cookie'}->{'path'} || '/' ) . '; ';

    my $domain = $config->{'cookie'}->{'domain'};
    $header .= 'domain=' . $domain . '; ' if length($domain);

    if ( exists $cref->{'expires'} ) {
      my $expiry = POSIX::strftime( "%a, %d-%b-%Y %T GMT",
                                    gmtime( time + $cref->{'expires'} ) );
      $header .= 'expires=' . $expiry . '; ';
    }

    $self->{'ctx'}->cgi_header_out( 'Set-Cookie', $header );
    &log_message( undef, "Set cookie header: [Set-Cookie => $header]" )
    if $self->{'verbose'} > 1;
  }
}

sub startSession {
  my ( $self, $config ) = @_;

  $self->{'config'} = $config;

  die ref($self),
  "->startSession(): param `table_name' must be specified in config\n"
  unless $config->{table_name};

  $self->CONNECT( config => $config );
}

sub newLoginCookie {
  my $self = shift;

  my $config = $self->{'config'};
  my $ctx    = $self->{'ctx'};
  my $id     = &digest;

  unless ( $config->{'cookieless_sessions'} ) {

    # Set the cookie header
    $self->cookie(
            $config->{'login_cookie_name'},
            'value'   => $id,
            'expires' => ( $config->{'login_cookie_expiry_days'} || 30 ) * 86400
    );
    $self->send_cookie;
  }

  $id;
}

sub newSessionID {
  my $self = shift;

  my $config = $self->{'config'};
  my $ctx    = $self->{'ctx'};
  my $id     = $self->{'session'} = &digest;

  my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400;
  $self->{'expires'} = $secs;

  unless ( $config->{'cookieless_sessions'} ) {

    # Set the cookie header
    $self->cookie( $self->{'name'},
                   'value'   => $id,
                   'expires' => $secs
                 );
    $self->send_cookie;
  }

  $id;
}

sub newSession {
  my $self = shift;

  $self->newSessionID;
  $self->{'new_session'} = 1;
  $self->{'data'} = { 'prefs' => {} };
  $self->{'session'};
}

sub init_session {
  my $self = shift;
  my $aref = shift;

  my ($verbose) = @{$self}{qw(verbose)};

  if ($aref) {
    &log_message(
      undef,
"Initializing session\nusername = ($aref->[0])\nfirstname = ($aref->[1])\nlastname = ($aref->[2])\nemail = ($aref->[3])"
    ) if $verbose;
    &log_message( undef, "Session prefs are\n$aref->[-1]" ) if $verbose > 1;

    my $data = {};

    @{$data}{qw(username firstname lastname email)} =
    ( @{$aref}[ 0, 1, 2, 3 ] );

    $data->{'prefs'} = Bedrock::XML->newFromString( $aref->[-1] )
    if length( $aref->[-1] );
    $data->{'prefs'} = {} unless $data->{'prefs'};

    $self->{'data'} = $data;
  }
  else {
    &log_message( undef, "Initializing new session" ) if $verbose;
    $self->newSession;
  }
}

#
# `session' is stored under $self
# `username', `password', `firstname', `lastname', `email' if stored under $self->{'data'}
# `new_session' is set to 1 if no previous session info found for user
# Other than these are stored under $self->{'data'}->{'prefs'}
#
sub readData {
  my ( $self, $id ) = @_;

  my ( $config, $verbose ) = @{$self}{qw(config verbose)};

  &log_message( undef, "Reading data for session [$id]" ) if $verbose;
  my $aref = $self->FETCH_SESSION( config  => $config,
                                   session => $id );

  unless ($aref) {
    &log_message( undef, "Unable to read data for session [$id]" ) if $verbose;
    return;
  }

  my $secs = $config->{'cookie'}->{'expiry_secs'} || 86400;

  unless ( $config->{'cookieless_sessions'} ) {
    $self->cookie( $self->{'name'},
                   'value'   => $id,
                   'expires' => $secs
                 );
    $self->send_cookie;
  }

  $self->{'expires'} = $secs;

  $self->{'session'} = $id;

  $self->init_session($aref);

  $self->{'session'};
}

sub newLoginSession {
  my $self     = shift;
  my $login_id = shift;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $aref =
  $self->FETCH_LOGIN_SESSION( config => $config, login_id => $login_id );

  unless ($aref) {
    &log_message( undef, "Login session [$login_id] not found" ) if $verbose;
    return;
  }

  my $data = {};

  &log_message(
    undef,
"Found login session [$login_id]\nusername = ($aref->[0])\nfirstname = ($aref->[1])\nlastname = ($aref->[2])\nemail = ($aref->[3])"
  ) if $verbose;
  &log_message( undef,
            "Saved session info for login session [$login_id] is\n$aref->[-1]" )
  if $verbose > 1;

  @{$data}{qw(username firstname lastname email)} = ( @{$aref}[ 0, 1, 2, 3 ] );
  $data->{'prefs'} = Bedrock::XML->newFromString( $aref->[-1] )
  if length( $aref->[-1] );

  # Create new session id
  my $id = $self->newSessionID;

  my $rows = $self->STORE_LOGIN_SESSION( session  => $id,
                                         login_id => $login_id,
                                         expires  => $self->{expires},
                                         config   => $config
                                       );

  &log_message(
      undef,
      "Updating session = [$id] for login session [$login_id]: rows = [$rows]\n"
  ) if $verbose;

  $data->{'prefs'} = {} unless $data->{'prefs'};
  $self->{'data'} = $data;
  $self->{'session'};
}

sub TIEHASH {
  my ( $class, $ctx, $config ) = @_;

  # What is the name of the session variable being used?
  my $name = $config->{'param'};
  die "$class->TIEHASH(): `param' not set in config\n" unless $name;

  # Create session object
  my $self = bless {}, $class;
  $self->{'ctx'}    = $ctx;
  $self->{'name'}   = $name;
  $self->{'config'} = $config;

  my $verbose = $self->{'verbose'} = $config->{'verbose'};

  # Initialize session
  $self->startSession($config);

  # Check for an existing session
  my $id =
    $config->{'cookieless_sessions'}
  ? $ctx->getInputValue($name)
  : $ctx->getCookieValue($name);

  # Get the session data only if a session exists
  if ( defined($id) ) {
    &log_message( undef, "Read user's session: [$id]" ) if $verbose;
    my $session = $self->readData($id);
    &log_message( undef, "User has session [$session]" )
    if $session and $verbose;
    return $self if $session;
  }

  # No session cookie -- check to see if login cookie present
  my $login_cookie_name = $config->{'login_cookie_name'};
  my $login_id =
    $config->{'cookieless_sessions'}
  ? $ctx->getInputValue($login_cookie_name)
  : $ctx->getCookieValue($login_cookie_name);

  if ($login_id) {
    my $session = $self->newLoginSession($login_id);
    &log_message( undef,
                 "User has login session [$login_id] -- session is [$session]" )
    if $session and $verbose;
    return $self if $session;
  }

  # everything failed -- need to create a new session
  my $session = $self->newSession;
  &log_message(
     undef,
     "User does not have anonymous session or login session -- using [$session]"
  ) if $verbose;

  $self->{'data'}->{'prefs'}->{expiry_secs} =
  $self->{'config'}->{'cookie'}->{'expiry_secs'};

  # And return the session object
  $self;
}

sub FETCH {
  my ( $self, $key ) = @_;
  if ( $key eq 'session' ) { return $self->{$key} }
  elsif ( $key =~ /^(username|firstname|lastname|email|config)$/ ) {
    return $self->{'data'}->{$key};
  }
  elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) {
    $self->{'data'}->{'prefs'}->{$key};
  }
  else { return $self->{'config'}->{'default_prefs'}->{$key} }
}

# Just store the value in the session and return the value
sub STORE {
  my ( $self, $key, $value ) = @_;
  if ( $key =~ /^(session|username)$/ ) {
    die "Cannot set `$key': attribute is read-only.\n";
  }
  elsif ( $key eq 'password' ) {
    die "Cannot set `password': Use `change_password()' instead.\n";
  }
  elsif ( $key =~ /^(firstname|lastname|email)$/ ) {
    die
    "Cannot set `$key' -- no username: use `login()' or `register()' first.\n"
    unless $self->{'data'}->{'username'};
    die "Cannot store empty string in `$key'.\n"
    if $key =~ /^(firstname|lastname)$/ and length($value) == 0;
    &log_message( undef, "Storing [$key] = [$value]" ) if $self->{'verbose'};
    return $self->{'data'}->{$key} = $value;
  }
  else {
    &log_message( undef, "Stored [$key] = [$value] into prefs" )
    if $self->{'verbose'};
    return $self->{'data'}->{'prefs'}->{$key} = $value;
  }
}

# Invoked to loop over the properties of the session
sub FIRSTKEY {
  my $self = shift;

  delete $self->{'keys'};

  my $k = { 'session'   => $self->{'session'},
            'username'  => $self->{'data'}->{'username'},
            'firstname' => $self->{'data'}->{'firstname'},
            'lastname'  => $self->{'data'}->{'lastname'},
            'email'     => $self->{'data'}->{'email'}
          };

  my %keys;
  @keys{
    keys %{ $self->{'data'}->{'prefs'} },
    keys %{ $self->{'config'}->{'default_prefs'} }
  }
  = ();
  for my $key ( keys %keys ) {
    if ( exists $self->{'data'}->{'prefs'}->{$key} ) {
      $k->{$key} = $self->{'data'}->{'prefs'}->{$key};
    }
    else {
      $k->{$key} = $self->{'config'}->{'default_prefs'}->{$key};
    }
  }
  $self->{'keys'} = $k;
  each %{ $self->{'keys'} };
}

sub NEXTKEY {
  each %{ shift->{'keys'} };
}

sub EXISTS {
  my ( $self, $key ) = @_;
  if ( $key eq 'session' ) { return 1 }
  elsif ( $key =~ /^(username|password|firstname|lastname|email)$/ ) {
    return exists $self->{'data'}->{$key};
  }
  elsif ( exists $self->{'data'}->{'prefs'}->{$key} ) { return 1 }
  else { exists $self->{'config'}->{'default_prefs'}->{$key} }
}

sub DELETE {
  my ( $self, $key ) = @_;
  if ( $key =~ /^(session|username|firstname|lastname|email|password)$/ ) {
    die "Cannot delete `$key': illegal operation.\n";
  }
  else {
    return delete $self->{'data'}->{'prefs'}->{$key};
  }
}

sub CLEAR {
  my $self = shift;
  %{ $self->{'data'}->{'prefs'} } = ();
}

sub closeBLM {
  my $obj  = shift;
  my $self = tied( %{$obj} );

  my ( $verbose, $session ) = @{$self}{qw(verbose session)};

  my $prefs = $self->{data}->{prefs};

  # this is a very implementation specific session rule that says, if
  # there is no session, then if there is a 'default_prefs' set in the
  # session configuration, then map that to the session data...
  $prefs = $self->{config}->{default_prefs} if keys %{$prefs} == 0;

  my $xml = Bedrock::XML::writeXMLString($prefs);
  &log_message( undef, "Saving session [" . $session . "] data\n$xml" )
  if $verbose > 1;
  my $data = $self->{data};
  $data->{prefs} = $xml;

  $self->STORE_SESSION( verbose => $verbose,
                        session => $session,
                        data    => $data,
                        expires => $self->{expires},
                        new     => $self->{new_session},
                        config  => $self->{config}
                      );

  my $nrows = $self->SESSION_CLEANUP( config => $self->{config} );
  &log_message( undef, sprintf( "Cleaned up %s rows", $nrows ) )
  if $verbose;

  $self->DISCONNECT( config => $self->{config} );
}

1;

# $Log$
# Revision 1.10  2011/11/23 19:24:15  eutl420
# - the change_passwd method was not sending 'session' to the UPDATE_LOGIN_PASSWORD() method
# - create_temp_login_session() is a new method that creates a temporary session for a user
#   so they can change their password
# - before using a cookieless_session() we want to make sure that expired sessions are cleaned up
#
# Revision 1.9  2011/09/15 16:05:32  eutl420
# - perl tidy
#
# Revision 1.8  2011/09/09 17:51:13  eutl420
# - implemented several new methods to support the notion of specific session directories.  Since apps have been using the
#   SESSION_DIR by adding per session directories, these need to be removed when sessions expire.
#   * create_session_dir() - allows apps to create session directories
#   * cleanup_session_dir() - sets a flag that indicates that session directories should be cleaned up
#   * create_session_tempfile() - creates a temporary file in the current session directory
#
# Revision 1.7  2011/08/10 21:44:13  eutl420
# pod tweaks
#
# Revision 1.6  2011/07/17 16:50:32  eutl420
# @PERL@, log_message if verbose
#
# Revision 1.5  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.4  2011/07/08 12:24:37  eutl420
# - corrected documentation for UPDATE_LOGIN_PASSWORD to require session
#
# Revision 1.3  2011/01/13 14:19:28  eutl420
# - in closeBLM, log # of rows cleaned up
# - in newSessionID, set the expires date for cookieless sessions from the value in the cookie config section
#
# Revision 1.2  2010/12/17 16:29:42  eutl420
# -add KILL_SESSION, kill_session()
#
# Revision 1.1  2010/12/12 16:35:59  eutl420
# - MySQLSession.pm, PostgreSQLSession.pm, SQLSession.pm and SessionManager.pm are
#   part of a rework of the Bedrock sessions designed to create a framework for
#   adding session implmentations in a painless manner.  Two reference implementations
#   of sessions based on SQL databases are provided.
#
