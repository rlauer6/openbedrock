#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2024, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::SessionManager;

use strict;
use warnings;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

use Bedrock qw(:booleans);
use Bedrock::Array;
use Bedrock::Constants qw(:all);
use Bedrock::XML;
use Carp;
use Data::Dumper;
use Digest::MD5;
use English qw(-no_match_vars);
use Exporter;
use File::Basename;
use File::Copy;
use File::Path;
use File::Temp qw(tempfile);
use IO::Handle;
use JSON;
use List::Util qw(none any);
use Log::Log4perl::Level;
use POSIX qw(strftime);
use Scalar::Util qw(blessed);

use Role::Tiny::With;
with 'Bedrock::Logger';
with 'Bedrock::CSRF';

use parent qw( Bedrock::Hash );

# +---------------------------------------------------------------+
# | Implement the functions below to create a session manager.    |
# | For examples see:                                             |
# |                                                               |
# |  BLM::Startup::MySQLSession                                   |
# |  BLM::Startup::PostgreSQLSession                              |
# |  BLM::Startup::SQLiteSession                                  |
# |                                                               |
# +---------------------------------------------------------------+

# +---------------------------------------------------------------+
# | ->CONNECT( %options )                                         |
# |                                                               |
# | config      => config object from tagx.xml                    |
# |                                                               |
# | Purpose: perform any database connection ritual required.     |
# |          This method will be called when the session object   |
# |          is instantiated.                                     |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub CONNECT {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->DISCONNECT( %options )                                      |
# |                                                               |
# | config => configuration object                                |
# |                                                               |
# | Purpose: perform any database disconnect ritual required.     |
# |          This function will be called from the DESTROY        |
# |          method of the session object.                        |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub DISCONNECT {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->FETCH_LOGIN_SESSION( %options )                             |
# |                                                               |
# | login_id => login-id                                          |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: read row from the session table based on a login     |
# |          identifier (usually a cookie value)                  |
# | Returns: reference to session data                            |
# +---------------------------------------------------------------+
sub FETCH_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->STORE_LOGIN_SESSION( %options )                             |
# |                                                               |
# | session  => session-id                                        |
# | login_id => login-id                                          |
# | expires  => expiry-time                                       |
# | username => username                                          |
# | data     => ref(session-data)                                 |
# | config   => configuration object                              |
# |                                                               |
# | Purpose: This function should be prepared to update the       |
# |          session table based on username or login_id          |
# |          depending on which one is passed.  You should        |
# |          update the expiration time of the session data.      |
# |          You are also responsible for storing the data        |
# |          which is passed as a reference to a hash object      |
# |                                                               |
# |            $options{data}->{prefs}                            |
# |                                                               |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub STORE_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_SESSION( %options )                            |
# |                                                               |
# | username => username                                          |
# | config   => configuration object                              |
# | login_id => login-id                                          |
# |                                                               |
# | Purpose: This function gives the implementation the login-id  |
# |          associated with this session.  You should probably   |
# |          save this to the session in the 'login_cookie'       |
# |          column. This column is then used to identify this    |
# |          user's session.                                      |
# | Returns: 1 if successfully updated session data               |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->FETCH_SESSION( %options )                                   |
# |                                                               |
# | config   => configuration object                              |
# | session  => username                                          |
# |                                                               |
# | Purpose: This function retrieves the session data based on a  |
# |          session identifier.                                  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub FETCH_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->SESSION_CLEANUP( %options )                                 |
# |                                                               |
# | config   => configuration object                              |
# | session  => session-id                                        |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to clean up stale sessions.                          |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub SESSION_CLEANUP {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->STORE_SESSION( %options )                                   |
# |                                                               |
# | session => session-id                                         |
# | new     => 1 indicates that the session is new                |
# | expires => expiry-time                                        |
# | data    => ref(session-data)                                  |
# | config  => configuration object                               |
# | verbose => 0/1                                                |
# |                                                               |
# | Purpose: This function is called prior to destruction of the  |
# |          session object to give the implementation a chance   |
# |          to save the session data.                            |
# | Returns: none                                                 |
# +---------------------------------------------------------------+
sub STORE_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->REGISTER( %options )                                        |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# | firstname => first name                                       |
# | lastname  => last name                                        |
# | email     => email address                                    |
# |                                                               |
# | Purpose:  Register a new user.  Usually involves writing the  |
# |           user's information to a database so they can login  |
# |           later.                                              |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub REGISTER {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->REMOVE_USER( %options )                                     |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => password                                         |
# |                                                               |
# | Purpose:  Remove a user from system.                          |
# | Returns: 1 if successfully removed user                       |
# +---------------------------------------------------------------+
sub REMOVE_USER {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->UPDATE_LOGIN_PASSWORD( %options )                           |
# |                                                               |
# | config    => configuration object                             |
# | username  => username                                         |
# | password  => [new-password, old-password                      |
# |                                                               |
# | Purpose:  Change a user's password. Note that                 |
# |           $options{password} is an array reference where      |
# |           element 0 is the new password and element 1 is the  |
# |           old password.                                       |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub UPDATE_LOGIN_PASSWORD {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->KILL_SESSION( %options )                                    |
# |                                                               |
# | session => session-id                                         |
# | config  => configuration object                               |
# |                                                               |
# | Purpose: delete a session from table                          |
# | Returns: 1 if delete is successful                            |
# +---------------------------------------------------------------+
sub KILL_SESSION {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->LOGOUT( %options )                                          |
# |                                                               |
# | username => username                                          |
# | session  => session-id                                        |
# | config   => configuration object                              |
# |                                                               |
# | Purpose:  Log a user out of the session.  This method is      |
# |           called when the logout() session method is called.  |
# |           You probably want to indicate that the session is   |
# |           expired.  Note that if the method is called with    |
# |           $options{username} set then this is a login session,|
# |           otherwise it is an anonymous session.               |
# | Returns: 1 if successfully added user                         |
# +---------------------------------------------------------------+
sub LOGOUT {
  my ( $self, %options ) = @_;

  return;
}

# +---------------------------------------------------------------+
# | ->LOGIN( %options )                                           |
# |                                                               |
# | config   => configuration object                              |
# | username => username                                          |
# | password => password                                          |
# |                                                               |
# | Purpose:  Log in and start a login session.                   |
# |           called when the logout() session method is called.  |
# | Returns: reference to session data if successful              |
# +---------------------------------------------------------------+
sub LOGIN {
  my ( $self, %options ) = @_;

  return;
}

########################################################################
sub clear {
########################################################################
  my ( $self, %options ) = @_;

  return;
}

########################################################################
sub remove_user {
########################################################################
  my ( $obj, @args ) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $username, $password ) = @args;

  die "usage: remove_user(username, password)\n"
    if !$username || !$password;

  my $logged_in_user = $self->{data}->{username};

  if ( $logged_in_user && $logged_in_user eq $username ) {
    $obj->logout();
  }

  my $rows = $self->REMOVE_USER(
    config   => $self->{config},
    username => $username,
    password => $password,
  );

  return $rows;
}

########################################################################
sub lookup_user {
########################################################################
  my ( $obj, $username, $return_ref ) = @_;

  my $self = tied %{$obj} || $obj;

  my $rows = $self->do_select_ref( 'LOOKUP_USER', 'username', $username );

  return $return_ref ? $rows->[0] : $rows->[0]->{username};
}

########################################################################
sub lookup_users {
########################################################################
  my ( $obj, $username ) = @_;

  my $self = tied %{$obj} || $obj;

  return $self->do_select_set('LOOKUP_USERS');
}

########################################################################
sub register { ## no critic (ProhibitManyArgs)
########################################################################
  my ( $obj, $username, $password, $firstname, $lastname, $email ) = @_;

  my $self = tied %{$obj} || $obj;

  my $verbose = $self->{verbose};

  die 'user already exists'
    if $self->lookup_user($username);

  my $rows = $self->REGISTER(
    username  => $username,
    config    => $self->{config},
    password  => $password,
    firstname => $firstname,
    lastname  => $lastname,
    email     => $email
  );

  $self->get_logger->debug(
    sprintf 'Registering user (%s, %s, %s, %s)',
    map { defined $_ // q{} } $username,
    $firstname, $lastname, $email
  );

  return $rows;
}

########################################################################
sub kill_session {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $verbose, $ctx, $config, $session )
    = @{$self}{qw(verbose ctx config session)};

  $self->{data} = {};

  if ( !$config->{cookieless_sessions} ) {

    # Delete the cookie
    $self->cookie(
      $self->{name},
      'value'   => 'killed',
      'expires' => -$SECONDS_IN_A_DAY,
    );
    $self->send_cookie;
  }

  return $self->KILL_SESSION(
    session => $session,
    config  => $config,
  );
}

########################################################################
sub login {
########################################################################
  my ( $obj, $username, $password ) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  $self->get_logger->debug( sprintf 'Attempting to log in user [%s]', $username );

  my $aref = $self->LOGIN(
    username => $username,
    password => $password,
    config   => $self->{config},
  );

  # cleanup session directory if one exists...this would be an older session
  if ( $aref->[5] && $self->cleanup_login_sessions ) {
    my $session_dir = sprintf '%s/%s', $self->session_root, $aref->[5];

    if ( -d $session_dir ) {
      rmtree $session_dir;
    }
  }

  $self->init_session($aref);

  # Create a new session id for the user
  my $session = $self->newSessionID;

  # Delete the `new_session' flag
  delete $self->{new_session};

  # Save the merged prefs and the session id
  my $prefs = Bedrock::XML::writeXMLString( $self->{data}->{prefs} );

  return $self->STORE_LOGIN_SESSION(
    session  => $session,
    data     => { prefs => $prefs },
    expires  => $self->{expires},
    username => $username,
    config   => $self->{config},
  );
}

########################################################################
sub logout {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  $self->LOGOUT(
    config   => $config,
    session  => $self->{session},
    username => $self->{data}->{username},
  );

  # Reset data
  $self->{data} = {};

  if ( !$config->{cookieless_sessions} ) {

    # Delete the cookie
    $self->cookie(
      $self->{name},
      'value'   => 'killed',
      'expires' => -$SECONDS_IN_A_DAY,
    );

    $self->send_cookie;
  }

  # do not return $self <null $session.logout()> will store $self as
  # the default variable $_.  Bedrock will attempt to destroy $session
  # & $_ and end up calling closeBLM twice.
  return;
}

########################################################################
sub change_passwd {
########################################################################
  my ( $obj, $old_password, $new_password ) = @_;

  my $self = tied %{$obj} || $obj;

  my $username = $self->{data}->{username};

  die "Cannot change password: user not logged in.\n"
    if !$username;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};
  my $t = $config->{table_name};

  $self->get_logger->debug( sprintf 'Attempting to change password for user: [%s]', $username );

  if ($old_password) {
    $self->LOGIN(
      username => $username,
      password => $old_password,
    );
  }

  return $self->UPDATE_LOGIN_PASSWORD(
    table    => $config->{table_name},
    username => $username,
    password => [ $new_password, $old_password ],
    session  => $self->{session},
  );
}

########################################################################
sub remember_user {
########################################################################
  my ( $obj, @args ) = @_;

  my $self = tied %{$obj} || $obj;

  my $username = $self->{data}->{username};

  die "No user logged in to remember\n"
    if !$username;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $login_cookie_name = $config->{login_cookie_name};

  my $login_id = $ctx->getCookieValue($login_cookie_name);

  if ( !@args ) {
    return length $login_id ? $TRUE : $FALSE;
  }

  if ( $args[0] =~ /on/ixsm ) {
    $login_id = $self->newLoginCookie;
  }
  else {

    # Delete the login cookie
    $self->cookie(
      $login_cookie_name,
      value   => 'killed',
      expires => -$SECONDS_IN_A_DAY,
    );

    $login_id = $EMPTY;
    $self->send_cookie;
  }

  return $self->UPDATE_LOGIN_SESSION(
    config   => $config,
    username => $username,
    login_id => $login_id,
  );
}

########################################################################
sub encrypt {
########################################################################
  my ( $obj, $str, $seed ) = @_;

  my $self = tied %{$obj} || $obj;

  $seed //= substr $str, 0, 2;

  my $encrypted_str = crypt $str, $seed;

  return $encrypted_str;
}

########################################################################
sub create_temp_login_session {
########################################################################
  my ( $obj, $username, $session_timeout, $recycle ) = @_;

  my $self = tied %{$obj} || $obj;

  $session_timeout //= '15m';

  # calculate expiry in seconds
  my $seconds;

  if ( $session_timeout =~ /^(\d+)([smdh])?$/xsmi ) {
    $session_timeout = $1;

    my $unit = lc( $2 || 'm' );

    $seconds = {
      d => 24 * 60 * 60,
      h => 60 * 60,
      m => 60,
      s => 1,
    }->{$unit};

    $seconds //= 1;
    $seconds *= $session_timeout;
  }
  else {
    die "invalid expiry time\n";
  }

  $self->get_logger->debug("Attempting to create temporary log-in session for user: $username");

  my $default_expiry = $seconds || $self->{config}->{cookie}->{expiry_secs};
  $self->{config}->{cookie}->{expiry_secs} = $default_expiry;

  # Create a new session id for the user
  my $session;

  # Delete the 'new_session' flag
  delete $self->{new_session};

  my $data;

  if ($recycle) {
    # do we have an active session for this user? If so, then use this token
    $session = eval {
      $data = $self->FETCH_LOGIN_SESSION_BY_USERNAME(
        config   => $self->{config},
        username => $username,
      );
      return $data->[5];
    };
  }

  if ( !$session || $EVAL_ERROR ) {
    $session = $self->newSessionID;

    $self->UPDATE_LOGIN_SESSION(
      config   => $self->{config},
      username => $username,
      login_id => $session,
    );

    $data = $self->FETCH_LOGIN_SESSION(
      config   => $self->{config},
      login_id => $session,
    );
  }

  $self->init_session($data);

  # this resets the expiry time
  $self->STORE_LOGIN_SESSION(
    session  => $session,
    expires  => $seconds,
    data     => $data,
    username => $username,
    config   => $self->{config}
  );

  # logs out the user...
  $self->UPDATE_LOGIN_SESSION(
    config   => $self->{config},
    username => $username,
    login_id => q{},
  );

  $obj->closeBLM;

  # new session
  $self->startSession( $self->{config} );
  $self->newSession;
  $self->{data}->{prefs}->{expiry_secs} = $default_expiry;

  return $session;
}

########################################################################
sub context {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj} || $obj;

  return $self->{ctx};
}

########################################################################
sub session_root {
########################################################################
  my ($obj) = @_;

  return $obj->context->{CONFIG}->{SESSION_DIR};
}

########################################################################
sub create_session_directory { goto &create_session_dir; }
########################################################################
sub create_session_dir {
########################################################################
  my ( $obj, $sub_dir ) = @_;

  my $self = tied %{$obj} || $obj;

  $sub_dir //= $EMPTY;

  my $session_id = $self->{session};

  my $session_dir = $self->session_root;

  die "No SESSION_DIR defined in your configuration.\n"
    if !$session_dir;

  die "no such directory ($session_dir)\n"
    if !-d $session_dir;

  $session_dir = sprintf '%s/%s/%s', $session_dir, $session_id, $sub_dir;

  if ( !-d $session_dir ) {

    $self->get_logger->debug("creating directory $session_dir");

    my ($created_dir) = eval { return mkpath($session_dir); };

    if ( !$created_dir || $EVAL_ERROR || !-d $session_dir ) {
      $self->get_logger->error(
        sub {
          return "Unable to create $session_dir\n" . "$EVAL_ERROR\n" . "$OS_ERROR";
        }
      );

      die "Unable to create $session_dir\n";
    }

  }
  else {
    $self->get_logger->debug('session directory already exists');
  }

  return $session_dir;
}

########################################################################
sub cleanup_session_dir {
########################################################################
  my ( $self, $cleanup ) = @_;

  if ( defined $cleanup ) {
    $self->config( cleanup_session_dir => $cleanup );
  }

  $cleanup = $self->config('cleanup_session_dir') // $EMPTY;

  return $cleanup =~ /y/ixsm;
}

########################################################################
sub cleanup_login_sessions {
########################################################################
  my ( $self, $cleanup ) = @_;

  if ( defined $cleanup ) {
    $self->config( cleanup_login_sessions => $cleanup );
  }

  $cleanup = $self->config('cleanup_login_sessions') // $EMPTY;

  return $cleanup =~ /y/ixsm;
}

########################################################################
sub create_session_file {
########################################################################
  my ( $self, $filename, $content, $ttl ) = @_;

  my $session_dir = $self->create_session_dir;

  die "could not create session directory\n"
    if !$self->create_session_dir;

  my $path = sprintf '%s%s', $session_dir, $filename;

  if ( is_hash($content) || is_array($content) ) {
    $content
      = is_hash($content)
      ? Bedrock::Hash->new( %{$content} )
      : Bedrock::Array->new( @{$content} );

    $content = JSON->new->encode( $content->devolve );
  }

  open my $fh, '>', $path
    or die "could not open $path for writing\n";

  print {$fh} $content;

  close $fh;

  if ($ttl) {
    $self->set_session_file_ttl( $path, $ttl );
  }

  return $path;
}

########################################################################
sub get_session_dir {
########################################################################
  my ( $obj, $verify ) = @_;

  $verify //= $TRUE;

  my $self = tied %{$obj} || $obj;

  my $session_id = $self->{session};

  my $session_dir = $self->session_root;

  die "No SESSION_DIR defined in your configuration.\n"
    if !$session_dir;

  die "$session_dir does not exist\n"
    if !-d $session_dir;

  $session_dir = sprintf '%s/%s', $session_dir, $session_id;

  die "$session_dir does not exist\n"
    if $verify && !-d $session_dir;

  return $session_dir;
}

########################################################################
sub delete_session_file {
########################################################################
  my ( $obj, $name ) = @_;

  my $session_dir = $obj->get_session_dir;

  my $fqp_name = "$session_dir/$name";

  return
    if !-e $fqp_name;

  return unlink $fqp_name;
}

########################################################################
sub rename_session_file {
########################################################################
  my ( $obj, $old_name, $new_name ) = @_;

  my $session_dir = $obj->get_session_dir;

  my $old_fqp_name = "$session_dir/$old_name";

  die "$old_name does not exist\n"
    if !-e $old_fqp_name;

  rename $old_fqp_name, "$session_dir/$new_name";

  return $new_name;
}

########################################################################
sub set_session_file_ttl {
########################################################################
  my ( $self, $filename, $ttl ) = @_;

  return
    if !$ttl;

  my $cache = $self->{cache} // {};

  $cache->{$filename} = { ttl => $ttl, created => time };

  $self->{cache} = $cache;

  return $cache;
}

########################################################################
sub create_session_tempfile {
########################################################################
  my ( $self, $template, %options ) = @_;

  my $name = delete $options{NAME};

  my $suffix = delete $options{SUFFIX};

  my $dir = $self->create_session_dir( $options{dir} );

  if ($name) {
    $template = 'tempXXXXX';
  }

  my ( $fh, $filename ) = tempfile(
    $template,
    DIR => $dir,
    $name ? () : ( SUFFIX => $suffix // '.html' ),
  );

  if ($name) {
    rename "$dir/$filename", "$dir/$name";
  }

  return Bedrock::Array( $fh, $name || $filename );
}

########################################################################
sub version {
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj} || $obj;

  my $aref = $self->VERSION();

  return $aref->[0];
}

########################################################################
sub copy2session {
########################################################################
  my ( $obj, $file, $ttl ) = @_;

  my $self = tied %{$obj} || $obj;

  die "usage: copy2session(file)\n"
    if !$file;

  my ( $name, $path, $ext ) = fileparse( $file, qr/[.][^.]*$/xsm );

  if ( $path eq q{./} ) {
    $file = sprintf '%s/%s', $ENV{DOCUMENT_ROOT}, $file;
  }

  my $dest = sprintf '%s/%s%s', $obj->create_session_dir, $name, $ext;

  $self->get_logger->debug( sprintf 'copying %s to %s', $file, $dest );

  die "file not found file \n"
    if !-e $file;

  die "insufficient privileges to read $file\n"
    if !-r $file;

  if ( -s $file ) {
    die "could not copy file [$file] to [$dest]\n"
      if !copy( $file, $dest );
  }
  else {
    die "file $file is empty\n";
  }

  if ($ttl) {
    $self->set_session_file_ttl( $dest, $ttl );
  }

  return $dest;
}

########################################################################
sub config {
########################################################################
  my ( $obj, @args ) = @_;

  my $self = tied %{$obj} || $obj;

  my $config = $self->{config};

  return $config
    if !@args;

  if ( @args > 1 ) {
    $config->{ $args[0] } = $args[1];
  }

  return $config->{ $args[0] };
}

########################################################################
sub cookieless_session {
########################################################################
  my ( $obj, $id, $do_not_kill_cookie ) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  # don't allow someone to access a stale session...iow...if the
  # session identifier being passed is associated with a stale
  # session, the call below will remove that identifier.
  $self->SESSION_CLEANUP( config => $self->{config} );

  if ($id) {
    $self->{new_session} = $FALSE;
  }

  $self->{session} = $id || $self->{session};
  $self->read_data($id);

  $config->{cookieless_sessions} = !$do_not_kill_cookie;

  # kill the cookie if cookies are enabled, since on instantiation,
  # UserSession ($session) will create a cookie.

  # You might want to set the do-not-kill-cookie flag if you are
  # injecting a session id using the cookieless_session() method.
  #
  #  <null $session.cookieless_session( $input.session, 1 )>
  #
  #  This would then permanently log your user in for example, or allow
  #  you to inject a pre-fabricated session environment for the user
  #  that is now persistent without now having to carry around the
  #  session variable...in otherwords 'cookieless_session' becomes a
  #  misnomer, since you'll now have a session cookie, but with the
  #  session you built.
  #

  $self->cookie(
    $self->{name},
    'value'   => $do_not_kill_cookie ? $id              : 'killed',
    'expires' => $do_not_kill_cookie ? $self->{expires} : -$SECONDS_IN_A_DAY,
  );

  return $self->send_cookie;
}

########################################################################
sub resend_cookie {
########################################################################
  my ( $obj, $cookie ) = @_;

  my $self = tied %{$obj} || $obj;

  return $self->send_cookie($cookie);
}

########################################################################
sub cookie {
########################################################################
  my ( $self, $name, @args ) = @_;

  $self->{cookies} //= {};
  $self->{cookies}->{$name} //= {};

  my $cookies = $self->{cookies}->{$name};

  my %more_cookies = ref $args[0] ? %{ $args[0] } : @args;

  for my $cookie_name ( keys %more_cookies ) {
    $cookies->{$cookie_name} = $more_cookies{$cookie_name};
  }

  return $cookies;
}

########################################################################
sub digest {
########################################################################
  my $md5 = Digest::MD5->new;

  my $remote_address = $ENV{REMOTE_ADDR} // $EMPTY;

  my @args = ( time, $remote_address, $PID, rand );

  my $str_to_hash = sprintf '%012d:%20s:%08d:%.10f', @args;

  $md5->add($str_to_hash);

  return $md5->hexdigest;
}

########################################################################
sub send_cookie {
########################################################################
  my ( $self, $expires_in ) = @_;

  return
    if !$self->{cookies};

  my $cookie_config = $self->{config}->{cookie};

  my @cookie_jar = $self->bake_cookies($expires_in);

  foreach my $cookie (@cookie_jar) {
    $self->{ctx}->headers_out( 'Set-Cookie' => $cookie );
    $self->get_logger->trace( sub { sprintf 'Set cookie header: [Set-Cookie => %s]', $cookie } );
  }

  return \@cookie_jar;
}

########################################################################
sub bake_cookies {
########################################################################
  my ( $obj, $expires_in ) = @_;

  my $self = tied %{$obj} || $obj;

  my $cookie_config = $self->{config}->{cookie};

  my ( $default_cookie_path, $cookie_domain ) = @{$cookie_config}{qw(path domain)};

  $default_cookie_path //= $EMPTY;
  $cookie_domain       //= $EMPTY;

  my @cookie_jar;

  for my $name ( keys %{ $self->{cookies} } ) {
    my $cookie = $self->{cookies}->{$name};

    my $cookie_expires = $expires_in     || $cookie->{expires};
    my $path           = $cookie->{path} || $default_cookie_path;
    my $value          = $cookie->{value};

    my $cookie_value = sprintf '%s=%s; path=%s;', $name, $value, $path;

    if ( length $cookie_domain ) {
      $cookie_value .= sprintf ' domain=%s;', $cookie_domain;
    }

    if ($cookie_expires) {
      $cookie_value .= sprintf ' expires=%s;', create_expiration_time($cookie_expires);
    }

    push @cookie_jar, $cookie_value;
  }

  return @cookie_jar;
}

########################################################################
sub create_expiration_time {
########################################################################
  my ($expires) = @_;

  return POSIX::strftime( '%a, %d-%b-%Y %T GMT', gmtime( time + $expires ) );
}

########################################################################
sub startSession { ## no critic (Capitalization)
########################################################################
  my ( $self, $config ) = @_;

  $self->{config} = $config;

  die ref $self, "->startSession(): param `table_name' must be specified in config\n"
    if !$config->{table_name};

  $self->CONNECT( config => $config );

  return $self->SESSION_CLEANUP( config => $config );
}

########################################################################
sub newLoginCookie { ## no critic (Capitalization)
########################################################################
  my ($self) = @_;

  my $config = $self->{config};

  my $ctx = $self->{ctx};
  my $id  = digest();

  if ( !$config->{cookieless_sessions} ) {
    my $expiration_days = $config->{login_cookie_expiry_days} || 30;

    # Set the cookie header
    $self->cookie(
      $config->{login_cookie_name},
      'value'   => $id,
      'expires' => $expiration_days * $SECONDS_IN_A_DAY,
    );

    $self->send_cookie;
  }

  return $id;
}

########################################################################
sub newSessionID { ## no critic (Capitalization)
########################################################################
  my ($self) = @_;

  my $config = $self->{config};
  my $ctx    = $self->{ctx};
  my $id     = $self->{session} = digest();

  my $seconds = $config->{cookie}->{expiry_secs} || $SECONDS_IN_A_DAY;
  $self->{expires} = $seconds;

  if ( !$config->{cookieless_sessions} ) {

    # Set the cookie header
    $self->cookie(
      $self->{name},
      'value'   => $id,
      'expires' => $seconds,
    );

    $self->send_cookie;
  }

  return $id;
}

########################################################################
sub newSession { ## no critic (Capitalization)
########################################################################
  my ($self) = @_;

  $self->newSessionID;

  $self->{new_session} = $TRUE;

  $self->{data} = { 'prefs' => {} };
  return $self->{session};
}

########################################################################
sub init_session {
########################################################################
  my ( $self, $aref ) = @_;

  if ($aref) {
    my ( $username, $firstname, $lastname, $email, $prefs )
      = map { defined $_ ? $_ : $EMPTY } @{$aref};

    $self->get_logger->trace(
      sub {
        my $message = <<'END_OF_MESSAGE';
---------------------
Initializing session:
---------------------
  username  => [%s]
  firstname => [%s]
  lastname  => [%s]
  email     => [%s]
--------------------
END_OF_MESSAGE
        return sprintf $message, $username, $firstname, $lastname, $email;
      }
    );

    $self->get_logger->trace( sub { return sprintf 'prefs => [%s]', $prefs // $EMPTY } );

    my $data = {};

    @{$data}{qw(username firstname lastname email)} = @{$aref};

    if ( length $prefs ) {
      $data->{prefs} = Bedrock::XML->newFromString($prefs);
    }

    $data->{prefs} //= {};

    $self->{data} = $data;
  }
  else {
    $self->get_logger->trace('initializing new session');

    $self->newSession;
  }

  return $self;
}

#
# `session' is stored under $self
# `username', `password', `firstname', `lastname', `email' if stored under $self->{data}
# `new_session' is set to 1 if no previous session info found for user
# Other than these are stored under $self->{data}->{prefs}
#
########################################################################
sub read_data { ## no critic (Capitalization)
########################################################################
  my ( $self, $id ) = @_;

  my ( $config, $verbose ) = @{$self}{qw(config verbose)};

  $self->get_logger->debug("Reading data for session: [$id]");

  my $aref = $self->FETCH_SESSION(
    config  => $config,
    session => $id,
  );

  if ( !$aref ) {
    $self->get_logger->debug("No data yet for session: [$id]");
    return;
  }

  my $secs = $config->{cookie}->{expiry_secs} || $SECONDS_IN_A_DAY;

  if ( !$config->{cookieless_sessions} ) {
    $self->cookie(
      $self->{name},
      value   => $id,
      expires => $secs,
    );

    $self->send_cookie;
  }

  @{$self}{qw(expires session)} = ( $secs, $id );

  $self->init_session($aref);

  return $self->{session};
}

########################################################################
sub newLoginSession { ## no critic (Capitalization)
########################################################################
  my ( $self, $login_id ) = @_;

  my ( $verbose, $ctx, $config ) = @{$self}{qw(verbose ctx config)};

  my $session_ref = $self->FETCH_LOGIN_SESSION(
    config   => $config,
    login_id => $login_id
  );

  if ( !$session_ref ) {
    $self->get_logger->error("Login session [$login_id] not found");
    return;
  }

  my @session_params = @{$session_ref};

  my $data = {};

  $self->get_logger->trace(
    sub {
      my $message = <<'EOT';
Found login session [%s]
 username: (%s)
firstname: (%s)
 lastname: (%s)
    email: (%s)
    prefs: (%s)
EOT
      return sprintf $message, $login_id, @session_params;
    }
  );

  @{$data}{qw(username firstname lastname email prefs)}
    = (@session_params);

  my $prefs = $data->{prefs};

  $self->get_logger->trace(
    sub {
      return sprintf 'Saved session info for login session [%s] is %s', $login_id, $prefs;
    }
  );

  if ( length $prefs ) {
    $data->{prefs} = Bedrock::XML->newFromString($prefs);
  }

  # Create new session id
  my $id = $self->newSessionID;

  my $rows = $self->STORE_LOGIN_SESSION(
    session  => $id,
    login_id => $login_id,
    expires  => $self->{expires},
    config   => $config,
  );

  $self->get_logger->trace(
    sub {
      "Updating session = [$id] for login session [$login_id]: rows = [$rows]\n";
    }
  );

  if ( !$data->{prefs} ) {
    $data->{prefs} = {};
  }

  $self->{data} = $data;

  return $self->{session};
}

########################################################################
sub set_log_level {
########################################################################
  my ( $self, $level ) = @_;

  $level //= 'info';

  $level = lc $level;

  if ( none { $level eq $_ } qw(0 1 2 3 4 error warn info debug trace) ) {
    $level = 'info';
  }

  my %levels = (
    error => 0,
    warn  => 1,
    info  => 2,
    debug => 3,
    trace => 4,
  );

  if ( $level !~ /^\d$/xsm ) {
    $level = $levels{$level};
  }

  $self->{verbose} = $level;

  $self->{log_level} = { reverse %levels }->{$level};

  my $log4perl_level = ( $ERROR, $WARN, $INFO, $DEBUG, $TRACE )[$level];

  $self->get_logger->level($log4perl_level);
  $self->get_logger->debug( sprintf 'logging at the %s level', $self->{log_level} );

  return $self->{log_level};
}

########################################################################
sub TIEHASH {
########################################################################
  my ( $class, $ctx, $config ) = @_;

  my $name = $config->{param} // $config->{cookie}->{name};

  croak q{set 'param' or cookie->name in config}
    if !$name;

  # Create session object
  my $self = bless {}, $class;

  $self->{ctx}    = $ctx;
  $self->{name}   = $name;
  $self->{config} = $config;

  # verbosity level can be set in config with 'verbose' or 'log_level'
  # log_level -> error, warn, info, debug, trace
  # verbose   -> 0, 1, 2, 3, 4
  my $verbosity_level = exists $config->{verbose} ? $config->{verbose} : $config->{log_level};

  my $log_level = $self->set_log_level($verbosity_level);

  # Initialize session
  $self->startSession($config);

  # Check for an existing session
  my $id = $config->{cookieless_sessions} ? $ctx->getInputValue($name) : $ctx->getCookieValue($name);

  # Get the session data only if a session exists
  if ( defined $id ) {
    $self->get_logger->trace(
      sub {
        return sprintf q{Reading user's session: [%s]}, $id;
      }
    );

    my $session = $self->read_data($id) // $EMPTY;

    $self->get_logger->trace(
      sub {
        return sprintf 'User session [%s]', $session;
      }
    );

    return $self if $session;
  }

  # No session cookie -- check to see if login cookie present
  my $login_cookie_name = $config->{login_cookie_name};

  my $login_id
    = $config->{cookieless_sessions}
    ? $ctx->getInputValue($login_cookie_name)
    : $ctx->getCookieValue($login_cookie_name);

  if ($login_id) {
    my $session = $self->newLoginSession($login_id) // $EMPTY;

    $self->get_logger->trace(
      sub {
        return sprintf 'User has login session [%s] -- session is [%s]', $login_id, $session;
      }
    );

    return $self
      if $session;
  }

  # everything failed -- need to create a new session
  my $session = $self->newSession;

  $self->get_logger->debug(
    sub {
      return sprintf 'User does not have anonymous session or login session -- using [%s]', $session;
    }
  );

  $self->{data}->{prefs}->{expiry_secs}
    = $self->{config}->{cookie}->{expiry_secs};

  # And return the session object
  return $self;
}

########################################################################
sub FETCH {
########################################################################
  my ( $self, $key ) = @_;

  if ( $key eq 'session' ) {
    return $self->{$key};
  }
  elsif ( $key =~ /^(username|firstname|lastname|email|config)$/xsm ) {
    return $self->{data}->{$key};
  }
  elsif ( exists $self->{data}->{prefs}->{$key} ) {
    return $self->{data}->{prefs}->{$key};
  }
  else {
    return $self->{config} && $self->{config}->{default_prefs}->{$key};
  }
}

########################################################################
# Just store the value in the session and return the value
sub STORE {
########################################################################
  my ( $self, $key, $value ) = @_;

  if ( $key =~ /^(session|username)$/xsm ) {
    die "Cannot set `$key': attribute is read-only.\n";
  }
  elsif ( $key eq 'password' ) {
    die "Cannot set `password': Use `change_password()' instead.\n";
  }
  elsif ( $key =~ /^(firstname|lastname|email)$/xsm ) {
    die "Cannot set `$key' -- no username: use `login()' or `register()' first.\n"
      if !$self->{data}->{username};

    die "Cannot store empty string in `$key'.\n"
      if $key =~ /^(firstname|lastname)$/xsm and length($value) == 0;

    $self->get_logger->trace(
      sub {
        "Storing [$key] = [$value]";
      }
    );

    return $self->{data}->{$key} = $value;
  }

  $self->get_logger->trace(
    sub {
      "Stored [$key] = [$value] into prefs";
    }
  );

  return $self->{data}->{prefs}->{$key} = $value;
}

# Invoked to loop over the properties of the session
########################################################################
sub FIRSTKEY {
########################################################################
  my ($self) = @_;

  delete $self->{keys};

  my $k = {
    session   => $self->{session},
    username  => $self->{data}->{username},
    firstname => $self->{data}->{firstname},
    lastname  => $self->{data}->{lastname},
    email     => $self->{data}->{email},
  };

  my %keys;
  @keys{ keys %{ $self->{data}->{prefs} }, keys %{ $self->{config}->{default_prefs} } } = ();
  for my $key ( keys %keys ) {
    if ( exists $self->{data}->{prefs}->{$key} ) {
      $k->{$key} = $self->{data}->{prefs}->{$key};
    }
    else {
      $k->{$key} = $self->{config}->{default_prefs}->{$key};
    }
  }

  $self->{keys} = $k;

  return each %{ $self->{keys} };
}

########################################################################
sub NEXTKEY {
########################################################################
  my ($self) = @_;

  return each %{ $self->{keys} };
}

########################################################################
sub EXISTS {
########################################################################
  my ( $self, $key ) = @_;

  if ( $key eq 'session' ) {
    return $TRUE;
  }
  elsif ( $key =~ /^(username|password|firstname|lastname|email)$/xsm ) {
    return exists $self->{data}->{$key};
  }
  elsif ( exists $self->{data}->{prefs}->{$key} ) {
    return $TRUE;
  }
  else {
    return exists $self->{config}->{default_prefs}->{$key};
  }
}

########################################################################
sub DELETE {
########################################################################
  my ( $self, $key ) = @_;

  if ( any { $key eq $_ } qw(session username firstname lastname email password) ) {
    die "Cannot delete `$key': illegal operation.\n";
  }
  else {
    return delete $self->{data}->{prefs}->{$key};
  }
}

########################################################################
sub CLEAR {
########################################################################
  my ($self) = @_;

  return %{ $self->{data}->{prefs} } = ();
}

########################################################################
sub closeBLM { ## no critic (Capitalization)
########################################################################
  my ($obj) = @_;

  my $self = tied %{$obj} || $obj;

  my ( $verbose, $session ) = @{$self}{qw(verbose session)};

  my $prefs = $self->{data}->{prefs};

  # this is a very implementation specific session rule that says, if
  # there is no session, then if there is a 'default_prefs' set in the
  # session configuration, then map that to the session data...
  if ( !keys %{$prefs} ) {
    $prefs = $self->{config}->{default_prefs};
  }

  my $xml = Bedrock::XML::writeXMLString( $prefs || {} );

  $self->get_logger->trace(
    sub {
      return sprintf "Saving session [%s] data\n%s", $session, $xml;
    }
  );

  # there are certain situations where Bedrock may call closeBLM() more than once
  # if that happens, we don't want to alter the object since the second call will fail
  # because the prefs object was already converted to XML...so we create a clone
  # object that is written to the database
  my $data = {};

  COPY_DATA:
  foreach my $key ( keys %{ $self->{data} } ) {
    next COPY_DATA if $key eq 'prefs';

    $data->{$key} = $self->{data}->{$key};
  }

  $data->{prefs} = $xml;

  $self->STORE_SESSION(
    verbose => $verbose,
    session => $session,
    data    => $data,
    expires => $self->{expires},
    new     => $self->{new_session},
    config  => $self->{config},
  );

  # in the event someone calls closeBLM again, we don't want to create
  # a second session row...however implementations of session handlers
  # should probably be smart enough not to create multiple instances
  # of the same session object (however they store them).

  delete $self->{new_session};

  my $nrows = $self->SESSION_CLEANUP( config => $self->{config} );

  $self->get_logger->trace(
    sub {
      "Cleaned up $nrows rows";
    }
  );

  return $self->DISCONNECT( config => $self->{config} );
}

1;

__END__

=pod

=head1 PUBLIC

BLM::Startup::SessionManager - Base class for implementing Bedrock sessions.

=head1 SYNOPSIS

 use parent qw(BLM::Startup::SessionManager);

=head1 DESCRIPTION

This is a base class that you can use as a starting point when
implementing a custom Bedrock session manager.  For example
implementations, see: L<BLM::Startup::MySQLSession>,
L<BLM::Startup::PostgreSQLSession> and L<BLM::Startup::SQLiteSession>.

You are expected to implement several methods to create a valid
session manager.  You can also provide implementations for a few other
B<optional> methods that are called at various points during session
handling.  These methods may or may not be necessary for your
implmentations.  YMMV.

=head1 METHODS AND SUBROUTINES TO IMPLEMENT

The methods described below are categorized as either B<optional> or
B<required>. Required means, if you want the class to do something
useful, you more or less need to do something and return something.
Only death and taxes are actually required. 

All of the methods take a hash as an argument.  The hash members
passed are described in general and each methodE<039>s documentation will
then indicate which of these is passed to you for this call.

Your implementation may or may not require these arguments to
implement the functionality you are providing.

=head1 SUBCLASSING

The purpose of your implementation is to store a userE<039>s data to a
permanent data store.  Permanence is defined based on the type of
session that is being created by the calls to your handlers.  Login
sessions should save a userE<039>s data for access any time the user
I<logs in> using the session objectE<039>s C<login()> method.

I<Note: if you are not particularly interested in login sessions, then
donE<039>t bother implementing the method. It is certanly conceivable
that you may want to provide transient sessions for your application
and your implementation is not interested in persisting data for
particular users across session instances.  It is totally up to you
whether or not you want to provide that functionality.  If you choose
not to, it might be a good idea to throw an exception or something to
indicate that this feature is not provided in your session
implementation.>

 sub LOGIN {
   die "method not provided in this implementation\n";
 }

Anonymous sessions on the other hand, tend to expire based on some
setting in your configuration file.  That expiration is translated
into the expiry date of a cookie, thus cookie based session ids become
unavailable after that time and thus the session associated with that
id becomes inaccessible.  Likewise, with login sessions the cookie
expires the session, but not the data in the session store.  Once a
login session expires, the user must login in again to reactivate the
session, but their data is still in tact - assumming you implement
things properly.

=head2 Selecting Your Storage Method

The description of the API is generic enough such that you should be
able to design your own storage mechanism in whatever fashion you
please.  The calls made to methods you write provide the relevant
pieces of information needed to store or retrieve a particular
session, including the C<config> object that is defined in your
F<tagx.xml> entry for this Application Plugin.  Since you have control
over what goes in that configuration section you should provide
whatever additional settings or configuration values you need to
implement your session manager.

The storage and retrieval mechanism might involve an SQL table for
example, or it might be involve some other way to store and retrieve
data based on a unique key.  The only real requirement is that the API
provide a way to store and retrieve data using a unique key.
Typically this means a database table and a unique key, however there
is a variety ways you can skin that cat.

Requests to store and retrieve session data will occur across
different client requests implying a different Apache process will
service different requests.  That means you must have a way to persist
the data across these requests, i.e. you canE<039>t simply store things in
a hash for the current request for example.

Sessions are generally not meant to last forever (unless we are
talking about login sessions) and are not usually large, however your
application needs will dictate much of that.

If you decide to implement sessions using a database table, the
reference implemenation documented in C<BLM::Startup::MySQLSession>
should give you some clues as to what a table might look like and one
way to provide persistence.  ItE<039>s not the only way, and probably not
the most efficient way one could construct.  Again, YMMV.

=head2 Storing and Retrieving the Session Data

YouE<039>ll be implementing a set of methods for storing and retrieving
session data.

  ->FETCH_SESSION( )
  ->STORE_SESSION( )
  ->FETCH_LOGIN_SESSION( )
  ->STORE_LOGIN_SESSION( )

The C<FETCH_*> methods you implement should return a reference to a
hash object that minimally contains a member named C<prefs>.  The
C<prefs> object is a text blob that was sent to you to save via one of
the C<STORE_*> methods.

Technically speaking you donE<039>t need to know too much more than that,
however the object that you stored is a Bedrock XML object.  It will
be converted to its internal representation (a hash reference) by the
calling functions and eventually will be accessible to the Bedrock
page via the C<$session> object.

Likewise, the C<STORE_*> methods expect you to take a hash reference
which is passed as the hash member C<data> and store the session data
I<somewhere>.  Other arguments to C<STORE_*> will tell you what
session or user this data belongs to so you can store the data in such
as way as to allow for later retrieval using that same information as
a key or index.

So, to clarify a bit - you are B<NOT> responsible for serializing and
deserializing the session information!  Your implementation is only
responsible for fetchinng and storing a serialized representation of a
userE<039>s session.  The rest of the plumbing takes care of the
actual process of serialization and deserialization.

=head2 Arguments to Methods

The argument to the methods that you will implement is a hash.  The
members can be any of those described below depending on the particular
method being invoked.

=over 5

=item config

This is a hash reference to the configuration information you defined
in your F<tagx.xml> entry for this Application Plugin. HereE<039>s what he
configuration object looks like for the reference implementation.

      <object name="config">

        <scalar name="verbose">2</scalar>
        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>
        <scalar name="data_source">dbi:mysql:bedrock</scalar>
        <scalar name="username">fred</scalar>
        <scalar name="password">flintstone</scalar>
        <scalar name="table_name">session</scalar>
        <scalar name="purge_user_after">30</scalar>
        <scalar name="cookieless_sessions"></scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>

Your configuration object can have whatever information is necessary
to implement your session manager, however you should have these
elements at a minimum to provide for cookie based sessions.

      <object name="config">

        <scalar name="param">session</scalar>
        <scalar name="login_cookie_name">session_login</scalar>
        <scalar name="login_cookie_expiry_days">365</scalar>

        <object name="cookie">
          <scalar name="path">/</scalar>
          <scalar name="expiry_secs">3600</scalar>
          <scalar name="domain"></scalar>
        </object>
      </object>


=item data

A reference to a hash that possibly contains various members including
C<prefs> which is a text represenation of the userE<039>s session data.
You should save that data so you can return it via one of the
C<FETCH_*> methods for the given session or login identifier.

Possible members that may appear in the hash reference as well and
that you may or may not need or wish to store include (see descriptions
below):

=over 5

=item username

=item password

=item email

=item firstname

=item lastname

=item prefs

=back

=item email

The email address of a user.  Used as an argument to the C<register()> method of the session object.

=item expires

The session expiration time in seconds.

=item firstname

The first name of a user.  Used as an argument to the C<register()> method of the session object.

=item lastname

The last name of a user.  Used as an argument to the C<register()> method of the session object.

=item login_id

=item new 

A flag that indicates if the session is new.

=item password

The password associated with the username of a registered user.  Used
as an argument to the C<register()> and C<login()> methods of the
session object.

=item prefs

This is the payload that contains the session data that you should
store or retrieve.  It is a serialized representation of the session
object.

=item session

A unique session identifier based on an MD5 digest value.

=item username

The username associated with a registered user.  Used as an argument
to the C<register()> and C<login()> methods of the session object.

=item verbose

An integer, possibly >=0 that indicates the verbosity level desired.

=back

=head2 Optional Methods

The method descriptions below include an indication of which hash
elements are passed and a brief explanation of what the method is
required to do and/or return.  Your method should access the arguments
in a similar manner as shown in the stub below:

  sub CONNECT {
    my $self = shift;
    my %options = @_;
   
    my $table_name = $options{config}->{table};
    ...
  }

=head3 CONNECT

 config => configuration object

This method is called when the session object is instantiated and
gives your method an opportunity to do any initialization rituals
necessary prior to being asked to fetch or store any data.  Typically,
this means connecting to a database, like so:

  $self->{dbh} = DBI->connect( $options{config}->{data_source},
                               $options{config}->{username},
                               $options{config}->{password}
                             );

You can save state to the object, but be careful.  A better approach
is to create your own reference to data you need to keep track of.
The element C<_manager_state> is reserved for this purpose.  So
C<CONNECT> might be better written:

  my $dbh = DBI->connect( $options{config}->{data_source},
                          $options{config}->{username},
                          $options{config}->{password}
                        );

  $self->{_manager_state} = { dbh => $dbh };


=head3 DISCONNECT

 config => configuration object

This method is called when the session object is destroyed. You should
do whatever is necessary to close files, database, etc.

=head3 SESSION_CLEANUP

 config  => configuration object

This method is called when the session object is destroyed prior to
the call to C<DISCONNECT>.  You can use this opportunity to clear out
stale sessions if necessary.

Just a quick note about stale sessions.  If you don't have a way to
clear out expired sessions, you will quickly start collecting them
like beer cans in the recycle bin.  There are three obvious ways to
cleanup sessions, however depending on your implementation you may not
care, or there may be some magic in your implementation that obviates
the need for cleanup.  The three obvious ways I know of to cleanup
sessions are:

=over 5

=item * Look for stales sessions during the SESSION_CLEANUP() method.

This works, as long as some active session is running, otherwise you
would never have been called.  This implies your session store will
always include at least 1 stale session.

=item * Run a scheduled job and clean up stale sessions

This works, and is the approach that seems logical.  But who wants to
write more software than they have to?

=item * Use magic

This is the best approach, if you pull it off.  By magic, I really
mean use some technology that expires itself, in the background,
without any intervention from you.  An example of this might be using
Redis which includes the ability the expire objects.  Just make sure
that you are renewing the lease on these objects.

=back

Finally, you can ignore the problem - if itE<039>s not a problem for you.
If you have an infinite amount of storage and access times to your
session are not impacted by the number of objects you store, then
ignore the problem by all means.  Again, YMMV.


=head3 LOGOUT

 username => username
 session  => session-id
 config   => configuration-object

This method is called in response to the session object method
C<logout()>.  Typically, userE<039>s like to logout of applications
for a variety of reasons including security.  This is an opportunity
for you to expire the session in some manner.

=head2 Required Methods

=head3 FETCH_LOGIN_SESSION

 login_id => login-id                             
 config   => configuration object

Return a hash reference that minimally includes the member C<prefs>
representing the session associated with the given C<login-id>.

=head3 STORE_LOGIN_SESSION

 session  => session-id                                        
 login_id => login-id                                          
 expires  => expiry-time                                       
 username => username                                          
 data     => ref(session-data)                                 
 config   => configuration object                              

You should save the session associated with the C<login-id> given.
Return 1 if the session has successfully been saved.

=head3 UPDATE_LOGIN_SESSION

 username => username                                          
 config   => configuration object                              
 login_id => login-id                                          

Update the currency of the login session and the username associated
with the session (if you are keeping track of things like that a wish
to be able to expire sessions or identify them as belonging to a
particular user).

=head3 FETCH_SESSION

 config   => configuration object                              
 session  => session-id

Return a reference to a hash that minimally contains the member
C<prefs> representing the session data associated with the given
C<session-id>.

=head3 STORE_SESSION

 session => session-id                         
 new     => 1 indicates that the session is new
 expires => expiry-time                        
 data    => ref(session-data)                  
 config  => configuration object               
 verbose => 0/1                                

Store the session data and return a 1 if the session has successfully
been stored.  The session data is passed in the hash reference C<data>
as member C<prefs>.

  $options{data}->{prefs}


=head3 REGISTER

 config    => configuration object
 username  => username            
 password  => password            
 firstname => first name          
 lastname  => last name           
 email     => email address       

For login sessions you might want to provide an implementation of
C<REGISTER> that enables the session method C<register()> to add a user
to your store of registered users.

Return a 1 if the operation is successful.

=head3 UPDATE_LOGIN_PASSWORD

 config    => configuration object        
 username  => username                    
 password  => [ new-password, old-password ]
 session   => session-id

Update password associated with the username given.  Return a 1 if the
update is successful.

=head1 METHODS AND SUBROUTINES

The methods are provided for you by the base class but can be
overwridden by your implementation of a session handler. For example:
C<look_user> might have a different implementation for a SQL based
session vs an in-memory type of session.

=head2 Methods Documented in L<BLM::Startup::UserSession>

The methods below are document in
L<BLM::Startup::UserSession>. Although that version of a session
manager is based on MySQL, the documentation of these methods should
be consistent across implementations.

=over 5

=item * L<BLM::Startup::UserSession/change_passwd>

=item * L<BLM::Startup::UserSession/cleanup_session_dir>

=item * L<BLM::Startup::UserSession/clear>

=item * L<BLM::Startup::UserSession/config>

=item * L<BLM::Startup::UserSession/context>

=item * L<BLM::Startup::UserSession/cookie>

=item * L<BLM::Startup::UserSession/cookieless_session>

=item * L<BLM::Startup::UserSession/create_temp_login_session>

=item * L<BLM::Startup::UserSession/delete_session_file>

=item * L<BLM::Startup::UserSession/encrypt>

=item * L<BLM::Startup::UserSession/get_session_dir>

=item * L<BLM::Startup::UserSession/kill_session>

=item * L<BLM::Startup::UserSession/login>

=item * L<BLM::Startup::UserSession/logout>

=item * L<BLM::Startup::UserSession/lookup_user>

=item * L<BLM::Startup::UserSession/lookup_users>

=item * L<BLM::Startup::UserSession/register>

=item * L<BLM::Startup::UserSession/remember_user>

=item * L<BLM::Startup::UserSession/remove_user>

=item * L<BLM::Startup::UserSession/set_log_level>

=item * L<BLM::Startup::UserSession/version>

=back

=head2 Session File Handling

=head3 cleanup_session_dir

 cleanup_session_dir( 0 | 1 )

Indicate whether or not anonymous session directories should be removed after a
session times out.

=head3 cleanup_login_sessions

This flag is used by the C<login()> method to determine if login
session will be cleaned. Note that just before a logged in user gets a
new session this flag indicates that the user's old session should be
removed if it exists.

=head3 copy2session

 copy2session(path)

Copies the file indicated by C<path> to the session directory.  Throws
an exception if the file does not exist, is empty or is unreadable. If
the path is the name of a file, it is assumed to be in the document
root.

=head3 create_session_dir

 create_session_dir([sub-dir])

Creates a session directory with a corresponding subdirectory if
provided. Session directories are subdirectories that are identified
by the session id typically stored as cookie value and used in
conjunction with C<Apache::BedrockSessionFiles>.

Your F<tagx.xml> file should define a C<SESSION_DIR> value that
provides the root for the session directory.

 <scalar name="SESSION_DIR">/var/www/vhosts/mydomain.com/session</scalar>

I<NOTE: The session directory root (SESSION_DIR) should be outside the
context of your DOCUMENT_ROOT. If you specify the root of session
directories inside your DOCUMENT_ROOT you may be inadvertantly
exposing a user's session directory to all users.>

For stateless session directories the root of session directory could
be, for example, an NFS mount available to a fleet of web servers. You
could also create a custom C<mod_perl> handler for that directory that
serves files from some other location (e.g. an external file storage
system like Amazon S3, etc). However, if your session directory is not
directly accessible by normal file access utilities then method's like
C<create_session_dir()> will throw exceptions.

Your handler would obviously need to manage session directories and
serve files from your external file storage system.

You could also sub-class this module and provide your own
C<create_session_dir()>, C<create_session_tempfile()>, and 

See L<Apache::BedrockCloudSessionFiles> for an example of serving
session files from S3.

=head3 create_session_tempfile

 create_session_tempfile(template, options)

Creates a temporary file in the current session directory.

 <null:tempfile $session.create_session_tempfile('fooXXXX', 'SUFFIX', '.html')>

Returns a two element C<Bedrock::Array> containing a filehandle and
the name of the temporary file.

=over 5

=item template

Template to use for file creation (see C<tempfile>). Use at least 4
X's. If you provide a C<NAME> parameter, then the template value is
ignored.

=item options

=over 10

=item DIR

Sub directory under the C<session> directory to create.

=item SUFFIX

Suffix (extension). The default SUFFIX is C<.html>.  If you want no
suffix, pass '' as the SUFFIX parameter.

=item NAME

Creates a temporary file with this name (include an extension). If you
pass NAME, SUFFIX is ignored.

=back

=back

=head3 create_session_file

 create_session_file( filename, content, [ttl] )

Writes the content to the session directory using the filename specified.
If the C<content> parameter is a hash or array it will be deserialize
as a JSON object.

Optionally add a TTL value for the file. Defaults to the TTL defined
in the C<session_files> section of the configuration file (ttl) or the
environment variable C<BEDROCK_SESSION_FILES_TTL> if they exist.

=head3 rename_session_file

 rename_session_file(old-name, new-name);

Renames a file in a use session. Throws an exception if the file does
not exist.

=head3 set_session_file_ttl

 set_session_file_ttl(seconds)

Sets the TTL for a session file. If a client attempts to access the
file after the TTL has expired the file will be removed from the
session and a 404 will be returned.

When a file is created using C<create_session_file> it may be assigned
a default TTL. See L</create_session_file>.

=head1 SEE ALSO

L<BLM::Startup::UserSession>, L<BLM::Startup::SQLSession>, L<BLM::Startup::Session>

=head1 AUTHOR

Rob Lauer <bigfoot@cpan.org>

=cut
