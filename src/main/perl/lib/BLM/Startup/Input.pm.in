#!@PERL@ -w

# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::Startup::Input;

use strict;

BEGIN {
  use Exporter ();
  use vars qw ($VERSION @ISA);
  $VERSION = do { my @r = ( q$Revision$ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
}

use TagX::Log;
use Bedrock::Hash;
use Data::Dumper;

@ISA = qw(Bedrock::Hash);

sub TIEHASH {
  my ( $class, $ctx, $config ) = @_;
  my $self = {};

  $self->{'config'}  = $config;
  $self->{'verbose'} = $config->{'verbose'};
  $self->{'vars'}    = {};
  $self->{'_ctx'}    = $ctx;

  my $self = bless $self, $class;

  $config->{scrubber} && do {
    require HTML::Scrubber;
    my $cfg = $config->{scrubber};

    $self->{'_html_scrubber'} = new HTML::Scrubber;

    $self->scrubber->allow( split ' ', $cfg->{allow} )
    if exists $cfg->{allow};
    $self->scrubber->deny( split ' ', $cfg->{deny} )
    if exists $cfg->{deny};
  };

  for my $key ( $ctx->getInputValue ) {

    #      $self->{$key} = $self->scrub( $ctx->getInputValue($key) );
    $self->{'vars'}->{$key} = $self->scrub( $ctx->getInputValue($key) );
  }

  $self;
}

sub scrub {
  return ( $_[0]->{'_html_scrubber'} )
  ? $_[0]->{'_html_scrubber'}->scrub( $_[1] )
  : $_[1];
}

sub scrubber {
  my $self = shift;

  $self->{'_html_scrubber'};
}

sub upload_file {
  my $self     = shift;
  my $form_var = shift;

  my $result = $self->{'_ctx'}->upload_file( $form_var, @_ );
  my $file = $self->{$form_var};
  $self->{$form_var} = "$file";

  $result;
}

sub FETCH {
  my ( $self, $key ) = @_;
  &log_message( undef, "Value for [$key]: [$self->{'vars'}->{$key}]" )
  if $self->{'verbose'};
  my $ref = $self->{'vars'}->{$key};

  return $self->{_ctx} if $key eq '_ctx';

  #-- returned arrays should always be Bedrock::Array(s)
  if ( ref($ref) =~ /array/i ) {
    $ref = Bedrock::Array::Reference->new($ref);
    $self->{'vars'}->{$key} = $ref;
  }

  $self->{'vars'}->{$key};
}

sub STORE {
  $_[0]->{'vars'}->{ $_[1] } = $_[2];
}

sub FIRSTKEY {
  my $self = shift;
  my $a    = scalar keys %{ $self->{'vars'} };
  each %{ $self->{'vars'} };
}

sub NEXTKEY {
  each %{ shift->{'vars'} };
}

sub EXISTS {
  exists $_[0]->{'vars'}->{ $_[1] };
}

sub CLEAR {
  %{ shift->{'vars'} } = ();
}

sub DELETE {
  delete $_[0]->{'vars'}->{ $_[1] };
}

1;

=pod

=head1 PUBLIC

C<BLM::Startup::Input> - provides access to HTML form variables and more!

=head1 SYNOPSIS

Access an HTML form variable named 'foo':

 <var $input.foo>

Display all of the HTML form variables:

 <foreach $input.keys()>
   FORM variable <var $_> = <var $input.get($_)><br>
 </foreach>

 <foreach $input>
   FORM variable <var $_.key> = <var $_.value><br>
 </foreach>

 <var $input.map("%s = %s").join("<br\>")>

Upload a file from the user's computer (C<upfile> is a form variable
of type C<FILE>):

  <if $input.upfile>
  <try>
   <null:file_info $input.upload_file('upfile')>
   Successfully upload file <var $file_info.file>, size: <var $file_info.size>
  <catch>
   Error uploading file <var $input.upfile>
  </try>
  </if>

  <form method="post" enctype="multipart/form-data">
  file to upload: <input type="file" name="upfile"><br>
  <input type="submit" value="submit">
  </form>


=head1 DESCRIPTION

The C<$input> object is the Bedrock page's access method for HTML form
variables.  The C<$input> object is implemented as a Bedrock hash
(therefore all the methods of a Bedrock hash are also available) that
allows you to access all of the HTML form variables sent by the
browser.

For HTML form variables that have the same name (checkboxes for
example), you'll find that the object returned to you will be a
Bedrock array.  Try the example below:

  <if $input.foo_box>
  <pre>
  <trace --output $input.foo_box>
  </pre>
  </if>

  <form name="foo" method="post">
  [1] <input type="checkbox" name="foo_box" value="1"><br>
  [2] <input type="checkbox" name="foo_box" value="2"><br>
  [3] <input type="checkbox" name="foo_box" value="3"><br>
  <input type="submit" value="Submit">
  </form>

=head1 SANITIZING INPUT

Form input may contain unwanted and potentially harmful input.
Consider sanitizing your input before injecting it back into a page.

You can do this yourself in any one of a number of ways, however,
Bedrock provides a way to do this transparently.

The input object will filter form input through HTML::Scrubber if you
have defined a configuration object for the C<BLM::Startup::Input>
object in F<tagx.xml> named C<scrubber>.  The C<scrubber> object can
contain a C<deny> or an C<allow> scalar that defines the tags are
either denied or those that are allowed.

  <scalar name='allow'>b i p</scalar>

See the C<HTML::Scrubber> documentation for more detail.

=head1 METHODS

C<$input> is a Bedrock hash, thus you can use methods associated with
any Bedrock hash in addition to those documented below.

=head2 upload_file( form-var-name, options ... )

Upload a file from the browser to the web server.  Returns a hash of
file information similar to the information returned by the perl
C<stat> function. (see perldoc C<stat> or C<BLM::Stat>).

  <null:file_info $input.upload_file('upfile')>

C<$file_info> will contain same output as C<BLM::Stat> + the key
"file" that contains the path name to the uploaded file as well as a
key with the same name as the upload file CGI var name.

I<NOTE:> The CGI variable that contains the name of the file to be uploaded and is of type C<file>:

  <input type="file" name="upfile">

has a dual nature (it's a file handle too!) that makes it unsuitable
for consumption by Bedrock as a Bedrock scalar.  Thus in your page
that processes the form that contains that variable you should use the
copy of the name of the file returned in the C<upload_file> hash
object as that is a true Bedrock scalar.  So, for example, if you named the CGI
variable C<upfile> as in the example above and you executed the
following Bedrock statement:

 <null:file_info $input.upload_file('upfile')>

...then C<$file_info.upfile> would contain the name of the file (on
the client) that was uploaded.

=over 5

=item * form-var-name

The name of the form variable of type C<FILE> that contains the file name to be uploaded.

=item * options

Either a hash that contains the options or a list of options as described below:

=over 5

=item * filename

Name you would like to give the file if not the default name as uploaded.

=item * path 

The path to the upload directory where the file should be stored.  The
web server process should be able to write to this directory of
course.  Defaults to either:

$config.UPLOAD_PATH (as defined in tagx.xml) or F< E<sol>tmp >

=item * content-type

Either the mime-type or an array reference to a list of mime-types
that are acceptable.  This allows you to restrict the type of files
that are accetable to upload. If the mime-type is not one of the types
in your list the method will raise an exception.

  <null:file_info $input.upload_file(filename, 'upfile', content-type, 'application/pdf')>

=back

=back

=head1 NOTES

The C<upload_file> method will throw exceptions if an error occurs or
if the mime-type of the file is not one of the types you specify.

=head1 AUTHOR

J. Sridhar

Rob Lauer - rlauer@signatureinfo.com

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.22  2011/09/15 16:05:31  eutl420
# - perl tidy
#
# Revision 1.21  2011/09/14 18:49:09  eutl420
# - prevent the form variable of type 'file' from being returned as file handle
# - use ref, not UNIVERSAL in FETCH, partly anal, partly more correct
#
# Revision 1.20  2011/08/22 23:37:27  eutl420
# - enable scrubbing of HTML input for malicsious javascript injection
#
# Revision 1.19  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.18  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.17  2011/07/04 13:40:32  eutl420
# - fix typo in pod E<sol>
#
# Revision 1.16  2010/11/29 15:57:51  rlauer
# - change openbedrock.org to openbedrock.net
#
# Revision 1.15  2010/11/20 04:10:12  rlauer
# - add note about filehandle nature of the upload_file parameter
#
# Revision 1.14  2010/11/19 19:14:21  rlauer
# - documentation edits
#
# Revision 1.13  2010/11/15 02:21:15  rlauer
# - minor documentation tweaks
#
# Revision 1.12  2010/11/14 21:01:59  rlauer
# - minor documentation fixes
#
# Revision 1.11  2009/12/30 12:40:51  rlauer
# added documentation
#
# Revision 1.10  2009/12/28 20:32:33  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.9  2009/12/23 12:31:07  rlauer
# - Input.pm is an implementation of a hash, thus any vars set that are supposed to be class private vars need to be handled a little differently
#   when you are accessing them...i.e. $self->{foo} will invoke the default FETCH which is definitely not what you want if you are trying to
#   store some sort of class private variable...i.e. ctx!  Probably can do this better by using CORE::FETCH or SUPER?
#
# Revision 1.8  2009/12/23 00:45:12  rlauer
# save context object
#
# Revision 1.7  2008/12/03 14:01:19  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.6  2002/02/13 18:00:20  rlauer
# Force an array CGI var to be a SIS::Array
#
# Revision 1.5  2001/02/14 15:35:46  sridhar
# Added copyright and GPL notice
#
# Revision 1.4  2000/11/16 16:24:46  sridhar
# Overriding all Tie::Hash methods to do things right.
#
# Revision 1.3  2000/11/14 14:20:35  sridhar
# 1. Kicked out "*ctx*". Overrode FIRSTKEY and NEXTKEY to achieve this.
# 2. Config gets passed as the last arg to constructor. We pick up
# `verbose' from the config.
# 3. More log messages
#
# Revision 1.2  2000/10/16 13:55:56  sridhar
# Streamlining to accomodate Bedrock shell:
# 1. Module doesn't do anything about input until asked for.
# 2. Stores the context object as a private value for later unpacking of
# the CGI vars
#
# Revision 1.1  2000/06/06 20:42:08  sridhar
# Bedrock loadable modules for startup
#
#
