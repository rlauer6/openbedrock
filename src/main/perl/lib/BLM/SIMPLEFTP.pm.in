#!/usr/local/bin/perl -w
# Simple FTP BLM
# ident "@(#) $Header$"


package BLM::SIMPLEFTP;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log 1.01;
use SIS::Handle;
use Net::FTP;    
@ISA = qw(SIS::Hash);

sub TIEHASH
{
    my $class = shift;
    my $host = shift;
    my ($user, $password, $acct) = @_;

    my $self = bless {}, $class;
    $self->{'host'} = $host;

    my $ftp = Net::FTP->new($host);

    die "FTP(connect): connect failed $@" unless defined $ftp;

    $self->{'ftp'} = $ftp;
  
    if ($user) {
	die "FTP(connect): login failed ($user, $password)" unless defined $ftp->login($user, $password, $acct);
    }

    $self;
}

sub CLOSE
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    $ftp->quit if $ftp; 
}

sub login
{
    my $self = shift;
    
    my ($user, $pass, $acct) = @_;

    my $ftp = $self->{'ftp'};

    die "FTP(login): login failed ($user, $pass)" unless defined $ftp->login($user, $pass, $acct);
}

sub ascii
{
    my $self = shift;

    my $args = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->ascii($args);
    die "FTP(ascii): could not set type (ascii)" unless $last;

    $last;
}

sub binary
{
    my $self = shift;

    my $args = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->binary($args);

    die "FTP(binary): could not set type (binary)" unless $last;

    $last;
}

sub cwd
{
    my $self = shift;

    my $args = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->cwd($args);

    die "FTP(cwd): could not set dir ($args)" unless $last;

    $last;
}

sub pwd
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $pwd = $ftp->pwd();

    die "FTP(pwd): could not get current working directory" unless $pwd;

    $pwd;
}

sub ls
{
    my $self = shift;
    my $dir = shift;

    my $ftp = $self->{'ftp'};

    $dir = ($dir or ".");

    return SIS::Array->new(@{$ftp->ls($dir)});
}

sub size
{
    my $self = shift;
    my $file = shift;

    die "FTP(size): not connected" unless exists $self->{'ftp'};

    ${$self->{'ftp'}}->size($file);
}

sub dir
{
    my $self = shift;

    my $dir = shift;
    my $ftp = $self->{'ftp'};

    $dir = ($dir or ".");
    my @full_dir = $ftp->dir($dir);

    shift @full_dir if $full_dir[0] =~ '^total';
    my @dir;

    foreach (@full_dir) {
	my @dummy = split " ", $_;
	my $ref = {};
	$ref->{'permissions'} = $dummy[0];
	$ref->{'links'} = $dummy[1];
	$ref->{'owner'} = $dummy[2];
	$ref->{'group'} = $dummy[3];
	$ref->{'size'} = $dummy[4];
	$ref->{'month'} = $dummy[5];
	$ref->{'day'} = $dummy[6];
	$ref->{'year'} = $dummy[7];
	$ref->{'file'} = $dummy[8];
	push @dir, $ref;
    }

    return SIS::Array->new(@dir);
}

sub quit
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    $ftp->quit;

    $self->{'ftp'} = undef;
}

sub stor 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->stor($file);

    die "FTP(stor): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub stou 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};
    
    my $conn = $ftp->stou($file);

    die "FTP(stou): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub unique_name
{
    my $self;

    die "FTP(unique_name) not connected" unless exists $self->{'ftp'};

    ${$self->{'ftp'}}->unique_name;
}

sub retr
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->retr($file);

    die "FTP(retr): error opening file ($file) for reading" unless defined $conn;

    $self->{'conn'} = $conn;
}

sub read 
{
    my $self = shift;
    my ($size, $timeout) = @_;
    
    my $ftp = $self->{'ftp'};
    my $conn = $self->{'conn'};

    die "FTP(read): no data connection" unless exists $self->{'conn'};

    my $buffer;
    my $_buffer;

    $size = int($size);
    my $len;

    while (1) {
	last unless $len = $conn->read($_buffer, 1024, $timeout);
	$buffer .= $_buffer;
	$size -= $len;
	last unless ($size > 0);
    }

    die "FTP(read): error reading from host" if $size;

    $buffer;
}

sub write 
{
    my $self = shift;

    my ($buffer, $timeout) = @_;
    
    my $conn = $self->{'conn'};

    die "FTP(write): no data connection" unless exists $self->{'conn'};

    my $len = $conn->write($buffer, length($buffer), $timeout);

    die "FTP(write): error writing to host" unless $len == length($buffer);

    $buffer;
}

sub close
{
    my $self = shift;

    die "FTP(close): no data connection" unless exists $self->{'conn'};

    my $conn = $self->{'conn'};

    $conn->close;

    $self->{'conn'} = undef;
}

sub put
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;
    die "FTP(put): file does not exist" unless -f $file;

    $ftp->put($file);
}

sub get
{
    my $self = shift;
    my $remote_file = shift;
    my $local_file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;

    $ftp->get($remote_file, $local_file);
}

sub getline
{
    my $self = shift;

    die "FTP(getline): no data connection" unless exists $self->{'conn'};

    my $conn = $self->{'conn'};

    return $conn->getline;
}

sub getlines
{
    my $self = shift;

    die "FTP(getlines): no data connection" unless exists $self->{'conn'};

    my $conn = $self->{'conn'};

    return SIS::Array->new(@{$conn->getlines});
}
#
# Name of Release: $Name$
# $Log$
# Revision 1.4  2000/11/06 15:03:38  rlauer
# - documentation changes based on J.'s comments
#
# Revision 1.3  2000/11/02 20:30:02  rlauer
# - Back to SIS::Hash
# - Documentation!
# - added user, password, acct to constructor
# - beefed up the exception handling (i.e. actuall threw some!)
# - fixed read to iterate until it gets the right amount
# - added methods (stou, unique_name, appe, size)
#
#

=head1 SYNOPSIS

BLM::SIMPLEFTP -- Bedrock module for access FTP services (use with the understanding that
this is ALPHA.  A BLM named FTP will replace this module).

=head1 USAGE

=head2 Constructor

Invoke the constructor as follows.

  <null --define-var = "ftp" $Bedrock.new("BLM::SIMPLEFTP", $host, [$user, $password [,$acct]])>

If you supply the $user and $password the constructor will attempt to login to the 
ftp server specified by the $host argument.  Alternately, you can use the $ftp.login()
method.  For more information see the documentation for Net::FTP.

=head2 Methods

The following methods are availble:

=head3 $ftp.login( username, password, acct )

Login to the ftp server.

=head3 $ftp.quit()

Disconnect from an ftp server.

=head3 $ftp.cwd( [dir] )

Change the current working directory.

=head3 $ftp.pwd()

Return the current working directory

=head3 $ftp.ls( [dir] )

List the files (only the file names are returned) in a directory.

=head3 $ftp.dir( [dir] )

Retrieve file information for the files in a directory. If dir is not given
the current working directory is returned.

File attributes are returned as properties of the object returned by this
method.

 
 <table>
   <tr>
     <th>File</th>
     <th>Permissions</th>
     <th>Size</th>
     <th>Owner</th>
     <th>Group</th>
     <th>Timestamp</th>
   </tr>

 <foreach $ftp.dir('.')>
   <tr>
     <td><a href="/TagX/ftp.html?file=<var $file --URLEncode>"><var $file></a></td>
     <td><var $permissions></td>
     <td><var $size></td>
     <td><var $owner></td>
     <td><var $group></td>
     <td><var ($month+' '+$day+' '+$year)></td>
   </tr>
 </foreach>
 </table>

=head3 $ftp.put( local_file, remote_file )

Send a file to a host.

=head3 $ftp.get( remote_file, local_file )

Receive a file from a host.

=head3 $ftp.ascii()

Change the current mode of transfer to 'ASCII'

=head3 $ftp.binary()

Change the current mode of transfer to 'BINARY'

=head3 $ftp.retr( remote_file )

Open a file for reading.

=head3 $ftp.getlines()

Read all of the lines in a file.

=head3 $ftp.getline()

Read the next line in a file.

=head3 $ftp.close()

Close an open file.

=head3 $ftp.stor( file )

Open file on the host for writing.  This method returns a handle so should
be used as the argument to the C<SINK> tag.  The body of the C<SINK> tag becomes
the data to write to the file.

  <sink $ftp.stor('myfile.txt')>
    Hello World!
  </sink>

=head3 $ftp.stou()

Sames as $ftp.stor except a unique file name is created on the host.  The name
that is used is available using $ftp.unique_name.

=head3 $ftp.unique_name()

Returns the name of the unique file created using the $ftp.stou method.

=head3 $ftp.appe( file )

Same as $ftp.stor except the data is appended to file.  If the file does
not exist on the host it is created.

=head3 $ftp.size( file )

Returns the size of host file in bytes.

=head1 ChangeLog

  $Log$
  Revision 1.4  2000/11/06 15:03:38  rlauer
  - documentation changes based on J.'s comments

  Revision 1.3  2000/11/02 20:30:02  rlauer
  - Back to SIS::Hash
  - Documentation!
  - added user, password, acct to constructor
  - beefed up the exception handling (i.e. actuall threw some!)
  - fixed read to iterate until it gets the right amount
  - added methods (stou, unique_name, appe, size)


=head1 Author

Rob Lauer rlauer@cji.com

=head1 Credits

Graham Barr gbarr@pobox.com - Net::FTP

J. Sridhar sridharj@earhtlink.com - Bedrock Chief Technologist

=cut

1;
