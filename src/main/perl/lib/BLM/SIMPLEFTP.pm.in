#!/usr/local/bin/perl -w
# Simple FTP BLM
# ident "@(#) $Header$"


#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::SIMPLEFTP;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log 1.01;
use SIS::Handle;
use Net::FTP;    
use Time::Local;

@ISA = qw(SIS::Hash);

sub TIEHASH
{
    my $class = shift;
    my $host = shift;
    my ($user, $password, $acct) = @_;

    my $self = bless {}, $class;
    $self->{'host'} = $host;

    my $ftp = Net::FTP->new($host);

    die "FTP(connect): connect failed $@" unless defined $ftp;

    $self->{'ftp'} = $ftp;
  
    if ($user) {
	die "FTP(connect): login failed ($user, $password)" unless $ftp->login($user, $password, $acct);
    }

    $self;
}

sub CLOSE
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $self->{'conn'};

    $conn->close if defined $self->{'conn'};

    $ftp->quit if $ftp; 
}

sub login
{
    my $self = shift;
    
    my ($user, $pass, $acct) = @_;

    my $ftp = $self->{'ftp'};

    die "FTP(login): login failed ($user, $pass)" unless defined $ftp->login($user, $pass, $acct);
}

sub ascii
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->ascii();

    die "FTP(ascii): could not set type (ascii)" unless $last;

    $last;
}

sub binary
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->binary();

    die "FTP(binary): could not set type (binary)" unless $last;

    $last;
}

sub cwd
{
    my $self = shift;

    my $args = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->cwd($args);

    die "FTP(cwd): could not set dir ($args)" unless $last;

    $last;
}

sub pwd
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $pwd = $ftp->pwd();

    die "FTP(pwd): could not get current working directory" unless $pwd;

    $pwd;
}

sub ls
{
    my $self = shift;
    my $dir = shift;

    die "FTP(ls): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $dir = ($dir or ".");

    my @ls = $ftp->ls($dir);

    return SIS::Array->new(@ls);
}

sub size
{
    my $self = shift;
    my $file = shift;

    die "FTP(size): not connected" unless defined $self->{'ftp'};
    my $ftp = $self->{'ftp'};

    $ftp->size($file);
}

sub dir
{
    my $self = shift;
    my $dir = shift;
    
# sort field - same as field returned
    my ($sort, $asc_desc) = @_;
    
    my $ftp = $self->{'ftp'};

    my %Months = (Jan => 0,
		  Feb => 1,
		  Mar => 2,
		  Apr => 3,
		  May => 4,
		  Jun => 5,
		  Jul => 6,
		  Aug => 7,
		  Sep => 8,
		  Oct => 9,
		  Nov => 10,
		  Dec => 11 );
		   
    $dir = ($dir or ".");
    my @full_dir = $ftp->dir($dir);
    
    return undef unless @full_dir;

    shift @full_dir if $full_dir[0] =~ '^total';
    my @dir;

    foreach (@full_dir) {
	my @dummy = split " ", $_;
	my $ref = {};
	$ref->{'permissions'} = $dummy[0];
	$ref->{'links'} = $dummy[1];
	$ref->{'owner'} = $dummy[2];
	$ref->{'group'} = $dummy[3];
	$ref->{'size'} = $dummy[4];
	$ref->{'month'} = $dummy[5];
	$ref->{'day'} = $dummy[6];
	$ref->{'year'} = $dummy[7];
	$ref->{'file'} = $dummy[8];
	$ref->{'FILE'} = uc($dummy[8]);
	$ref->{'hour'} = 0;
	$ref->{'minute'} = 0;
	
        if ($dummy[7] =~ ':') {
	    my @temp_time = localtime(time);
	    my $year = 1900 + $temp_time[5];
	    my ($hours, $min) = split ':', $dummy[7];
	    $ref->{'hour'} = $hours;
	    $ref->{'minute'} = $min;
	    $ref->{'year'} = $year;
	    $ref->{'time'} = timelocal(0, $min, $hours, $dummy[6], $Months{$dummy[5]}, $year-1900);
	}
	else {
	    $ref->{'time'} = timelocal(0, 0, 0, $dummy[6], $Months{$dummy[5]}, $dummy[7]-1900);
	}	
	    
	push @dir, $ref;
    }
    
    $sort = ($sort or "file");
    $asc_desc = ($asc_desc or "asc");

    if ($sort =~ "(file|FILE|month|owner|permissions|group)") {
	if ($asc_desc eq "asc") {
	    @dir = sort { $BLM::SIMPLEFTP::a->{$sort} cmp $BLM::SIMPLEFTP::b->{$sort} } @dir;
	}
	else {
	    @dir = sort { $BLM::SIMPLEFTP::b->{$sort} cmp $BLM::SIMPLEFTP::a->{$sort} } @dir;
	}
    }
    else {
	if ($asc_desc eq "asc") {
	    @dir = sort { $BLM::SIMPLEFTP::a->{$sort} <=> $BLM::SIMPLEFTP::b->{$sort} } @dir;
	}
	else {
	    @dir = sort { $BLM::SIMPLEFTP::b->{$sort} <=> $BLM::SIMPLEFTP::a->{$sort} } @dir;
	}

    }

    return SIS::Array->new(@dir);
}

sub delete
{
    my $self = shift;

    die "FTP(delete): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    my $file = shift;

    $ftp->delete($file);
}

sub file_wait 
{
    my $self = shift;

    die "FTP(file_wait): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    my ($file, $wait, $poll_time, $errstr) = @_;

    die "FTP(file_wait): no file specified." unless $file;

    $wait = ($wait or 60);
    $poll_time = ($poll_time or 5);

    my @list;

    while ($wait > 0) {
	@list = $ftp->dir($file);
	last if @list;
	sleep($poll_time);
	$wait -= $poll_time;
    }

    my $ok = @list;

    die $errstr if ($errstr && !$ok);

    return $ok;
}

sub rename
{
    my $self = shift;
    my ($old_name, $new_name) = @_;

    die "FTP(rename): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $ftp->rename($old_name, $new_name);
}

sub quit
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    close($self) if defined $self->{'conn'};

    $ftp->quit;
    $self->{'ftp'} = undef;
}

sub stor 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->stor($file);

    die "FTP(stor): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub stou 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};
    
    my $conn = $ftp->stou($file);

    die "FTP(stou): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub unique_name
{
    my $self;

    die "FTP(unique_name) not connected" unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $ftp->unique_name;
}

sub retr
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->retr($file);

    die "FTP(retr): error opening file ($file) for reading" unless defined $conn;

    $self->{'conn'} = $conn;
}

sub read 
{
    my $self = shift;
    my ($size, $timeout) = @_;
    
    my $ftp = $self->{'ftp'};
    my $conn = $self->{'conn'};

    die "FTP(read): no data connection" unless defined $self->{'conn'};

    my $buffer;
    my $_buffer;

    $size = int($size);
    my $len;

    while (1) {
	last unless $len = $conn->read($_buffer, 1024, $timeout);
	$buffer .= $_buffer;
	$size -= $len;
	last unless ($size > 0);
    }

    die "FTP(read): error reading from host" if $size;

    $buffer;
}

sub write 
{
    my $self = shift;

    my ($buffer, $timeout) = @_;
    
    my $conn = $self->{'conn'};

    die "FTP(write): no data connection" unless defined $self->{'conn'};

    my $len = $conn->write($buffer, length($buffer), $timeout);

    die "FTP(write): error writing to host" unless $len == length($buffer);

    $buffer;
}

sub close
{
    my $self = shift;

    die "FTP(close): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};

    $conn->close;

    $self->{'conn'} = undef;
}

sub put
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;
    die "FTP(put): file does not exist" unless -f $file;

    $ftp->put($file);
}

sub get
{
    my $self = shift;
    my $remote_file = shift;
    my $local_file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;

    $ftp->get($remote_file, $local_file);
}

sub getline
{
    my $self = shift;

    die "FTP(getline): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};

    return $conn->getline;
}

sub getlines
{
    my $self = shift;
    my $nlines = shift;

    die "FTP(getlines): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};
    
    return SIS::Array->new(@{$conn->getlines}) unless $nlines;

    die "FTP(getlines): number of lines ($nlines) must be greater than 0." unless $nlines > 0;
    my @lines;

    while ($nlines--) {
	push @lines, $conn->getline();
    }

    return SIS::Array->new(@lines);
}
#
# Name of Release: $Name$
# $Log$
# Revision 1.8  2001/02/14 15:35:44  sridhar
# Added copyright and GPL notice
#
# Revision 1.7  2000/12/18 14:10:34  rlauer
# - some documentation cleanup
#
# Revision 1.6  2000/11/29 21:18:05  rlauer
# - added docs
# - fixed dir
# - fixed ascii/binary
# - various bad constructions
#
# Revision 1.5  2000/11/06 16:15:37  rlauer
# - incorrect exception handling for login, caught by J.
#
# Revision 1.4  2000/11/06 15:03:38  rlauer
# - documentation changes based on J.'s comments
#
# Revision 1.3  2000/11/02 20:30:02  rlauer
# - Back to SIS::Hash
# - Documentation!
# - added user, password, acct to constructor
# - beefed up the exception handling (i.e. actuall threw some!)
# - fixed read to iterate until it gets the right amount
# - added methods (stou, unique_name, appe, size)
#
#

=head1 NAME

C<BLM::SIMPLEFTP> - access methods of the Net::FTP package 

=head1 DESCRIPTION

Bedrock module for accessing FTP services.

=head1 OVERVIEW

C<BLM::SIMPLEFTP> provides access to FTP services for your web pages. Services provided
include; file transfer, directory listing, file creation and file reading to and from
an FTP host.  The BLM will throw exceptions on various error conditions.  It is the 
duty of the rocker to catch and handle these exceptions.

You are encouraged to read the documentation for C<Net::FTP> for more insight into the 
FTP process.  Oh, BTW...'man ftp' might be a good idea too.

Two of the more interesting features of this BLM are the ability to wait for a file and
throw an exception if the file does not appear after a specific timeout period and the 
ability to read files line by line.  The former feature is perfect for use with JetForm.
In that case, you typically need to create a job file for JetForm and then wait for it
to produce the output (PDF files).  You can then serve the PDF file to the web client.

Reading files line by line or all ones at once is useful for displaying files on remote
systems.

Why FTP?  Why not write some mojo that talks to the host and does whatever it is that you
need to do?

=over 4

=item *
FTP is ubiquitous (that means pervasive, that means EVERYWHERE!)

=item *
It's part of the standard installation of most sites

=item *
It works pretty well and we like to stand on the shoulders of other developers

=item *
It has many features and can perform a variety of duties

=item *
It can even be used on the same server as your webserver

=back

=head1 SYNOPSIS

 
    <sink>
      <null --define-var = "ftp" $Bedrock.new("BLM::SIMPLEFTP", "ftp.myhost.com", "joe", "eoj")>
      <null $ftp.cwd('/home/joe/pebbles')>
      <null $ftp.ascii()>
      <null $ftp.get('menu.peb')>
      <null $ftp.quit()>
    </sink>

    <sink>
      <null --define-var = "ftp" $Bedrock.new("BLM::SIMPLEFTP")>
      <null $ftp.login("drevil", "bigglesworth")>
      <null $ftp.cwd('/home/joe/pebbles')>
      <null $ftp.ascii()>
      <sink $ftp.stor('notes.txt')>
 It was the best of times, it was the worst of times...
 ...more later
      </sink>
      <null $ftp.quit()>
    </sink>

=head1 CONSTRUCTOR

    <null --define-var = "ftp" $Bedrock.new("BLM:SIMPLEFTP", host_name, [user_name, password])>

Creates an "FTP" object based upon the C<Net::FTP> perl module.  If you supply the C<$user> and
C<$password> arguments, the constructor will attempt to login to the 
ftp server specified by the C<$host> argument.  Alternately, you can use the C<$ftp.login()>
method.  An exception will be thrown if login or connection is not successful. For more information
see the documentation for C<Net::FTP>.

=head1 METHODS

Methods of the C<BLM::SIMPLEFTP> object throw exceptions...get your glove ready buckaroo!

=head2 $ftp.login( username, password, acct )

Login to the ftp server.

=head2 $ftp.quit()

Disconnect from an ftp server.

=head2 $ftp.cwd( [dir] )

Change the current working directory.

=head2 $ftp.pwd()

Return the current working directory

=head2 $ftp.ls( [dir] )

List the files (only the file names are returned) in a directory.

=head2 $ftp.dir( [dir], [sort field], [asc|desc] )

Retrieve file information for the files in a directory. If dir is not given
the current working directory is returned.

File attributes are returned as properties of the object returned by this
method.

 
 <table>
   <tr>
     <th>File</th>
     <th>Permissions</th>
     <th>Size</th>
     <th>Owner</th>
     <th>Group</th>
     <th>Timestamp</th>
   </tr>

 <foreach $ftp.dir('.')>
   <tr>
     <td><a href="/TagX/ftp.html?file=<var $file --URLEncode>"><var $file></a></td>
     <td><var $permissions></td>
     <td><var $size></td>
     <td><var $owner></td>
     <td><var $group></td>
     <td><var ($month+' '+$day+' '+$year)></td>
   </tr>
 </foreach>
 </table>

Sort field may be any of:

 file
 FILE (upper case of file name)
 time (number of seconds since 1970)
 month
 year
 day
 size
 owner
 permissions
 group
 links

Default is sort by file name.  Sort direction is 'asc' for ascending (default), 'desc' for descending

=head2 $ftp.put( local_file, remote_file )

Send a file to a host.

=head2 $ftp.get( remote_file, local_file )

Receive a file from a host.

=head2 $ftp.ascii()

Change the current mode of transfer to 'ASCII'

=head2 $ftp.binary()

Change the current mode of transfer to 'BINARY'

=head2 $ftp.retr( remote_file )

Open a file for reading. You must use the C<$ftp.read> or C<$ftp.getlines()> method
to retrieve data.  You should remember to C<$ftp.close()> the the file when
finished.

Example:

  <null $ftp.retr('myfile.txt')>
  <null --define-var = 'lines' $ftp.getlines()>
  <null $ftp.close()>

=head2 $ftp.read( nbyte )

Read at most nbytes of data from a file.  You must first open the file
using the C<$ftp.retr()> method.

Example:

 <null $ftp.retr('myfile.txt')>
 <null --define-var = "contents" $ftp.read($ftp.size('myfile.txt'))>
 <null $ftp.close()>

=head2 $ftp.getlines( nlines )

Read at most nlines of a file into an array object.  You must first open the 
file using C<$ftp.retr>.

=head2 $ftp.getline()

Read the next line in a file.

=head2 $ftp.close()

Close an open file.

=head2 $ftp.stor( file )

Open file on the host for writing.  This method returns a handle so should
be used as the argument to the C<sink> tag.  The body of the C<sink> tag becomes
the data to write to the file.

  <sink $ftp.stor('myfile.txt')>
    Hello World!
  </sink>

=head2 $ftp.stou()

Sames as C<$ftp.stor> except a unique file name is created on the host.  The name
that is used is available using C<$ftp.unique_name>.

=head2 $ftp.unique_name()

Returns the name of the unique file created using the C<$ftp.stou> method.

=head2 $ftp.appe( file )

Same as C<$ftp.stor> except the data is appended to file.  If the file does
not exist on the host it is created.

=head2 $ftp.size( file )

Returns the size of host file in bytes.

=head2 $ftp.rename(old_name, new_name)

Rename a file on the host from C<old_name> to C<new_name>.

=head2 $ftp.file_wait(file, timeout, poll_time)

Wait for timeout seconds  until a file exists.  poll_time 
indicates the number of seconds to sleep between checks
for the file's existence.

=head2 $ftp.delete( file ) 

Delete the file named file on the host.

=head1 CHANGELOG

  $Log$
  Revision 1.8  2001/02/14 15:35:44  sridhar
  Added copyright and GPL notice

  Revision 1.7  2000/12/18 14:10:34  rlauer
  - some documentation cleanup

  Revision 1.6  2000/11/29 21:18:05  rlauer
  - added docs
  - fixed dir
  - fixed ascii/binary
  - various bad constructions

  Revision 1.5  2000/11/06 16:15:37  rlauer
  - incorrect exception handling for login, caught by J.

  Revision 1.4  2000/11/06 15:03:38  rlauer
  - documentation changes based on J.'s comments

  Revision 1.3  2000/11/02 20:30:02  rlauer
  - Back to SIS::Hash
  - Documentation!
  - added user, password, acct to constructor
  - beefed up the exception handling (i.e. actuall threw some!)
  - fixed read to iterate until it gets the right amount
  - added methods (stou, unique_name, appe, size)


=head1 AUTHOR

Rob Lauer rlauer@cji.com

=head1 CREDITS

Graham Barr gbarr@pobox.com - Net::FTP

J. Sridhar sridharj@earhtlink.com - Bedrock Chief Technologist

=cut

1;
