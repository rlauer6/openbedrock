#!/usr/local/bin/perl -w
# Simple FTP BLM
# ident "@(#) $Header$"


package BLM::SIMPLEFTP;

use strict;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA);
    $VERSION	= do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use TagX::Log 1.01;
use SIS::Handle;
use Net::FTP;    
use Time::Local;

@ISA = qw(SIS::Hash);

sub TIEHASH
{
    my $class = shift;
    my $host = shift;
    my ($user, $password, $acct) = @_;

    my $self = bless {}, $class;
    $self->{'host'} = $host;

    my $ftp = Net::FTP->new($host);

    die "FTP(connect): connect failed $@" unless defined $ftp;

    $self->{'ftp'} = $ftp;
  
    if ($user) {
	die "FTP(connect): login failed ($user, $password)" unless $ftp->login($user, $password, $acct);
    }

    $self;
}

sub CLOSE
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $self->{'conn'};

    $conn->close if defined $self->{'conn'};

    $ftp->quit if $ftp; 
}

sub login
{
    my $self = shift;
    
    my ($user, $pass, $acct) = @_;

    my $ftp = $self->{'ftp'};

    die "FTP(login): login failed ($user, $pass)" unless defined $ftp->login($user, $pass, $acct);
}

sub ascii
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->ascii();

    die "FTP(ascii): could not set type (ascii)" unless $last;

    $last;
}

sub binary
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->binary();

    die "FTP(binary): could not set type (binary)" unless $last;

    $last;
}

sub cwd
{
    my $self = shift;

    my $args = shift;

    my $ftp = $self->{'ftp'};

    my $last = $ftp->cwd($args);

    die "FTP(cwd): could not set dir ($args)" unless $last;

    $last;
}

sub pwd
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    my $pwd = $ftp->pwd();

    die "FTP(pwd): could not get current working directory" unless $pwd;

    $pwd;
}

sub ls
{
    my $self = shift;
    my $dir = shift;

    die "FTP(ls): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $dir = ($dir or ".");

    my @ls = $ftp->ls($dir);

    return SIS::Array->new(@ls);
}

sub size
{
    my $self = shift;
    my $file = shift;

    die "FTP(size): not connected" unless defined $self->{'ftp'};
    my $ftp = $self->{'ftp'};

    $ftp->size($file);
}

sub dir
{
    my $self = shift;
    my $dir = shift;
    
# sort field - same as field returned
    my ($sort, $asc_desc) = @_;
    
    my $ftp = $self->{'ftp'};

    my %Months = (Jan => 0,
		  Feb => 1,
		  Mar => 2,
		  Apr => 3,
		  May => 4,
		  Jun => 5,
		  Jul => 6,
		  Aug => 7,
		  Sep => 8,
		  Oct => 9,
		  Nov => 10,
		  Dec => 11 );
		   
    $dir = ($dir or ".");
    my @full_dir = $ftp->dir($dir);
    
    return undef unless @full_dir;

    shift @full_dir if $full_dir[0] =~ '^total';
    my @dir;

    foreach (@full_dir) {
	my @dummy = split " ", $_;
	my $ref = {};
	$ref->{'permissions'} = $dummy[0];
	$ref->{'links'} = $dummy[1];
	$ref->{'owner'} = $dummy[2];
	$ref->{'group'} = $dummy[3];
	$ref->{'size'} = $dummy[4];
	$ref->{'month'} = $dummy[5];
	$ref->{'day'} = $dummy[6];
	$ref->{'year'} = $dummy[7];
	$ref->{'file'} = $dummy[8];
	$ref->{'FILE'} = uc($dummy[8]);
	$ref->{'hour'} = 0;
	$ref->{'minute'} = 0;
	
        if ($dummy[7] =~ ':') {
	    my @temp_time = localtime(time);
	    my $year = 1900 + $temp_time[5];
	    my ($hours, $min) = split ':', $dummy[7];
	    $ref->{'hour'} = $hours;
	    $ref->{'minute'} = $min;
	    $ref->{'year'} = $year;
	    $ref->{'time'} = timelocal(0, $min, $hours, $dummy[6], $Months{$dummy[5]}, $year-1900);
	}
	else {
	    $ref->{'time'} = timelocal(0, 0, 0, $dummy[6], $Months{$dummy[5]}, $dummy[7]-1900);
	}	
	    
	push @dir, $ref;
    }
    
    $sort = ($sort or "file");
    $asc_desc = ($asc_desc or "asc");

    if ($sort =~ "(file|FILE|month|owner|permissions|group)") {
	if ($asc_desc eq "asc") {
	    @dir = sort { $BLM::SIMPLEFTP::a->{$sort} cmp $BLM::SIMPLEFTP::b->{$sort} } @dir;
	}
	else {
	    @dir = sort { $BLM::SIMPLEFTP::b->{$sort} cmp $BLM::SIMPLEFTP::a->{$sort} } @dir;
	}
    }
    else {
	if ($asc_desc eq "asc") {
	    @dir = sort { $BLM::SIMPLEFTP::a->{$sort} <=> $BLM::SIMPLEFTP::b->{$sort} } @dir;
	}
	else {
	    @dir = sort { $BLM::SIMPLEFTP::b->{$sort} <=> $BLM::SIMPLEFTP::a->{$sort} } @dir;
	}

    }

    return SIS::Array->new(@dir);
}

sub delete
{
    my $self = shift;

    die "FTP(delete): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    my $file = shift;

    $ftp->delete($file);
}

sub file_wait 
{
    my $self = shift;

    die "FTP(file_wait): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    my ($file, $wait, $poll_time, $errstr) = @_;

    die "FTP(file_wait): no file specified." unless $file;

    $wait = ($wait or 60);
    $poll_time = ($poll_time or 5);

    my @list;

    while ($wait > 0) {
	@list = $ftp->dir($file);
	last if @list;
	sleep($poll_time);
	$wait -= $poll_time;
    }

    my $ok = @list;

    die $errstr if ($errstr && !$ok);

    return $ok;
}

sub rename
{
    my $self = shift;
    my ($old_name, $new_name) = @_;

    die "FTP(rename): not connected." unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $ftp->rename($old_name, $new_name);
}

sub quit
{
    my $self = shift;

    my $ftp = $self->{'ftp'};

    close($self) if defined $self->{'conn'};

    $ftp->quit;
    $self->{'ftp'} = undef;
}

sub stor 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->stor($file);

    die "FTP(stor): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub stou 
{
    my $self = shift;

    my $file = shift;

    my $ftp = $self->{'ftp'};
    
    my $conn = $ftp->stou($file);

    die "FTP(stou): error opening file ($file) for writing" unless defined $conn;

    $self->{'conn'} = $conn;

    $conn;
}

sub unique_name
{
    my $self;

    die "FTP(unique_name) not connected" unless defined $self->{'ftp'};

    my $ftp = $self->{'ftp'};

    $ftp->unique_name;
}

sub retr
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    my $conn = $ftp->retr($file);

    die "FTP(retr): error opening file ($file) for reading" unless defined $conn;

    $self->{'conn'} = $conn;
}

sub read 
{
    my $self = shift;
    my ($size, $timeout) = @_;
    
    my $ftp = $self->{'ftp'};
    my $conn = $self->{'conn'};

    die "FTP(read): no data connection" unless defined $self->{'conn'};

    my $buffer;
    my $_buffer;

    $size = int($size);
    my $len;

    while (1) {
	last unless $len = $conn->read($_buffer, 1024, $timeout);
	$buffer .= $_buffer;
	$size -= $len;
	last unless ($size > 0);
    }

    die "FTP(read): error reading from host" if $size;

    $buffer;
}

sub write 
{
    my $self = shift;

    my ($buffer, $timeout) = @_;
    
    my $conn = $self->{'conn'};

    die "FTP(write): no data connection" unless defined $self->{'conn'};

    my $len = $conn->write($buffer, length($buffer), $timeout);

    die "FTP(write): error writing to host" unless $len == length($buffer);

    $buffer;
}

sub close
{
    my $self = shift;

    die "FTP(close): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};

    $conn->close;

    $self->{'conn'} = undef;
}

sub put
{
    my $self = shift;
    my $file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;
    die "FTP(put): file does not exist" unless -f $file;

    $ftp->put($file);
}

sub get
{
    my $self = shift;
    my $remote_file = shift;
    my $local_file = shift;

    my $ftp = $self->{'ftp'};

    die "FTP(put): no connection" unless $ftp;

    $ftp->get($remote_file, $local_file);
}

sub getline
{
    my $self = shift;

    die "FTP(getline): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};

    return $conn->getline;
}

sub getlines
{
    my $self = shift;
    my $nlines = shift;

    die "FTP(getlines): no data connection" unless defined $self->{'conn'};

    my $conn = $self->{'conn'};
    
    return SIS::Array->new(@{$conn->getlines}) unless $nlines;

    die "FTP(getlines): number of lines ($nlines) must be greater than 0." unless $nlines > 0;
    my @lines;

    while ($nlines--) {
	push @lines, $conn->getline();
    }

    return SIS::Array->new(@lines);
}
#
# Name of Release: $Name$
# $Log$
# Revision 1.6  2000/11/29 21:18:05  rlauer
# - added docs
# - fixed dir
# - fixed ascii/binary
# - various bad constructions
#
# Revision 1.5  2000/11/06 16:15:37  rlauer
# - incorrect exception handling for login, caught by J.
#
# Revision 1.4  2000/11/06 15:03:38  rlauer
# - documentation changes based on J.'s comments
#
# Revision 1.3  2000/11/02 20:30:02  rlauer
# - Back to SIS::Hash
# - Documentation!
# - added user, password, acct to constructor
# - beefed up the exception handling (i.e. actuall threw some!)
# - fixed read to iterate until it gets the right amount
# - added methods (stou, unique_name, appe, size)
#
#

=head1 SYNOPSIS

BLM::SIMPLEFTP -- Bedrock module for access FTP services (use with the understanding that
this is ALPHA.  A BLM named FTP will replace this module).

=head1 USAGE

=head2 Constructor

Invoke the constructor as follows.

  <null --define-var = "ftp" $Bedrock.new("BLM::SIMPLEFTP", $host, [$user, $password [,$acct]])>

If you supply the $user and $password the constructor will attempt to login to the 
ftp server specified by the $host argument.  Alternately, you can use the $ftp.login()
method.  For more information see the documentation for Net::FTP.

=head2 Methods

The following methods are availble:

=head3 $ftp.login( username, password, acct )

Login to the ftp server.

=head3 $ftp.quit()

Disconnect from an ftp server.

=head3 $ftp.cwd( [dir] )

Change the current working directory.

=head3 $ftp.pwd()

Return the current working directory

=head3 $ftp.ls( [dir] )

List the files (only the file names are returned) in a directory.

=head3 $ftp.dir( [dir], [sort field], [asc|desc] )

Retrieve file information for the files in a directory. If dir is not given
the current working directory is returned.

File attributes are returned as properties of the object returned by this
method.

 
 <table>
   <tr>
     <th>File</th>
     <th>Permissions</th>
     <th>Size</th>
     <th>Owner</th>
     <th>Group</th>
     <th>Timestamp</th>
   </tr>

 <foreach $ftp.dir('.')>
   <tr>
     <td><a href="/TagX/ftp.html?file=<var $file --URLEncode>"><var $file></a></td>
     <td><var $permissions></td>
     <td><var $size></td>
     <td><var $owner></td>
     <td><var $group></td>
     <td><var ($month+' '+$day+' '+$year)></td>
   </tr>
 </foreach>
 </table>

Sort field may be any of:

 file
 FILE (upper case of file name)
 time (number of seconds since 1970)
 month
 year
 day
 size
 owner
 permissions
 group
 links

Default is sort by file name.  Sort direction is 'asc' for ascending (default), 'desc' for descending

=head3 $ftp.put( local_file, remote_file )

Send a file to a host.

=head3 $ftp.get( remote_file, local_file )

Receive a file from a host.

=head3 $ftp.ascii()

Change the current mode of transfer to 'ASCII'

=head3 $ftp.binary()

Change the current mode of transfer to 'BINARY'

=head3 $ftp.retr( remote_file )

Open a file for reading. You must use the $ftp.read or $ftp.getlines() method
to retrieve data.  You should remember to $ftp.close() the the file when
finished.

Example:

  <null $ftp.retr('myfile.txt')>
  <null --define-var = 'lines' $ftp.getlines()>
  <null $ftp.close()>

=head3 $ftp.read( nbyte )

Read at most nbytes of data from a file.  You must first open the file
using the $ftp.retr() method.

Example:

 <null $ftp.retr('myfile.txt')>
 <null --define-var = "contents" $ftp.read($ftp.size('myfile.txt'))>
 <null $ftp.close()>

=head3 $ftp.getlines( nlines )

Read at most nlines of a file into an array object.  You must first open the 
file using $ftp.retr.

=head3 $ftp.getline()

Read the next line in a file.

=head3 $ftp.close()

Close an open file.

=head3 $ftp.stor( file )

Open file on the host for writing.  This method returns a handle so should
be used as the argument to the C<SINK> tag.  The body of the C<SINK> tag becomes
the data to write to the file.

  <sink $ftp.stor('myfile.txt')>
    Hello World!
  </sink>

=head3 $ftp.stou()

Sames as $ftp.stor except a unique file name is created on the host.  The name
that is used is available using $ftp.unique_name.

=head3 $ftp.unique_name()

Returns the name of the unique file created using the $ftp.stou method.

=head3 $ftp.appe( file )

Same as $ftp.stor except the data is appended to file.  If the file does
not exist on the host it is created.

=head3 $ftp.size( file )

Returns the size of host file in bytes.

=head3 $ftp.rename(old_name, new_name)

Rename a file on the host from old_name to new_name.

=head3 $ftp.file_wait(file, timeout, poll_time)

Wait for timeout seconds  until a file exists.  poll_time 
indicates the number of seconds to sleep between checks
for the file's existence.

=head3 $ftp.delete( file ) 

Delete the file named file on the host.

=head1 ChangeLog

  $Log$
  Revision 1.6  2000/11/29 21:18:05  rlauer
  - added docs
  - fixed dir
  - fixed ascii/binary
  - various bad constructions

  Revision 1.5  2000/11/06 16:15:37  rlauer
  - incorrect exception handling for login, caught by J.

  Revision 1.4  2000/11/06 15:03:38  rlauer
  - documentation changes based on J.'s comments

  Revision 1.3  2000/11/02 20:30:02  rlauer
  - Back to SIS::Hash
  - Documentation!
  - added user, password, acct to constructor
  - beefed up the exception handling (i.e. actuall threw some!)
  - fixed read to iterate until it gets the right amount
  - added methods (stou, unique_name, appe, size)


=head1 Author

Rob Lauer rlauer@cji.com

=head1 Credits

Graham Barr gbarr@pobox.com - Net::FTP

J. Sridhar sridharj@earhtlink.com - Bedrock Chief Technologist

=cut

1;
