#!@PERL@ -w

# $Id$

package BLM::FileIO;

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA @EXPORT);
    $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use strict;

use Bedrock::Hash;
use Bedrock::Array;
use IO::File;
use IO::Handle;
use TagX::Scalar;

@ISA = qw(Bedrock::Hash);

=pod

=head1 PUBLIC

C<BLM::FileIO> - An interface to IO::File

=head1 SYNOPSIS

 <plugin:FileIO "/tmp/joe.dat" "w">

 <null $FileIO.print("blah blah blah")>
 <sink $FileIO.handle>

 Here's some text that will go into the file.
 </sink>

 <null $FileIO.close()>


 <plugin:FileIO>
 <while "$FileIO.getline(1)"><var $_>
 </while>

=head1 DESCRIPTION

The C<FileIO> plugin provides a facility for reading and writing files.

=head1 OVERVIEW

C<BLM::FileIO> allows enables Bedrock to read and write files to the
file system.  Remember, however, that Bedrock is running as the user
that Apache is running as (usually C<nobody>, C<apache>, C<www-data>
or some such application user, so your permissions are dictated by
that users rights on the file system.

=head1 CONSTRUCTOR

 <plugin:FileIO  pathname [mode]>

=over 5

=item * mode

"r" -> read

"w" -> write

"a" -> append

"r+" -> reading/writing

=back

If C<mode> is not given the file is opened in read-only mode.

If C<pathname> is not given, then STDIN is opened for reading.

=cut

sub TIEHASH
{
    my $class = shift;
    my $file = shift;
    my $mode = shift || "r";

    my $self = bless {}, $class;
    my $fh;

    if ( $file  ) { 
      $fh = IO::File->new($file, $mode);
    }
    else {
      $fh = new IO::Handle;
      $fh->fdopen(fileno(STDIN), "r");
    }

    die "FileIO: Could not open [$file]" unless $fh;

    $self->{'handle'} = $fh;

    $self;
}

sub DESTROY
{
    my $self = shift;

    $self->{'handle'}->close;
}

=pod

=head1 METHODS

=head2 close

=cut

# just over IO::Handle function calls
sub close
{
    my $self = shift;

    $self->{'handle'}->close;
}

=pod

=head2 getlines chomp-mode

Return a Bedrock array containing all of the lines of the file.  If
C<chomp-mode> is true, trailing new line characters will be removed.

 <plugin:FileIO "file.txt">
 <null:lines $FileIO.getlines(1)>

=head2 getline chomp-mode

Return a line from the file. Optinally remove new line.

 <plugin:FileIO "file.txt">
 <null:lines $FileIO.getlines(1)>

=head2 eof

=head2 flush

=head2 read

=head2 write

=head2 sysread

=head2 syswrite

=head2 truncate

=head2 getc

See C<IO::File> for a complete description of these methods.

=cut

sub getline { 
  
  my $handle = $_[0]->{'handle'};
  return undef if $handle->eof;

  my $line = $handle->getline;
  chomp $line if $_[1];

  return $line;
}

sub getlines { 
  my @lines = $_[0]->{'handle'}->getlines;
 
  @lines = map { s/[\n\r]//; $_; } @lines
    if $_[1];

  return Bedrock::Array->new( @lines );
}

sub eof { return $_[0]->{'handle'}->eof; }
sub flush { return $_[0]->{'handle'}->flush; }
sub read { my $self = shift; return $self->{'handle'}->read(@_); }
sub write { my $self = shift; return $self->{'handle'}->write(@_); }
sub sysread { my $self = shift; return $self->{'handle'}->sysread(@_); }
sub syswrite { my $self = shift; return $self->{'handle'}->syswrite(@_); }
sub truncate { my $self = shift; return $self->{'handle'}->truncate(@_); }
sub getc { return $_[0]->{'handle'}->getc; }

=pod

=head2 not_eof

Convenience routine for determining if you are NOT at the C<eof>
condition for a file handle.  You need this to implement a loop across a
file handle as show below.

  <while "$FileIO.not_eof()">
  ...
  </while>

I<Note that the construction:>

  <while "--not $FileIO.eof()">
  ...
  </while>

I<...will not work! Bedrock does not allow expressions as the while
loop argument. Bedrock essentially evaluates the value of the term as
a boolean.>

=cut

sub not_eof { return ! $_[0]->{'handle'}->eof; }

=pod

=head2 printf(FMT, [ARGS])

Formatted print, using 'C' style format string.

=cut

sub printf { my $self = shift; return $self->{'handle'}->printf(@_); }

=pod

=head2 print( data )

Write C<data> to file.

=cut

sub print { my $self = shift; return $self->{'handle'}->printf(@_); }

# see - man 'stat'

=pod

=head2 stat

I<See C<perlfunc stat> for more details>

As a convenience, the 8th, 9th, and 10th elements of the return array
which represent the last access time, modify time, and create time
respectively are returned as array objects since they are themselves
Unix time values.

I<See also C<BLM::Stat>, C<BLM::Date>>

=cut

sub stat
{
    my $self = shift;

    my @info = $self->{'handle'}->stat;
    my @tmp;
    for (my $i=8; $i<11; $i++) {
	# these elements are time doobies
	@tmp = localtime($info[$i]);
	# save the time doobie at the end of the array
	push(@tmp, $info[$i]);
	# co-erce them into a real array
	$info[$i] = Bedrock::Array->new(@tmp);
    }

    return Bedrock::Array->new(@info);
}

=head1 SEE ALSO

The C<open> tag may be more useful, as it returns an C<IO::File> handle.

=head1 AUTHOR

Rob Lauer - rlauer@signatureinfo.com

=head1 CREDITS

Just a wrapper on C<IO::File>.  Credit to that author.

=cut

1;                                                                                                                                                                                                         
# $Log$
# Revision 1.11  2011/08/31 02:43:42  eutl420
# - getline() now accepts chomp-mode as well
# - if no filename is given, then STDIN is opened, especially useful with bedrock shell
#
# Revision 1.10  2011/08/30 12:34:12  eutl420
# - added the chomp-mode option to getlines() to allow for automatic removal of new line
#   characters
# - if no file mode is given, then the file is opened "r" (read only)
#
# Revision 1.9  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.8  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.7  2010/11/20 18:47:26  rlauer
# - cleanup pod
#
# Revision 1.6  2010/11/15 02:27:56  rlauer
# - make PUBLIC, minor documentation tweaks
#
# Revision 1.5  2009/12/30 00:23:31  rlauer
# update docs for Bedrock II
#
