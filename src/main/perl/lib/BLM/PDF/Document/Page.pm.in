# ident "@(#) $Header$"
# ident "@(#)        $Name$"

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.org
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

package BLM::PDF::Document::Page;


BEGIN
{
   use Exporter ();
   use vars    qw ($VERSION @ISA);
}

use BLM::PDF::Document::Document;
use BLM::PDF::Render::Newline;
use BLM::PDF::Render::Text::Metrics;
use BLM::PDF::Text::Text;
use BLM::PDF::Text::Properties;

@ISA = qw(BLM::PDF::Document::Document PDF::Log);
use strict;

sub new
{
   my ($class, $root_document)  = @_;
   my $this 			= {};
   $$this{'outline_header_text'}= '';
   $$this{'parent'} 		= undef;
   $$this{'text_properties'}	= undef;
   $$this{'page_properties'}	= undef;
   $$this{'components'}		= [];
   $$this{'biggest_font'}       = 0; 
   $$this{'drop'}		= new BLM::PDF::Render::Newline;
   $$this{'peer'}		= undef;
   $$this{'x'}			= 0;

   # Further initialization from the parent
   BLM::PDF::Document::Document->new($this);
   $$this{'root_document'}	= $root_document;
   $root_document->_incPages();
   bless $this, $class;
   $this->addComponent($this->{'drop'});

   push @{$this->{'components'}}, $this;
   $this;
} # sub new

sub setOutlineText
{
   my $this = shift;
   my $text = shift;

   $$this{'outline_header_text'} = $text if defined($text) && length($text);
} # sub setOutlineText

sub getHeight 		  { ${_[0]}->{'page_properties'}->getHeight(); }
sub getWidth 		  { ${_[0]}->{'page_properties'}->getWidth(); }
sub getOutlineText	  { ${_[0]}->{'outline_header_text'}; }
sub getComponents	  { ${_[0]}->{'components'}; } 
sub getRootDocument	  { ${_[0]}->{'root_document'}; } 

sub setPeer
{
   my ($this, $peer) = @_;
   die 'Peer set to nonreference: \"$this\"' unless ref $peer;
   $$this{'peer'}    = $peer;
} # sub setPeer

sub getPeer 		{ ${_[0]}->{'peer'}; } 

sub setParent
{
   my ($this, $parent) = @_;
   die 'Parent set to nonreference: \"$this\"' unless ref $parent;
   $$this{'parent'} = $parent if ref $parent;
} # sub setParent

sub addComponent
{
   my ($this, $ob) = @_;

   push @{$this->{'components'}}, $ob if ref $ob;
} # sub addComponent

sub setTextProperties
{
   my $this = shift;
   my $properties = shift;
   $$this{'text_properties'} = $properties->copy() if ref $properties;
} # sub setTextProperties

sub setPageProperties
{
   my $this = shift;
   my $properties = shift;
   $$this{'page_properties'} = $properties->copy() if ref $properties;
} # sub setPageProperties

sub getPageProperties { ${_[0]}->{'page_properties'}->copy(); }

sub addText
{
   my $this = shift;
   my $text = shift;
   my $properties = $$this{'text_properties'};
   $text = $this->_collapseText($text, $properties);
   $this->addComponent($properties);
   my $size = $properties->getFontSize();

   my @lines = split "\n", $text;
   my $newlines = ($text =~ tr/\n//);
   my $i = $newlines;

   if( 0 == $i ) # Contining the same line, recalculate drop
   {
      $$this{'biggest_font'} = $size if $size > $$this{'biggest_font'};
   }
   else
   {
      $this->{'drop'}->setDrop(-($$this{'biggest_font'}+
				 $$this{'page_properties'}->getVerticalPad()));
      $this->{'drop'} = BLM::PDF::Render::Newline->new(-$size);
      $$this{'biggest_font'} = $size;
   }

   foreach my $line (@lines)
   {
      $this->addComponent(BLM::PDF::Text::Text->new($properties, $line));

      if( $i > 0 )
      {
         $this->addComponent($this->{'drop'});
      }
      $i--;
   }

   while( $i-- > 0 )
   {
      $this->addComponent($this->{'drop'});
   }

   $$this{'x'} = 0 if $newlines >= @lines;
} # sub addText


# $+ returns whatever the last bracket match matched. 
# $& returns the entire matched string. 
# ($0 used to return the same thing, but not any more.) 
# $` returns everything before the matched string. 
# $' returns everything after the matched string. Examples: 

sub _collapseText
{
   my ($this, $text, $text_properties) = @_;
   my $page_properties = $$this{'page_properties'};
   my $left_margin     = 72*$page_properties->getLeftMargin();
   my $right_margin    = $this->getWidth()-(72*$page_properties->getRightMargin());
   my $line_width      = $right_margin-$left_margin;	
   my $metrics = BLM::PDF::Render::Text::Metrics->new($text_properties, 
				           $text_properties->getFont());
   my $fontsize 	    = $text_properties->getFontSize();
   my $newlines             = ($text =~ tr/\n//);
   my @lines                = split "\n", $text;
   my @collapsed            = ();
   my $ignore_leading_space = $page_properties->getDiscardLeadingSpace();
   my $specials_are_words   = $text_properties->getTreatSpecialsAsWords();

   push @lines, map { '' } (1..($newlines-@lines+1));

   my $x = $$this{'x'};
   $x = $left_margin unless $x >= $left_margin;

   foreach my $line (@lines)
   {
      my @collected 	= ();
      my $width 	= $metrics->stringWidth($line, $fontsize);

      if( $x+$width <= $right_margin )
      {  
         push @collapsed, $line;
	 $x += $width;
      }
      else
      {
	 $_ = $line;
         print STDERR "\"$line\" doesnt fit\n";

         while( length $_ )
	 {
	    my ($matched, $rest);
	    my $is_spaces = 0;

            if( $specials_are_words )
            { 
               /^\S+/ or  ($is_spaces = $_ =~ /^\s+/); 
	       ($matched, $rest) = ($&, $');
            }
            else 
            { 
               /^\w+/ or  ($is_spaces = $_ =~ /^\s+/) or /^\W+/; 
	       ($matched, $rest) = ($&, $');
            }

	    my $word_width = $metrics->stringWidth($matched, $fontsize);
            #print STDERR "WIDTH: $word_width\n";

	    if( $x+$word_width <= $right_margin )
	    {
	       push @collected, $matched unless $ignore_leading_space && 
			        $is_spaces && 0 == @collected;
	       $x += $word_width;
	    }
	    else
	    { 
	       if( $left_margin+$word_width < $line_width )
	       { 
	          push @collapsed, join '', @collected;
	          $x = $left_margin;
	          @collected = ();

		  push @collected, $matched; 
	          $x += $word_width;
	       }
               else  
	       {
	          my @split =
                       $this->_splitLongText($text, $metrics, $fontsize,
			                     $line_width, $right_margin-$x);

		  #print STDERR "SPLIT INTO:\n", join("\n", @collapsed);
	          push @collapsed, @split;
	          $x += $metrics->stringWidth($split[-1],$fontsize);
	       }
	    }
	    $_ = $rest;
	 }
	 push @collapsed, join '', @collected;
      }
   }
   $$this{'x'} = $x;

   join "\n", @collapsed;
} # sub _collapseText

sub _splitLongText
{
   my ($this, $text, $metrics, $fontsize, $line_width, $first_remaining) = @_;
   my @broken = ();

   print STDERR "Long segment started at: $$this{'x'}\n";
   my $getFittedSubstring = sub
   {
      my ($string, $threshold) = @_;
      my ($fit, $remain);
      my $length = $metrics->stringWidth($string, $fontsize);
      #print STDERR "Length: \"$string\"($fontsize) $length Threshold: $threshold\n";

      if( $metrics->stringWidth($string, $fontsize) <= $threshold )
      {
         ($fit, $remain) = ($string, '');
      }
      else
      {
         $_ = $string;
         my ($i, $length) = (1, 0);

         for( ;; $i++ )
         {
            /.{$i}?/;
            $length = $metrics->stringWidth($&, $fontsize);

            if( $length > $threshold )
	    {
               ($fit, $remain) = ($&, $');
               $remain .= chop $fit unless length $remain == 1;
	       last;
	    }
	    last unless length $';
         } 
      }
      ($fit, $remain);
   }; # sub getFittedSubstring
   
   my ($fit, $remain) = 
     $getFittedSubstring->($text, $first_remaining);

   push @broken, $fit;

   while( length $remain )
   {
      ($fit, $remain) = 
         $getFittedSubstring->($remain, $line_width);

      #print STDERR "FIT: $fit REMAIN: $remain\n";
      push @broken, $fit;
   }

   @broken;
} # sub _splitLongText

sub getTextProperties
{
   my $this = shift;
   my $parent = $$this{'parent'};
   die "Page has no parent!" unless defined $parent;
   my $properties = $$this{'text_properties'};
   $properties->copy();
} # sub getTextProperties

sub close
{
   my $this = shift;
   # This ensures one-line non newline terminated pages are handled correctly
   $this->addText("\n");
   # Add headers and footers
   my $page_properties = $$this{'page_properties'};
   my @aligns = ('Left', 'Center', 'Right');
   my @funcs = ('', 'Font', 'Color', 'Size');
   # Font, Color, Size

   foreach my $type (map { (["${_}Header", $_, 'top',], 
                            ["${_}Footer", $_, 'bottom']); } @aligns)
   {
      my $text_properties = new BLM::PDF::Text::Properties;
      my $font = $text_properties->getFont();
      my $prefix = 'get'.$type->[0];
      my $text = $page_properties->${prefix}();

      if( defined $text )
      {
         $text_properties->setAlign($type->[1]);
         $text_properties->setVAlign($type->[2]);
         $text_properties->setColor($page_properties->${\"${prefix}Color"}());
         $text_properties->setFontSize($page_properties->${\"${prefix}FontSize"}());
         $font->setFontName($page_properties->${\"${prefix}FontName"}());
         $this->setTextProperties($text_properties);
	 $this->addText($text);
      }
   }
} # sub close

1;

__END__

=pod

=head1 Synopsis

   use BLM::PDF::Document::Page

   Create a page object that includes text (and possibly other)
   components that describe its the visual charateristics.
   These objects should never be created by a call to the constructor
   'new'. Page objects are created by either calling the subroutine
   'newPage' in an instance of either BLM::PDF::Document::Document or 
   this class.

=over 4

=item *
Subroutine

B<Name:>           setOutlineText

B<Synopsis:>       Sets the outline text 

   If the document to be generated will allow the outline
   objects to be built for document navigation (via a call 
   to setUseOutlines through a reference the parent document,
   see the documentation for BLM::PDF::Document::Document)
   then the outline item corresponding to the page is 
   determined by the value set by this subroutine. This text
   will appear with the outline item that user clicks on to
   jump to the page.

   

B<Arguments:>      A string.

B<Default:>        undef

B<Example:>

   $pageone->setOutlineText('License Agreement and Conditions of Use');

   Here, we may have an outline structure with three major subheadings
   with the second, 'Overview', having two subheadings. If a user
   wanted to jump to the first page of 'Goals', they would click the
   item with the mouse.
   
   [] - License Agreement and Conditions of Use
   [] - Overview
     | [] - What is X?
     | [] - Goals
   [] - Credits

=item *
Subroutine

B<Name:>           getOutlineText

B<Synopsis:>       Returns the outline text

B<Arguments:>      None

B<Returns:>        A string or undef(if setOutlineText 
                   was never called)

B<Default:>        undef

B<Example:>

   my $outline_text = $pageone->getOutlineText();

=item *
Subroutine

B<Name:>           setHeight

B<Synopsis:>       Sets the height of the page

   Sets the height of the page, measured in user space units. 
   (probably 1/72 dpi <dots per inch>)

B<Arguments:>      A non-negative integer. 

B<Default:>        undef

B<Example:>

   $pageone->setHeight(590);

=item *
Subroutine

B<Name:>           setSize

B<Synopsis:>       Sets the height and width of the page.

B<Arguments:>      One of the following values under 'Name'

  One of the following values in the 'Name' column may
  be passed.

    Name           Height	Width
    ---------------------------------
    letter	   8.5          11
    legal          8.5          14
    executive      7.5          10.5
    a4             8.27         11.69
    a5             5.83         8.27
    ---------------------------------
    * Units given in inches.
   
B<Example:>

   $pageone->setSize('a4');

=item *
Subroutine

B<Name:>           getHeight

B<Synopsis:>       Returns the height of the page

   This value is measured in the default user space units
   (probably 1/72 dpi)

B<Arguments:>      None

B<Returns:>        A non-negative integer

B<Default:>        590

B<Example:>

   $pageone->setHeight(590);

=item *
Subroutine

B<Name:>           setWidth

B<Synopsis:>       Sets the width of the page

   Sets the width of the page, measured in user space units. 
   (probably 1/72 dpi)

B<Arguments:>      A non-negative integer. 

B<Default:>        undef

B<Example:>

   $pageone->setWidth(792);

=item *
Subroutine

B<Name:>           getWidth

B<Synopsis:>       Returns the width of the page

   This value is measured in the default user space units
   (probably 1/72 dpi)

B<Arguments:>      None

B<Returns:>        A non-negative integer

B<Default:>        792

B<Example:>

   $pageone->setWidth(792);

=item *
Subroutine

B<Name:>           setPageProperties

B<Synopsis:>       Set the properties for this page

   A COPY will be made of the passed reference's instance 
   data, therefore subsequent state transitions in the 
   passed reference will have no effect the page unless 
   this subroutine is called again with the reference as the
   argument.

   See the perldoc documentation for
   BLM::PDF::Document::Page::Properties
   for further information.

B<Arguments:>      BLM::PDF::Document::Page::Properties reference

B<Example:>

   my $page_properties = new BLM::PDF::Document::Page::Properties;
   # Set all margins
   map { $page_properties->${_}(1); }
     ( 'setTopMargin', 'setBottomMargin',
       'setLeftMargin', 'setRightMargin', );
   $pageone->setPageProperties($page_properties);

=item *
Subroutine

B<Name:>           getPageProperties

B<Synopsis:>       Returns a reference to a COPY of the current
                   page properties.

B<Arguments:>      None

B<Example:>

   my $page_properties = $pageone->getPageProperties();

=item *
Subroutine

B<Name:>           setTextProperties

B<Synopsis:>       Set the text properties to be inherited by
                   descendant pages.

   A COPY will be made of the passed reference's instance 
   data, therefore subsequent state transitions in the 
   reference will have no effect on the page unless
   subroutine is called again with the reference as the 
   argument.

   See the perldoc documentation for BLM::PDF::Text::Properties
   for further information.

B<Arguments:>      BLM::PDF::Text::Properties reference

B<Example:>

   my $text_properties = new BLM::PDF::Text::Properties;
   $text_properties->setColor('#3333FF');
   $text_properties->setAlign('center');
   $pageone->setTextProperties($text_properties);

=item *
Subroutine

B<Name:>           getTextProperties

B<Synopsis:>       Returns a reference to a COPY of the current
                   text properties.

B<Arguments:>      None

B<Example:>

   my $text_properties = $pageone->getTextProperties();

=item *
Subroutine

B<Name:>           addText

B<Synopsis:>       Adds text to the page.

   The text to be added will inherit the page and text 
   properties at the time this subroutine is invoked.
   Over successive calls, text added to the page will flow
   from left to right, top to bottom. Words that are too
   long to fit horizontally will be moved to the next line
   if and only if it is smaller than the width of an empty
   line. A very large word (one that is longer than the width
   of an empty line), will be wrapped beginning on the line 
   it was inserted. 'Words' are perl's '\w'. Special characters
   outside of '_' are treated atomically. However, this 
   behaviour may be altered. See BLM::PDF::Text::Propreties.

B<Arguments:>      A string

B<Example:>

   my $pageone->addText('Hello World');

=back 

=cut

#
# Name of Release: $Name$
# $Log$
# Revision 1.9  2001/02/14 15:35:44  sridhar
# Added copyright and GPL notice
#
# Revision 1.8  2001/02/14 15:24:46  sridhar
# added CVS headers and trailers
#
#
