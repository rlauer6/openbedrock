package BLM::PDF::Document::Page;


BEGIN
{
   use Exporter ();
   use vars    qw ($VERSION @ISA);
}

use BLM::PDF::Defaults;
use BLM::PDF::Document::Document;
use BLM::PDF::Render::Newline;
use BLM::PDF::Render::Text::Metrics;
use BLM::PDF::Text::Text;
use BLM::PDF::Text::Properties;

@ISA = qw(BLM::PDF::Document::Document PDF::Log);
use strict;

my %page_dimensions = 
(
   'letter'                     => [8.5,  11],
   'legal'                      => [8.5,  14],
   'executive'                  => [7.5,  10.5],
   'a4'                         => [8.27, 11.69],
   'a5'                         => [5.83, 8.27],
);

sub new
{
   my ($class, $root_document) = @_;
   my $this = {};
   $$this{'outline_header_text'}= '';
   $$this{'parent'} 		= undef;
   $$this{'text_properties'}	= undef; #new BLM::PDF::Text::TextProperties;
   $$this{'page_properties'}	= undef; #new BLM::PDF::Document::Page::Properties;
   $$this{'components'}		= [];
   $$this{'biggest_font'}       = 0; #$this->{'text_properties'}->getFontSize();
   $$this{'drop'}		= new BLM::PDF::Render::Newline;
   $$this{'width'}		= $BLM::PDF::Defaults::Defaults{'page_width'}*72;
   $$this{'height'}		= $BLM::PDF::Defaults::Defaults{'page_height'}*72;
   $$this{'peer'}		= undef;

   BLM::PDF::Document::Document->new($this);
   $$this{'root_document'}	= $root_document;
   $root_document->_incPages();
   bless($this, $class);
   $this->addComponent($this->{'drop'});

   push @{$this->{'components'}}, $this;
   $this;
} # sub new

sub setOutlineText
{
   my $this = shift;
   my $text = shift;

   $$this{'outline_header_text'} = $text if defined($text) && length($text);
} # sub setOutlineText

sub getHeight 		  { ${_[0]}->{'height'}; }
sub getWidth 		  { ${_[0]}->{'width'}; }
sub getOutlineText	  { ${_[0]}->{'outline_header_text'}; }
sub getComponents	  { ${_[0]}->{'components'}; } 
sub getRootDocument	  { ${_[0]}->{'root_document'}; } 

sub setPeer
{
   my $this = shift;
   $$this{'peer'} = shift;
} # sub setPeer

sub getPeer 		{ return ${_[0]}->{'peer'}; } 

sub setParent
{
   my $this = shift;
   my $obj = shift;

   $$this{'parent'} = $obj if ref $obj;
} # sub setParent

sub addComponent
{
   my $this = shift;
   my $ob = shift;

   if( ref $ob )
   {
      push @{$this->{'components'}}, $ob;
   }
} # sub addComponent

sub setTextProperties
{
   my $this = shift;
   my $properties = shift;
   $$this{'text_properties'} = $properties->copy() if ref $properties;
} # sub setTextProperties

sub setPageProperties
{
   my $this = shift;
   my $properties = shift;
   $$this{'page_properties'} = $properties->copy() if ref $properties;
} # sub setPageProperties

sub getPageProperties { ${_[0]}->{'page_properties'}->copy(); }

sub addText
{
   my $this = shift;
   my $text = shift;
   my $properties = $$this{'text_properties'};
   $text = $this->_collapseText($text, $properties);
   $this->addComponent($properties);
   my $size = $properties->getFontSize();

   my @lines = split "\n", $text;
   my $newlines = ($text =~ tr/\n//);
   my $i = $newlines;

   if( $i == 0 ) # Contining the same line, recalculate drop
   {
      $$this{'biggest_font'} = $size if $size > $$this{'biggest_font'};
   }
   else
   {
      $this->{'drop'}->setDrop(-($$this{'biggest_font'}+
				 $$this{'page_properties'}->getVerticalPad()));
      $this->{'drop'} = BLM::PDF::Render::Newline->new(-$size);
      $$this{'biggest_font'} = $size;
   }

   foreach my $line (@lines)
   {
      if( $i )
      {
         $this->addComponent($this->{'drop'});
      }
      $i--;
      $this->addComponent(BLM::PDF::Text::Text->new($properties, $line));
   }

   while( $i-- > 0 )
   {
      $this->addComponent($this->{'drop'});
   }
} # sub addText

=begin comment

$+ returns whatever the last bracket match matched. 
$& returns the entire matched string. 
($0 used to return the same thing, but not any more.) 
$` returns everything before the matched string. 
$' returns everything after the matched string. Examples: 

=cut

sub _collapseText
{
   my ($this, $text, $text_properties) = @_;
   my $page_properties = $$this{'page_properties'};
   my $left_margin     = 72*$page_properties->getLeftMargin();
   my $right_margin    = $this->getWidth()-(72*$page_properties->getRightMargin());
   my $metrics = BLM::PDF::Render::Text::Metrics->new($text_properties, 
				           $text_properties->getFont());
   my $fontsize = $text_properties->getFontSize();
   my $newlines             = ($text =~ tr/\n//);
   my @lines                = split "\n", $text;
   my @collapsed            = ();
   my $ignore_leading_space = $page_properties->getDiscardLeadingSpace();

   push @lines, map { '' } (1..($newlines-@lines+1));

   foreach my $line (@lines)
   {
      my @collected 	= ();
      my $x 		= $left_margin;
      my $width 	= $metrics->stringWidth($line, $fontsize);

      #print STDERR "LINE: ".($x+$width)." RIGHT: $right_margin\n";
      if( $x+$width < $right_margin )
      {
         push @collapsed, $line;
      }
      else
      {
	 my $panic = 0;
	 $_ = $line;
	 #print STDERR "LINE: \"$_\"\n";

         while( length $_ && ++$panic < 20 )
	 {
	    my $is_spaces = 0;
	    /^\w+/ or  ($is_spaces = $_ =~ /^\s+/) or /^\W+/;

	    #print STDERR "TOKEN: \"$&\"\n";
	    #print STDERR "IS SPACE: ", $is_spaces ? "YES" : "NO", "\n";
	    my $word_width = $metrics->stringWidth($&, $fontsize);
	    #print STDERR "Current Word Width: $word_width\n";
	    #print STDERR "$x/$right_margin\n";

	    if( $x+$word_width < $right_margin )
	    {
	       unless( $is_spaces || $
	       push @collected, $& unless $ignore_leading_space && 
			        $is_spaces && 0 == @collected;
	       $x += $word_width;
	    }
	    else
	    { 
	       if( @collected > 0 )
	       {
	          push @collapsed, join '', @collected;
		  $x = $left_margin;
	          @collected = ();
		  if( $x+$word_width < $right_margin )
		  { push @collected, $&; }
	       }
	    }
	    $_ = $';
	 }
	 push @collapsed, join '', @collected;
      }
   }

   #print STDERR "COLLAPSED: [", join("\n", @collapsed), "]\n";
   join "\n", @collapsed;
} # sub _collapseText

=begin comment
	       else # An unbroken word extending past the margin 
	       { # First fit what we can on current line
                  print STDERR "LONG UNBROKEN [$word]\n";
	          my ($i, $length) = (1, length $word);
		  my $sub = substr $word, 0, $i;
		  my $sub_width = $metrics->stringWidth($sub, $fontsize);

	          while( $sub_width+$x < $right_margin && $i <= $length )
	          {
	            $sub = substr $sub, 0, ++$i;
		    $sub_width = $metrics->stringWidth($sub, $fontsize);
	          }

		  chop $sub;
	          push @collapsed, $sub;

	 	  $sub = substr $word, $i;
	         
	          # Now break the rest of the word into parts that
	 	  # span entire lines until it is exhausted
	          while( length )
		  {
	             my ($i, $length) = (1, length $sub);
		
		     while( $i < $length && $left_margin+
	                    $metrics->stringWidth(substr($sub, 0, $i), $fontsize) )
	  	     { $i++ }
		     push @collapsed, substr $sub, 0, $i;
		     $sub = substr $sub, $i;
	          }
    	       }
=cut
sub getTextProperties
{
   my $this = shift;
   my $parent = $$this{'parent'};
   die "Page has no parent!" unless defined $parent;
   my $properties = $$this{'text_properties'};
   return $properties->copy();
} # sub getTextProperties

sub close
{
   my $this = shift;
   # This ensures one-line non newline terminated pages are handled correctly
   $this->addText("\n");
   # Add headers and footers
   my $page_properties = $$this{'page_properties'};
   my @aligns = ('Left', 'Center', 'Right');
   my @funcs = ('', 'Font', 'Color', 'Size');
   # Font, Color, Size

   foreach my $type (map { (["${_}Header", $_, 'top',], 
                            ["${_}Footer", $_, 'bottom']); } @aligns)
   {
      #print STDERR "Adding ".$type->[0]." ".$type->[1]."\n";
      my $text_properties = new BLM::PDF::Text::Properties;
      my $font = $text_properties->getFont();
      my $prefix = 'get'.$type->[0];
      #print STDERR "PREFIX: $prefix\n";
      my $text = $page_properties->${prefix}();

      if( defined $text )
      {
         #print STDERR "Text: $text\n";
         #print STDERR "$prefix => $text\n";
         #print STDERR "COLOR: ",$page_properties->${\"${prefix}Color"}(), "\n";
         $text_properties->setAlign($type->[1]);
         $text_properties->setVAlign($type->[2]);
         $text_properties->setColor($page_properties->${\"${prefix}Color"}());
         $text_properties->setFontSize($page_properties->${\"${prefix}FontSize"}());
         #print STDERR "SIZE: ",$page_properties->${\"${prefix}FontSize"}(), "\n";
         $font->setFontName($page_properties->${\"${prefix}FontName"}());
         #print STDERR "FONT: ",$page_properties->${\"${prefix}FontName"}(), "\n";
         $this->setTextProperties($text_properties);
	 $this->addText($text);
      }
   }
} # sub close

1;
