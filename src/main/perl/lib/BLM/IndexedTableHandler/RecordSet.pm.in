#!/usr/bin/perl

# $Id$

package BLM::IndexedTableHandler::RecordSet;

use strict;
use SIS::Array;
use BLM::IndexedTableHandler::Common qw( create_html_element
					 create_label_name
					 create_xhtml_element
					 create_radio_buttons
					 create_select_list
				      );

BEGIN
{
    use Exporter ();
    use vars	qw ($VERSION @ISA @ENV @EXPORT_OK @EXPORT);
    $VERSION	= 1.02;
}


@ISA = qw(SIS::Array);

=pod

=head1 NAME

BLM::IndexedTableHandler::RecordSet

=head1 SYNOPSIS

    my $record_set = BLM::IndexedTableHandler::RecordSet->new(@list);

=head1 DESCRIPTION

Creates an object which represents a set of rows from a MySQL table.
Each element of the record set is a C<BLM::IndexedTableHandler>
object.

=head1 METHODS

=cut

=pod

=head2 html_form_header

=cut

sub html_form_header {
    my $self = shift;
    my $attributes = shift || {};
    my $table_name = $self->[0]->{_table};

    return create_html_element('form', (name=> $table_name.'_set', method=>"post", action => $ENV{PATH_INFO}), %$attributes);
}

=pod

=head2 html_form_footer

=cut

sub html_form_footer {
    my $self = shift;
    my $attributes = shift || {};

    my $table_name = $self->[0]->{_table};

    return sprintf("%s\n%s\n%s\n%s\n",
		   create_html_element('input', (type => 'hidden', name=> 'action', value => 'edit')),
		   create_html_element('input', (type => 'hidden', name => 'table', value => $table_name)),
		   create_html_element('input', (type => 'submit', value => 'Edit'), %{$attributes}),
		   "</form>"
	);
}

=pod

=head2 html_form_body

=cut

sub html_form_body {
    my $self = shift;
    my $labels = shift || {};
    my $attributes = shift || {};
    my $fields = shift;

    my $html= create_html_element('table', %{$attributes->{table}});

    $html .= sprintf("%s\n", create_html_element('tr', %{$attributes->{tr}}));

    my @columns;
    if ($fields) {
	@columns = @$fields;
    }
    else {
	@columns =  @{$self->[0]->fields()};
    }

    foreach ("&nbsp;", @columns) {
	next if $_ eq 'id';
	$html .= sprintf("%s%s</th>\n", 
			 create_html_element('th', %{$attributes->{th}}), 
			 $labels->{$_} || create_label_name($_));
    }

    $html .= "</tr>\n";

    foreach my $rec (@{$self}) {

	$html .= sprintf("%s\n", create_html_element('tr', %{$attributes->{tr}}));
	foreach ("idx", @columns) {
	    next if $_ eq 'id';
	    if ($_ eq 'idx') {
		$html .= sprintf("%s%s</td>\n",
				 create_html_element('td', %{$attributes->{td}}),
				 create_html_element('input', (type => 'radio', name => 'id', value => $rec->{id}), %{$attributes->{input}})
				 );
		    }
	    else {
	    $html .= sprintf("%s%s</td>\n", 
			     create_html_element('td', %{$attributes->{td}}),
			     $rec->get($_)
		);
	    }
	}

	$html .= "</tr>\n";
    }

    $html .= "</table>\n";

    return $html;
}

=pod

=head1 NOTES

=head1 AUTHOR

rlauer@signatureinfo.com

=cut

1;


# $Log$
# Revision 1.3  2008/12/03 14:01:19  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.2  2008/11/25 19:04:13  rlauer
# changes based on Bedrock 2.0 migration plan
#
