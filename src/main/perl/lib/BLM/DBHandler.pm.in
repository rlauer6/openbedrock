package BLM::DBHandler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock::Array;
use Bedrock::Constants qw{:booleans :chars};
use Carp;
use DBI;
use Data::Dumper;
use Digest::MD5 qw(md5_hex);
use Scalar::Util qw/reftype/;
use Benchmark qw(:all :hireswallclock);

use Readonly;

Readonly our $DEFAULT_MAX_ROWS    => 100;
Readonly our $MAX_HISTORY_ENTRIES => 5;
Readonly our $ISO_8601_FORMAT     => '%Y-%m-%dT%TZ';

__PACKAGE__->_create_accessors(
  qw{
    rows
    mysql_insertid
    return_bedrock_refs
    _query
    max_history
  }
);

use parent qw(Bedrock::Hash);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)
our $BENCHMARK;

########################################################################
sub new {
########################################################################
  my ( $class, $dbi, %options ) = @_;

  die 'usage: BLM::DBHandler->new(dbi-handle, key, value, ...)'
    if !ref $dbi || ref($dbi) !~ /DBI::db/xsm;

  $options{max_rows}            //= $DEFAULT_MAX_ROWS;
  $options{return_bedrock_refs} //= $TRUE;
  $options{max_history}         //= $MAX_HISTORY_ENTRIES;

  if ( exists $options{auto_commit} ) {
    $dbi->{AutoCommit} = delete $options{auto_commit};
  }

  foreach ( keys %options ) {
    $options{"_$_"} = delete $options{$_};
  }

  my $self = $class->SUPER::new(
    _db  => $dbi,
    _dbi => $dbi,
    %options,
  );

  $self->set_auto_commit( $dbi->{AutoCommit} );

  $self->track_all();

  return $self;
}

########################################################################
sub track {
########################################################################
  my ( $self, $arg, $state ) = @_;

  if ($state) {
    $self->{ '__' . $arg } = [];
  }
  else {
    delete $self->{ '__' . $arg };
  }

  return $self;
}

########################################################################
sub show_history {
########################################################################
  my ( $self, $style, $format ) = @_;

  require Text::ASCIITable;

  my $t = Text::ASCIITable->new( { headingText => 'History' } );
  $t->setCols( 'Index', 'Query', 'Arguments', 'Time' );
  $t->setOptions( { headingAlign => 'center', alignHeadRow => 'center' } );

  $t->setColWidth( 'Query', 50, 1 );

  $t->alignCol(
    { 'Index' => 'center', 'Arguments' => 'left', 'Time' => 'center' } );

  foreach my $row ( @{ $self->history } ) {
    my @cols = @{$row};

    if ( ref $cols[3] ) {
      if ( $style && $format ) {
        $cols[3] = timestr( timediff( @{ $cols[3] } ), $style, $format );
      }
      else {
        $format //= '%08.5f';
      }
      my $t0 = $cols[3]->[1];
      my $t1 = $cols[3]->[0];

      $cols[3] = sprintf $format, $t1->[0] - $t0->[0];
    }

    $t->addRow(@cols);
    $t->addRowLine();
  }

  return scalar $t;
}

########################################################################
sub history {
########################################################################
  my ($self) = @_;

  my @history;
  my @benchmarks;

  if ( @{ $self->{__benchmarks} } ) {
    @benchmarks = @{ $self->{__benchmarks} };
  }
  else {
    @benchmarks = (q{none}) x @{ $self->{__query} };
  }

  foreach ( 0 .. $#{ $self->{__query} } ) {
    push @history,
      [
      $_ + 1,                    $self->{__query}->[$_],
      $self->{__arg_list}->[$_], $benchmarks[$_]
      ];
  }

  return \@history;
}

########################################################################
sub track_all {
########################################################################
  my ($self) = @_;

  for (qw( query args arg_list benchmarks)) {
    $self->track( $_, $TRUE );
  }

  return $self;
}

# aliases for legacy CamelCased method names
########################################################################
sub SelectList  { goto &select_list; }  ## no critic (Capitalization)
sub Select      { goto &select; }       ## no critic (Capitalization)
sub Prepare     { goto &prepare; }      ## no critic (Capitalization)
sub setBindVars { goto &bind_vars; }    ## no critic (Capitalization)
sub setQuery    { goto &query; }        ## no critic (Capitalization)
sub setErr      { goto &errstr; }       ## no critic (Capitalization)
sub Do          { goto &do; }           ## no critic (Capitalization)
########################################################################

# aliases to encourage use of set/get methods
########################################################################
sub set_bind_vars { goto &bind_vars; }
sub get_bind_vars { goto &bind_vars; }
sub set_err       { goto &errstr; }
sub get_err       { goto &errstr; }
sub get_dbi       { goto &dbi; }
sub set_dbi       { goto &dbi; }
########################################################################

########################################################################
# setters/getters
########################################################################
{
  ## no critic (RequireArgUnpacking)
  sub query          { return shift->_set_get( '_query',      @_ ); }
  sub get_query      { return shift->_set_get( '_query',      @_ ); }
  sub set_query      { return shift->_set_get( '_query',      @_ ); }
  sub get_benchmarks { return shift->_set_get( '_benchmarks', @_ ); }
  sub set_benchmarks { return shift->_set_get( '_benchmarks', @_ ); }
########################################################################
  sub get_args { return shift->_set_get( '_args', @_ ); }
  sub set_args { return shift->_set_get( '_args', @_ ); }
########################################################################
  sub max_rows     { return shift->_set_get( '_max_rows', @_ ); }
  sub set_max_rows { return shift->_set_get( '_max_rows', @_ ); }
  sub get_max_rows { return shift->_set_get( '_max_rows', @_ ); }
########################################################################
  sub get_arg_list { return shift->_set_get( '_arg_list', @_ ); }
  sub set_arg_list { return shift->_set_get( '_arg_list', @_ ); }
########################################################################
  # getter/setters for these created by create_accessors()
  sub mysql_insert_id { return shift->_set_get( 'mysql_insert_id', @_ ); }
  sub errstr          { return shift->_set_get( '_err',            @_ ); }
  sub rows            { return shift->_set_get( 'rows',            @_ ); }
  sub arg_list        { return shift->_set_get( '_arg_list',       @_ ); }
  sub set_auto_commit { return shift->auto_commit(@_); }
  sub get_auto_commit { return shift->auto_commit; }
}
########################################################################

########################################################################
sub date_format {
########################################################################
  my ( $self, $date, $format, $utc_offset ) = @_;

  $date //= time;

  die 'not a valid date'
    if !( $date =~ /^\d{4}-\d{2}-\d{2}/xsm || $date !~ /\D/xsm );

  $format //= $ISO_8601_FORMAT;

  my $hour = $utc_offset || 0;

  my $query = <<'SQL';
select date_format( date_add(%s, INTERVAL ? HOUR), ?) formatted_date
SQL

  $query = sprintf $query, $date =~ /^\d+$/xsm ? 'from_unixtime(?)' : q{?};

  my $result = $self->select( $query, $date, $hour, $format );

  return $result->{formatted_date};
}

########################################################################
sub auto_commit {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    $self->{_autocommit} = shift @args;
    $self->dbi->{AutoCommit} = $self->{_autocommit};
  }

  return $self->{_autocommit};
}

########################################################################
sub dbi {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    push @args, sub {  # argument checker
      die 'not a DBI::db object'
        if !ref $args[0] || ref( $args[0] ) !~ /DBI::db/xsm;

      return $args[0];
    };
  }

  return $self->_set_get( '_dbi', @args );
}

########################################################################
sub do {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_do( $self->dbi, @args );
}

########################################################################
sub select {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_select( $self->dbi, @args );
}

########################################################################
sub select_list {
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_select_list( $self->dbi, @args );
}

########################################################################
sub prepare {
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_prepare( $self->dbi, @args );
}

########################################################################
sub bind_vars {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    my $arg_list = ref $args[0] ? $args[0] : \@args;

    $self->set_args($arg_list);

    $self->set_arg_list( join q{|},
      map { defined $_ ? $_ : 'null' } @{$arg_list} );
  }

  return $self->get_args ? @{ $self->get_args } : ();
}

########################################################################
sub commit {
########################################################################
  my ($self) = @_;

  if ( !$self->dbi->{AutoCommit} ) {
    return $self->dbi->commit;
  }

  return $TRUE;
}

########################################################################
sub rollback {
########################################################################
  my ($self) = @_;

  if ( !$self->dbi->{AutoCommit} ) {
    return $self->dbi->rollback;
  }

  return $TRUE;
}

# +-----------------+
# | PRIVATE METHODS |
# +-----------------+

########################################################################
sub _create_accessors {
########################################################################
  my ( $self, @accessors ) = @_;

  no strict 'refs';  ## no critic

  my $class = ref $self || $self;

  foreach my $sub (@accessors) {
    *{ $class . q{::set_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };

    *{ $class . q{::get_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };
  }

  return;
}

########################################################################
# Usage      : _set_get(var, value);
#            : _set_get(var, value, sub { }); # custom setter
#            : _set_get(var, value, [ ]);     # lookup
#            : _set_get(var, value, { });     # transform
#            : _set_get(var, value, SCALAR);  # r/o
# Parameters :
# Returns    :
# Errors     :
########################################################################
sub _set_get {
########################################################################
  my ( $self, @args ) = @_;

  return $self->{ $args[0] }
    if @args == 1;

  if ( @args == 3 ) {
    if ( reftype( $args[2] ) eq 'CODE' ) {  ## no critic (ProhibitCascadingIfElse)
                                            # checker/scrubber of value
      $args[1] = $args[2]->( $args[1] );
    }
    elsif ( reftype( $args[2] ) eq 'ARRAY' ) {
      die 'not a valid value'
        if none { $args[1] eq $_ } @{ $args[2] };
    }
    elsif ( reftype( $args[2] ) eq 'HASH' ) {  # transformation?
      $args[1] = $args[2]->{ $args[1] };
    }
    elsif ( !ref $args[2] ) {                  # flag indication r/o ?
      die 'attempt to set a r/o var';
    }
  }

  my $history_var = '_' . $args[0];

  if ( $args[0] =~ /^_[^_]/xsm && exists $self->{$history_var} ) {

    $self->{$history_var} //= [];

    unshift @{ $self->{$history_var} }, $args[1];  # save last value in history

    # only keep $MAX_HISTORY_ENTRIES
    if ( @{ $self->{$history_var} }
      > ( $self->get_max_history || $MAX_HISTORY_ENTRIES ) ) {
      pop @{ $self->{$history_var} };
    }
  }

  $self->{ $args[0] } = $args[1];

  return $self->{ $args[0] };
}

########################################################################
sub execute {
########################################################################
  my ( $self, $sth, @args ) = @_;

  return $sth->execute(@args);
}

########################################################################
sub _db_do {
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  my $bm = $BENCHMARK ? Benchmark->new : undef;

  $self->set_bind_vars( \@args );

  my $sth = $self->_db_prepare( $dbi, $query );

  my $rv = $sth->err();

  $self->set_err( $sth->errstr() );

  # make sure we start out with 0
  $self->rows(0);

  if ( !$sth->err() ) {

    $self->execute( $sth, @args );

    $rv = $sth->err();

    $self->rows( $sth->rows() );
    $self->set_err( $sth->errstr() );
  }

  $self->set_mysql_insertid( $sth->{mysql_insertid} );

  $sth->finish;

  if ($BENCHMARK) {
    $self->set_benchmarks( [ Benchmark->new, $bm ] );
  }

  return $rv;
}

########################################################################
sub _db_prepare {  ## no critic (Capitalization)
########################################################################
  my ( $self, $dbi, $statement ) = @_;

  $self->set_query($statement);

  croak sprintf 'no database handle for: [%s]:[%s]', $statement, ref $dbi
    if !ref $dbi || ref($dbi) !~ /DBI::db/xsm;

  my $sth = $dbi->prepare($statement);

  return $sth;
}

########################################################################
sub _db_select {  ## no critic Capitalization
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  $self->set_bind_vars( \@args );

  my $bm = $BENCHMARK ? Benchmark->new : undef;

  my $sth = $self->_db_prepare( $dbi, $query );
  $self->execute( $sth, @args );

  if ( !$dbi->{RaiseError} ) {
    if ( $sth->err() ) {
      my $error_message = sprintf "MySQL error (%d): %s\n",
        $dbi->{mysql_errno}, $sth->errstr() // $EMPTY;

      $self->set_err($error_message);
    }
    else {
      $self->set_err($EMPTY);
    }
  }

  my $result = $sth->fetchrow_hashref;
  $sth->finish;

  if ($BENCHMARK) {
    $self->set_benchmarks( [ Benchmark->new, $bm ] );
  }

  return $result
    if !$result || !$self->get_return_bedrock_refs;

  my $obj = bless {}, 'Bedrock::Hash';

  tie %{$obj}, 'Bedrock::Hash', %{$result};  ## no critic (ProhibitTies)

  return $obj;
}

########################################################################
sub _db_select_list {  ## no critic Capitalization
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  $self->set_bind_vars( \@args );

  my $bm = $BENCHMARK ? Benchmark->new : undef;

  my $sth = $self->_db_prepare( $dbi, $query );
  $self->execute( $sth, @args );

  my $max_rows = $self->get_max_rows // 0;

  my $result = [];

  my $return_bedrock_refs = $self->get_return_bedrock_refs;

  my $count = 0;

  while ( my $row = $sth->fetchrow_hashref ) {

    if ($return_bedrock_refs) {

      my $obj = bless {}, 'Bedrock::Hash';
      tie %{$obj}, 'Bedrock::Hash', %{$row};  ## no critic (ProhibitTies)

      push @{$result}, $obj;
    }
    else {
      push @{$result}, $row;
    }

    last if $max_rows && ++$count >= $max_rows;
  }

  $sth->finish;

  if ($BENCHMARK) {
    $self->set_benchmarks( [ Benchmark->new, $bm ] );
  }

  if ($return_bedrock_refs) {
    $result = Bedrock::Array::Reference->new($result);
  }

  return $result;
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 PUBLIC

BLM::DBHandler - Provides support for MySQL database operations

=head1 SYNOPSIS

 package BLM::Customer;

 use parent qw(BLM::DBHandler);

 1;

=head1 DESCRIPTION

Use as a base class to create a module you can use to perform CRUD
operations on your MySQL database.

or use directly...

 my $dbi = DBI->connect('dbi:mysql:mydb', 'user', 'password');

 my $dbhandler = BLM::DBHandler->new( $dbi );

 my $results = $dbhandler->select_list("select * from customer where name acct = ?", $acct);

See L<BLM::IndexedTableHandler> for a more robust implementation of an
ORM for MySQL tables.

=head1 METHODS AND SUBROUTINES

=head2 CONSTRUCTOR

=head3 new

 new( dbi, [options] )
 
Create a new L<DBHandler> object.

 my $dbhandler = BLM::DBHandler->new( $dbi, max_rows => 100 );

B<dbi> is a C<DBI> handle to an open MySQL database.

Options is a list of key/value pairs described below.

=over 5

=item auto_commit

boolean indicating whether a commit should be done after the C<do()>
method is called.

This is a convenience method setting the AutoCommit member of the DBI
handle.

It will reflect the current value of AutoCommit when the handler is
instatiated.

L<BLM::DBhandler::_db_do()> B<will not> change the value of AutoCommit
before executing a query.

=item max_rows 

Sets the maximum number of rows to return in a C<select_list()>
call. Set this value to 0 or undef to return all of the rows from a
query.

default: 100

=back

=head3 return_bedrock_refs

boolean indicating whether methods should return simple Perl objects
or Bedrock objects for C<select_*> methods.

default: true.

=head3 max_history

The number of versions of queries and their arguments to keep in
history. This can be most useful for dumping the SQL queries and bind
values used in an application. See L</history>.

default: 5

=head2 SETTER/GETTER METHODS

=head3 auto_commit

Returns the current state of auto commit from the DBI object.  Equivalent to:

 $dbi->{AutoCommit}

=head3 dbi

 dbi()

Set/get the current C<DBI> handle.

=head3 errstr

 errstr()

Sets/get the error message from the last executed statement.


=head3 get_bind_vars

 get_bind_vars()

Return an array containing the last bind variables used.  Helpful in debugging.


=head3 get_query

 get_query()

Return the last query executed. Helpful in debugging.

=head3 history

Returns the an array of tuples that represent the history of queries,
there arguments and possibly their timings. The argument list is
returned as a pipe delimited string of values.

 my $history = $dbh->history();

 for ( @{$history) {
   printf "query: %s arguments: %s time: %s\n", @{$_});
 }

See L</show_history>

=head3 max_rows

 max_rows( [rows] )

Set or retrieve the maximum number of rows to return in a
C<SelectList> call.  The default is 100.

=head3 show_history

Returns an ASCII formatted table that represents the history of SQL
querier, their arguments and their timings (if benchmarking is
enabled).

C<show_history()> requires L<Text::ASCIITable>.

=head2 SQL METHODS

=head3 commit

 commit()

Commit a transaction if C<AutoCommit> is not set.

=head3 date_format

 date_format( date, format-string, [utc-flag] )

Returns the result of the MySQL DATE_FORMAT function.

  <var $tb.date_format('2011-01-01', '%a')>

 Sat

=over 5

=item date

A MySQL date field.

=item format-string

MySQL format string.  See MySQL C<DATE_FORMAT> documentation.

=item utc-flag

Indicates the date is a UTC date and should be adjusted this many
hours.

=back

=head3 do

 do( query, [args] )

Execute a SQL statement.

  $dbhandler->do("update results set status='1' where order_num = ?", $order_num);

=over 5

=item query

The SQL statement to execute.

=item args

The bind variables to use in the query.

=back

Returns a non-zero value if there was an error.  Use
C<errstr()> to retrieve error message.  Also sets C<-E<gt>{rows}> to
the number of rows affected by the statement.

=head3 prepare

 prepare( query )

Prepare a statement for execution. Returns a statement handle.

=over 5

=item query

The query to execute.

=back

Example:

 my $sth = $dbhandler->prepare("select * from my_table where ...");
 $sth->execute;

Why would you do this instead of:

   my $sth = $dbi->prepare("select * from my_table where ....");
   $sth->execute;

...well because this class handles errors, saves querys, etc. (see below).


=head3 rollback

 rollback()

Rollback a transaction if C<AutoCommit> is not enabled.

=head3 select

 select( query, [args] )

Select a record from a database. Returns a C<Bedrock::Hash> containing
the fields of the record.  Returns C<undef> if the query does not
return a result.

Example:

  my $rec = $dbhandler->select("select * from custmr where acct = ?", 1);

  printf "%s\n", $rec->{'NAME'};

=over 5

=item query

The SQL query to execute.

=item args

The bind variables to use in the query.

=back

=head3 select_list

 select_list( query, [args] )

Selects multiple records from a database.  Returns a C<Bedrock::Array>
of C<Bedrock::Hash> objects.

  my $list = $dbhandler->select_list("select * from custmr where name like 'TEST%'");

  foreach $rec (@$list) {
    printf "%s\n", $rec->{'NAME'};
  }

Returns a 0 length L<Bedrock::Array> object if no records are selected.

=over 5

=item query

The query to execute.

=item args

The bind variables to use in the query.

=back

=head2 ATTRIBUTES

Use the C<get_{attribute}> methods to retrieve various attributes
described below.

=head3 err

Last error message returned by an executed statement. Can be retrieved
with the C<errstr()> method.

=head3 max_rows

Maximum number of rows to return on a C<select_list()> call.  Can be set
or retrieved via the C<max_rows()> method.

=head3 mysql_insertid

Updated after a C<do> just in case you were doing an insert on a table
with an C<auto_increment> field.

=head3 rows

Number of rows affected by the last execute statement.

=head1 BENCHMARKING QUERIES

SQL operations can be timed by setting the package global
C<$BLM::DBHandler::BENCHMARKS> to a true value. The default is false.

Benchmarking requires the L<Benchmark> and L<Time::Hires> modules.

Use the C<max_history()> method to set the number of queries to record. The default is 5.

Operations that use the C<do()>, C<select()> and C<select_list> methods are benchmarked when benchmarking is enabled. Use the C<history()> method to retrieve the history and timings.

For a "pretty" version of the results use the C<show_history()> method.

=head1 SEE ALSO

L<DBI>, L<BLM::IndexedTableHandler>

=head1 AUTHOR

Rob Lauer - rlauer6@comcast.net

=cut
