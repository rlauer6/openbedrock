package BLM::DBHandler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use DBI;
use Data::Dumper;

use Bedrock::Array;
use Bedrock::Hash;

use Bedrock::Constants qw{:booleans :chars};

use Scalar::Util qw/reftype/;
use Carp;

use parent qw/Bedrock::Hash/;

use Readonly;

Readonly our $DEFAULT_MAX_ROWS    => 100;
Readonly our $MAX_HISTORY_ENTRIES => 5;
Readonly our $ISO_8601_FORMAT     => '%Y-%m-%dT%TZ';

__PACKAGE__->_create_accessors(
  qw{
    rows
    mysql_insertid
    return_bedrock_refs
    _query
    max_history
  }
);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolationOfMetachars)

########################################################################
sub new {
########################################################################
  my ( $class, $dbi, %options ) = @_;

  die 'usage: BLM::DBHandler->new(dbi-handle, key, value, ...)'
    if !ref $dbi || ref($dbi) !~ /DBI::db/xsm;

  $options{max_rows}            //= $DEFAULT_MAX_ROWS;
  $options{return_bedrock_refs} //= $TRUE;
  $options{max_history}         //= $MAX_HISTORY_ENTRIES;

  foreach ( keys %options ) {
    $options{"_$_"} = delete $options{$_};
  }

  my $self = $class->SUPER::new(
    _db        => $dbi,
    _dbi       => $dbi,
    __query    => [],   # setting __{var} tells _set_get to track history of _{var}
    __args     => [],
    __arg_list => [],
    %options,
  );

  return $self;
}

# aliases for legacy CamelCased method names
########################################################################
sub SelectList  { goto &select_list; }  ## no critic (Capitalization)
sub Select      { goto &select; }       ## no critic (Capitalization)
sub Prepare     { goto &prepare; }      ## no critic (Capitalization)
sub setBindVars { goto &bind_vars; }    ## no critic (Capitalization)
sub setQuery    { goto &query; }        ## no critic (Capitalization)
sub setErr      { goto &errstr; }       ## no critic (Capitalization)
sub Do          { goto &do; }           ## no critic (Capitalization)
########################################################################

# aliases to encourage use of set/get methods
########################################################################
sub set_bind_vars { goto &bind_vars; }
sub get_bind_vars { goto &bind_vars; }
sub set_err       { goto &errstr; }
sub get_err       { goto &errstr; }
sub get_dbi       { goto &dbi; }
sub set_dbi       { goto &dbi; }
########################################################################

########################################################################
# setters/getters
########################################################################
{
  ## no critic (RequireArgUnpacking)
  sub query     { return shift->_set_get( '_query', @_ ); }
  sub get_query { return shift->_set_get( '_query', @_ ); }
  sub set_query { return shift->_set_get( '_query', @_ ); }
########################################################################
  sub get_args { return shift->_set_get( '_args', @_ ); }
  sub set_args { return shift->_set_get( '_args', @_ ); }
########################################################################
  sub max_rows     { return shift->_set_get( '_max_rows', @_ ); }
  sub set_max_rows { return shift->_set_get( '_max_rows', @_ ); }
  sub get_max_rows { return shift->_set_get( '_max_rows', @_ ); }
########################################################################
  sub get_arg_list { return shift->_set_get( '_arg_list', @_ ); }
  sub set_arg_list { return shift->_set_get( '_arg_list', @_ ); }
########################################################################
  # getter/setters for these created by create_accessors()
  sub mysql_insert_id { return shift->_set_get( 'mysql_insert_id', @_ ); }
  sub errstr          { return shift->_set_get( '_err',            @_ ); }
  sub rows            { return shift->_set_get( 'rows',            @_ ); }
  sub arg_list        { return shift->_set_get( '_arg_list',       @_ ); }
}
########################################################################

########################################################################
sub date_format {
########################################################################
  my ( $self, $date, $format, $utc_offset ) = @_;

  $date //= time;

  die 'not a valid date'
    if !( $date =~ /^\d{4}-\d{2}-\d{2}/xsm || $date !~ /\D/xsm );

  $format //= $ISO_8601_FORMAT;

  my $hour = $utc_offset || 0;

  my $query = <<'SQL';
select date_format( date_add(%s, INTERVAL ? HOUR), ?) formatted_date
SQL

  $query = sprintf $query, $date =~ /^\d+$/xsm ? 'from_unixtime(?)' : q{?};

  my $result = $self->select( $query, $date, $hour, $format );

  return $result->{formatted_date};
}

########################################################################
sub dbi {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    push @args, sub {  # argument checker
      die 'not a DBI::db object'
        if !ref $args[0] || ref( $args[0] ) !~ /DBI::db/xsm;

      return $args[0];
    };
  }

  return $self->_set_get( '_dbi', @args );
}

########################################################################
sub do {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_do( $self->dbi, @args );
}

########################################################################
sub select {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_select( $self->dbi, @args );
}

########################################################################
sub select_list {
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_select_list( $self->dbi, @args );
}

########################################################################
sub prepare {
########################################################################
  my ( $self, @args ) = @_;

  return $self->_db_prepare( $self->dbi, @args );
}

########################################################################
sub bind_vars {
########################################################################
  my ( $self, @args ) = @_;

  if (@args) {
    $self->set_args( \@args );
    $self->set_arg_list( join q{|}, map { defined $_ ? $_ : 'null' } @args );
  }

  return $self->get_args ? @{ $self->get_args } : ();
}

########################################################################
sub commit {
########################################################################
  my ($self) = @_;

  if ( !$self->get_dbi->{AutoCommit} ) {
    return $self->dbi->commit;
  }

  return $TRUE;
}

########################################################################
sub rollback {
########################################################################
  my ($self) = @_;

  if ( !$self->dbi->{AutoCommit} ) {
    return $self->dbi->rollback;
  }

  return $TRUE;
}

# +-----------------+
# | PRIVATE METHODS |
# +-----------------+

########################################################################
sub _create_accessors {
########################################################################
  my ( $self, @accessors ) = @_;

  no strict 'refs';  ## no critic

  my $class = ref $self || $self;

  foreach my $sub (@accessors) {
    *{ $class . q{::set_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };

    *{ $class . q{::get_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };
  }

  return;
}

########################################################################
# Usage      : _set_get(var, value);
#            : _set_get(var, value, sub { }); # custom setter
#            : _set_get(var, value, [ ]);     # lookup
#            : _set_get(var, value, { });     # transform
#            : _set_get(var, value, SCALAR);  # r/o
# Parameters :
# Returns    :
# Errors     :
########################################################################
sub _set_get {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args > 1 ) {
    if ( @args == 3 ) {
      if ( reftype( $args[2] ) eq 'CODE' ) {  ## no critic (ProhibitCascadingIfElse)
                                              # checker/scrubber of value
        $args[1] = $args[2]->( $args[1] );
      }
      elsif ( reftype( $args[2] ) eq 'ARRAY' ) {
        die 'not a valid value'
          if none { $args[1] eq $_ } @{ $args[2] };
      }
      elsif ( reftype( $args[2] ) eq 'HASH' ) {  # transformation?
        $args[1] = $args[2]->{ $args[1] };
      }
      elsif ( !ref $args[2] ) {                  # flag indication r/o ?
        die 'attempt to set a r/o var';
      }
    }

    my $history_var = '_' . $args[0];

    if ( $args[0] =~ /^_[^_]/xsm && exists $self->{$history_var} ) {

      $self->{$history_var} //= [];

      unshift @{ $self->{$history_var} }, $args[1];  # save last value in history

      # only keep $MAX_HISTORY_ENTRIES
      if ( @{ $self->{$history_var} } > $self->get_max_history ) {
        pop @{ $self->{$history_var} };
      }
    }

    $self->{ $args[0] } = $args[1];
  }

  return $self->{ $args[0] };
}

########################################################################
sub _db_do {
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  $self->set_bind_vars(@args);

  my $sth = $self->_db_prepare( $dbi, $query );
  my $rv  = $sth->err();
  $self->set_err( $sth->errstr() );

  # make sure we start out with 0
  $self->rows(0);

  if ( !$sth->err() ) {
    $sth->execute(@args);
    $rv = $sth->err();

    $self->rows( $sth->rows() );
    $self->set_err( $sth->errstr() );
  }

  $self->set_mysql_insertid( $sth->{mysql_insertid} );

  $sth->finish;

  return $rv;
}

########################################################################
sub _db_prepare {  ## no critic (Capitalization)
########################################################################
  my ( $self, $dbi, $statement ) = @_;

  $self->set_query($statement);

  croak sprintf 'no database handle for: [%s]:[%s]', $statement, ref $dbi
    if !ref $dbi || ref($dbi) !~ /DBI::db/xsm;

  my $sth = $dbi->prepare($statement);

  return $sth;
}

########################################################################
sub _db_select {  ## no critic Capitalization
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  $self->set_bind_vars(@args);

  my $sth = $self->_db_prepare( $dbi, $query );
  $sth->execute(@args);

  if ( !$dbi->{RaiseError} ) {
    if ( $sth->err() ) {
      my $error_message = sprintf "MySQL error (%d): %s\n",
        $dbi->{mysql_errno}, $sth->errstr() // $EMPTY;

      $self->set_err($error_message);
    }
    else {
      $self->set_err($EMPTY);
    }
  }

  my $result = $sth->fetchrow_hashref;
  $sth->finish;

  if ( $result && $self->get_return_bedrock_refs ) {
    my $self = bless {}, 'Bedrock::Hash';
    tie %{$self}, 'Bedrock::Hash', %{$result};  ## no critic (ProhibitTies)
    return $self;
  }

  return $result;
}

########################################################################
sub _db_select_list {  ## no critic Capitalization
########################################################################
  my ( $self, $dbi, $query, @args ) = @_;

  $self->set_bind_vars(@args);

  my $sth = $self->_db_prepare( $dbi, $query );
  $sth->execute(@args);

  my $max_rows = $self->get_max_rows;

  my $result = [];

  my $return_bedrock_refs = $self->get_return_bedrock_refs;

  while ( my $row = $sth->fetchrow_hashref ) {

    if ($return_bedrock_refs) {

      my $self = bless {}, 'Bedrock::Hash';
      tie %{$self}, 'Bedrock::Hash', %{$row};  ## no critic (ProhibitTies)

      push @{$result}, $self;
    }
    else {
      push @{$result}, $row;
    }

    last if $max_rows && @{$result} >= $max_rows;
  }

  $sth->finish;

  if ($return_bedrock_refs) {
    return Bedrock::Array::Reference->new($result);
  }
  else {
    return $result;
  }
}

1;

__END__
