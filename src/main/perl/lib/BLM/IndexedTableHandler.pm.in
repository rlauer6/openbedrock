package BLM::IndexedTableHandler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use Data::Dumper;

BEGIN
{
    use Exporter ();
    use vars	qw($VERSION @ISA @ENV @EXPORT_OK @EXPORT);
}

use BLM::DBHandler;
use Bedrock::Array;

use Bedrock::HTML::Helper qw(
			     create_html_element
			     create_label_name
			     create_xhtml_element
			     create_radio_buttons
			     create_select_list
			   );

use BLM::IndexedTableHandler::RecordSet;

@ISA = qw(BLM::DBHandler);

=pod

=head1 PUBLIC

C<BLM::IndexedTableHandler> -- Base class for a MySQL table handler

=head1 SYNOPSIS

  my $foo_ith = new BLM::IndexedTableHandler( $dbi, $id, undef, 'foo' );

  # foo handler with locking
  my $foo_ith = new BLM::IndexedTableHandler( $dbi, { id => $id, 
                                                      table_name => 'foo',
                                                      lock => 1
                                                     }
                                                );

Using C<BLM::IndexedTableHandler> as a base class:

  package BLM::Foo;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  1;


 my $foo_ith = new BLM::Foo( $dbi );


=head1 DESCRIPTION

C<BLM::IndexedTableHandler> is a base class used to construct a package
for updating, deleting, and searching a MySQL table.  The class
handles the relatively mundane tasks associated with managing a table.
These include for example, inserts, deletes, and updates.

It is also a class designed to aid in the contruction of a web
application by providing a host of methods that help construct HTML
forms typically used in support of table maintenance and other aspects of web
application development.

Essentially, C<BLM::IndexedTableHandler> through itE<039>s super-class
represents a MySQL table and thus is named according to the tableE<039>s
name.  In the synopsis above the super-class C<BLM::Foo> represents
the MySQL table C<foo>.

Although primarily designed to be a base class that allows you to
override some of the methods in order to provide your own table
handling behaviors, C<BLM::IndexedTableHandler> can be used "naked"
with no overridden methods as in the synopsis above.

Methods you might want to consider overriding include:

  set
  search 
  find
  save
  handler

...and especially the methods that provide some HTML snippets for
constructing the HTML form for editing your table.

B<Example of overriding one of the HTML construction methods...>

  package BLM::Birds;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  sub create_timestamp_field {
      my ($self, $field_name, $attributes, $labels, $lists) = @_;

      return $self->SUPER::create_timestamp_field($field_name, $attributes, $labels, $lists) unless $field_name =~/last_spotted/;

      return &calendar("birds", "last_spotted", $self->{last_spotted});
}

  sub calendar {
    my ($form_name, $field_name, $value) = @_;

    my $html =<<eot;
  <table cellpadding="0" border="1" cellspacing="0">
    <tr>
      <td valign="center"><input name="$field_name" type="text" size="19" value="$value" maxlength="19"></td>
      <td valign="center"><input type="image" onClick='javascript:popUpCalendar(document.$form_name.$field_name, document.$form_name.$field_name, "m/d/yyyy"); return false' src="/img/calendar.gif"></td>
    </tr>
  </table>
  eot

    return $html;
  } 

These HTML construction methods are described in more detail later in
this documentation.

I<The MySQL table should conform to certain conventions.  It is assumed
to have an indexed (unique) field named C<id> which is defined as an
C<auto_increment field>.>

Your class, which sub classes C<BLM::IndexedTableHandler>, should be
named such that the suffix is the table name.  The program assumes the
actual MySQL table name is lower cased.  So, in the C<SYNOPSIS> above,
assuming we have an example table named C<foo> that looks something
like:

  create table foo (
   id int auto_increment primary key,
   lname varchar(32),
   fname varchar(32),
   email varchar(64)
  );

...and assuming I pass a handle to an open database to C<BLM:Foo>
constructor, I would get a whole lot of stuff necessary for building a
typical Bedrock application for free!

  <sqlconnect --data-source="dbi:mysql:bedrock_site" --username="fred" --password="flintstone" --db="dbi">

  <plugin:Foo $dbi>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Gina', 'email', 'gina@openbedrock.com')>
  <null $Foo.save()>

  <null $Foo.reset()>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Geena', 'email', 'geena@openbedrock.com')>
  <null $Foo.save()>

Update a record...

  <null $Foo.set('email', 'geena123@openbedrock.com')>
  <null $Foo.save()>

Return a list of all records in table C<foo>. I<Note that the
C<find()> method returns a list of C<BLM::IndexedTableHandler> objects
suitable for use in the same way you used the original object.  If you
want just a hash reference of the fields of the record, you can use
the C<asref()> method of an object or a record set.>

  <null --define-var="foo_list" $Foo.find()> 

Just show the database columns...

  <trace --outptut $foo_list.asref()>

Return a list of records in table C<foo> where the C<lname> field starts with 'Lolla'...

   <null --define-var="lollas" $Foo.find('lname', 'Lolla')>

Find a record in table C<foo> where the C<lname> field exactly matched 'Lolla'...

   <null --define-var="lolla" $Foo.find_unique('lname', 'Lolla')>

Return a list of records in table C<foo> where the C<lname> field exactly matched 'Lolla'...

   <null --define-var="lollas" $Foo.find(1, 'lname', 'Lolla')>


=head1 DOCUMENTATION

=head2 Getting Started

Using the template from the C<SYNOPSIS> above, create your
C<BLM::table_name> package and copy this somewhere within the Bedrock
perl path. Typically this might be somewhere like:

  /var/www/vhosts/www.mysite.com/perl5/BLM

...or wherever you told perl to look for perl modules.  If you are
using Bedrock as a cgi then you might have added include paths to
F<perl.INC> or if you are using C<mod_perl> then you might have used
the C<PerlSwitches> directive in your Apache configuration file.

  package BLM::Foo;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  1;

YouE<039>ll then want to create your MySQL table.

 create table foo (
   id    int auto_increment primary key,
   name  varchar(32),
   email varchar(32)
 );


 $ cp Foo.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Foo.pm

You then instantiate C<IndexedTableHandler> objects either directly
from your Bedrock page :-( as shown above using the
C<E<lt>pluginE<gt>> tag:

  <plugin:Foo $dbi>

...or you can do this from your siteE<039>s Application Plugin object
which might typically provide a factory method for instantiating
objects to handle your table.  This is the preferred method and the
details below will guide you in creating an Application Plugin that
creates your database handling object.

=head2 The Gory Details

First you should create an application plugin configuration file.
Assuming our Application Plugin will be named C<Example>, weE<039>ll create
a configuration file named F<example.xml> as show below:

   <object> 
    <scalar name="binding">example</scalar> 
    <scalar name="module">BLM::Startup::Example</scalar> 
    <object name="config"> 
     <scalar name="data_source">dbi:mysql:bedrock_site</scalar>
     <scalar name="username">fred</scalar>
     <scalar name="password">flintstone</scalar>
    </object> 
   </object> 

This file should be added to your site's configuration by placing the
file in the F<CONFIG_PATH/config.d/startup>
directory. C<CONFIG_PATH> is the path you set in the Apache
configuration file to tell Bedrock where to find your virtual host's
local configuration information.

 SetEnv CONFIG_PATH /var/www/vhosts/www.mysite.com/config

Note the binding name for this object is I<example> and will be
referenced in the Bedrock example below.

Now create the Application Plugin perl module.

  use strict;
  use warnings;

  package BLM::Foo;

  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  package BLM::Startup::Example;
  
  use vars qw(@ISA);
    
  use Bedrock::Application::Plugin;
  
  @ISA = qw(Bedrock::Application::Plugin);
  
  # - factory method for creating Foo handlers
  sub foo {
      my $self = shift;
  
      return BLM::Foo->new($self->dbi, @_);
  }
  
  1;

Again, this Perl module should be installed somewhere where Perl will
find the module when you web applicaion is executing.

  $ cp Example.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Startup/Example.pm

As you can see, the application plugin provides a factory method named
C<foo> that simply returns a C<foo> object.  The C<foo> object is a
C<BLM::IndexedTableHandler>.

=head2 Bedrock Web Development with C<BLM::IndexedTableHandler>

Now create a sample Bedrock page to test your object.

  <null --define-var="fred" $example.foo()>
  <null --define-var="wilma" $example.foo()>
  
  <html>
  <body>
  <pre>
  <trace --output $fred>
  </pre>
  <null $fred.set('lname', 'Flintstone',
                  'fname', 'Fred',
                   'email', 'fflintstone@bedrock.com')>
  <null $fred.save()>
  
  <null $wilma.set('lname', 'Flintstone', 
                   'fname', 'Wilma', 
                    'email', 'wflintstone@bedrock.com')>
  <null $wilma.save()>
  <null --define-var="flintstones" $wilma.find('lname', 'Flintstone')>
  
  <pre>
  <hr>
  <trace --output $flintstones>
  </pre>

  <table>
    <tr>
      <th>First</th>
      <th>Last</th>
      <th>E-Mail</th>
    </tr>
    <foreach $flintstones>
    <tr>
      <td><var $fname></td>
      <td><var $lname></td>
      <td><var $email></td>
    </tr>
    </foreach>
    </table>
  </body>
  </html>

=head2 Constructing HTML Forms

If the the C<BLM::IndexedTableHandler> did nothing more than handle
the I<insert>, I<update>, I<delete> drudgery for MySQL records and
provide some query tools that would probably be enough.  Probably, but
there is still much tedium and re-hashed HTML snippets that we all use
in every Bedrock application we write that makes developing HTML apps
a chore.

By standardizing on how we might want to handle specific MySQL field
types within applications it is possible to provide a template of an
HTML form that might help us create database applications with Bedrock
and MySQL. Enter the C<html_form_*()> methods.

The C<html_form_*> methods will create a template for a completely
usable HTML form that allows you to edit your MySQL table.  The
C<html_form_body()> method interprets the various field types within a
MySQL table and creates appropriate form objects.  It will also
properly set the data values within the form based on the values in
the current object.

The form is rendered inside a 2-column table where the first column
contains the field names and the second column contains the HTML input
element that allows entry or editing of the data values.  A row in the
table is written for each field in the table.  Field names are
converted to a more readable from from the column names in the MySQL
table using the following conventions:

=over 4

=item * underscores ('_') are converted to blanks

=item * the first letter of each word in the resulting string is converted to upper case

=back

Examples:

 first_name       => First Name
 last_name        => Last Name
 primary_position => Primary Position
 e_mail_address   => E Mail Address

The HTML form is rendered in three parts, a head, a body and a footer
using the three methods C<html_form_header()>, C<html_form_body()> and
C<html_form_footer()>.

You can probably reduce most Bedrock applications that handle a MySQL
table to something like the Bedrock snippet below:

 <html>
 <head>
 <body>
  
 <null --define-var="foo" $example.foo($input.id)>

 <if $input.action --eq "save">
   <null $foo.set($input)>
   <null $foo.save()>
 <elseif $input.action --eq "find">
  <null --define-var="foo_find_list" $foo.search($input)>
  <if $foo_find_list.length() --eq "1">
    <null --define-var="foo" $foo_find_list.get(0)>
  <elseif $foo_find_list.length()>
   <foreach $foo_find_list>
     <a href="?id=<var $_.id>"><var $_.id></a><br>
   </foreach>

   <null --define-var="foo" $example.foo()>
   <null $foo.set($search_field, $input.get($search_field))>
  </if>
 </if>

 <var $foo.html_form_header()>
 <var $foo.html_form_body()>
 <var $foo.html_form_footer()>

 </form>
 </body>
 </html>

or you can use the L</handler> method which pretty much performs a
similar function as the logic above.

The C<html_form_body()> method currently has support for the following
MySQL field types:

=over 4 

=item int

An C<int> field will be converted to an HTML <input> object with a size of 5.

=item char

A C<char(n)> field will be converted to an HTML <input> object with a size of n.

=item varchar

A C<varchar(n)> field will be converted to an HTML <input> object with a size of n.

=item enum

An C<enum> field will be converted into a <select> or <input (radio)>
object where the options and values are equal to the specification
within the definition of the C<enum> field.

If the number of elements in the enumeration is 4 or less, then the
C<html_form()> method will produce a set of radio buttons.  If the
list is greater than 3, the method will produce a <select> object.
This behavior can be overridden as described in the overloaded version
of the C<html_form()> method (see the full documentation on
C<html_form()>) for details.

For example if your field is defined as below:

 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |

The C<html_form()> method would create a select box as follows:

 <select name="pant_size">
   <option value="S">S</option>
   <option value="M">M</option>
   <option value="L" selected>L</option>
   <option value="XL">XL</option>
   <option value="XXL">XXL</option>
   <option value="XXXL">XXXL</option>
 </select>

=item set

A set field is converted to either a <select> element that allows
mulitple selections or a series of checkboxes.  If the number of
elements in the set is 4 or less then the set is represented by a
series of check boxes, otherwise it is represented as a multi-select
list.

=item tinyint

A C<tinyint> or C<boolean> field is converted into a check box object.

=item date

A C<date> field is converted to an <input> object with a length of 10.
Upon display, this field is shown as a standard MySQL date field of
the form YYYY-MM-DD.  Before being saved to a table, this field will
be converted to the YYYY-MM-DD format if the format is MM/DD/YYYY or
MM/DD/YY.  See C<set> for more details on how form fields are
converted to MySQL data types before being saved.

=item timestamp

C<timestamp> fields are treated in a similar fashion to C<date> fields
except they are 19 characters in length and support a suffix of HH:MM
PM.

=item text

C<text> fields are converted into a <textarea> object with 40 columns
and 5 rows.  These attributes can be overridden (see the full
documentation for the C<html_form_body()> method.

=back

=head1 METHODS

=head2 new

 new( dbi, id, config, table-name )
 new( dbi, id, table-name )
 new( dbi, { id => id, table_name => table-name, config => config, lock => 0 |1  })

Polymorphims run amok, but pick your poison...these are unambiquous
signatures. My preference in Bedrock is...

  <plugin:IndexedTableHandler $dbi 'table-name'>

=over 5

=item dbi

An instance of a C<DBI> object representing an open connection to a
MySQL database.

=item id

The C<id> field which uniquely identifies a record in the MySQL table.

=item config

Configuration object containing an object named C<tables> that
contains options for handling MySQL tables.

=item table-name

The name of the MySQL table.

=item lock

The lock mode.

 0 => no locking
 1 => FOR UPDATE
 2 => LOCK IN SHARE MODE

=over 5

=item LOCK IN SHARE MODE

I<SELECT ... LOCK IN SHARE MODE sets a shared mode lock on any rows that
are read. Other sessions can read the rows, but cannot modify them
until your transaction commits. If any of these rows were changed by
another transaction that has not yet committed, your query waits until
that transaction ends and then uses the latest values.> - from http://dev.mysql.com

=item FOR UPDATE

I<SELECT ... FOR UPDATE locks the rows and any associated index entries,
the same as if you issued an UPDATE statement for those rows. Other
transactions are blocked from updating those rows, from doing SELECT
... LOCK IN SHARE MODE, or from reading the data in certain
transaction isolation levels. Consistent reads ignore any locks set on
the records that exist in the read view. (Old versions of a record
cannot be locked; they are reconstructed by applying undo logs on an
in-memory copy of the record.)> - from http://dev.mysql.com

=back

B<Note that row level locking in MySQL is only available with the InnoDB
engine.  The row is locked immediately when the object is instatiated
for the give C<id>.  You should commit the record to release the lock.>

=back 

=cut

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = bless {}, $class;

    my $dbi = shift;
    
    my ( $id, $config, $table_name );

    # new(id, config)
    # new(id, table-name)
    # new(id, config, table-name)
    unless ( ref($_[0]) ) {
      if ( @_ == 2 ) {
	if ( ref($_[1]) ) {
	  ($id, $config) = @_;
	}
	else {
	  ($id, $table_name) = @_;
	}
      }
      else {
	($id, $config, $table_name) = @_;
      }
    }
    # new( dbi, hash-ref )
    else {
      my $opts = shift;
      ($id, $config, $table_name) = @{$opts}{qw/id config table_name/};
      $self->lock( $opts->{lock} );
    }

    if ( $id ) {
      die "id must be integer, not [$id]\n"
	unless $id =~/^\d+$/;
    }

    if ( ref($dbi) ) {
      unless ( ref($dbi) =~/DBI/ ) {
	my $ref = $dbi;

	$dbi = $ref->{dbi};
	die "usage: BLM::IndexedTableHandler->new( dbi, ...)\n"
	  unless $dbi && ref($dbi) =~/DBI/;

	($id, $config, $table_name) = @{$ref}{qw/id config table_name/};
      }
    }
    
    die "BLM::IndexedTableHandler currently only supports MySQL tables.\n"
      unless $dbi->get_info(17) =~/mysql/i;

    $class =~/^(.*)::(.*?)(=.*)?$/;

    $table_name = $table_name || lc($2) or die "Unable to determine table name.";

    # validate config object
    unless ( ref($config) && $config->{tables} ) {
      $config = {};
    }

    $self->{_config} = $config;
    $self->{_table} = $table_name;
    $self->{_dbi} = $self->{_db} = $dbi;

# - avoid redundant creation of data structure for each row in a list
#   i.e. if this object is being constructed thusly:
#
#   $another = $me->new($dbi, $id);
#
#   which is done from find() for example, then we really don't want to 
#   create whole bunch of arrays that hold the table directory, one will do nicely thanks
#
    unless ( ref($this) && $this->get_field_list ) {
      my $sth = $dbi->prepare("show fields from $table_name");
      $sth->execute;

      my $fields = {};
      my $id_found;
      my $idx = 0;

      while (my $ref = $sth->fetchrow_hashref) {
	$ref->{idx} = ++$idx;
	$fields->{$ref->{Field}} = $ref;
	if (($ref->{Field} eq 'id') && 
	    ($ref->{Key} eq 'PRI') && 
	    ($ref->{Extra} eq 'auto_increment')) {
	  $id_found = $ref;
	}
      }

      die "Table must have an indexed field named [id] and it must be auto_increment!" 
	unless $id_found;

      $sth->finish;

      $self->{_table_dir} = $fields;
      $self->{_field_list} = [sort {$fields->{$a}->{idx} <=> $fields->{$b}->{idx}} keys %$fields];

      if ( $self->get_table_config->{$table_name}->{labels} ) {
	$self->{_labels} = $self->get_table_config->{$table_name}->{labels};
      }

      if ( $self->get_table_config->{$table_name}->{lists} ) {
	$self->{_lists} = $self->{_config}->{tables}->{$table_name}->{lists};
      }

      if ( $self->get_table_config->{$table_name}->{attributes}) {
	$self->{_attributes} = $self->get_table_config->{$table_name}->{attributes};
      }

      if ( $self->get_table_config->{$table_name}->{search_fields} ) {
	$self->{_search_fields} = [];

	foreach ( @{$self->get_table_config->{$table_name}->{search_fields}} ) {
	  push @{$self->{_search_fields}}, $_->{exact};
	  push @{$self->{_search_fields}}, $_->{field};
	}
      }
    }
    else {
      @{$self}{keys %$this} = values %$this if $this;

      foreach ( $self->get_fields() ) {
	$self->{$_} = undef;
      }
      die unless $self->get_config;
    }

    my $dir = $self->get_table_dir;

    foreach ( $self->get_fields ) {
      if ( $dir->{$_}->{Type} eq 'timestamp') {
	$self->set_display_only( $_ );
      }
    }

    if ( $id ) {
      my $query = "select * from %s where id = ? %s";
      
      my $lock_mode = { 0 => '',
			1 => 'for update',
			2 => 'lock in share mode'
		      }->{$self->lock};

      my $ref = $self->select( sprintf($query, $table_name, $lock_mode), $id );

      foreach (keys %$ref) {
	$self->set($_, $ref->{$_});
      }
    }

    $self->max_rows( 50 );

    $self;
}

sub lock {
  my $self = shift;

  $self->{_lock} = $_[0]
    if ( @_ );

  return $self->{_lock};
}

sub get_attributes {
  return $_[0]->{_attributes} || {};
}

sub get_labels {
  return $_[0]->{_labels} || {};
}

sub get_lists {
  return $_[0]->{_lists} || {};
}

sub get_field_list {
  return $_[0]->{_field_list};
}

=head2 delete

 delete()
 delete( id )
 delete( column-name )

Deletes the currently defined row from the database, a specified
record identified by C<id> or removes a column from the object so that
it will not be updated on subsequent saves.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "delete">
     <null $foo.delete()>
     <null --define-var="foo" $factory.foo()>
  </if>

=over 5

=item id

The C<id> of the record you wish to delete.  If no value is given for
C<id> the current object is deleted if the C<id> column is set.

=item column-name

The name of a column in the table.  If this value is passed then the
member will be deleted from the object allowing you to update a record
without updating that particular column.  I<Note that the C<save()>
method will read the record back into the object after it has been
updated, thus restoring that column to the object.>

=back

=cut

sub delete {
  my $self = shift;
  my $id = shift || $self->{id};
  
  if ( $id && $id =~/^\d+$/ ) {
    $self->reset();

    return $self->_delete( $id );
  }
  elsif ( $id && grep { /$id/} @{$self->get_field_list} ) {
    return delete $self->{$id};
  }
}

sub _delete {
  my $self = shift;
  my $id = shift;

  $self->Do("delete from ". $self->{_table}." where id = ?", $id);

  return $self->{rows};
}

=pod

=head2 null

 null( column, ... )
 null( array-ref )

Sets the specified column (or columns) to NULL (undef).  Pass a list
of column names or an array reference of column names.

=cut

sub null {
  my $self = shift;

  my @list = ref($_[0]) ? @{$_[0]} : @_;

  my @fields = $self->get_fields();

  foreach my $column_name ( @list) {
    if ( $self->is_field($column_name) ) {
      $self->{$column_name} = undef;
    }
  }
}

=pod

=head2 is_null

 is_null( field-name )

Returns true if the field is NULL, false if it is not NULL.  Not that
the empty string is NOT a NULL value.

Example:

  <if $contact.is_null('username')>
    ...
  </if>

=cut

sub is_null {
  my $self = shift;
  my $field = shift;

  return ! defined $self->{$field};
}

=pod

=head2 is_field

 is_field( name )

Returns true if C<name> is a column in the table.  Returns false if it is not.

=cut

sub is_field {
  my $self = shift;
  my $field = shift;

  return exists $self->get_table_dir->{$field};
}

=pod

=head2 reset

 reset

Clears (sets columns to NULL) all of the columns in the object.

=cut

sub reset {
  my $self = shift;

  foreach (@{$self->get_field_list}) {
    $self->{$_} = undef;
  }
}


=pod

=head2 encrypt

 encrypt( column-name, secret )

Encrypts (updates) a column with C<secret> using the MySQL
C<aes_encrypt()> function.

=cut

sub encrypt {
  my $self = shift;
  my ($column, $secret) = @_;

  return $self->Do(
		   sprintf("update %s set %s = aes_encrypt(%s, ?)", $self->{_table}, $column, $column), 
		   $secret
		  );
}


=pod

=head2 decrypt

Decrypt a column value using C<secret> and the MySQL C<aes_decrypt()> method.

 decrypt( column-name, secret )

=cut

sub decrypt {
  my $self = shift;
  my ($column, $secret) = @_;

  my $result = $self->select("select aes_decrypt(?, ?) as dummy", $self->{$column}, $secret);

  return $result->{dummy};
}

sub init_config {
  my $self = shift;

    # no configuration passed
  return unless $self->get_config && $self->get_table_config;
  
    my $config = $self->get_table_config;
  
  # not configuration info for this particular table
  return unless 
    my $table_config = $config->{$self->get_table_name};
  
  my %default = ( set        => '', 
		  get        => '', 
		  attributes => {}, 
		  labels      => ''
		);
  
    my @cols = $self->get_fields;
  
  foreach my $type qw(set get attributes labels) {
    my $config = $table_config->{$type} || {};
    foreach ( @cols ) {
      $config->{$_} = $default{$type} 
	unless exists $config->{$_};
    }
    
    $table_config->{$type} = $config;
  }
  
    $self->get_table_config->{$self->get_table_name} = $table_config;
  
  return $self->get_config;
}


sub keys {
  $_[0]->fields();
}


sub get_table_name {
  my $self = shift;

  return $self->{_table};
}

sub get_table_config {
  my $self = shift;

  return $self->get_config->{tables} || {};
}

sub get_table_dir {
  my $self = shift;

  return $self->{_table_dir} || {};
}

sub config {
  $_[0]->get_config;
}

sub get_config {
  my $self = shift;

  return $self->{_config} || {};
}

=pod

=head2 get

=cut

# - Default getter method checks to see whether there is method override specified
#   in tagx.xml
sub get {
  my ($self, $key) = @_;

  my $getters;

  if ( $self->get_table_config ) {
    $getters = $self->get_table_config->{$self->get_table_name}->{get};
  }

  return $self->{$key} unless $getters && $getters->{$key};

  my $method= $getters->{$key};

  if ( $method ) {
    if ( $self->can( $method ) ) {
      return $self->can($method)->($self, $key);
    }
    else {
      die "You've specified a field formatter, but there is no method \'$method\'";
    }
  }
}

sub _set {
  my $self = shift;
  my $key;
  my $value;

  my $setters = $self->get_table_config->{$self->get_table_name}->{set};

  my $dir = $self->get_table_dir;

  while (@_) {
    $key = shift;
    $value = shift;

    my $type = $dir->{$key}->{Type};

    if ( $type =~/(date|time)/ ) {
      $value = undef
	unless $value;
    }

    if (my $method = $setters->{$key}) {
	if ($self->can($method)) {
	  $self->{$key} = $self->can($method)->($self, $key, $value);
	}
	else {
	  die "You've specified a field formatter, but there is no method \'$method\'";
	}
    }
    elsif ( $type eq 'date') {
      if ($value =~/\d{1,2}\/\d{1,2}\/\d{4}/) {
	$value = sprintf("%04d-%02d-%02d", (split "/", $value)[2, 0, 1]);
      }
      elsif ($value =~/\d{1,2}\/\d{1,2}\/\d{2}/) {
	my @date = split "/", $value;
	$date[2] += 2000 if $date[2] < 20;
	    $date[2] += 1900 if $date[2] > 20;
	$value = sprintf("%04d-%02d-%02d", @date[(2, 0, 1)]);
      }
      $self->{$key} = $value;
    }
    elsif ( $type =~/set/) {
      if (ref($value)) {
	$self->{$key} = join(",",@$value);
	}
      else {
	$self->{$key} = $value;
      }
    }
    else {
      $self->{$key} = $value;
    }
  }
}

=pod

=head2 set

  set(field name, value, ...)

Sets the field name(s) to the specified value(s).

  set($input)

Calling C<set> with the C<$input> object as the parameter (or in
general a hash) will result in the field names for your table being
set from the hash.  That is to say...

  <null $player.set($input)>

is equivalent too...

   <foreach keys $input>
     <null $player.set($_, $input.get($_))>
   </foreach>

or more correctly...

  <foreach $player.fields()>
     <if $input --exists $_>
       <null $player.set($_, $input.get($_))>
     </if>
  </foreach>

You should be aware that the C<save()> method will not update fields
that are not in your object.  So to prevent updating all fields, you
could delete elements of the object thusly.

  <null $customer.delete('name')>

I<Note: HTML checkboxes that are NOT checked, will not manifest
themselves as elements in your C<$input> object.  This is a limitation
of the way the browser encodes these fields.  This could be
problematic since this method now does not know if you want to set the
field to null or if you want to skip updating that field.

In this case, the C<set()> method has chosen to assume you want to
update the field and arbritrarily decides to assume that if the
checkbox field is missing from the hash reference, it is because it
was B<unchecked>.  If should explicitly carry along a value then for
checkbox fields.>

Additionally, the C<set()> method will do some basic manipulation of
input data in order to support MySQL date types.  If your input looks
like this:

  mm/dd/yyyy

...the method will convert the date to this:

  yyyy-mm-dd

...before attempting to save the data to a MySQL table.

=cut

sub set {
    my $self = shift;

# - if there is only one argument to set then assume
#   the argument is an object (typicaly $input) and we're 
#   setting the field values from that object...
    if (@_ == 1) {
	my $dir = $self->get_table_dir;
	my $ref = shift;

	foreach ( $self->get_fields() ) {
	    if (exists $ref->{$_}) {
	      $self->_set($_, $ref->{$_});
	    }
# - drudge! if the field type is a 'tinyint', i.e. boolean, then this was 
#   rendered as a checkbox.  Unfortunately, an HTML checkbox that is not checked
#   does not manifest itself in the QUERY_STRING.  Therefore, we're going out a bit 
#   on a limb here, but if you've asked this method to use an object to set the 
#   field values, then most likely this is the $input object AND we'll attempt to 
#   handle the checkbox problem for you...so if the field value is NOT in the input
#   object AND the field type is tinyint...set the value to '0'
	    elsif ($dir->{$_}->{Type} =~/tinyint/) {
		$self->_set($_, 0);
	    }
	}
    }
    else {
	$self->_set(@_);
    }
}

# dumps private/public keys separately (debugging)

=pod

=head2 dumper

 dumper()

Return a two-element array of public/private information stored by the
class.  Typically used for debugging.

 [0] => Bedrock hash representing the public key/value pairs (column values)
 [1] => Bedrock hash of private key/value pairs

=cut

sub dumper {
  my $self = shift;
 
  my @private;
  my @public;

  foreach (CORE::keys %{$self}) {
    push @private, $_ if $_=~/^_/;
    push @public, $_ unless $_=~/^_/;
  }
  
  my $public_values = Bedrock::Hash->new;
  my $private_values = Bedrock::Hash->new;

  @{$public_values}{@public} = @{$self}{@public};
  @{$private_values}{@private} = @{$self}{@private};
 
  return Bedrock::Array->new($public_values, $private_values);
}


=pod

=head2 save

 save( [$input] )

This method will C<update> a record or C<insert> a new record into the
database.  If the C<id> field is null or "0" it will assume a new
record is to be added to the table, otherwise the record with the
corresponding C<id> will be updated.

The return value of the method is the value of the C<id> field.

You can optionally pass a hash which contains the key/value pairs for
columns of the record to set.  Only keys that correspond to valid
columns will be set.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "save">
    <null $foo.save($input)>
  </if>

I<Note that only the fields corresponding to the columns that exist in
the object are updated.  In other words if you want to avoid updating
a column, delete the member from the object.>

  <null $foo.delete('bar')>

=cut

sub save {
  my $self = shift;
  my $input = shift;
  
  if ( UNIVERSAL::isa($input, 'HASH')) {
    foreach ( $self->get_fields ) {
      $self->set($_, $input->{$_} )
	if exists $input->{$_};
    }
  }

  if ( $self->{id} ) {
    $self->_update;
  }
  else {
    $self->_insert;
  }

  my $table_name = $self->get_table_name;

  # update the record from the database
  my $ref = $self->select("select * from $table_name where id = ?", $self->{id});

  foreach (CORE::keys %$ref) {
    $self->set($_, $ref->{$_});
  }

  return $self->{id};
}


=pod

=head set_field

 set_field( field-name, value )

Formats a field before storing it to the database.  This method is
only called if I<format mode> is selected for the given field.

 <null $customer.set_format_mode('date_entered', 1)>

 <null $customer.save()>

C<BLM::IndexedTableHandler> has built-in formatters for field whose
names contain the words date, time or phone and whose types are
date/datetime, timestamp, char or varchar.

If the field type is B<date>, B<datetime>, B<timestamp> and the column
name contains the words date or time, AND format mode is selected,
then the field is formatted appropriately before being inserted into
the database.

If the field type is B<char> or B<varchar> and the column name
contains the word B<phone> the field is formatted as a phone number
(Either xxx-yyyy or (zzz) xxx-yyyy).

If you donE<039>t like this behavior or wish to apply other transformations
of the data prior to the data being written to the database, you can
override this method.

=cut


sub set_field {
  my $self = shift;
  my ($field, $value) = @_;

  return if $self->get_display_only( $field );

  my $type = $self->get_field_type( $field );
  $value =~s/^\s*(.*?)\s*/$1/;

  for ( $field ) {

    /phone/ && $type=~/char/ && do {
      
      if ( $value ) {
	$self->{$field} = $self->set_phone_field( $field, $value );
	die "invalid phone format: $value\n"
	  unless $self->{$field};
      }
      last;
    };
      
# rules of engagement:
# - if the date is of the form mm/dd/yy[yy] then we 
#   we need to reformat the field to yyyy-mm-dd in order
#   to insert this successfully into a MySQL database date field
#   * if the year portion is yy (2-digit), we'll assume it is in this
#     century if the value is < 20, i.e. 08 = 2008
#   * if the year portion is > 20 and < 100 then we will assume
#     the year is in the 20th century, i.e. 1900+yy
# - if the date is of the form yyyy-mm-dd then we will leave it alone
# - if the field is a timestamp and there is a date, but no time...
#   * if the date is the current date, we will add the current time
#   * if the date is not today, then the time added will bee 00:00:00
# - if the field is null, let it be
# - if the field is not of a recognized format, let it be


    /(date|time)/ && $type =~/(date|datetime|timestamp)/ && do {

      my $date;
      my ($mm, $dd, $year);
      
      if ($value =~/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/ ) {
	($mm, $dd, $year) = ($1,$2,$3);
	if ($year < 20) {
	  $year += 2000;
	}
	elsif ($year < 100) {
	  $year += 1900;
	}
	$date = sprintf("%04d-%02d-%02d", $year, $1, $2);
      }
      elsif ($value =~/^\s*(\d{4}-\d{2}-\d{2})/) {
	$date = $1;
      }
      else {
	$date = $value;
      }

      if ( $type =~/(timestamp|datetime)/) {
	if ($value =~/(\d{1,2}):(\d{1,2})(:\d{1,2})*\s*(AM|PM)*$/i) {
	  my ($hh, $mi, $sec, $ampm) = ($1, $2, $3, $4);
	  $sec =~s/://;

	  $date .= sprintf(" %02d:%02d:%02d", ((uc($ampm) eq "PM") ? $hh + 12 : $hh), $mi, $sec);
	}
	else {
	  my ($cday, $cmon, $cyear) = (localtime)[(3,4,5)];
	  if ($cday == $dd && $cmon == $mm-1 && $year == 1900+$cyear) {
	    $date .= sprintf(" %02d:%02d:%02d", (localtime)[(2,1,0)]);
	  }
	  else {
	    $date .= " 00:00:00";
	  }
	}
      }

      $self->{$field} = $date;
      last;
    };
    
    $self->{$field} = $value;
  }
}

sub _format_fields_for_insert {
  my $self = shift;

  my $dir = $self->get_table_dir;

  foreach my $field ( $self->get_fields() ) {
    if ( $self->get_format_mode( $field ) ) {
      $self->set_field( $field, $self->{$field} )
	if exists $self->{$field};
    }
  }
}

sub _insert {
  my $self = shift;

  $self->_format_fields_for_insert;

  my $query = "insert into %s (%s) values (%s)";
  $self->{id} = 0;

  $query = sprintf($query,
		   $self->get_table_name,
		   join(",", @{$self->{_field_list}}),
		   join(",", split "", "?" x scalar($self->get_fields()))
		  );

  $self->Do($query, @{$self}{$self->get_fields});

  $self->{id} = $self->dbi->{mysql_insertid};
}

sub _update {
  my $self = shift;

  $self->_format_fields_for_insert;

  my @fields = grep { !/^id$/ } ($self->get_fields());
  @fields = map { exists $self->{$_} ? $_ : (); } @fields;

  my $query = sprintf("update %s set %s where id = ?",
		      $self->get_table_name,
		      join(",", map { "$_ = ?" } @fields)
      );

  $self->Do($query, @{$self}{@fields}, $self->{'id'});

  return $self->{rows};
}


sub _find {
  my $self = shift;
  
  my $sql = sprintf("select id from %s ", $self->{_table});

  my $limit = " limit " . $self->max_rows
    if $self->max_rows;

  if (@_) {
    $sql .= "where ";
  }
  
  my @args = ();
  my @where_clause;
  my @fields = $self->get_fields;

  while ( @_ ) {
    my $exact_flag = shift;
    my $field = shift;
    die "$self: invalid column name: [$field]\n"
      unless grep { /$field/ } @fields;

    my $value = shift;
    
    push @where_clause, sprintf(" %s %s ?", $field,  $exact_flag ? "=" : "like");
    push @args, $exact_flag ? $value : $value."%";
  }
  
  if ( @where_clause ) {
    $sql .= join(" and ", @where_clause);
  }
  
  my @list;
 
  my $ref;

  $sql .= $limit;

  eval {
    $ref = $self->select_list($sql, @args);
  };

  die "Could not execute query:\n$sql\n$@"
    if $@;

  my $idx = 0;

  if ( @$ref ) {
    foreach ( @{$ref} ) {
      my $obj = $self->new($self->dbi, $_->{id}, $self->get_config, $self->get_table_name);
      $obj->max_rows( $self->max_rows );
      $obj->{idx} = ++$idx;
      push @list, $obj;
    }

    return new BLM::IndexedTableHandler::RecordSet( @list );
  }
  else {
    return new BLM::IndexedTableHandler::RecordSet;
  }
}

# - an intelligent 'find'
sub key_fields {
  my $self = shift;
  my @fields = $self->get_fields();
  
  my $dir = $self->get_table_dir;
  my @keys;
  
  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'UNI';
  }

  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'MUL';
  }
    
  return Bedrock::Array->new(@keys);
}

sub set_search_field {
  my $self = shift;
  my ($exact_flag, $field) = @_;

  $self->{_search_fields} = [] unless $self->{_search_fields};

  push @{$self->{_search_fields}}, $exact_flag, $field;
}

sub set_key_fields {
  my $self = shift;

  my @unique;
  my @mul;

  my $dir = $self->get_table_dir;
  my %fields;

  foreach (CORE::keys %{$dir}) {
    $fields{$dir->{$_}->{idx}} = $_;
    push @unique, $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'UNI';
    push @mul,  $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'MUL';
  }

  foreach (sort @unique) {
    $self->set_search_field(0, $fields{$_});
  }

  foreach (sort @mul) {
    $self->set_search_field(1, $fields{$_});
  }
}

=head2 search

  search($input) 

This is essentially the same as C<find> except it attempts to
intelligently figure out what you want to search by looking at the
fields in the object you pass and matching these up with the potential
indexes in the table.

Suppose you have a form that represents the table and each field in
the form corresponds to a field in the database. Potentially you could
search by any of the fields in the database using the C<find> method.

For example:

  <if $input.lname>
    <null --define-var="foo_list" $foo.find('lname', $input.lname)>
  <elsif $input.fname>
    <null --define-var="foo_list" $foo.find('fname', $input.fname)>
  <elsif $input.email>
    <null --define-var ="foo" $foo.find_unique('email', $input.email)>   
  </if>

This begs the question of what to do when multiple fields are
populated and what order should the search be done in?

C<search> tries to guess all of this for you by looking at the indexes
you have created for the table and the order you have defined the
fields.

The search will proceed by looking at C<UNIQUE> index fields first
then fields indexed as C<MUL> (i.e. the index allows duplicate keys).
Within each index it will use the order in which the fields have been
defined in the table to see if the field is defined in the form.  If
it is, then it will use that field as the search key, otherwise it
will go to the next index field.  If there are no index fields it will
simply follow the order of the fields as defined in the table.

Give the table F<foo> defined below:

 +-----------+-------------------------------------+------+-----+---------+----------------+
 | Field     | Type                                | Null | Key | Default | Extra          |
 +-----------+-------------------------------------+------+-----+---------+----------------+
 | id        | int(11)                             | NO   | PRI | NULL    | auto_increment |
 | lname     | varchar(32)                         | YES  | MUL | NULL    |                |
 | fname     | varchar(32)                         | YES  |     | NULL    |                |
 | email     | varchar(64)                         | YES  | UNI | NULL    |                |
 | comments  | text                                | YES  |     | NULL    |                |
 | hat_size  | char(1)                             | YES  |     | NULL    |                |
 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |
 | active    | tinyint(1)                          | YES  |     | NULL    |                |
 +-----------+-------------------------------------+------+-----+---------+----------------+


The statement:

 <null --define-var="foo_list" $foo.search($input)>

...would look to see if C<$input.email> had a value first, if so it
would conduct a search equivalent to:

 <null --define-var="foo_list" $foo.find('email', $input.email)>

if C<$input.email> was not defined, it would then look at
C<$inpt.lname> and if that were defined would conduct a search
equivalent to:

 <null --define-var="foo_list" $foo.find('lname', $input.lname)>

C<search> would then proceed similarly through the non-indexed fields
(C<fname>, C<comments>, C<hat_size>, C<pant_size>, and C<active>).

=cut

sub search {
    my $self = shift;
    my $input = shift;

    $self->set($input);
    $self->set_key_fields() unless $self->{_search_fields};
    
    my @search_args;
    
    if ($self->{_search_fields} && @{$self->{_search_fields}}) {
      my @search_fields = @{$self->{_search_fields}};
      while (@search_fields) {
	my $exact_flag = shift @search_fields;
	my $field_name = shift @search_fields;
	
	if ($self->{$field_name}) {
	  push @search_args, $exact_flag, $field_name, $input->{$field_name};
	}
	  }
    }
    
# still uncomfortable with assuming certain wildcard/non-wildcard searching
    unless (@search_args) {
      foreach ( $self->get_fields() ) {
	if ( $input->{$_} ) {
	  push @search_args, 0, $_, $input->{$_};
	}
      }
    }

    return $self->_find(@search_args);
}

=pod

=head2 find

  find( id )

Returns a C<BLM::IndexedTableHandler> object representing the row in
the table with an C<id> equal to the specified id.

  find ( field, value )

Returns an array of C<BLM::IndexedTableHandler> objects that B<start with> the 
value passed.

  find()

Returns an array of C<BLM::IndexedTableHandler> objects.  The number
of elements in the array is controlled by the current C<max_rows>
setting.  For all rows, set C<max_rows> to 0.

  find( match-flag, field, value, ...)

Returns an array of C<BLM::IndexedTableHandler> objects that match the
fields and values passed.  Each C<match-flag> is is either 0,
indicating B<non-exact match> (starts with) or 1, indicating B<exact match>.

=over 5

=item id

MySQL id of the row to return.

=item field

name of a column in a MySQL table

=item value

value of the column specifed in C<field> to search for

=back

=head3 Example - Return all rows.

  <null $player.max_rows()>
  <null --define-var="players" $player.find()>

Returns all rows in the table.  Typically this is used for relatively
small tables.  B<By default a maximum value of 50> is used to limit
the number of elements returned.

If you B<really> want to return more rows, then use the C<max_rows()>
method to control the number of row to return.

  <null $player.max_rows(100)>

For an unlimited number...

  <null $player.max_rows()>   

=head3 Example - Return a specific record based on the primary key

 <null --define-var="player" $player.find($input.id)>

=head3 Example - Return a list by searching a field.

 <null --define-var="players" $player.find('fname', 'Jo')>

Would return an array of player objects where the field F<fname> is like Jo%

I<Note:> This method will always return an array even if there is only 1 row that matches
the criteria.

=head3 Example - Return rows based on matching more than 1 field.

 <null --define-var="players" $player.find(1, 'position', 1, 0, 'lname', 'R')>

Would return all of the records where the C<position> column was
B<equal> to 1 and the last name of the player started with 'R'.

=cut

sub find {
  my $self = shift;
  
  if (@_ == 1) {
    die "usage: find(n), where n > 0\n"
      unless $_[0] =~/^\d+$/ && $_[0];

    my $ref = $self->_find(1, 'id', @_);
    return $ref ? $ref->[0] : undef;
  }
  elsif ( @_ == 2) {
      return $self->_find(0, @_);
    }
  elsif ( @_ > 2) {
      return $self->_find( @_ );
  }
  else {
    return $self->_find;
  }
}

=pod

=head2 find_unique

  find_unique(field, value)

Returns a single row where C<field> = C<value>.  Returns C<undef> if
the value is not found in the database.

  <null --define-var="pujols" $player.find_unique('lname', 'Pujols')>

=cut

sub find_unique {
  my $self = shift;
  my $ref = $self->_find(1, @_);

  return $ref ? $ref->[0] : undef;
}


=pod

=head2 fields

 fields()
 columns()

Returns a Bedrock array containg the column names.

=cut

sub columns { $_[0]->fields() };

sub fields {
  my $self = shift;

  return Bedrock::Array->new( $self->get_fields() );
}

=pod

=head2 get_fields

Returns a list of field names.  Note that in the Bedrock context
returning lists and array references are equivalent, since Bedrock
will promote lists to Bedrock array objects.  When using this method
in the Perl context it will return a list.  Use C<get_field_list()> if
you want an array reference.

=cut

sub get_fields {
  @{$_[0]->{_field_list}};
}

=pod

=head2 asref

 asref()
 asref( key, key, ... )

Returns a hash object containing just the values of the columns of the
table.  This is not a particular useful object as it is not endowed
with the magic of the C<BLM::IndexedTableHandler> class, however some
may find it more satisfying than seeing all of the internal guts of
the classE<039> object hierarchy.

If the C<key> argument is provided, the returned hash will contain
only the keys specified.  C<key> can be a scalar or an array
reference.

 <null:record $ith.asref( $ith.get_field_list(), 'my_extra_key') >

=cut

sub asref {
  my $self = shift;
  my $ref = {};
  my @cols;

  if ( scalar(@_) ) {
    push @cols,  map { (ref $_ ) ? @{$_} : $_ } @_;
  }
  else {
    @cols = @{$self->get_field_list()};
  }

    
  @{$ref}{@cols} = @{$self}{@cols};
  
  return Bedrock::Hash->new( %$ref );
}


sub get_formatted_field_length {
  my $self = shift;
  my $field = shift;

  my $type = $self->get_field_type( $field );

  for ( $field ) {
    /phone/ && $type =~/char/ && do {
      return 14;
    };

    /(date|time)/ && $type =~/time/ && do {
      return 20;
    };

    /date/ && $type =~/date/ && do {
      return 10;
    };

    $type =~/\((\d+)\,?.*\)/ && return $1;

    $type eq 'boolean' && return 1;
  }

  return undef;
}



=pod 

=head2 get_field_length

 get_field_length(field-name)

Returns the length of a field.

=cut

sub get_field_length {
  my ($self, $field_name) = @_;
  
  my $type = $self->get_field_type( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    return $self->get_formatted_field_length( $field_name );
  }
  elsif ($type =~/\((\d+)\,?.*\)/) {
    return $1;
  }
  elsif ( $type eq 'date' ) {
    return 10;
  }
  elsif ( $type eq 'datetime' ) {
    return 20;  # 12/45/78 01:34:67 90
  }
  elsif ( $type eq 'timestamp' ) {
    return 20;
  }
  elsif ( $type eq 'boolean' ) {
    return 1;
  }

  return undef;
}

sub get_field_type {
  my $self = shift;
  my $field_name = shift;

  return $self->get_table_dir->{$field_name}->{Type};
}

sub _get_options {
  my $self = shift;
  my ($list_type, $field_type) = @_;

  # 1. counties:select
  # 2. counties
  # 3. Atlantic,Bergen,Burlington,...
  # 4. [ { id => 0, item => 'foo'} ... ]
  # 5. { type => 'select',
  #      list => [ { id => 0, item => 'foo'} ... ]
  #     }   

  my $options = {};

  if ( UNIVERSAL::isa($list_type, 'HASH') ) {
    $options = $list_type;
  }
  elsif ( UNIVERSAL::isa($list_type, 'ARRAY') ) {
    $options->{list} = [map { {id => $_, item => $_} } @{$list_type}];
  }
  else {
 
    my ($table_name, $type) = split ":", $list_type;
    
    if ( $table_name ) {
      if ( $table_name =~/\,/ ) {
	my @list_items = split ",", $table_name;
	$options->{list} = [map { {id => $_, item => $_}} split ",", $table_name];
      }
      else {
	$options->{list} = $self->select_list(sprintf("select * from %s order by id", $table_name));
      }
    
    }
    else {
      $field_type =~/(enum|set)(\(.*?\))/;
      
      $options->{list} = [map { {id => $_, item => $_} } eval $2];
      
      if ($field_type =~/enum/  &&  @{$options->{list}} > 4) {
	unshift @{$options->{list}}, {id => undef, item => "None"};
      }
    }
  }

  $options->{type} = $options->{type} || (@{$options->{list}} > 4) ? 'select' : 'radio',

  return $options;
}

=pod

=head2 get_enum_values

 get_enum_values( column-name )

Return an array of possible values for a C<set> or C<enum> field type.

Given a table with an enum column 'doc_type':

  +----------+-------------------+------+-----+---------+----------------+
  | Field    | Type              | Null | Key | Default | Extra          |
  +----------+-------------------+------+-----+---------+----------------+
  | id       | int(11)           | NO   | PRI | NULL    | auto_increment |
  | doc_type | enum('a','b','c') | YES  |     | NULL    |                |
  +----------+-------------------+------+-----+---------+----------------+


  <null:list $document.get_enum_values('doc_type')>
  <trace --output $list>

  [
  [0] .. (a)
  [1] .. (b)
  [2] .. (c)
  ]

=cut

sub get_enum_values {
  my $self = shift;
  my $column = shift;

  my $dir = $self->{_table_dir};

  die "usage: get_enum_value( column-name )\n" 
    unless $column && $dir->{$column};

  my @list; 

  if ( $dir->{$column}->{Type} =~/(enum|set)(\(.*?\))/) { 
    @list = eval $2;
  }
  else {
    die "column: [$column] is not an enum or set field type\n";
  }
  
  return Bedrock::Array->new( @list );
}

sub create_date_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $length = $self->get_field_length( $field_name );
  
  my $value = $self->get_formatted_field( $field_name );
  my $size = length($value) > $length ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );
  
  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
                              maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}});
  
}

sub create_char_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $_, 
			      value     => $value, 
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}})
}


sub create_select_field {
    my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
    my $value;
    
    if ($self->{_table_dir}->{$field_name}->{Type} =~/set/) {
      $value = [split ",", $self->{$field_name}];
    }
    else {
      $value = $self->{$field_name};
    }
    
  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

    return create_select_list($field_name, $value, $attributes, $options->{list});
  }

sub create_radio_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;

  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

  return create_radio_buttons($field_name, $self->{$field_name}, $attributes, $options->{list});
}

sub get_formatted_field {
  my $self = shift;
  my $field_name = shift;

  my $value = $self->get( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    $value = $self->format_field( $field_name, $value );
  }

  return $value;
}

sub format_field {
  my $self = shift;
  my ($field_name, $value) = @_;

  my $type = $self->get_field_type ( $field_name );
  
  for ( $field_name ) {
    /date/ && $type =~/date/ && do {
      $value = $self->get_date_field( $field_name );
      last;
    };
    
    /phone/ && $type =~/char/ && do {
      $value = $self->get_phone_field( $field_name );
      last;
    };
  }

  return $value;
}

sub create_varchar_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;
 
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      =>'text', 
			      name      => $field_name, 
                              value     => $value,
                              maxlength => $length,
			      size      => $size
			     ),
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}


sub create_tinyint_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  return $self->create_checkbox_field($field_name, $attributes, $labels, $lists);
  
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type  =>"checkbox", 
			      name  =>$field_name, 
			      value => 1
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : (), 
			     $self->{$field_name} ? ("checked" => undef) : ());
}

sub create_checkbox_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  $options = $options || { list => [  {id=>1, item=>""} ] };
  
  my $value;

  if ($self->{_table_dir}->{$field_name}->{Type} =~/set/) {
    $value = [split ",", $self->{$field_name}];
  } else {
    $value = $self->{$field_name};
  }

  my @values = ref($value) ? @$value : ($value);

  my @items = map {$_->{item}} @{$options->{list}};

  my $html;

  foreach my $ref (@{$options->{list}}) {
    $html .= sprintf("%s&nbsp;<b>%s</b>&nbsp;&nbsp;&nbsp;",
		     create_html_element('input',
					 (type=>"checkbox", name=>$field_name, value=> $ref->{id}), 
					 $attributes ? %{$attributes->{input}} : (), 
					 scalar(grep { $ref->{id} eq $_ } @values) ? ("checked" => undef) : ()
					),
		     $ref->{item});
  }

  return $html;
}


sub create_int_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ( $size > length($value) )  ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}

sub create_timestamp_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = length($value) || $size;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      => 'text', 
			       name      => $field_name, 
			       value     => $value,
			       maxlength => $size,
			       size      => $size,
			      ),
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_decimal_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ($size > length($value)) ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      =>'text', 
			       name      => $field_name, 
                               value     => $self->{$field_name}, 
			       maxlength => $size,
			       size      => $size
			      ), 
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_text_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $disabled = $self->get_display_only( $field_name );
  return sprintf("%s%s</textarea>", 
		 create_html_element( 'textarea', 
				      (
				       name => $field_name, 
				       rows => 5, 
				       cols => 40
				      ), 
				      $disabled ? (disabled => undef) : (),
				      $attributes ? %{$attributes->{textarea}} : ()),
		 $self->{$_}
		);
}

=pod

=head2 html_form_header

 html_form_header(attributes)

=cut

sub html_form_header {
  my $self = shift;
  my $attributes = shift || {};
  
  return create_html_element( 'form', 
			      ( 
			       name   => $self->{_table}, 
			       method => "post", 
			       action => $ENV{PATH_INFO}
			      ), 
			      %$attributes
			    );
}

=pod

=head2 html_form_footer

 html_form_footer(attributes)

Creates a row of buttons (I<save>, I<delete>, I<find>, I<new>) that
submit the form and set the C<action> hidden element.

=cut

sub html_form_footer {
  my $self = shift;
  my $attributes = shift || $self->get_attributes;
  my %hidden = @_;

  my @html;
  my $form_name = $self->{_table};
  
  my $form_element = sprintf("document.%s", $form_name);
  
  my $onclick = qq{%s%s.action.value='%s'; %s.submit();};
  my @buttons = ("find", "save", "delete", "new");

  foreach (@buttons) {
    $attributes->{$_} = {} unless exists $attributes->{$_};
  }
  
  $attributes->{delete}->{disabled} = undef unless $self->{id};
  $attributes->{new}->{disabled} = undef unless $self->{id};
  
  foreach ("save","delete","find", "new") {
    push @html, create_html_element( 'input', 
				     (
				      type => "Button", 
				      value => ucfirst($_), 
				      onClick => sprintf( $onclick, 
							  $_ eq "new" ? qq{$form_element.id.value='0';}: "",
							  $form_element, $_, $form_element
							)
				     ), 
				     %{$attributes->{$_}})
  }
  
  push @html, create_html_element('input', (type => "hidden", name=>"action", value=>""));
  push @html, create_html_element('input', (type => "hidden", name=>"table", value=>$self->{_table}));
  
  # additional hidden input elements you might want to carry along
  foreach (CORE::keys %hidden) {
    push @html, create_html_element('input', (type  => "hidden", 
					      name  => $_, 
					      value => $hidden{$_}
					     )
				   );
      
  }

  # add the format mode for these fields
  foreach (@{$self->{_field_list}}) {
    push @html, create_html_element('input', (type => "hidden", name=>"format_mode", value=> "$_"))
      if $self->get_format_mode( $_ );
  }

  return sprintf("%s\n%s\n", join("&nbsp;\n", @html), "</form>\n");
}

=pod

=head2 html_form_body

 html_form_body(attributes, labels, lists, exclude-fields)

=cut

sub html_form_body {
  my $self = shift;
  my $attributes = shift || $self->get_attributes;
  my $labels = shift || $self->get_labels;
  my $lists = shift || $self->get_lists;
  my $exclude_fields = shift || [];

  my $exclude_field_list = {};
  map { $exclude_field_list->{$_} = 1; } @{$exclude_fields};

  my $dir = $self->{_table_dir};

  my $html = create_html_element("table", %{$attributes->{table}})."\n";
  
  foreach ( $self->get_fields() ) {
    next if exists $exclude_field_list->{$_};

    # if no "maxlength" is given for an input field and a "size" is given, then use that as maxlength
    if ($attributes->{$_} && $attributes->{$_}->{input}->{size}) {
      $attributes->{$_}->{input}->{maxlength} = $attributes->{$_}->{input}->{size} 
	unless $attributes->{$_}->{input}->{maxlength};
    }
    
    # - first check to see if this is a pick list
    my $options;
    $options = $self->_get_options( $lists->{$_}, $dir->{$_}->{Type} ) 
      if $lists->{$_} || $dir->{$_}->{Type} =~/(enum|set)/;
    
    if ( $lists->{$_} ) {
      if ($options->{type} =~/(select|radio|checkbox)/) {
	my $input_element;

	if ($options->{type} eq 'select' ) {
	  $input_element = $self->create_select_field( $_, 
						       $attributes->{$_}, 
						       $labels, 
						       $lists, 
						       $options
						     );
	} elsif ($options->{type} eq 'radio') {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} elsif ($options->{type} eq 'checkbox') {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $input_element
			);
      }
    } elsif ($dir->{$_}->{Type} =~/(enum|set)/) {
      if ($options && @{$options->{list}} > 4) {
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $self->create_select_field($_, $attributes->{$_}, $labels, $lists, $options)
			);
      } else {
	my $input_element;
	if ($dir->{$_}->{Type} =~/enum/) {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} else {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $input_element
			);
      }
    } elsif ($dir->{$_}->{Type} =~/tinyint/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_tinyint_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($dir->{$_}->{Type} =~/varchar/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_varchar_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/int/) {
      next if $_ =~/^id$/;
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_int_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($dir->{$_}->{Type} =~/^char/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_char_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/date/) {
      
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_date_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/timestamp/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_timestamp_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/text/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_text_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/decimal/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_decimal_field($_, $attributes->{$_}, $labels, $lists)
		      );
    }
  }
  
  $html .= "</table>\n";
  $html .= create_html_element('input', (type=>"hidden", value=>$self->{id}, name=>"id"));
  
  return $html;
}

=pod

=head2 handler

  handler($input)

Method that invokes various methods of your table handler object
depending upon the value of the C<action> CGI variable.

The values of the C<action> CGI variable support are:

=over 5

=item save

Saves the field values in the C<$input> object to the MySQL table.
Supports both updates and inserts depending on whether the C<id> field
is set to 0 (insert) or a non-zero (update) value.

Returns the table handler object.

=item delete

Deletes the row in the MySQL table indicated by the value of C<id>.

Return the table handler object.

=item new

Creates a new table handler object.

Returns a new table handler object.

=item find

Performs a query against the MySQL table depending upon the fields
(CGI variables) that are set in the C<$input> object.

If 1 or more rows found after executing the query, the method will
returns either C<BLM::IndexedTableHandler::RecordSet> object.

If no rows are found after executing the query, the method will return
a table handler object.

=back

=cut


sub handler {
  my $self = shift;
  my $input = shift;

  if ( $input->{format_mode} ) {
    my @mode = ref($input->{format_mode}) ? @{$input->{format_mode}} : ($input->{format_mode});
    foreach ( @mode ) {
      $self->set_format_mode($_, 1);
    }
  }

  if ($input->{action} eq 'save') {
    $self->set($input);
    $self->save();
    return $self;
  } elsif ( $input->{action} eq 'delete' ) {
    die "no id\n"
      unless $input->{id};

    $self->delete($input->{id});
    $self->{id} = 0;
    foreach (@{$self->{_field_list}}) {
      $self->set($_, undef);
    }
    return $self;
  } elsif ($input->{action} eq 'new') {
    return $self;
  } elsif ($input->{action} eq 'find') {
    my $list = $self->search($input);
    if ($list && @$list >= 1) {
      return $list;
    } else {
      return $self;
    }
  } else {
    return $self;
  }
}

=pod

=head2 get_display_only

 get_display_only( field-name )

Returns true or false depending on whether the field is set to be a
display-only field

=cut

sub get_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  return $self->{_display_only}->{$field_name};
}


=pod

=head2 set_display_only

 set_display_only( field-name )

Set the field to be display only.  This prevents user input to this field.

=cut

sub set_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  $self->{_display_only}->{$field_name} = 1;
}


# - Some default pseudo field type handlers

=pod

=head2 get_format_mode( field-name )

Returns a boolean value that determines if a field should be formatted
when it is show in a form field.

=cut

sub get_format_mode {
  my $self = shift;
  my $key = shift;

  $self->{_format_mode} = {} unless $self->{_format_mode};

  return $self->{_format_mode}->{$key};
}


=pod 

=head2 set_format_mode

 set_format_mode( field-name, mode )

Indicate that a field should be formatted when the value is shown in a
form field.  Before the fieldE<039>s value is output, it is passed to
the C<format_field()> method if the format mode for the field
is set to 1.  The method is responsible for returning a formatted
version of the field.

  <null $customer.set_format_mode('date_inserted', 1)>

C<BLM::IndexedTableHandler> provides formatting for C<date>,
C<datetime>, C<timestamp>, char and varchar fields whose name is has
either the word "phone" or "date" in them.

If you donE<039>t want any default behavior or you want some other behaivor
you might consider overriding the C<format_field()> method.

  package BLM::Customer;
  
  use BLM::IndexedTableHandler;
  use Bedrock::Plugin;
  
  use strict;
  use vars qw(@ISA);
  
  @ISA = qw( BLM::IndexedTableHandler Bedrock::Plugin);
  
  sub format_field {
    my $self = shift;
    my ($field, $value) = @_;
  
    for ( $field ) {
      /(firstname|lastname)/ && do {
        $value = ucfirst(lc($value));
        return $value;
      };
  
    }
  
    return $self->SUPER::format_field($field, $value);
  }
  
  1;

=cut

sub set_format_mode {
  my $self = shift;
  my ($key, $mode) = @_;

  $self->{_format_mode} = {} unless $self->{_format_mode};
  $self->{_format_mode}->{$key} = $mode;
}



# +---------------+
# | PHONE NUMBERS |
# +---------------+

=pod

=head2 set_phone_field

  set_phone_field(field, value)

Removes extraneous data from a phone number field and returns and/or
sets the column value to just the digits of the phone number.  If the
resulting length of the object is 10 or 7 then the column is set to
just the digits, otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the digits are just returned to the caller.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_phone_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value =~s/[^\d]//g;
    $value =~/^(\d{7}|\d{10})$/;
    $value = ($1 ? $1 : undef);

  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}

=pod

=head2 get_phone_field

 get_phone_field( field-name )

Returns a formatted phone number.  If the phone number length is 7 digits:

 555-1212

If the phone number legnth is 10 digits:

 (888) 555-1212 

Example:

 <var $customer.get_phone_field('work_phone')>

=cut

sub get_phone_field {
  my ($self, $key) = @_;
  
  if ($self->{$key}) {
    my $str = $self->{$key};
    
    if (length($str) == 7) {
      return sprintf("%s-%s", unpack "a3a4", $str);
    } elsif (length($str) == 10) {
      return sprintf("(%s) %s-%s", unpack "a3a3a4", $str);
    } else {
      return $self->{$key}; # I have no idea what you're up to here dude!
    }
  } else {
    return $self->{$key};
  }
}

=pod

=head2 set_date_field

 set_date_field( field-name, value )
 set_date_field( value )

Use this method to set the value of a date field.  The idea being, you
may have a user enter a date in either YYYY-MM-DD format or
MM/DD/YY[YY] formats and this method will format the date properly for
insertion into a MySQL date field.

Passing only the C<value> argument will return the formatted value.

Example:

  <null $player.set_date_field('birthday', $input.birthday)>

=cut


sub set_date_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }


  if ( $value ) {
    my @date = split /[\/-]/, $value;
    
    if (3 == scalar(@date) ) {
      if ($value =~/-/) {
	$value = sprintf("%4d-%02d-%02d", @date);
      } else {
	$date[2] += 2000 if $date[2] < 30;
	$value = sprintf("%4d-%02d-%02d", @date[(2,0,1)]);
      }
    }
  }

  $self->{$key} = $value
    if defined $key;

  return $value;
}



=pod

=head2 now

Return the current date and time YYYY-MM-DD HH24:MI:SS format.

 <var $customer.now()>

=cut

sub now {
  my $self = shift;

  return $self->select("select now() as n")->{n};
}

=pod

=head2 curdate

Return the current date in YYYY-MM-DD format.

 <var $customer.curdate()>

=cut

sub curdate {
  my $self = shift;

  return $self->select("select curdate() as d")->{d};
}

=pod

=head2 curtime

Return the current time in HH24:MI:SS format.

 <var $customer.curtime()>

=cut

sub curtime {
  my $self = shift;

  return $self->select("select curtime() as t")->{t};
}


=pod

=head2 date_format

 date_format( date, format-string )

 date_format( field-name, format-string) 

Returns the result of the MySQL DATE_FORMAT function.

 <var $obj.date_format('2011-01-01', '%a')>

 <var $obj.date_format('date_filed', '%a')>

Sat

=cut

sub date_format {
  my $self = shift;
  my ($date, $fmt, $utc) = @_;
  $date = ($date =~/^[\-0-9]+$/) ? $date : $self->{$date};

  my $hour = $utc ? -5 : 0;
 
  my $ref = $self->select("select date_format( date_add(?, INTERVAL ? HOUR), ?) date_fmt",$date, $hour, $fmt);

  return $ref->{date_fmt};
}

=pod

=head2 get_date_field

 get_date_field( field-name )

Returns a MM/DD/YYYY or MM/DD/YYYYY HH:MI:SS formatted date or
datetime value from a MySQL YYYY-MM-DD date.

Example:

 <input type="text" name="birthday" value="<var $player.get_date_field('birthday')>">

=cut

sub get_date_field {
  my ($self, $key) = @_;

  return undef unless $self->{$key} && $self->{$key} !~/0000\-00\-00/;

  my @date = split("-", $self->{$key});

  $date[3] = $1 if $date[2] =~/\d{2} (\d{2}:\d{2}:\d{2})/;

  my $fmt_date = sprintf("%02d/%02d/%04d", @date[(1,2,0)]);
  $fmt_date .= ' ' . $date[3] if $date[3] && $date[2] !~/00:00:00/;

  return $fmt_date;
}

=pod

=head2 set_email_field

 set_email_field(field, value)

Validates and returns and/or sets the column valued to an email
address. If the email is valid, then the column is set to the value,
otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the email address is just returned to the caller if valid.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_email_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value = $self->validate_email( $value ) ? $value : undef;
  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}


=pod

=head2 validate_email

 validate_email( email )

Returns true or false depending on validity of email address.  This
doesnE<039>t mean this address is associated with a real email account,
just that it might. ;-)

=cut

sub validate_email {
  my $self = shift;
  my $email = shift;

  return $email =~/^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/;
}

=head1 CAVEATS

=head2 checkbox fields

Because checkbox fields are not manifested in the CGI C<QUERY_STRING>
when form data is submitted and the checkbox is not checked, you may
find that using a simplistic approach to updating the fields in your
object may result in checkbox fields being ignored.  For example, the
Bedrock code:

  <foreach $input.keys()>
     <null $player.set($_, $input.get($_)>
  </foreach>

would never actually update a checkbox field that was unchecked.
Therefore, as shown above the "more correct" approach to setting
the values of your object from your HTML form:

  <foreach $player.fields()>
     <null $player.set($_, $input.get($_))>
  </foreach>

...guarantees that each field in the table will be set, even if it is
set to a null value.

If you rely on the single argument version of the C<set> method youE<039>re
in luck (at least if youE<039>re database field being rendered as a
checkbox is a boolean).  Since C<html_form()> renders C<tinyint> or
C<boolean> fields as checkboxes, C<set> will make sure that any
C<tinyint> field in the record is set, regardless of whether it exists
in the C<$input> object.

=head1 AUTHOR

Rob Lauer - rlauer@signatureinfo.com

=head1 SEE ALSO

DBHandler

=cut

# Revision 1.30  2013/05/11 18:27:59  rlauer
# - inherit DBHandler::max_rows()
#
# Revision 1.29  2013/03/26 20:33:03  rlauer
# - allow 1 argument version of set_date_field(), similar to set_phone_field()
#
# Revision 1.28  2013/03/26 19:55:39  rlauer
# - pod, value was not being set in set_date_field() method
#
# Revision 1.27  2013/01/02 19:18:34  rlauer
# - tweaked pod
#
# Revision 1.26  2012/12/30 17:23:41  rlauer
# - pod tweaks
#
# Revision 1.25  2012/12/30 17:19:23  rlauer
# - updated pod for encrypt/decrypt
#
# Revision 1.24  2012/12/30 17:17:37  rlauer
# - added new methods encrypt(), decrypt() for encrypting/decrypting a column using the aes_* function
#
# Revision 1.23  2012/12/30 16:53:34  rlauer
# - added method reset() to clear all columns
# - updated delete method to take id or column name to delete members of an object prior to saving
#
# Revision 1.22  2012/12/27 20:20:36  rlauer
# - update the asref() function to take a list of keys
#
# Revision 1.21  2012/07/18 13:44:05  lauerrc
# - row level locking now supported when instantiating an object from an id.  new() method now takes dbi, hash-ref
# - added lock() method
#
# Revision 1.20  2012/04/16 13:12:58  eutl420
# - when using the handler() method and passing the input object, ITH was updating all of the columns of the table, not just those
#   found in the input object (or ITH object).
#
# Revision 1.19  2012/03/21 15:41:39  eutl420
# - pod tweaks
#
# Revision 1.18  2012/03/19 14:06:10  eutl420
# - set date/time values to undef (null) if blank
#
# Revision 1.17  2012/01/17 22:40:12  eutl420
# - updated pod for find_unique(), indicate that it is an exact match and returns 1 row
#
# Revision 1.16  2011/12/05 15:44:48  eutl420
# - added a bunch of new getter methods to avoid hash dipping and better isolate private data
# - find method now supports three forms find(), find(column, value), find(match-flag, column, value)
# - pick lists can now be sent as hash where value is array of hashes with id/item keys
#
#   { county : [ { id : 0, item : "Atlantic" ] ... }
#
# - save() method now optionally takes $input object
# - new dumper() method that can be used to dump private/public data separately
#
# Revision 1.15  2011/12/01 22:00:54  eutl420
# - use '_' prefix for hash variables to avoid collision with column names
# - in html_form_body() allow a new optional argument that is an array ref with
#   fields names that represent those NOT to render
#
# Revision 1.14  2011/12/01 15:38:07  eutl420
# - die in the constructor if the DBI object is not provide or if the DBI object does not indicate
#   a connection to a MySQL database
# - in the handler() function, we needed to send the id to the delete() method
#
# Revision 1.13  2011/11/28 21:20:51  eutl420
# - added the ability to carry along extra fields by passing them to html_form_footer()
# - ability to set "display only" fields via set_display_only() method
# - ability to set formatting on/off for fields via set_format_mode() method
#
# Revision 1.12  2011/11/21 14:08:10  eutl420
# - incrementally improving pod
# - in the _find() method we now eval the call to SelectList so that we can display the query in the error, also
#   return an empty array when no rows are found
# - in the one argument form of find(), check to make sure the argument is a valid id (i.e. int > 0)
# - the set_phone_field() method did not actually set the field as advertised
# - new methods:
#   + get_enum_values() which returns an array of possible values for an field type of `enum'
#   + set_email_field() which validates and sets an email field
#   + validate_emai() uses a regexp to validate a supposed email address
#
# Revision 1.11  2011/11/16 14:37:50  eutl420
# pod
#
# Revision 1.10  2011/11/14 22:36:32  eutl420
# - code in new() that avoids redundant operations when being instantiated from a reference should make sure that
#   this is in fact a first class BLM::IndexedTableHandler and not one that was simply a sub-class.  We check for
#   the member _field_list to make sure that the reference is in fact legit.
# - more pod cleanup
#
# Revision 1.9  2011/11/14 15:01:11  eutl420
# - this is being re-added to the Bedrock project
# - cleaned up pod and added some documentation for existing methods
# - added new methods
#   + asref() returns just a hash reference of the record's column values
#   + now() returns result of MySQL NOW() function
#   + curtime() returns result of MySQL CURTIME() function
#   + curdate() returns result of MySQL CURDATE() function
#
# Revision 1.8  2011/11/13 16:08:28  eutl420
# - adding back to project
#
# Revision 1.6  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.5  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.4  2009/12/31 00:04:41  rlauer
# docs need work - wip
#
# Revision 1.3  2009/12/28 20:32:33  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.2  2008/12/03 14:01:18  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.1  2008/11/25 14:32:27  rlauer
# added as part of Bedrock 2.0.0 reorg
#

1;
