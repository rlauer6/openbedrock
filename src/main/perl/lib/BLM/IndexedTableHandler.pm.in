package BLM::IndexedTableHandler;

#
#    This file is a part of Bedrock, a server-sidse web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2023, TBC Development Group, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use BLM::IndexedTableHandler::RecordSet;
use Bedrock::Array;
use Bedrock::Constants qw( :chars :booleans :find_flags );
use Bedrock::HTML::Helper qw(:all);
use Bedrock::Model::Field;
use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(fileparse);
use Hash::Merge qw(merge);
use JSON;
use List::Util qw( pairs any none mesh uniq);
use Scalar::Util qw( reftype );
use Text::CSV_XS;

use Role::Tiny::With;
with 'Bedrock::Logger';
with 'Bedrock::Role::Config';

use parent qw( Exporter BLM::DBHandler );

our $VERSION = '@PACKAGE_VERSION@';  ## no critic (RequireInterpolationOfMetachars)

__PACKAGE__->create_accessors(
  qw(
    _search_fields
    attributes
    labels
    config
    field_list
    insert_query
    lists
    lock
    reload_query
    table_dir
    table_name
    upsert_mode
    __query
    __args
    __arg_list
    __benchmarks
  )
);

our @EXPORT_OK = qw(easy_connect);

########################################################################
sub _new {
########################################################################
  my ( $self, @args ) = @_;

  die "usage: BLM::IndexedTableHandler->new(...)\n"
    if !ref $args[0];

  return $self->_new_with_query(@args)
    if ref( $args[0] ) !~ /DBI::db/xsm;

  my $dbi = shift @args;
  $self->dbi($dbi);

  return $self->_new_with_id(@args)
    if !is_hash( $args[0] );

  return $self->_new_with_options(@args);
}

# filename or open handle
########################################################################
sub load_config {
########################################################################
  my ( $self, $config_name ) = @_;

  my $config = eval {

    return $config_name
      if ref $config_name;

    return site_config($config_name);
  };

  croak "error loading $config_name\n$EVAL_ERROR"
    if !$config || $EVAL_ERROR;

  $self->set_config($config);

  croak q{no 'tables' element found, not a table definition file}
    if !$config->{tables};

  my %tables = %{ $config->{tables} };

  my ($table_name) = eval {
    return keys %tables
      if scalar keys %tables == 1;

    if ( !openhandle $config_name) {
      return fileparse( $config_name, qr/[.][^.]+$/xsm )
        if !openhandle $config_name;
    }

    return $self->create_table_name;
  };

  croak 'could not determine table name'
    if !$table_name || $EVAL_ERROR;

  my %db_config = %{ $config->{database} || {} };

  my $dbi = eval {
    return $self->easy_connect
      if !scalar keys %db_config;

    return easy_connect(
      user       => $db_config{user},
      password   => $db_config{password},
      dsn        => $db_config{dsn},
      AutoCommit => $db_config{auto_commit} // $TRUE,
      host       => $db_config{hostname}    // $db_config{host} // 'localhost',
    );
  };

  croak "could not connect to a database\n$EVAL_ERROR"
    if !$dbi || $EVAL_ERROR;

  return __PACKAGE__->new( $dbi, $table_name, $config );
}

########################################################################
sub easy_connect { goto &BLM::DBHandler::easy_connect; }
########################################################################

########################################################################
sub new {
########################################################################
  my ( $this, @args ) = @_;

  my $class = ref $this || $this;

  my $self = bless {}, $class;

  return $self
    if !@args;

  $self->track_all();

  my $id = $self->_new(@args);

  # - avoid redundant creation of data structure for each row in a list
  #   i.e. if this object is being constructed thusly:
  #
  #   $another = $me->new($dbi, $id);
  #
  #   which is done from find() for example, then we really don't want to
  #   create multiple arrays that hold the table directory, one will do nicely thanks
  #

  if ( ref $this && $this->can('get_field_list') ) {

    # grab all the same hidden values from the reference class
    # instance except the history vars
    for my $key ( keys %{$this} ) {
      next if $self->is_field($key);

      next if any { $key eq $_ } qw(__query __args __arg_list __benchmarks);

      $self->{$key} = $this->{$key};
    }
  }
  else {

    if ( !$self->get_table_name ) {
      $self->set_table_name( $self->create_table_name );
    }

    die 'Unable to determine table name'
      if !$self->get_table_name;

    # validate config object
    if ( !ref $self->get_config || !$self->get_config->{tables} ) {
      $self->set_config( {} );
    }

    if ( $self->table_exists( $self->get_table_name ) ) {

      $self->set_table_dir( $self->_get_table_dir );

      foreach ( $self->get_fields ) {
        if ( $self->get_field_type($_) eq 'timestamp' ) {
          $self->set_display_only($_);
        }
      }
    }

    $self->set_insert_query( $self->create_insert_query );

    $self->set_reload_query( $self->create_reload_query );

    $self->set_upsert_mode($FALSE);  # default legacy behavior

    $self->set_return_bedrock_refs($TRUE);
  }

  $self->init_config;

  return $self->_init_record($id);
}

########################################################################
sub create_reload_query {
########################################################################
  my ($self) = @_;

  my $reload_query = <<'END_OF_SQL';
 select *
   from %s
   where id = ?
END_OF_SQL

  return sprintf $reload_query, $self->get_table_name;
}

########################################################################
sub _init_record {
########################################################################
  my ( $self, $id ) = @_;

  return $self
    if !$id;

  die "invalid id\n"
    if !is_id($id);

  my $lock_mode = {
    0 => $EMPTY,
    1 => 'for update',
    2 => 'lock in share mode'
  }->{ $self->get_lock || 0 };

  my $query = $self->get_reload_query;

  my $ref = $self->select( "$query $lock_mode", $id );

  foreach ( keys %{$ref} ) {
    $self->{$_} = $ref->{$_};
  }

  return $self;
}

########################################################################
sub create_insert_query {
########################################################################
  my ( $self, @fields ) = @_;

  my $query = <<'END_OF_SQL';
insert into %s (%s) values (%s)
END_OF_SQL

  if ( !@fields ) {
    @fields = $self->get_fields();
  }

  my $field_names = join $COMMA, @fields;
  my $table_name  = $self->get_table_name;

  my $bind_vars = join $COMMA, split $EMPTY, ($QUESTION_MARK) x scalar @fields;

  return sprintf $query, $table_name, $field_names, $bind_vars;
}

########################################################################
sub get_count { unshift @_, 1; goto &_find_or_count; }  ## no critic (RequireArgUnpacking)
########################################################################

########################################################################
sub dbi {
########################################################################
  my ( $self, $dbi ) = @_;

  if ($dbi) {
    die "[$dbi] not a DBI object\n"
      if !ref $dbi || ref($dbi) !~ /DBI::db/xsm;

    die "BLM::IndexedTableHandler currently only supports MySQL tables.\n"
      if $dbi->get_info(17) !~ /mysql/xsmi;

    $self->{_dbi} = $self->{_db} = $dbi;
  }

  return $self->{_dbi};
}

########################################################################
sub create_accessors {
########################################################################
  my ( $self, @accessors ) = @_;

  no strict 'refs';  ## no critic

  my $class = ref $self || $self;

  foreach my $sub (@accessors) {
    *{ $class . q{::set_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };

    *{ $class . q{::get_} . $sub } = sub {
      shift->_set_get( "_$sub", @_ );
    };
  }

  return;
}

########################################################################
# Log::Log4perl logging!
########################################################################
{
  ## no critic (ProhibitBuiltInHomonyms, RequireArgUnpacking)

  sub _log {
    my ( $level, $self, @args ) = @_;

    return $self->get_logger( ref $self )->$level(@args);
  }

  sub debug { unshift @_, 'debug'; goto &_log; }
  sub warn  { unshift @_, 'warn';  goto &_log; }
  sub info  { unshift @_, 'info';  goto &_log; }
  sub error { unshift @_, 'error'; goto &_log; }
}
########################################################################

########################################################################
sub lock {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  return $self->_set_get( '_lock', @args );
}

########################################################################
sub is_id {
########################################################################
  my ( $self, $id ) = @_;

  if ( !ref $self ) {
    $id = $self;
  }

  return ( defined $id && $id !~ /\D/xsm ) ? $id : $FALSE;
}

########################################################################
sub get_format_mode {
########################################################################
  my ( $self, $key ) = @_;

  if ( !$self->{_format_mode} ) {
    $self->{_format_mode} = {};
  }

  return $self->{_format_mode}->{$key};
}

########################################################################
# Usage     : delete(id)
#           : delete(column_name)
#           : delete({ id => $id }); PREFERRED
#           : delete({ column_name => }); PREFERRED
# Purpose   : delete a record or delete a field from record
########################################################################
sub delete {  ## no critic (Subroutines::ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  ######################################################################
  # unpack arguments

  my $id;
  my $column_name;

  if ( is_hash( $args[0] ) ) {
    if ( exists $args[0]->{id} ) {
      $id = $args[0];
    }
    elsif ( exists $args[0]->{column} || exists $args[0]->{field} ) {
      $column_name = $args[0]->{field} || $args[0]->{column};
    }
  }
  elsif (@args) {
    if ( is_id( $args[0] ) ) {
      $id = $args[0];
    }
    elsif ( $args[0] && $self->is_field( $args[0] ) ) {
      $column_name = $args[0];
    }
  }
  else {
    $id = $self->{id};
  }

  ######################################################################
  # delete field or record

  if ($id) {
    $self->reset( { delete => $TRUE } );
    return $self->_delete($id);
  }

  if ( $column_name && $self->is_field($column_name) ) {
    return CORE::delete $self->{$column_name};
  }

  return $self;
}

########################################################################
sub null {
########################################################################
  my ( $self, @args ) = @_;

  my @columns = ref $args[0] ? @{ $args[0] } : @args;

  my @fields = $self->get_fields();

  foreach my $column_name (@columns) {
    if ( $self->is_field($column_name) ) {
      $self->{$column_name} = undef;
    }
  }

  return $self;
}

########################################################################
sub is_null {
########################################################################
  my ( $self, $column ) = @_;

  return !defined $self->{$column};
}

########################################################################
sub is_field {
########################################################################
  my ( $self, $column ) = @_;

  return exists $self->{_table_dir}->{$column};
}

########################################################################
sub reset {  ## no critic (ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  my $delete_flag;

  if ( is_hash( $args[0] ) ) {
    $delete_flag = $args[0]->{delete} // $FALSE;
  }
  else {
    $delete_flag = $args[0] // $FALSE;
  }

  foreach my $column ( @{ $self->get_field_list } ) {
    if ($delete_flag) {
      delete $self->{$column};
    }
    else {
      $self->{$column} = undef;
    }
  }

  return $self;
}

########################################################################
sub encrypt {
########################################################################
  my ( $self, $column, $secret ) = @_;

  croak "$column is not a column in the table\n"
    if !$self->is_field($column);

  my $query = <<'END_OF_SQL';
update %s
  set %s = aes_encrypt(%s, ?)
END_OF_SQL

  $query = sprintf $query, $self->get_table_name, $column, $column;

  return $self->Do( $query, $secret );
}

########################################################################
sub decrypt {
########################################################################
  my ( $self, $column, $secret ) = @_;

  my $query = <<'END_OF_SQL';
select aes_decrypt(?, ?) as secret
END_OF_SQL

  my $result = $self->select( $query, $self->{$column}, $secret );

  return $result->{secret};
}

########################################################################
sub init_config {
########################################################################
  my ($self) = @_;

  # no configuration passed
  return
    if !$self->get_config || !$self->get_table_config;

  my $config = $self->get_table_config;

  my $table_name = $self->get_table_name;

  my $table_config = $self->get_table_config($table_name);

  return
    if !$table_config;

  my %default = (
    set => sub {
      my ( $self, $f, $v ) = @_;
      return $self->{$f} = $v;
    },
    get => sub {
      my ( $self, $f, $v ) = @_;
      return $self->{$f};
    },
    attributes => {},
    labels     => $EMPTY,
  );

  foreach my $type (qw(set get attributes labels)) {
    my $config = $table_config->{$type} || {};

    foreach my $column ( $self->get_fields ) {
      next
        if exists $config->{$column};

      $config->{$column} = $default{$type};
    }

    $table_config->{$type} = $config;
  }

  $config->{$table_name} = $table_config;

  return $self->get_config;
}

########################################################################
sub get_table_config {
########################################################################
  my ( $self, $table_name ) = @_;

  my $config = $self->get_config // {};

  return $config
    if !$config->{tables};

  return $table_name ? $config->{tables}->{$table_name} : $config->{tables};
}

########################################################################
sub set_table_config {
########################################################################
  my ( $self, $config ) = @_;

  $config //= {};

  $self->get_config->{tables} = $config;

  $self->init_config;

  return $config;
}

########################################################################
sub config {
########################################################################
  my ($self) = @_;

  return $self->get_config;
}

########################################################################
sub get {
########################################################################
  my ( $self, @args ) = @_;

  if ( @args > 1 ) {
    return Bedrock::Array->new( map { $self->_get($_) } @args );
  }
  else {
    return $self->_get( $args[0] );
  }
}

########################################################################
sub set {  ## no critic (ProhibitBuiltinHomonyms,ProhibitAmbiguousNames)
########################################################################
  my ( $self, @args ) = @_;

  if ( @args == 1 ) {
    my $ref = $args[0];

    die "use of set() with one argument requires a hash reference\n"
      if !is_hash($ref);

    foreach my $f ( $self->get_fields() ) {
      if ( exists $ref->{$f} ) {
        $self->_set( $f, $ref->{$f} );
      }
      # NOTE: if the field type is a 'tinyint', i.e. boolean, then this was
      #   rendered as a checkbox.  Unfortunately, an HTML checkbox that is not checked
      #   does not manifest itself in the QUERY_STRING.  Therefore, we're going out a bit
      #   on a limb here, but if you've asked this method to use an object to set the
      #   field values, then most likely this is the $input object AND we'll attempt to
      #   handle the checkbox problem for you...so if the field value is NOT in the input
      #   object AND the field type is tinyint...set the value to $FALSE
      elsif ( $self->get_field_type($f) eq 'tinyint' ) {
        $self->_set( $f, $FALSE );
      }
    }
  }
  else {
    $self->_set(@args);
  }

  return $self;
}

########################################################################
sub get_field_type {
########################################################################
  my ( $self, $field ) = @_;

  die "usage: get_field_type(field)\n"
    if !$field;

  return $self->get_table_dir->{$field}->{Type};
}

########################################################################
# dumps private/public keys separately (debugging)
########################################################################
sub dumper {
########################################################################
  my ($self) = @_;

  my @private = grep { $_ =~ /^_/xsm } keys %{$self};
  my @public  = grep { $_ !~ /^_/xsm } keys %{$self};

  my $public_values  = Bedrock::Hash->new;
  my $private_values = Bedrock::Hash->new;

  @{$public_values}{@public}   = @{$self}{@public};
  @{$private_values}{@private} = @{$self}{@private};

  return Bedrock::Array->new( $public_values, $private_values );
}

########################################################################
sub save {
########################################################################
  my ( $self, @args ) = @_;

  my $reload = $TRUE;

  if (@args) {

    if ( is_hash( $args[0] ) ) {
      my $row = shift @args;

      foreach my $field ( $self->get_fields ) {
        next if !exists $row->{$field};

        $self->set( $field, $row->{$field} );
      }
    }
  }

  if (@args) {
    $reload = $args[0];
  }

  my $id = $self->{id} // 0;

  if ($id) {
    $self->_update;
  }
  elsif ( $self->get_upsert_mode ) {
    $self->_insert_some;
  }
  else {
    $self->_insert_all;
  }

  if ($reload) {
    $self->reload;
  }

  return $self->{id};
}

########################################################################
sub reload {
########################################################################
  my ( $self, $id ) = @_;

  $id //= $self->{id};

  # note we bypass benchmarking by not using $self->select();

  my $sth = $self->dbi->prepare( $self->get_reload_query );

  $sth->execute($id);

  my $ref = $sth->fetchrow_hashref;
  $sth->finish();

  foreach my $field ( keys %{$ref} ) {
    $self->set( $field, $ref->{$field} );
  }

  return $self;
}

########################################################################
sub get_fields {
########################################################################
  my ( $self, @args ) = @_;

  my %options = ref $args[0] ? %{ $args[0] } : @args;

  my @field_names = @{ $self->get_field_list // [] };

  if ( !@field_names ) {
    my $table_name = $self->get_table_name;

    croak sprintf "table [%s] does not exist\n", $table_name
      if !$self->table_exists($table_name);

    die "field list is empty\n";
  }

  if ( !$options{exists_only} ) {
    if ( !$options{backticks} ) {

      for my $field_name (@field_names) {
        $field_name =~ s/`//gxsm;
      }
    }
  }
  else {
    @field_names = grep { exists $self->{$_} } @field_names;

    if ( $options{backticks} ) {
      for my $field_name (@field_names) {
        $field_name = "`$field_name`";
      }
    }
  }

  return @field_names
    if !$options{exclude};

  return _filter_array( \@field_names, $options{exclude} );
}

########################################################################
sub _filter_array {
########################################################################
  my ( $array, $exclude ) = @_;

  $exclude = is_array($exclude) ? $exclude : [$exclude];

  my %exclude_list = map { $_ => 1 } @{$exclude};

  return grep { !exists $exclude_list{$_} } @{$array};
}

########################################################################
sub set_field {
########################################################################
  my ( $self, $field, $value ) = @_;

  return if $self->get_display_only($field);

  my $type = $self->get_field_type($field);

  $value =~ s/^\s*(.*?)\s*/$1/xsm;

  for ($field) {

    /phone/xsm && $type =~ /char/xsm && do {

      if ($value) {
        $self->{$field} = $self->set_phone_field( $field, $value );

        die "invalid phone format: $value\n"
          if !$self->{$field};
      }
      last;
    };

    # rules of engagement:
    # - if the date is of the form mm/dd/yy[yy] then we
    #   we need to reformat the field to yyyy-mm-dd in order
    #   to insert this successfully into a MySQL database date field
    #   * if the year portion is yy (2-digit), we'll assume it is in this
    #     century if the value is < 20, i.e. 08 = 2008
    #   * if the year portion is > 20 and < 100 then we will assume
    #     the year is in the 20th century, i.e. 1900+yy
    # - if the date is of the form yyyy-mm-dd then we will leave it alone
    # - if the field is a timestamp and there is a date, but no time...
    #   * if the date is the current date, we will add the current time
    #   * if the date is not today, then the time added will bee 00:00:00
    # - if the field is null, let it be
    # - if the field is not of a recognized format, let it be

    /date|time/xsm && $type =~ /date|datetime|timestamp/xsm && do {

      my $date;
      my ( $mm, $dd, $year );

      if ( $value =~ /^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/xsm ) {
        ( $mm, $dd, $year ) = ( $1, $2, $3 );
        if ( $year < 20 ) {
          $year += 2000;
        }
        elsif ( $year < 100 ) {
          $year += 1900;
        }
        $date = sprintf '%04d-%02d-%02d', $year, $1, $2;
      }
      elsif ( $value =~ /^\s*(\d{4}-\d{2}-\d{2})/xsm ) {
        $date = $1;
      }
      else {
        $date = $value;
      }

      if ( $type =~ /timestamp|datetime/xsm ) {
        if ( $value =~ /(\d{1,2}):(\d{1,2})(:\d{1,2})*\s*(AM|PM)*$/ixsm ) {
          my ( $hh, $mi, $sec, $ampm ) = ( $1, $2, $3, $4 );
          $sec =~ s/[:]//xsm;

          $date .= sprintf ' %02d:%02d:%02d', uc $ampm eq 'PM' ? $hh + 12 : $hh, $mi, $sec;
        }
        else {
          my ( $cday, $cmon, $cyear ) = (localtime)[ ( 3, 4, 5 ) ];
          if ( $cday == $dd && $cmon == $mm - 1 && $year == 1900 + $cyear ) {
            $date .= sprintf ' %02d:%02d:%02d', (localtime)[ ( 2, 1, 0 ) ];
          }
          else {
            $date .= ' 00:00:00';
          }
        }
      }

      $self->{$field} = $date;
      last;
    };

    $self->{$field} = $value;
  }

  return $self->{$field};
}

########################################################################
sub key_fields {
########################################################################
  my ( $self, $hash ) = @_;

  my @fields = $self->get_fields();

  my $table_def = $self->get_table_dir;

  my @key_fields = grep { defined $table_def->{$_}->{Key} } @fields;

  return Bedrock::Array->new(@key_fields);
}

########################################################################
sub max_id {
########################################################################
  my ($self) = @_;

  my $result = $self->select( sprintf 'select max(id) id from %s', $self->get_table_name );

  return $result->{id};
}

########################################################################
sub set_search_field {
########################################################################
  my ( $self, $exact_flag, $field ) = @_;

  if ( !$self->get__search_fields ) {
    $self->set__search_fields( [] );
  }

  push @{ $self->get__search_fields }, $exact_flag, $field;

  return $self->get__search_fields;
}

########################################################################
sub set_key_fields {
########################################################################
  my ($self) = @_;

  my $table_def = $self->get_table_dir;

  my %fields;
  my @uni;
  my @mul;

  foreach my $field ( keys %{$table_def} ) {
    $fields{ $table_def->{$field}->{idx} } = $field;

    if ( $table_def->{$field}->{Key} eq 'UNI' ) {
      push @uni, $table_def->{$field}->{idx};
    }

    if ( $table_def->{$field}->{Key} eq 'MUL' ) {
      push @mul, $table_def->{$field}->{idx};
    }
  }

  foreach my $idx ( sort @uni ) {
    $self->set_search_field( $FIND_EXACT, $fields{$idx} );
  }

  foreach my $idx ( sort @mul ) {
    $self->set_search_field( $FIND_FUZZY, $fields{$idx} );
  }

  return;
}

########################################################################
sub select {  ## no critic (Subroutines::ProhibitBuiltinHomonyms)
########################################################################
  my ( $self, @args ) = @_;

  if ( !@args ) {
    my $query = <<'END_OF_SQL';
SELECT *
  FROM %s
END_OF_SQL
    $query = sprintf $query, $self->get_table_name;

    my $result = $self->select_list($query);

    return BLM::IndexedTableHandler::RecordSet->new($result);
  }
  else {
    return $self->SUPER::select(@args);
  }
}

########################################################################
sub search {
########################################################################
  my ( $self, $input, $exact_flag ) = @_;

  $exact_flag = $exact_flag || 0;

  if ($input) {
    $self->set($input);
  }

  if ( !$self->get__search_fields ) {
    $self->set_key_fields;
  }

  my @search_args;

  if ( $self->get__search_fields && @{ $self->get__search_fields } ) {
    my @search_fields = @{ $self->get__search_fields };

    foreach my $p ( pairs @search_fields ) {
      my ( $exact_flag, $field_name ) = @{$p};

      if ( $self->{$field_name} ) {
        push @search_args, $exact_flag, $field_name, $input->{$field_name};
      }
    }
  }

  # still uncomfortable with assuming certain wildcard/non-wildcard searching
  if ( !@search_args ) {
    foreach my $f ( $self->get_fields ) {
      if ( $input->{$f} ) {
        push @search_args, $exact_flag, $f, $input->{$f};
      }
    }
  }

  return $self->_find(@search_args);
}

########################################################################
# Usage      : find(field, value)
#            : find(MATCH-FLAG, field, value, ...
#            : find(id)
# Returns    : BLM::IndexedHandler::RecordSet
# Parameters : field - valid column in table
#              value - value to use for matchig
#              MATCH-FLAG - $FIND_FUZZY or $FIND_EXACT
#              id - non-zero integer corresponding to id column
# Errors     : invalid number of arguments
########################################################################
sub find {
########################################################################
  my ( $self, @args ) = @_;

  # id
  if ( @args == 1 ) {
    my $id = shift @args;

    die "id must be a positive integer\n"
      if !is_id($id) || !$id;

    return $self->new( $self->dbi, $id );
  }

  # like
  if ( @args == 2 ) {
    return $self->_find( $FIND_FUZZY, @args );
  }

  # match-flag, column, value
  if ( !( @args % 3 ) ) {
    return $self->_find(@args);
  }

  # ?
  if (@args) {
    die "invalid number of arguments\n";
  }
  # all rows
  else {
    return $self->_find;
  }
}

########################################################################
sub columns { goto &fields; }
########################################################################

########################################################################
sub fields {
########################################################################
  my ($self) = @_;

  return Bedrock::Array->new( $self->get_fields() );
}

########################################################################
sub find_unique {
########################################################################
  my ( $self, @args ) = @_;

  my @find_args;

  foreach my $p ( pairs @args ) {
    push @find_args, $FIND_EXACT, @{$p};
  }

  my $result = $self->_find(@find_args);

  return
    if !$result;

  return $result ? $result->[0] : undef;
}

########################################################################
sub as_string {
########################################################################
  my ($self) = @_;

  return join $LIST_SEPARATOR, @{ $self->as_array_no_ref };
}

{
  my $csv;

########################################################################
  sub as_csv {
########################################################################
    my ($self) = @_;

    my @row  = @{ $self->as_array_no_ref };
    my @data = (@row)[ map { 1 + 2 * $_ } ( 0 .. $#row / 2 ) ];

    $csv //= Text::CSV_XS->new;

    return $csv->string()
      if $csv->combine(@data);

    die $csv->error_diag;
  }
}

########################################################################
sub as_json {
########################################################################
  my ($self) = @_;

  my @data = @{ $self->as_array };

  return JSON->new->encode( { @{ $self->as_array } } );
}

########################################################################
sub asref {
########################################################################
  my ( $self, @args ) = @_;

  return Bedrock::Hash->new( @{ $self->as_array(@args) } );
}

########################################################################
sub as_ref_raw {
########################################################################
  my ( $self, @args ) = @_;

  return Bedrock::Hash->new( @{ $self->as_array_no_ref(@args) } );
}

########################################################################
sub as_ref { goto &asref; }
########################################################################

########################################################################
sub _as_array_columns {
########################################################################
  my ( $self, @args ) = @_;

  return $self->get_fields()
    if !@args;

  return map { is_array($_) ? @{$_} : $_ } @args;
}

########################################################################
sub as_array {
########################################################################
  my ( $self, @args ) = @_;

  return [ map { ( $_ => $self->get($_) ) } $self->_as_array_columns(@args) ];
}

# if a getter returns a ref, use the raw value
########################################################################
sub as_array_no_ref {
########################################################################
  my ( $self, @args ) = @_;

  my $data = [];

  foreach ( $self->_as_array_columns(@args) ) {
    my $val = $self->get($_);
    push @{$data}, ref $val ? $self->{$_} : $val;
  }

  return $data;
}

########################################################################
sub get_formatted_field_length {
########################################################################
  my ( $self, $field ) = @_;

  my $type = $self->get_field_type($field);

  for ($field) {
    /phone/xsm && $type =~ /char/xsm && do {
      return 14;
    };

    /date|time/xsm && $type =~ /time/xsm && do {
      return 20;
    };

    /date/xsm && $type =~ /date/xsm && do {
      return 10;
    };

    $type =~ /[(](\d+)[,]?.*[)]/xsm && do {
      return $1;
    };

    $type eq 'boolean' && do {
      return 1;
    };
  }

  return 0;
}

#######################################################################
sub get_field_length {
#######################################################################
  my ( $self, $field_name ) = @_;

  my $type = $self->get_field_type($field_name);

  if ( $type =~ /[(](\d+)[,]?.*[)]/xsm ) {
    return $1;
  }

  if ( $self->get_format_mode($field_name) ) {
    return $self->get_formatted_field_length($field_name);
  }

  my %field_lengths = (
    data      => 10,
    datetime  => 20,
    timestamp => 20,
    boolean   => 1,
    tinyint   => 1,
    int       => 11,
  );

  return $field_lengths{$type}
    if $field_lengths{$type};

  return 0;
}

########################################################################
sub get_enum_values {
########################################################################
  my ( $self, $field ) = @_;

  die "usage: get_enum_value( column-name )\n"
    if !$field;

  my $type = $self->get_field_type($field);

  my $enum;

  if ( $type =~ /(enum|set)[(]([^()]+)[)]/xsm ) {
    $enum = $2;
  }

  die "column: [$field] is not an 'enum' or 'set' field type\n"
    if !$enum;

  $enum =~ s/[']//gxsm;

  return Bedrock::Array->new( split /[,]/xsm, $enum );
}

########################################################################
sub add_class {
########################################################################
  my ( $class, $new_class ) = @_;

  return join $SPACE, $new_class, split /$SPACE/xsm, $class;
}

########################################################################
sub create_date_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  $attributes //= {};
  $attributes->{input} //= {};

  my $length = $self->get_field_length($field_name);

  my $value = $self->get_formatted_field($field_name) // $EMPTY;

  my $size = length $value > $length ? length $value : $length;

  my $disabled = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    ( type  => 'date',
      name  => $field_name,
      value => $value,
    ),
    $disabled ? ( disabled => undef ) : (),
    %{ $attributes->{input} }
  );

}

########################################################################
sub create_char_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $value = $self->get_formatted_field($field_name) // $EMPTY;

  my $length = $self->get_field_length($field_name);

  my $size = $length <= length $value ? length $value : $length;

  my $disabled = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    ( type      => 'text',
      name      => $field_name,
      value     => $value,
      maxlength => $size,
      size      => $size
    ),
    $disabled ? ( disabled => undef ) : (),
    %{ $attributes->{input} }
  );
}

########################################################################
sub get_selected_values {
########################################################################
  my ( $self, $field_name ) = @_;

  my $value = $self->{$field_name};

  return $value
    if $self->get_field_type($field_name) !~ /set/xsm;

  return [ split $COMMA, $self->{$field_name} // $EMPTY ];
}

########################################################################
sub create_select_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists, $options ) = @_;

  my $value = $self->get_selected_values($field_name);

  if ( $self->get_display_only($field_name) ) {
    $attributes->{disabled} = undef;
  }

  return create_select_list( $field_name, $value, $attributes, @{ $options->{list} } );
}

########################################################################
sub create_radio_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists, $options ) = @_;

  if ( $self->get_display_only($field_name) ) {
    $attributes->{disabled} = undef;
  }

  return create_radio_buttons( $field_name, $self->{$field_name}, $attributes, $options->{list} );
}

########################################################################
sub get_formatted_field {
########################################################################
  my ( $self, $field_name ) = @_;

  my $value = $self->get($field_name);

  if ( $self->get_format_mode($field_name) ) {
    $value = $self->format_field( $field_name, $value );
  }

  return $value;
}

########################################################################
sub format_field {
########################################################################
  my ( $self, $field_name, $value ) = @_;

  my $type = $self->get_field_type($field_name);

  for ($field_name) {
    /date/xsm && $type =~ /date/xsm && do {
      $value = $self->get_date_field($field_name);
      last;
    };

    /phone/xsm && $type =~ /char/xsm && do {
      $value = $self->get_phone_field($field_name);
      last;
    };
  }

  return $value;
}

########################################################################
sub create_varchar_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $value = $self->get_formatted_field($field_name) // $EMPTY;

  my $length = $self->get_field_length($field_name);

  my $size = $length <= length $value ? length $value : $length;

  my $disabled = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    ( type      => 'text',
      name      => $field_name,
      value     => $value // $EMPTY,
      maxlength => $length,
      size      => $size
    ),
    $disabled   ? ( disabled => undef )     : (),
    $attributes ? %{ $attributes->{input} } : ()
  );
}

########################################################################
sub create_tinyint_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists, $options ) = @_;

  $attributes //= { input => { id => $field_name } };

  my $disabled = $self->get_display_only($field_name);

  if ($disabled) {
    $attributes->{input}->{disabled} = undef;
  }

  return $self->create_checkbox_field( $field_name, $attributes, $labels, $lists );
}

########################################################################
sub create_checkbox_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists, $options ) = @_;

  $options //= { list => [ create_label_name($field_name), 1 ] };

  my $value;

  if ( $self->get_field_type($field_name) =~ /set/xsm ) {
    $value = [ split /$COMMA/xsm, $self->{$field_name} // $EMPTY ];
  }
  else {
    $value = $self->{$field_name} ? [ $self->{$field_name} ] : [];
  }

  return create_checkbox(
    { name       => $field_name,
      attributes => $attributes,
      checked    => $value,
      values     => $options->{list} // [],
    }
  );
}

########################################################################
sub create_int_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $size = $self->get_field_length($field_name);
  $attributes //= {};

  my $value = $self->get_formatted_field($field_name) // $EMPTY;

  my %int_attributes = %{$attributes};
  $int_attributes{disabled} = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    type  => 'number',
    name  => $field_name,
    value => $value,
  );
}

########################################################################
sub create_timestamp_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $size = $self->get_field_length($field_name);

  my $value = $self->get_formatted_field($field_name);
  $size = length($value) || $size;

  my $disabled = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    ( type      => 'text',
      name      => $field_name,
      value     => $value,
      maxlength => $size,
      size      => $size,
    ),
    $disabled   ? ( disabled => undef )     : (),
    $attributes ? %{ $attributes->{input} } : ()
  );
}

########################################################################
sub create_decimal_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $size = $self->get_field_length($field_name);

  my $value = $self->get_formatted_field($field_name);

  $size = ( $size > length $value ) ? $size : length $value;

  my $disabled = $self->get_display_only($field_name);

  return create_html_element(
    'input',
    ( type      => 'text',
      name      => $field_name,
      value     => $self->{$field_name},
      maxlength => $size,
      size      => $size
    ),
    $disabled   ? ( disabled => undef )     : (),
    $attributes ? %{ $attributes->{input} } : ()
  );
}

########################################################################
sub create_text_field {
########################################################################
  my ( $self, $field_name, $attributes, $labels, $lists ) = @_;

  my $disabled = $self->get_display_only($field_name);

  my %defaults = (
    name => $field_name,
    rows => 5,
    cols => 40,
    $disabled ? ( disabled => undef ) : (),
  );

  return sprintf '%s%s</textarea>',
    create_html_element( 'textarea', %defaults, $attributes ? %{ $attributes->{textarea} } : () ),
    $self->{$_};
}

########################################################################
sub html_form_header {
########################################################################
  my ( $self, $attributes ) = @_;

  $attributes //= $self->get_attributes // {};

  my $table_name = $self->get_table_name;

  my %defaults = (
    method => 'post',
    name   => $table_name,
    id     => $table_name,
    $ENV{PATH_INFO} ? ( action => $ENV{PATH_INFO} ) : (),
  );

  return create_xhtml_element_header( 'form', %defaults, %{ $attributes->{form} }, );
}

########################################################################
sub html_form_footer {
########################################################################
  my ( $self, $attributes, %hidden ) = @_;

  $attributes //= $self->get_attributes() // {};
  my $table_name = $self->get_table_name;

  my $table_config = $self->get_table_config($table_name) // {};

  # default button list

  my %button_config = %{ $table_config->{buttons} // {} };

  my $default_button_attributes = delete $button_config{attributes} // {};

  my @buttons = uniq( qw(save find new delete), keys %button_config );

  foreach (@buttons) {
    $button_config{$_} = merge( $button_config{$_} // {}, $default_button_attributes );
  }

  if ( !$self->{id} ) {
    $button_config{delete}->{disabled} = undef;
  }

  my @button_group;

  foreach my $button (@buttons) {

    my %button_attributes = (
      value => $button,
      id    => sprintf( '%s-%s-button', $table_name, $button ),
      %{ $button_config{$button} },
    );

    push @button_group, create_xhtml_element( 'button', ( ucfirst $button ), %button_attributes );
  }

  my $buttons = join "\n", @button_group;

  my @html = create_xhtml_element( 'div', $buttons, id => sprintf '%s-button-group', $table_name );

  my @hidden_elements = create_html_element(
    'input',
    type  => 'hidden',
    name  => 'action',
    value => $EMPTY,
  );

  push @hidden_elements,
    create_html_element(
    'input',
    type  => 'hidden',
    name  => 'table',
    value => $table_name,
    );

  push @hidden_elements,
    create_html_element(
    'input',
    type  => 'hidden',
    value => $self->{id} // $EMPTY,
    name  => 'id',
    id    => 'id',
    );

  # add hidden fields
  foreach ( keys %hidden ) {
    push @hidden_elements,
      create_html_element(
      'input',
      type  => 'hidden',
      name  => $_,
      value => $hidden{$_},
      );
  }

  # format fields
  my @fields = @{ $self->get_field_list };

  my @format_fields = grep { $self->get_format_mode($_) } @fields;

  foreach (@format_fields) {
    push @hidden_elements,
      create_html_element(
      'input',
      type  => 'hidden',
      name  => 'format_mode',
      value => $_,
      );
  }

  return join "\n", @html, @hidden_elements, '</form>';
}

########################################################################
sub html_form_body_with_class {
########################################################################
  my ( $self, $attributes, $labels, $lists, $exclude_fields ) = @_;

  $attributes     //= $self->get_attributes;
  $labels         //= $self->get_labels;
  $lists          //= $self->get_lists;
  $exclude_fields //= [];

  my $class;

  if ( ref($self) =~ /::([^:]+)$/xsm ) {
    $class = lc $1;
    $class =~ s/_/-/xsm;
  }
  else {
    $class = $EMPTY;  # not sure this is even valid?
  }

  foreach my $name ( $self->get_fields() ) {
    my $hyphenated_name = lc $name;
    $hyphenated_name =~ s/_/-/xsmg;

    $attributes->{$name} //= {};

    foreach my $element (qw(input select textarea)) {
      $attributes->{$name}->{$element} = {
        class => $class . $DASH . $element,
        id    => $hyphenated_name,
      };
    }

    $attributes->{$name}->{th} = {
      class => "$class-label",
      id    => $hyphenated_name . $DASH . 'label'
    };
  }

  return $self->html_form_body( $attributes, $labels, $lists, $exclude_fields );
}

########################################################################
sub html_form_body {
########################################################################
  my ( $self, $attributes, $labels, $lists, $exclude_fields ) = @_;

  $attributes     //= $self->get_attributes;
  $labels         //= $self->get_labels;
  $lists          //= $self->get_lists;
  $exclude_fields //= [];

  my %exclude_field_list = map { $_ => 1 } ( 'id', @{ $exclude_fields // [] } );

  my $table_attributes = $attributes->{table} || {};

  my @field_types = qw(
    char
    checkbox
    date
    decimal
    int
    radio
    select
    timestamp
    tinyint
    varchar
  );

  my %dispatch = map { $_ => $self->can( 'create_' . $_ . '_field' ); } @field_types;

  $dispatch{datetime} = $dispatch{timestamp};

  my @elements;

  my $html = create_xhtml_element_header( 'table', %{ $attributes->{table} } ) . "\n";

  my @fields = grep { !exists $exclude_field_list{$_} } $self->get_fields();

  foreach my $field (@fields) {
    my $field_attributes = $attributes->{$field} // {};

    # if no "maxlength" is given for an input field and a "size" is
    # given, then use that as maxlength
    if ( $field_attributes->{size} && !exists $field_attributes->{maxlength} ) {
      $field_attributes->{maxlength} = $field_attributes->{size};
    }

    my $tr_attributes = $field_attributes->{tr};
    my $td_attributes = $field_attributes->{td};
    my $th_attributes = $field_attributes->{th};

    $tr_attributes //= $attributes->{tr} // {};
    $th_attributes //= $attributes->{th} // {};
    $td_attributes //= $attributes->{td} // {};

    my $field_type = $self->get_field_type($field);

    # - first check to see if this is a pick list
    my $options;

    if ( $lists->{$field} || $field_type =~ /enum|set/xsm ) {
      $options = $self->_get_options( $lists->{$field}, $field_type );
    }

    if ( $lists->{$field} ) {  ## no critic (ProhibitCascadingIfElse)
      if ( $options->{type} =~ /select|radio|checkbox/xsm ) {
        my $input_element;

        if ( $options->{type} eq 'select' ) {
          $input_element = $self->create_select_field( $field, $field_attributes, $labels, $lists, $options );
        }
        elsif ( $options->{type} eq 'radio' ) {
          $input_element = $self->create_radio_field( $field, $field_attributes, $labels, $lists, $options );
        }
        elsif ( $options->{type} eq 'checkbox' ) {
          $input_element = $self->create_checkbox_field( $field, $field_attributes, $labels, $lists, $options );
        }

        $html .= sprintf
          "%s\n%s%s</th>%s%s</td>\n</tr>\n",
          create_xhtml_element_header( 'tr', %{$tr_attributes} ),
          create_xhtml_element_header( 'th', %{$th_attributes} ),
          $labels->{$field} || create_label_name($field),
          create_xhtml_element_header( 'td', %{$td_attributes} ),
          $input_element;
      }
    }
    elsif ( $field_type =~ /enum|set/xsm ) {

      if ( $options && get_options_count( $options->{list} ) > 4 ) {
        $html .= sprintf
          "%s\n%s%s</th>%s%s</td>\n</tr>\n",
          create_xhtml_element_header( 'tr', %{$tr_attributes} ),
          create_xhtml_element_header( 'th', %{$th_attributes} ),
          $labels->{$field} || create_label_name($field),
          create_xhtml_element_header( 'td', %{$td_attributes} ),
          $self->create_select_field( $field, $field_attributes, $labels, $lists, $options );
      }
      else {
        my $input_element;

        if ( $field_type =~ /enum/xsm ) {
          $input_element = $self->create_radio_field( $field, $field_attributes, $labels, $lists, $options );
        }
        else {
          $input_element = $self->create_checkbox_field( $field, $field_attributes, $labels, $lists, $options );
        }

        $html .= sprintf
          "%s\n%s%s</th>%s%s</td>\n</tr>\n",
          create_xhtml_element_header( 'tr', %{$tr_attributes} ),
          create_xhtml_element_header( 'th', %{$th_attributes} ),
          $labels->{$field} || create_label_name($field),
          create_xhtml_element_header( 'td', %{$td_attributes} ),
          $input_element;
      }
    }
    elsif ( $field_type =~ /tinyint/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} // $EMPTY,
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_tinyint_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /varchar/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_varchar_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /int/xsm ) {
      next if $field =~ /^id$/xsm;
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_int_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /^char/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_char_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /date/xsm ) {

      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_date_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /timestamp/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_timestamp_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /text/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_text_field( $field, $field_attributes, $labels, $lists );
    }
    elsif ( $field_type =~ /decimal/xsm ) {
      $html .= sprintf
        "%s\n%s%s</th>%s%s</td>\n</tr>\n",
        create_xhtml_element_header( 'tr', %{$tr_attributes} ),
        create_xhtml_element_header( 'th', %{$th_attributes} ),
        $labels->{$field} || create_label_name($field),
        create_xhtml_element_header( 'td', %{$td_attributes} ),
        $self->create_decimal_field( $field, $field_attributes, $labels, $lists );
    }
  }

  $html .= '</table>';

  return $html;
}

########################################################################
sub handler {
########################################################################
  my ( $self, $input ) = @_;

  my ( $format_mode, $action ) = @{$input}{qw(format_mode action)};

  if ($format_mode) {
    my @mode = ref $format_mode ? @{$format_mode} : $format_mode;

    foreach (@mode) {
      $self->set_format_mode( $_, $TRUE );
    }
  }

  my %dispatch = (
    save => sub {
      my ( $self, $input ) = @_;

      $self->set($input);
      $self->save();

      return $self;
    },
    delete => sub {
      my ( $self, $input ) = @_;

      die "no id\n"
        if !$input->{id};

      $self->delete( $input->{id} );
      $self->{id} = 0;

      foreach ( @{ $self->{_field_list} } ) {
        $self->set( $_, undef );
      }

      return $self;
    },
    new => sub {
      my ( $self, $input ) = @_;

      return $self;
    },
    find => sub {
      my ( $self, $input ) = @_;
      my $list = $self->search($input);
      if ( $list && @{$list} >= 1 ) {
        return $list;
      }
      else {
        return $self;
      }
    },
  );

  return $self
    if !$dispatch{$action};

  return $dispatch{$action}->( $self, $input );
}

########################################################################
sub get_display_only {
########################################################################
  my ( $self, $field_name ) = @_;

  $self->{_display_only} //= {};
  return $self->{_display_only}->{$field_name};
}

########################################################################
sub set_display_only {
########################################################################
  my ( $self, $field_name ) = @_;

  $self->{_display_only} //= {};

  return $self->{_display_only}->{$field_name} = 1;
}

# - Some default pseudo field type handlers

########################################################################
sub set_format_mode {
########################################################################
  my ( $self, $key, $mode ) = @_;

  $self->{_format_mode} //= {};
  return $self->{_format_mode}->{$key} = $mode;
}

########################################################################
# sets the phone field or just removes non-digits and returns value
########################################################################
sub set_phone_field {
########################################################################
  my ( $self, @args ) = @_;

  my $key;
  my $value;

  if ( @args == 2 ) {
    ( $key, $value ) = @args;
  }
  else {
    $value = $args[0];
  }

  if ($value) {
    $value =~ s/\D//xsmg;

    if ( $value =~ /^(\d{7}|\d{10})$/xsm ) {
      $value = $1;
    }
    else {
      $value = undef;
    }
  }

  if ( @args == 2 ) {
    $self->{$key} = $value;
  }

  return $value;
}

########################################################################
sub get_phone_field {
########################################################################
  my ( $self, $key ) = @_;

  if ( $self->{$key} ) {
    my $str = $self->{$key};

    if ( length $str == 7 ) {
      return sprintf '%s-%s', unpack 'a3a4', $str;
    }
    elsif ( length $str == 10 ) {
      return sprintf '(%s) %s-%s', unpack 'a3a3a4', $str;
    }
    else {
      return $self->{$key};  # I have no idea what you're up to here dude!
    }
  }
  else {
    return $self->{$key};
  }
}

########################################################################
sub set_date_field {
########################################################################
  my ( $self, @args ) = @_;

  my $key;
  my $value;

  if ( @args == 2 ) {
    ( $key, $value ) = @args;
  }
  else {
    $value = $args[0];
  }

  if ($value) {
    my @date = split /[\/-]/xsm, $value;

    if ( 3 == scalar @date ) {
      if ( $value =~ /-/xsm ) {
        $value = sprintf '%4d-%02d-%02d', @date;
      }
      else {
        if ( $date[2] < 30 ) {
          $date[2] += 2000;
        }

        $value = sprintf '%4d-%02d-%02d', @date[ ( 2, 0, 1 ) ];
      }
    }
  }

  if ( defined $key ) {
    $self->{$key} = $value;
  }

  return $value;
}

########################################################################
sub curdate {
########################################################################
  my ($self) = @_;

  my $query = <<'END_OF_SQL';
select curdate() as foo
END_OF_SQL
  my $result = $self->select($query);

  return $result->{foo};
}

########################################################################
sub curtime {
########################################################################
  my ($self) = @_;

  my $query = <<'END_OF_SQL';
select curtime() as t
END_OF_SQL
  my $result = $self->select($query);

  return $result->{t};
}

########################################################################
sub now {
########################################################################
  my ($self) = @_;

  my $query = <<'END_OF_SQL';
select now() as t
END_OF_SQL
  my $result = $self->select($query);

  return $result->{t};
}

########################################################################
sub date_format {
########################################################################
  my ( $self, $date, $fmt, $utc ) = @_;

  $date = $date =~ /^[\-\d]+$/xsm ? $date : $self->{$date};

  my $hour = $utc ? -5 : 0;

  my $query = <<'END_OF_SQL';
select date_format( date_add(?, INTERVAL ? HOUR), ?) as formatted_date
END_OF_SQL

  my $result = $self->select( $query, $date, $hour, $fmt );

  return $result->{formatted_date};
}

########################################################################
sub get_date_field {
########################################################################
  my ( $self, $key ) = @_;

  my $date_val = $self->{$key};

  return
    if !$date_val || $date_val =~ /0000\-00\-00/xsm;

  my @date = split /-/xsm, $date_val;

  if ( $date[2] =~ /\d{2}\s+(\d{2}:\d{2}:\d{2})/xsm ) {
    $date[3] = $1;
  }

  my $formatted_date = sprintf '%02d/%02d/%04d', @date[ ( 1, 2, 0 ) ];

  if ( $date[3] && $date[2] !~ /00:00:00/xsm ) {
    $formatted_date .= $SPACE . $date[3];
  }

  return $formatted_date;
}

########################################################################
sub set_email_field {
########################################################################
  my ( $self, @args ) = @_;

  my $key;
  my $value;

  if ( @args == 2 ) {
    ( $key, $value ) = $args[0];
  }
  else {
    $value = $args[0];
  }

  if ($value) {
    $value = $self->validate_email($value) ? $value : undef;
  }

  if ( @args == 2 ) {
    $self->{$key} = $value;
  }

  return $value;
}

########################################################################
sub validate_email {
########################################################################
  my ( $self, $email ) = @_;

  ## no critic (ProhibitComplexRegexes)

  return $email
    =~ /^([\d[:lower:][:upper:]]([-.\w]*[\d[:lower:][:upper:]])*@([\d[:lower:][:upper:]][-\w]*[\d[:lower:][:upper:]][.])+[[:lower:][:upper:]]{2,9})$/xsm;
}

########################################################################
sub autocomplete {
########################################################################
  my ( $self, %options ) = @_;

  my $query = <<'END_OF_SQL';
select %s
  from %s
END_OF_SQL

  my $where = $options{query} // $EMPTY;

  if ($where) {
    $query .= "\n  where %s\n";
  }

  my $columns = $options{columns} // [$ASTERISK];

  if ( !is_array($columns) ) {
    $columns = [$columns];
  }

  my @labels = $columns->[0] eq $ASTERISK ? $self->not_id : @{$columns};

  $columns = join $COMMA, @{$columns};

  $query = sprintf $query, $columns, $self->get_table_name, $where ? $where : ();

  my @bind_args = is_array( $options{args} ) ? @{ $options{args} } : ();

  my $result = $self->select_list( $query, @bind_args );

  my @list;

  foreach my $row ( @{$result} ) {

    foreach my $label (@labels) {
      my $value = $row->{$label};

      # while this could be 0, '' it's doubtful it would be a useful value in an autocomplete list
      next
        if !$value;

      if ( $options{uc} ) {
        $value = uc $value;
      }
      elsif ( $options{ucfirst} ) {
        $value = ucfirst $value;
      }

      push @list,
        {
        id    => $row->{id},
        label => $value,
        value => $row->{$label},
        };
    }
  }

  return \@list;
}

#######################################################################
sub not_id {
#######################################################################
  my ($self) = @_;

  return _filter_array( [ $self->get_fields ], 'id' );
}

# +-----------------+
# | PRIVATE METHODS |
# +-----------------+

# 1. counties:select
# 2. counties
# 3. Atlantic,Bergen,Burlington,...
# 4. [ { id => 0, item => 'foo'} ... ]
# 5. { type => 'select',
#      list => [ { id => 0, item => 'foo'} ... ]
#     }

#######################################################################
sub _get_options {
#######################################################################
  my ( $self, $list_type, $field_type ) = @_;

  $list_type //= $EMPTY;

  my $options = {};

  if ( is_hash($list_type) ) {
    $options = $list_type;
  }
  elsif ( is_array($list_type) ) {
    $options->{list} = create_item_list($list_type);
  }
  else {
    my ( $table_name, $type ) = split /$COLON/xsm, $list_type;

    if ($table_name) {
      if ( $table_name =~ /[,]/xsm ) {
        my @list_items = split /$COMMA/xsm, $table_name;

        $options->{list} = create_item_list(@list_items);
      }
      else {  # get select list from a table
        my $query = <<'END_OF_SQL';
SELECT *
  FROM %s
  ORDER BY ID
END_OF_SQL
        $query = sprintf $query, $table_name;

        $options->{list} = $self->select_list($query);
      }
    }
    else {
      if ( $field_type =~ /enum|set/xsm ) {
        my ($enum) = $field_type =~ /[(]([^)]+)[)]/xsm;

        $enum =~ s/[']//gxsm;

        my @list = split /[,]/xsm, $enum;
        #$options->{list} = create_item_list( mesh( [ map {ucfirst} @list ], \@list ) );
        $options->{list} = [ mesh( [ map {ucfirst} @list ], \@list ) ];

        if ( ( $field_type =~ /enum|set/xsm ) && get_options_count( $options->{list} ) > 4 ) {
          # unshift @{ $options->{list} }, { id => undef, item => 'None' };
          unshift @{ $options->{list} }, ( 'None', $EMPTY );
        }
      }
    }
  }

  return $options
    if $options->{type};

  $options->{type} = @{ $options->{list} } > 4 ? 'select' : 'radio';

  return $options;
}

########################################################################
sub _format_fields_for_insert {
########################################################################
  my ($self) = @_;

  my $dir = $self->get_table_dir;

  foreach my $field ( $self->get_fields() ) {
    next if !exists $self->{$field};

    if ( $self->get_format_mode($field) ) {
      $self->set_field( $field, $self->{$field} );
    }
  }

  return $self;
}

########################################################################
sub _find_or_count {
########################################################################
  my ( $count_only, $self, @args ) = @_;

  my $select = $count_only ? 'select count(id) as count' : 'select id';

  my $table_name = $self->get_table_name;

  my $query = "$select from $table_name";

  my $limit = $EMPTY;

  if ( $self->max_rows ) {
    $limit = sprintf ' limit %s ', $self->max_rows;
  }

  if (@args) {
    $query .= ' where ';
  }

  my @where_clause;
  my @fields = $self->get_fields;

  my @bind_args;

  while (@args) {
    my $exact_flag = shift @args;
    my $field      = shift @args;
    my $value      = shift @args;

    die "$self: invalid column name: [$field]\n"
      if none { $field eq $_ } @fields;

    push @where_clause, sprintf ' %s %s ?', $field, $exact_flag ? $EQUALS_SIGN : 'like';

    push @bind_args, $exact_flag ? $value : $value . $PERCENT;
  }

  if (@where_clause) {
    $query .= join ' and ', @where_clause;
  }

  $query .= $limit;

  $self->debug(
    sub {
      return Dumper( [ 'query:', $query, 'bind args:', \@bind_args ] );
    }
  );

  my $result = eval { return $self->select_list( $query, @bind_args ); };

  $self->debug(
    sub {
      return Dumper( [ 'result:', $result ] );
    }
  );

  die "Could not execute query:\n$query\n$EVAL_ERROR"
    if $EVAL_ERROR;

  return $result->[0]->{count}
    if $count_only;

  my @records;

  if ( @{$result} ) {

    my $dbi      = $self->dbi;
    my $config   = $self->get_config;
    my $max_rows = $self->max_rows;

    @records = map { $self->new( $dbi, $_->{id}, $config, $table_name ); } @{$result};

    if (@records) {
      foreach my $i ( 0 .. $#records ) {
        $records[$i]->{idx} = $i;
        $records[$i]->max_rows($max_rows);
      }
    }
  }

  return BLM::IndexedTableHandler::RecordSet->new(@records);
}

sub _find { unshift @_, undef; goto &_find_or_count }  ## no critic (RequireArgUnpacking)

########################################################################

{
  ## no critic (RequireArgUnpacking)
  sub is_array { return ref $_[0] && reftype( $_[0] ) eq 'ARRAY'; }
  sub is_hash  { return ref $_[0] && reftype( $_[0] ) eq 'HASH'; }
}

########################################################################
sub _insert {
########################################################################
  my ( $self, $some_or_all ) = @_;

  $self->_format_fields_for_insert;

  $self->{id} = 0;

  my $query;

  my @fields;

  if ( $some_or_all eq 'some' ) {
    @fields = $self->get_fields(
      { backticks   => $TRUE,
        exists_only => $TRUE
      }
    );

    $query = $self->create_insert_query(@fields);
  }
  else {
    $query = $self->get_insert_query;
  }

  $self->do( $query, $self->_get_values(@fields) );

  $self->{id} = $self->dbi->{mysql_insertid};

  return $self->{id};
}

########################################################################
sub _get_values {
########################################################################
  my ( $self, @fields ) = @_;

  if ( !@fields ) {
    @fields = $self->get_fields;
  }
  else {
    foreach my $field (@fields) {
      $field =~ s/`//gxsm;
    }
  }

  return @{$self}{@fields};
}

########################################################################
sub _insert_some { push @_, 'some'; goto &_insert; }  ## no critic (RequireArgUnpacking)
sub _insert_all  { push @_, 'all';  goto &_insert; }  ## no critic (RequireArgUnpacking)
########################################################################

########################################################################
sub _update {
########################################################################
  my ($self) = @_;

  $self->_format_fields_for_insert;

  my @fields = grep { $_ ne 'id' } $self->get_fields;

  @fields = grep { exists $self->{$_} ? "`$_`" : () } @fields;

  my $query = <<'END_OF_SQL';
update %s set %s where id = ?
END_OF_SQL

  $query = sprintf $query, $self->get_table_name, join $COMMA, map {"$_ = ?"} @fields;

  $self->do( $query, $self->_get_values(@fields), $self->{id} );

  return $self->{rows};
}

# - Default getter method checks to see whether there is method override specified
#   in tagx.xml
########################################################################
sub _get {
########################################################################
  my ( $self, $field ) = @_;

  die "($field) is not a field in the table\n"
    if !$self->is_field($field);

  return $self->{$field}
    if !$self->get_table_config;

  my $getters = $self->get_table_config->{ $self->get_table_name }->{get};

  return $self->{$field}
    if !is_hash($getters);

  my $func = $getters->{$field};
  $func = ref $func ? $func : $self->can($func);

  return $func ? $func->( $self, $field ) : $self->{$field};
}

########################################################################
sub _set {
########################################################################
  my ( $self, @args ) = @_;

  my $setters = $self->get_table_config->{ $self->get_table_name }->{set};

  foreach my $p ( pairs @args ) {
    my ( $field, $value ) = @{$p};

    my $type = $self->get_field_type($field);

    die "field $field does not exist in table\n"
      if !defined $type;

    # 0 dates and time are undef?
    if ( $type =~ /date|time/xsm && !$value ) {
      $value = undef;
    }

    if ( my $method = $setters->{$field} ) {
      my $func = ref $method ? $method : $self->can($method);

      if ( ref $func ) {
        $self->{$field} = $func->( $self, $field, $value );
      }
      else {
        &warn( $self, "You've specified a field formatter, but there is no method \'$method\'\n" );
        $self->{$field} = $value;
      }
    }
    elsif ( $type eq 'date' ) {

      if ( $value && $value =~ /\d{1,2}\/\d{1,2}\/\d{4}/xsm ) {
        $value = sprintf '%04d-%02d-%02d', ( split /\//xsm, $value )[ 2, 0, 1 ];
      }
      elsif ( $value && $value =~ /\d{1,2}\/\d{1,2}\/\d{2}/xsm ) {
        my @date = split /\//xsm, $value;

        if ( $date[2] < 20 ) {
          $date[2] += 2000;
        }
        elsif ( $date[2] > 20 ) {
          $date[2] += 1900;
        }

        $value = sprintf '%04d-%02d-%02d', @date[ ( 2, 0, 1 ) ];
      }

      $self->{$field} = $value;
    }
    elsif ( $type =~ /set/xsm ) {
      if ( ref $value ) {
        $self->{$field} = join q{,}, @{$value};
      }
      else {
        $self->{$field} = $value;
      }
    }
    elsif ( $type =~ /enum/xsm ) {
      my $enum_values = $self->get_enum_values($field);
      $self->{$field} = any { $_ eq $value } @{$enum_values} ? $value : undef;
    }
    else {
      $self->{$field} = $value;
    }
  }

  return;
}

# creates a table name from a class name
# looks for CamelCase class suffixes and converts them to snake case words
# Example:
#   Foo::Bar => bar
#   Foo::AccountUser => account_user
########################################################################
sub create_table_name {
########################################################################
  my ($class) = @_;

  $class = ref $class || $class;

  my ($table_name) = $class =~ /:?([^:]+)$/xsm;

  if ( $table_name =~ /[_]/xsm ) {
    return lc $table_name;
  }
  else {
    return join $UNDERSCORE,
      map {lc} split /(?<=[[:lower:]])(?=[[:upper:]])|(?<=[[:upper:]])(?=[[:upper:]][[:lower:]])/xsm,
      $table_name;
  }
}

########################################################################
sub build_condition {
########################################################################
  my ( $column, $value, $bind_vars ) = @_;

  # '!foo' => 1      (foo <> 1)
  # '!foo' => undef  (is not null)

  my $not = $column =~ /^\s*[!]/xsm;
  $column =~ s/[!]//xsm;

  my $condition;

  if ( defined $value ) {
    push @{$bind_vars}, $value;

    $condition = sprintf '%s %s ?', $column, $not ? '<>' : $EQUALS_SIGN;
  }
  else {
    $condition = sprintf '%s is %s null', $column, $not ? 'not' : $EMPTY;
  }

  return $condition;
}

# new( { dbi => $dbi, [table_name => table], column1 => value1, ...})
########################################################################
sub _new_with_query {
########################################################################
  my ( $self, $args ) = @_;

  my %args = %{$args};

  croak "no dbi handle\nusage: new({ dbi => handle, column1 => value1 ...});\n"
    if !exists $args{dbi} || ref( $args{dbi} ) !~ /^DBI::db/xsm;

  $self->dbi( delete $args{dbi} );

  my $table_name = delete $args{table_name};
  $table_name //= delete $args{table};
  $table_name //= $self->create_table_name;
  $self->set_table_name($table_name);

  croak 'could not determine table name'
    if !$self->get_table_name;

  my @bind_vars;

  my @columns = %args;

  die "no columns to query\n"
    if !@columns;

  my @or;
  my @conditions;

  foreach my $p ( pairs %args ) {
    my ( $column, $value ) = @{$p};

    if ( is_array($value) ) {
      for ( pairs( @{$value} ) ) {
        push @or, build_condition( @{$_}, \@bind_vars );
      }

      push @conditions, sprintf '( %s )', join ' or ', @or;
    }
    else {
      push @conditions, build_condition( $column,, $value, \@bind_vars );
    }
  }

  my $filter = sprintf 'select id from %s where %s', $self->get_table_name, join ' and ', @conditions;

  my $ref = $self->select( $filter, @bind_vars );

  #  $self->set_query($filter);
  #
  #  $self->set_bind_vars( \@bind_vars );
  #
  #  my $sth = $self->dbi->prepare($filter);
  #
  #  $sth->execute(@bind_vars);
  #
  #  my $ref = $sth->fetchrow_hashref;

  return $ref->{id} ? $ref->{id} : 0;
}

########################################################################
sub _new_with_options {
########################################################################
  my ( $self, $options ) = @_;

  my ( $id, $config, $max_rows )
    = @{$options}{qw( id config max_rows )};

  $self->set_config($config);

  my ($table_name) = grep {defined} @{$options}{qw( table table_name )};

  $self->set_table_name($table_name);

  $self->max_rows($max_rows);

  $self->set_lock( $options->{lock} );

  return $id ? $id : 0;
}

########################################################################
# new(dbi, id, config)             =>  ref, scalar, ref
# new(dbi, id, table-name)         =>  ref, scalar, scalar
# new(dbi, id, table-name, config) =>  ref, scalar, scalar, ref
# new(dbi, id, config, table-name) =>  ref, scalar, ref, scalar
# new(dbi, table-name, config)     =>  ref, scalar, ref
#
# Q: Why so many signatures?
# A: To support the convenient use of this class directly in Bedrock pages
#
# For example:
#
#  <plugin:IndexedTableHandler $dbi foo>
#  <plugin:IndexedTableHandler $dbi foo $config.site_config('foo.json')>
#
########################################################################
sub _new_with_id {
########################################################################
  my ( $self, @args ) = @_;

  my $id;

  if ( @args && $args[0] =~ /^\d+$/xsm ) {
    $id = shift @args;
  }

  my ( $config, $table_name );

  if ( is_hash( $args[0] ) || ( defined $args[1] && !ref $args[1] ) ) {
    ( $config, $table_name ) = @args;
  }
  else {
    ( $table_name, $config ) = @args;
  }

  $self->set_config( $config         // {} );
  $self->set_table_name( $table_name // $self->create_table_name );

  return $id ? $id : 0;
}

########################################################################
sub _get_table_dir {
########################################################################
  my ($self) = @_;

  my $table_name = $self->get_table_name;

  my $database = $self->database;

  die "no database selected\n"
    if !$database;

  my @table_def = $self->get_table_definition($table_name);

  my $fields = {};
  my $idx    = 0;

  foreach my $column (@table_def) {
    $column->{idx} = ++$idx;
    $fields->{ $column->{Field} } = $column;

    if ( ( $column->{Field} eq 'id' )
      && ( $column->{Key}   =~ /pri/xsmi )
      && ( $column->{Extra} =~ /auto_increment/xsmi ) ) {
      $self->{_id} = $column;
    }
  }

  die 'Table must have an indexed field named [id] and it must be auto_increment!'
    if !$self->{_id};

  $self->set_table_dir($fields);

  my @field_list = sort { $fields->{$a}->{idx} <=> $fields->{$b}->{idx} } keys %{$fields};

  $self->set_field_list( \@field_list );

  # labels
  # attributes
  # lists
  # search_fields

  if ( $self->get_table_config->{$table_name}->{labels} ) {
    $self->set_labels( $self->get_table_config->{$table_name}->{labels} );
  }

  if ( $self->get_table_config->{$table_name}->{lists} ) {
    $self->set_lists( $self->get_table_config->{$table_name}->{lists} );
  }

  if ( $self->get_table_config->{$table_name}->{attributes} ) {
    $self->set_attributes( $self->get_table_config->{$table_name}->{attributes} );
  }

  my $search_fields = $self->get_table_config->{$table_name}->{search_fields} // [];

  $self->set__search_fields($search_fields);

  return $self->get_table_dir;
}

########################################################################
sub get_options_count {
########################################################################
  my ($options) = @_;

  my $count = @{$options};

  return ref $options->[0] && reftype( $options->[0] ) eq 'HASH' ? $count : $count / 2;
}

########################################################################
sub _delete {
########################################################################
  my ( $self, $id ) = @_;

  die 'not an id'
    if !is_id($id);

  my $query = <<'END_OF_SQL';
delete
  from %s
  where id = ?
END_OF_SQL

  $query = sprintf $query, $self->get_table_name;

  $self->do( $query, $id );

  return $self->{rows};
}

1;

## no critic (RequirePodSections)

__END__

=pod

=head1 PUBLIC

BLM::IndexedTableHandler - Base class for a MySQL ORM

=head1 SYNOPSIS

  my $foo_ith = BLM::IndexedTableHandler->new( $dbi, $id, 'foo' );

  # foo handler with locking
  my $foo_ith = BLM::IndexedTableHandler->new(
    $dbi,
    { id         => $id,
      table      => 'foo',
      lock       => 1
    }
  );

Using L<BLM::IndexedTableHandler> as a base class:

 package BLM::Foo;

 use parent qw(BLM::IndexedTableHandler);

 1;

 my $foo_ith = BLM::Foo->new( $dbi );

=head1 DESCRIPTION

C<BLM::IndexedTableHandler> is a base class used to construct
applications that perform basic CRUD operations on MySQL tables. The
class provides methods for selecting, searching, and saving data. In
other words it handles all of the mundane tasks associated with
managing the table's data.

The class also contains methods that will quickly construct HTML forms
that manage the data in a single table.

Essentially, C<BLM::IndexedTableHandler> represents a MySQL table.
When you use it as a base class the name of that class is interpretted
as the table name. In the synopsis above the sub-class C<BLM::Foo>
represents the MySQL table C<foo>. If you do not explicitly set the
table name in the constructor, the constructor will attempt to
determine the table name from the class suffix.

=head2 Table and Class Naming Rules

Table names should:

=over 5

=item * all lowercase

=item * start with a letter and conform to all MySQL naming rules

=item * can contain an underscore

=back

For C<BLM::IndexedTableHandler> to correctly determine your table
name, make sure the suffix when lowercased matches the table name. You
can use underscores to separate words in your table name or use
CamelCase.

Examples:

 +-------------+------------+
 | Class Name  | Table Name | 
 +-------------+------------+
 | Foo         | foo        |
 | Foo::Bar    | bar        |
 | Foo::BarBuz | bar_buz    |
 +-------------+------------+

C<BLM::IndexedTableHandler> is a sub-class of L<BLM::DBHandler>.

Although primarily designed to be a base class that allows you to
override methods so you can implement your own table handling
behaviors, C<BLM::IndexedTableHandler> can be used I<naked> with no
overridden methods as in the synopsis above.

Methods you might want to consider overriding include:

=over 5

=item * save

=item * delete

=item * set

=item * search 

=item * find

=item * handler

=back

...and the methods that provide some HTML snippets for
constructing the HTML form for editing your table.

=head2 Overriding HTML Construction Methods

  package BLM::Birds;

  use parent BLM::IndexedTableHandler;

  sub create_timestamp_field {
      my ($self, $field_name, $attributes, $labels, $lists) = @_;

      return $self->SUPER::create_timestamp_field($field_name, $attributes, $labels, $lists) if $field_name !~/last_spotted/;

      return &calendar("birds", "last_spotted", $self->{last_spotted});
}

  sub calendar {
    my ($form_name, $field_name, $value) = @_;

    my $html =<< 'END_OF_HTML';
  <table cellpadding="0" border="1" cellspacing="0">
    <tr>
      <td valign="center"><input name="$field_name" type="text" size="19" value="$value" maxlength="19"></td>
      <td valign="center"><input type="image" onClick='javascript:popUpCalendar(document.$form_name.$field_name, document.$form_name.$field_name, "m/d/yyyy"); return false' src="/img/calendar.gif"></td>
    </tr>
  </table>
  END_OF_HTML

    return $html;
  } 

The HTML construction methods are described in more detail later in
this documentation.

I<MySQL tables should conform to certain conventions. Table names
should be lowercase with words separated by the '_' character. The
table must have an indexed (unique) field named C<id> which is defined
as an C<auto_increment field>.>

Again, classes that subclass C<BLM::IndexedTableHandler>, should be
named such that the suffix corresponds to the table name.  The program assumes the
actual MySQL table name is lowercase.  So, in the C<SYNOPSIS> above,
assuming we have a MySQL table named C<foo> that looks something
like:

  create table foo (
   id int auto_increment primary key,
   lname varchar(32),
   fname varchar(32),
   email varchar(64)
  );

...and assuming I pass a handle to an open database to the C<BLM::Foo>
constructor, I would get a whole lot of stuff necessary for building a
typical Bedrock application for free!

HereE<039>s an example of how you might save a record to a table by
subclassing C<BLM::IndexedTableHandler> and using some of the tags
provided by Bedrock.

  <sqlconnect --data-source="dbi:mysql:bedrock_site" --username="fred" --password="flintstone" --db="dbi">

  <plugin:Foo $dbi>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Gina', 'email', 'gina@openbedrock.com')>
  <null $Foo.save()>

  <null $Foo.reset()>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Geena', 'email', 'geena@openbedrock.com')>
  <null $Foo.save()>

The C<id> of the saved record is immediately available in the object.

 <var $Foo.get('id')>

Updating a record...

  <null $Foo.set('email', 'geena123@openbedrock.com')>
  <null $Foo.save()>

The example below will return a list of all the records in table
C<foo>. I<Note that the C<find()> method returns a list of
C<BLM::IndexedTableHandler> objects suitable for use in the same way
you used the original object.  If you want just a hash reference of
the fields of the record, you can use the C<asref()> method of an
object or a record set.>

  <null:foo_list $Foo.find()> 

Just return a hash reference containing the key/values pairs instead
of an array of L<BLM::IndexedTableHandler> objects.

  <trace --outptut $foo_list.asref()>

Return a list of records in table C<foo> where the C<lname> field
starts with 'Lolla'...

   <null --define-var="lollas" $Foo.find('lname', 'Lolla')>

Find a record in table C<foo> where the C<lname> field exactly matched
'Lolla'...

   <null --define-var="lolla" $Foo.find_unique('lname', 'Lolla')>

Return a list of records in table C<foo> where the C<lname> field
exactly matched 'Lolla'...

   <null --define-var="lollas" $Foo.find(1, 'lname', 'Lolla')>

=head1 DOCUMENTATION

=head2 Getting Started

Using the template from the L</SYNOPSIS> above, create your
C<BLM::table_name> package and install it somewhere where Perl will
find it.  Typically in a web application, you might keep your Perl
modules together with your other web assets, for example:

  /var/www/vhosts/www.mysite.com/perl5/BLM

...or wherever you told Perl to look for Perl modules.  If you are
using Bedrock as a CGI (instead of C<mod_perl>) then you might have
added include paths to F<perl.INC> or if you are using C<mod_perl>
then you might have used the C<PerlSwitches> directive in your Apache
configuration file.

 package BLM::Foo;

 use parent BLM::IndexedTableHandler;

 1;

YouE<039>ll then want to create your MySQL table.

 create table foo (
   id    int auto_increment primary key,
   name  varchar(32),
   email varchar(32)
 );

Note: See L<Bedrock::Model> for a better way to create MySQL tables.

 $ cp Foo.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Foo.pm

You then instantiate C<IndexedTableHandler> objects either directly
from your Bedrock page :-( as shown above using the
C<E<lt>pluginE<gt>> tag:

  <plugin:Foo $dbi>

...or you can do this from your siteE<039>s Application Plugin object
which might typically provide a factory method for instantiating
objects to handle your table.  This is the preferred method and the
details below will guide you in creating an Application Plugin that
creates your database handling object.

=head2 Application Plugins

Application plugins (as opposed to plain old plugins instantiated with
the <plugin> tag) are immediately available on your page. They require
that you first create an application plugin configuration file with
specific values that tell Bedrock the name of the Perl module, the
variable name that will bound to the plugin and other custom
configuration information you might want to store for that plugin.

Assuming our application plugin will be named C<example>, weE<039>ll
create a configuration file named F<example.xml> as show below:

   <object> 
    <scalar name="binding">example</scalar> 
    <scalar name="module">BLM::Startup::Example</scalar> 
    <object name="config"> 
     <scalar name="data_source">dbi:mysql:bedrock_site</scalar>
     <scalar name="username">fred</scalar>
     <scalar name="password">flintstone</scalar>
    </object> 
   </object> 

This file should be added to your site's configuration by placing the
file in the F<CONFIG_PATH/config.d/startup>
directory. C<CONFIG_PATH> is the path you set in the Apache
configuration file to tell Bedrock where to find your site's
Bedrock configuration information.

 SetEnv CONFIG_PATH /var/www/vhosts/www.mysite.com/config

Note the binding name for this object is I<example> and will be
referenced in the Bedrock example below.

Now create the Application Plugin perl module.

  use strict;
  use warnings;

  package BLM::Foo;

  use parent qw(BLM::IndexedTableHandler);

  package BLM::Startup::Example;
  
  use parent Bedrock::Application::Plugin;
  
  # - factory method for creating Foo handlers
  sub foo {
      my $self = shift;
  
      return BLM::Foo->new($self->dbi, @_);
  }
  
  1;

Again, this Perl module should be installed somewhere where Perl will
find the module when your web applicaion is executing.

  $ cp Example.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Startup/Example.pm

As you can see, the application plugin provides a factory method named
C<foo> that simply returns a C<foo> object.  The C<foo> object is a
C<BLM::IndexedTableHandler>.

=head2 Bedrock Web Development with C<BLM::IndexedTableHandler>

Now create a sample Bedrock page to test your object.

  <null --define-var="fred" $example.foo()>
  <null --define-var="wilma" $example.foo()>
  
  <html>
  <body>
  <pre>
  <trace --output $fred>
  </pre>
  <null $fred.set('lname', 'Flintstone',
                  'fname', 'Fred',
                   'email', 'fflintstone@bedrock.com')>
  <null $fred.save()>
  
  <null $wilma.set('lname', 'Flintstone', 
                   'fname', 'Wilma', 
                    'email', 'wflintstone@bedrock.com')>
  <null $wilma.save()>
  <null --define-var="flintstones" $wilma.find('lname', 'Flintstone')>
  
  <pre>
  <hr>
  <trace --output $flintstones>
  </pre>

  <table>
    <tr>
      <th>First</th>
      <th>Last</th>
      <th>E-Mail</th>
    </tr>
    <foreach $flintstones>
    <tr>
      <td><var $fname></td>
      <td><var $lname></td>
      <td><var $email></td>
    </tr>
    </foreach>
    </table>
  </body>
  </html>

=head2 Constructing HTML Forms

If the the L<BLM::IndexedTableHandler> did nothing more than handle
the I<insert>, I<update>, I<delete> drudgery for MySQL records and
provide some query tools that would probably be enough.  Probably, but
there is still much tedium and re-hashed HTML snippets that we all use
in every Bedrock application we write that makes developing HTML apps
a chore.

By standardizing on how we might want to handle specific MySQL field
types within applications it is possible to provide a template of an
HTML form that might help us create database applications with Bedrock
and MySQL. Enter the C<html_form_*()> methods.

The C<html_form_*> methods will create a template for a completely
usable HTML form that implements a basic CRUD application for updating
your MySQL table.  The C<html_form_body()> method interprets the
various field types within a MySQL table and creates appropriate form
objects.  It will also properly set the data values within the form
based on the values in the current object.

The form is rendered inside a 2-column table where the first column
contains the field names and the second column contains the HTML input
element that allows entry or editing of the data values.  A row in the
table is written for each field in the table.  Field names are
converted to a more readable from from the column names in the MySQL
table using the following conventions:

=over 4

=item * underscores ('_') are converted to blanks

=item * the first letter of each word in the resulting string is converted to upper case

=back

Examples:

 first_name       => First Name
 last_name        => Last Name
 primary_position => Primary Position
 e_mail_address   => E Mail Address

The HTML form is rendered in three parts, a head, a body and a footer
using the three methods C<html_form_header()>, C<html_form_body()> and
C<html_form_footer()>.

You can probably reduce most Bedrock applications that handle a MySQL
table to something like the Bedrock snippet below:

 <html>
 <head>
 <body>
  
 <null --define-var="foo" $example.foo($input.id)>

 <if $input.action --eq "save">
   <null $foo.set($input)>
   <null $foo.save()>
 <elseif $input.action --eq "find">
  <null --define-var="foo_find_list" $foo.search($input)>
  <if $foo_find_list.length() --eq "1">
    <null --define-var="foo" $foo_find_list.get(0)>
  <elseif $foo_find_list.length()>
   <foreach $foo_find_list>
     <a href="?id=<var $_.id>"><var $_.id></a><br>
   </foreach>

   <null --define-var="foo" $example.foo()>
   <null $foo.set($search_field, $input.get($search_field))>
  </if>
 </if>

 <var $foo.html_form_header()>
 <var $foo.html_form_body()>
 <var $foo.html_form_footer()>

 </form>
 </body>
 </html>

or you can use the L</handler> method which pretty much performs a
similar function as the logic above.

The C<html_form_body()> method currently has support for the following
MySQL field types:

=over 4 

=item int

An C<int> field will be converted to an HTML <input> object with a size of 5.

=item char

A C<char(n)> field will be converted to an HTML <input> object with a size of n.

=item varchar

A C<varchar(n)> field will be converted to an HTML <input> object with a size of n.

=item enum

An C<enum> field will be converted into a <select> or <input (radio)>
object where the options and values are equal to the specification
within the definition of the C<enum> field.

If the number of elements in the enumeration is 4 or less, then the
C<html_form()> method will produce a set of radio buttons.  If the
list is greater than 3, the method will produce a <select> object.
This behavior can be overridden as described in the overloaded version
of the C<html_form()> method (see the full documentation on
C<html_form()>) for details.

For example if your field is defined as below:

 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |

The C<html_form()> method would create a select box as follows:

 <select name="pant_size">
   <option value="S">S</option>
   <option value="M">M</option>
   <option value="L" selected>L</option>
   <option value="XL">XL</option>
   <option value="XXL">XXL</option>
   <option value="XXXL">XXXL</option>
 </select>

=item set

A set field is converted to either a <select> element that allows
mulitple selections or a series of checkboxes.  If the number of
elements in the set is 4 or less then the set is represented by a
series of check boxes, otherwise it is represented as a multi-select
list.

=item tinyint

A C<tinyint> or C<boolean> field is converted into a check box object.

=item date

A C<date> field is converted to an <input> object with a length of 10.
Upon display, this field is shown as a standard MySQL date field of
the form YYYY-MM-DD.  Before being saved to a table, this field will
be converted to the YYYY-MM-DD format if the format is MM/DD/YYYY or
MM/DD/YY.  See C<set> for more details on how form fields are
converted to MySQL data types before being saved.

=item timestamp

C<timestamp> fields are treated in a similar fashion to C<date> fields
except they are 19 characters in length and support a suffix of HH:MM
PM.

=item text

C<text> fields are converted into a <textarea> object with 40 columns
and 5 rows.  These attributes can be overridden (see the full
documentation for the C<html_form_body()> method.

=back

I<The method C<html_form_body_with_class> will create the same form
with class and id attributes that correspond to your table name.>

=head1 EXPORTED METHODS

Nothing is exported by default. 

=head2 easy_connect

See L<BLM::DBHandler/easy_connect>.

=head1 METHODS AND SUBROUTINES

=head2 "as_" FUNCTIONS

All of the "as_" functions act as serializers for one or more columns
defined in the object. When the data is serialized it uses any custom
getter you may have defined for the column. You can bypass the use a
custom getter by calling the "_noref" version of the function. By
default, C<as_json>, C<as_csv> and C<as_string> wil never use a
reference if it is returned by your getter.

If you want to access the values of the columns as they would have
been stored to your table you can access them directly from the object
reference.

 my $name = $ith->{name};

Note that if you stored the value using C<set()> and you have defined
a setter for that column, then the value stored in the hash will be
the return value from your setter.

=over 5

=item as_array

 as_array()
 as_array(key, [key, key], ... )

Returns an array of values for the list of keys provided.  A list
element can also be a reference to a list of keys.

=item as_array_no_ref

If you have a custom getter that would normally return a reference you
can use C<as_array_no_ref> to return the raw value of that column. A
typical example where you might want to return the raw value might be
a getter that decodes a JSON string into a Perl object but you need
the serialized version for output.

Setting customer getters using C<BLM::IndexedTableHandler> is done by
sending a configuration object to the constructor that describes
custom setters and getters for each column. See L</CONFIGURING YOUR TABLE HANDLER>.

=item asref

Deprecated - use C<as_ref>

=item as_ref

 as_ref()
 as_ref( key, [key, key], ... )

Returns a C<Bedrock::Hash> object where the keys are column names and
the values are the values returned by the column C<get> method. If you
want to avoid references that might be returned by custom getters, use
C<as_ref_raw>.

If on or more C<key> arguments are provided, the returned hash will
contain only the keys specified.  C<key> can be a scalar or an array
reference containing additional keys.

 <null:record $ith.as_ref( $ith.get_field_list(), 'my_extra_key') >

=item as_ref_raw

Same as C<as_ref> however values will be returned as strings. Prevents
a getter from returning a reference.

=item as_csv

Returns a comma delimited version of the row. The order of the
columns will always reflect the order in which the columns were
defined in the table.

=item as_json

Returns the JSON representation of a row in the database.

=item as_string

Returns a string representation of each column. Use Perl's
C<LIST_SEPARATOR> value to separate columns.

=back

=head2 autocomplete

=over 5

=item query

Just the 'where' clause part...without the where

=item columns

Array reference

=item uc (optional)

=item ucfirst (optional)

=item args

Array reference

=back

=head2 curdate

Return the current date in YYYY-MM-DD format.

 <var $customer.curdate()>

=head2 curtime

Return the current time in HH24:MI:SS format.

 <var $customer.curtime()>

=head2 database

Returns the currenlty selected database.

=head2 date_format

 date_format( date, format-string )

 date_format( field-name, format-string) 

Returns the result of the MySQL DATE_FORMAT function.

 <var $obj.date_format('2011-01-01', '%a')>

 <var $obj.date_format('date_filed', '%a')>

 Sat

=head2 decrypt

Decrypt a column value using C<secret> and the MySQL C<aes_decrypt()> method.

 decrypt( column-name, secret )

=head2 delete

 delete()
 delete( id )
 delete( column-name )

Deletes the currently defined row from the database, a specified
record identified by C<id> or removes a column from the object so that
it will not be updated on subsequent saves.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "delete">
     <null $foo.delete()>
     <null --define-var="foo" $factory.foo()>
  </if>

=over 5

=item id

The C<id> of the record you wish to delete.  If no value is given for
C<id> the current object is deleted if the C<id> column is set.

=item column-name

The name of a column in the table.  If this value is passed then the
member will be deleted from the object allowing you to update a record
without updating that particular column.  I<Note that the C<save()>
method will read the record back into the object after it has been
updated, thus restoring that column to the object.>

=back

=head2 dumper

 dumper()

Return a two-element array of public/private information stored by the
class.  Typically used for debugging.

 [0] => Bedrock hash representing the public key/value pairs (column values)
 [1] => Bedrock hash of private key/value pairs

=head2 encrypt

 encrypt( column-name, secret )

Encrypts (updates) a column with C<secret> using the MySQL
C<aes_encrypt()> function.

=head2 fields

 fields()
 columns()

Returns a Bedrock array containg the column names. C<fields()> and
C<columns()> are synonymous.

=head2 find

  find( id )

Returns a L<BLM::IndexedTableHandler> object representing the row in
the table with an C<id> equal to the specified id.

  find ( field, value )

Returns an array of L<BLM::IndexedTableHandler> objects that B<start with> the 
value passed.

  find()

Returns an array of L<BLM::IndexedTableHandler> objects.  The number
of elements in the array is controlled by the current C<max_rows>
setting.  For all rows, set C<max_rows> to 0.

  find( match-flag, field, value, ...)

Returns an array of L<BLM::IndexedTableHandler> objects that match the
fields and values passed.  Each C<match-flag> is either 0,
indicating B<non-exact match> (starts with) or 1, indicating B<exact match>.

=over 5

=item id

MySQL id of the row to return.

=item field

Name of a column in a MySQL table

=item value

Value of the column specifed in C<field> to search for

=back

=head3 Example - Return all rows.

  <null $player.max_rows()>
  <null --define-var="players" $player.find()>

Returns all rows in the table.  Typically this is used for relatively
small tables.

Use the C<max_rows()> method to control the number of row to return.

  <null $player.max_rows(100)>

For an unlimited number...

  <null $player.max_rows()>   

=head3 Example - Return a specific record based on the primary key

 <null --define-var="player" $player.find($input.id)>

=head3 Example - Return a list by searching a field.

 <null --define-var="players" $player.find('fname', 'Jo')>

Would return an array of player objects where the field F<fname> is like Jo%

I<Note:> This method will always return an array even if there is only 1 row that matches
the criteria.

=head3 Example - Return rows based on matching more than 1 field.

 <null --define-var="players" $player.find(1, 'position', 1, 0, 'lname', 'R')>

Would return all of the records where the C<position> column was
B<equal> to 1 and the last name of the player started with 'R'.

=head2 find_unique

  find_unique(field, value, ...)

Returns a L<BLM::IndexedTableHandler> reference to a
L<BLM::IndexedTableHandler> object representing the row where the
specified column values match exactly.

Note that this method does not guarantee that there is only 1 row that
matches that criteria, however it will always return at most 1 row.

Returns C<undef> if no rows match this criteria.

  <null --define-var="pujols" $player.find_unique('lname', 'Pujols')>

=head2 get

 get(field)
 get(field, field, ...)

Returns the value of a field specified or a returns a Bedrock array of
the set of fields requested.  This behavior is consistent with the how
a Bedrock hash returns values.

=head2 get_count

 get_count()
 get_count(match-flag, field => value, ... ) 

Returns the number of rows in the database. You can also send a
tuple consisting of a flag, field name and a value, to restrict the
count based on the the field values passed. The tuple is the same
as that sent to the L</find> method.

=head2 get_date_field

 get_date_field( field-name )

Returns a MM/DD/YYYY or MM/DD/YYYYY HH:MI:SS formatted date or
datetime value from a MySQL YYYY-MM-DD date.

Example:

 <input type="text" name="birthday" value="<var $player.get_date_field('birthday')>">


=head2 get_display_only

 get_display_only( field-name )

Returns true or false depending on whether the field is set to be a
display-only field

=head2 get_enum_values

 get_enum_values( column-name )

Return an array of possible values for a C<set> or C<enum> field type.

Given a table with an enum column 'doc_type':

  +----------+-------------------+------+-----+---------+----------------+
  | Field    | Type              | Null | Key | Default | Extra          |
  +----------+-------------------+------+-----+---------+----------------+
  | id       | int(11)           | NO   | PRI | NULL    | auto_increment |
  | doc_type | enum('a','b','c') | YES  |     | NULL    |                |
  +----------+-------------------+------+-----+---------+----------------+


  <null:list $document.get_enum_values('doc_type')>
  <trace --output $list>

  [
  [0] .. (a)
  [1] .. (b)
  [2] .. (c)
  ]


=head2 get_field_length

 get_field_length(field-name)

Returns the length of a field.

=head2 get_field_type

 get_field_type(field)

Returns the fully articulated type of the field (int, varchar, enum,
set, etc) as manifested in a C<describe table> command.

=head2 get_fields

 get_fields([options])

Returns a list (not a reference) of field (column) names.  If you want
an array reference, call the poorly named C<get_field_list()>. Options
is hash ref or key value pair of options described below.

=over 5

=item backticks

Boolean flag that determines if field names will be returned with
surrounding backticks.

default: false

=item exists_only

Boolean that indicated that only the field names where a value exists
for that field in the object should be returned.

default: false

=back

I<Note when invoked from a Bedrock page, Bedrock will always promotes
lists to L<Bedrock::Array> objects.>

 <null:fields $obj.get_fields()>

 my @list = $obj->get_fields();
 my $list = $obj->get_field_list();

=head2 get_format_mode( field-name )

Returns a boolean value that determines if a field should be formatted
when it is shown in a form field.

=head2 get_phone_field

 get_phone_field( field-name )

Returns a formatted phone number.  If the phone number length is 7 digits:

 555-1212

If the phone number legnth is 10 digits:

 (888) 555-1212 

Example:

 <var $customer.get_phone_field('work_phone')>

=head2 get_upsert_mode

=head2 set_upsert_mode

Sets the mode for inserts.  If I<upsert_mode> is set to 0, then the
C<save()> method attempts to save all columns (columns that are not
set are assumed to be null).  If I<upsert_mode> is set to 1, then
C<save()> on new columns acts like an update, only inserting columns
that have been explicitly set.  They can be set to null and will be
updated if set to undef.

Assuming a table named 'foo' has columns 'biz', 'baz', 'buz';

 create table foo (
   id  int          auto_increment primary key,
   biz varchar(10)  not null,
   baz varchar(10)  null,
   buz varchar(10)  not null default 'buzzzz'
 )

Example: Insert a new record, setting only the 'biz' column.

 my $record = new MyApp::Foo($dbi);
 $record->set_upsert_mode(1);
 $record->set('biz');
 $record->save();

Note that column 'buz' is defined as 'not null' but has a default.  In
this case since we only insert column 'biz', the column will look this
after insertion.

Example: Insert a new record, setting all columns ('baz', 'buz', will be set to null)

 my $record = new MyApp::Foo($dbi);
 $record->set('biz');
 $record->save();

Note this will produce a NOT NULL exception on column 'buz' since we
attempt to insert all column and no value is given for 'buz'.

=head2 handler

  handler($input)

Method that invokes various methods of your table handler object
depending upon the value of the C<action> CGI variable.

The values of the C<action> CGI variable support are:

=over 5

=item save

 save([object],[reload-flag])
 save([reload-flag])

Saves the values in the object itself or the passed object to the MySQL table.

Supports both updates and inserts depending on whether the C<id> field
is set. To save a subset of the table's columns, set the C<upsert>
flag (see L</upsert>).

By default, the C<save()> method will read the record back and update the fields in the object. This is done to support the cases where the database may provide default values (timestamps) or otherwise populate a field when inserting or updating the row.

Returns the id value of the row inserted or updated.

=item delete

Deletes the row in the MySQL table indicated by the value of C<id>.

Return the table handler object.

=item new

Creates a new table handler object.

Returns a new table handler object.

=item find

Performs a query against the MySQL table depending upon the fields
(CGI variables) that are set in the C<$input> object.

If 1 or more rows found after executing the query, the method will
returns either C<BLM::IndexedTableHandler::RecordSet> object.

If no rows are found after executing the query, the method will return
a table handler object.

=back

=head2 html_form_body

 html_form_body(attributes, labels, lists, exclude-fields)
 html_form_body_with_class(attributes, labels, lists, exclude-fields)

=head2 html_form_footer

 html_form_footer(attributes)

Creates a row of buttons (I<save>, I<delete>, I<find>, I<new>) that
submit the form and set the C<action> hidden element.

=head2 html_form_header

 html_form_header(attributes)


=head2 is_field

 is_field( name )

Returns true if C<name> is a column in the table.  Returns false if it is not.

=head2 is_null

 is_null( field-name )

Returns true if the field is NULL, false if it is not NULL.  Not that
the empty string is NOT a NULL value.

Example:

  <if $contact.is_null('username')>
    ...
  </if>

=head2 lock

 lock(true | false)

Set lock mode for a select query.  If lock mode is set, then a select
query will include the 'for update' clause.

=head2 max_id

 max_id()

Returns the highest value for the id column in the table.

=head2 new

 new( dbi, id, config, table-name )
 new( dbi, id, table-name )
 new( dbi, table-name, config )
 new( dbi, config, table-name )
 new( dbi, { id => id, table_name => table-name, config => config, lock => 0 |1  } )
 new( { dbi => dbi, ... })
 new()

Multiple signatures to provide a convenient wasy to instantiate a
handler in a Bedrock page.

  <plugin:IndexedTableHandler $dbi $id 'table-name'>

C<new()> is a special case that allows you to instantiate a handler
without providing a database handle. Of course you won't be able to do
much if you don't provide one or provide the other parameters
necessary to perform actions.  However, if you are going to provide
the database handle later in some way then this could be a useful way
to instantiate a handler for you.

=over 5

=item dbi

An instance of a C<DBI> object representing an open connection to a
MySQL database.

=item id

The C<id> field which uniquely identifies a record in the MySQL table.

=item config

A hash reference representing configuration information associated
with this or other tables. The configuration object should contain an
object named C<tables> that can contain custom setters and getter for
columns in your table. The configuration object really can be used for
anything you would like, the only caveat being that the C<tables>
object should be a hash of key/value pairs where the key are the names
of each table config.

Each table configuration can have a C<set> and C<get> object which can
define custom setter/getter methods for selected columns.  Setters and
getters are essentially used for serializing/deserializing data to or
from the table.

Other than that, you can use the configuration object for whatever
purpose you might like.

See L</CONFIGURING YOUR TABLE HANDLER>

=item table_name

The name of the MySQL table. If a table name is not provided to the
constructor it attempts to determine the table name from the suffix of
the class name if you have sub-classed C<BLM::IndexedTableHandler>.

=item lock

The lock mode.

 0 => no locking
 1 => FOR UPDATE
 2 => LOCK IN SHARE MODE

=over 5

=item LOCK IN SHARE MODE

I<SELECT ... LOCK IN SHARE MODE sets a shared mode lock on any rows that
are read. Other sessions can read the rows, but cannot modify them
until your transaction commits. If any of these rows were changed by
another transaction that has not yet committed, your query waits until
that transaction ends and then uses the latest values.> - from http://dev.mysql.com

=item FOR UPDATE

I<SELECT ... FOR UPDATE locks the rows and any associated index entries,
the same as if you issued an UPDATE statement for those rows. Other
transactions are blocked from updating those rows, from doing SELECT
... LOCK IN SHARE MODE, or from reading the data in certain
transaction isolation levels. Consistent reads ignore any locks set on
the records that exist in the read view. (Old versions of a record
cannot be locked; they are reconstructed by applying undo logs on an
in-memory copy of the record.) - L<http://dev.mysql.com>>

=back

B<Note that row level locking in MySQL is only available with the InnoDB
engine.  The row is locked immediately when the object is instatiated
for the given C<id>.  You should commit the record to release the lock.>

=item max_rows

Indicates the maximum number of rows that should be returned for
select methods (C<find()>, C<select()>, C<select_list()>).  The
default is 0 which indicates "no limit".

=back

=head2 now

Return the current date and time YYYY-MM-DD HH24:MI:SS format.

 <var $customer.now()>

=head2 null

 null( column, ... )
 null( array-ref )

Sets the specified column (or columns) to NULL (undef).  Pass a list
of column names or an array reference of column names.

=head2 reset

 reset( [delete] )

Clears (sets columns to NULL) all of the columns in the object or if
the C<delete> flag is set, will remove the column from the set of
columns with data to save or insert.

In some cases, you may not want a value of NULL in your column and
want an insert or update to only update the columns that have been
explicitly set.  In that case, use C<insert()> instead of C<save()> as
C<insert()> will only insert columns that have explicitly been set
with a value (unlike C<save()> which will insert NULL for columns not
explicitly set).

So, when using C<reset()> you may want to reset the object to a state
where no columns have been explicitly set.

 $ith->reset(1);

An example of this may be when your columns have
default values and also have constraints.  Consider the column
definition below:

 first_name varchar(32) not null default '';

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->save();

The above example will cause a NOT NULL constraint exception. Now consider:

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->insert();

 $ith->reset();
 $ith->set('last_name', 'Jones');

In the example above, the first record is written and the second causes and exception. And then consider...

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->insert();

 $ith->reset(1);
 $ith->set('last_name', 'Jones');

...and both records are now written.

=head2 save

 save( [$input] )

This method will C<update> a record or C<insert> a new record into the
database.  If the C<id> field is null or "0" it will assume a new
record is to be added to the table, otherwise the record with the
corresponding C<id> will be updated.

The return value of the method is the value of the C<id> field.

You can optionally pass a hash which contains the key/value pairs for
columns of the record to set.  Only keys that correspond to valid
columns will be set.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "save">
    <null $foo.save($input)>
  </if>

I<Note that only the fields corresponding to the columns that exist in
the object are updated if the record exists. For new records, all
columns are inserted regardless of whether or not you have explicitly
provided a value for that column!  In other words, for UPDATES ONLY,
if you want to avoid updating a column, delete the member from the
object.>

  <null $foo.delete('bar')>

I<If you want to only insert those columns that you have explicitly
set and therefore let your table defaults take care of the rest of the
columns, set 'upsert' mode first.>

 <null $foo.set_upsert_mode(1)>
 <null $foo.save()>

=head2 search

  search($input, [exact-flag]) 

This is essentially the same as C<find> except it attempts to
intelligently figure out what you want to search by looking at the
fields in the object you pass and matching these up with the potential
indexes in the table.

Suppose you have a form that represents the table and each field in
the form corresponds to a field in the database. Potentially you could
search by any of the fields in the database using the C<find> method.

For example:

  <if $input.lname>
    <null --define-var="foo_list" $foo.find('lname', $input.lname)>
  <elsif $input.fname>
    <null --define-var="foo_list" $foo.find('fname', $input.fname)>
  <elsif $input.email>
    <null --define-var ="foo" $foo.find_unique('email', $input.email)>   
  </if>

This begs the question of what to do when multiple fields are
populated and what order should the search be done in?

C<search> tries to guess all of this for you by looking at the indexes
you have created for the table and the order you have defined the
fields.

The search will proceed by looking at C<UNIQUE> index fields first
then fields indexed as C<MUL> (i.e. the index allows duplicate keys).
Within each index it will use the order in which the fields have been
defined in the table to see if the field is defined in the form.  If
it is, then it will use that field as the search key, otherwise it
will go to the next index field.  If there are no index fields it will
simply follow the order of the fields as defined in the table.

Give the table F<foo> defined below:

 +-----------+-------------------------------------+------+-----+---------+----------------+
 | Field     | Type                                | Null | Key | Default | Extra          |
 +-----------+-------------------------------------+------+-----+---------+----------------+
 | id        | int(11)                             | NO   | PRI | NULL    | auto_increment |
 | lname     | varchar(32)                         | YES  | MUL | NULL    |                |
 | fname     | varchar(32)                         | YES  |     | NULL    |                |
 | email     | varchar(64)                         | YES  | UNI | NULL    |                |
 | comments  | text                                | YES  |     | NULL    |                |
 | hat_size  | char(1)                             | YES  |     | NULL    |                |
 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |
 | active    | tinyint(1)                          | YES  |     | NULL    |                |
 +-----------+-------------------------------------+------+-----+---------+----------------+


The statement:

 <null --define-var="foo_list" $foo.search($input)>

...would look to see if C<$input.email> had a value first, if so it
would conduct a search equivalent to:

 <null --define-var="foo_list" $foo.find('email', $input.email)>

if C<$input.email> was not defined, it would then look at
C<$inpt.lname> and if that were defined would conduct a search
equivalent to:

 <null --define-var="foo_list" $foo.find('lname', $input.lname)>

C<search> would then proceed similarly through the non-indexed fields
(C<fname>, C<comments>, C<hat_size>, C<pant_size>, and C<active>).

=head2 select

 select([query, args]);

Returns an array of hashes containing the query results.

 select()

Returns a C<BLM::IndexedTableHandler::RecordSet> containing all
records in the table.

See also C<BLM::DBHandler>

=head2 set

  set(field name, value, ...)

Sets the field name(s) to the specified value(s).

  set($input)

Calling C<set> with the C<$input> object as the parameter (or in
general a hash) will result in the field names for your table being
set from the hash.  That is to say...

  <null $player.set($input)>

is equivalent too...

   <foreach keys $input>
     <null $player.set($_, $input.get($_))>
   </foreach>

or more correctly...

  <foreach $player.fields()>
     <if $input --exists $_>
       <null $player.set($_, $input.get($_))>
     </if>
  </foreach>

You should be aware that the C<save()> method will not update fields
that are not in your object.  So to prevent updating all fields, you
could delete elements of the object thusly.

  <null $customer.delete('name')>

I<Note: HTML checkboxes that are NOT checked, will not manifest
themselves as elements in your C<$input> object.  This is a limitation
of the way the browser encodes these fields.  This could be
problematic since this method now does not know if you want to set the
field to null or if you want to skip updating that field.>

I<In this case, the C<set()> method has chosen to assume you want to
update the field and arbritrarily decides to assume that if the
checkbox field is missing from the hash reference, it is because it
was B<unchecked>.  If should explicitly carry along a value then for
checkbox fields.>

Additionally, the C<set()> method will do some basic manipulation of
input data in order to support MySQL date types.  If your input looks
like this:

  mm/dd/yyyy

...the method will convert the date to this:

  yyyy-mm-dd

...before attempting to save the data to a MySQL table.

=head2 set_date_field

 set_date_field( field-name, value )
 set_date_field( value )

Use this method to set the value of a date field.  The idea being, you
may have a user enter a date in either YYYY-MM-DD format or
MM/DD/YY[YY] formats and this method will format the date properly for
insertion into a MySQL date field.

Passing only the C<value> argument will return the formatted value.

Example:

  <null $player.set_date_field('birthday', $input.birthday)>

=head2 set_display_only

 set_display_only( field-name )

Set the field to be display only.  This prevents user input to this field.

=head2 set_email_field

 set_email_field(field, value)

Validates and returns and/or sets the column valued to an email
address. If the email is valid, then the column is set to the value,
otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the email address is just returned to the caller if valid.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=head2 set_field

 set_field( field-name, value )

Formats a field before storing it to the database.  This method is
only called if I<format mode> is selected for the given field.

 <null $customer.set_format_mode('date_entered', 1)>

 <null $customer.save()>

C<BLM::IndexedTableHandler> has built-in formatters for field whose
names contain the words B<date>, B<time> or B<phone> and whose types are
C<date>, C<datetime>, C<timestamp>, C<char> or C<varchar>.

If the field type is C<date>, C<datetime>, C<timestamp> and the column
name contains the words B<date> or B<time>, AND B<format> mode is enabled,
then the field is formatted appropriately before being inserted into
the database.

If the field type is C<char> or C<varchar> and the column name
contains the word B<phone> the field is formatted as a phone number
(Either xxx-yyyy or (zzz) xxx-yyyy).

If you donE<039>t like this behavior or wish to apply other transformations
of the data prior to the data being written to the database, you can
override this method.

=head2 set_format_mode

 set_format_mode( field-name, mode )

Indicate that a field should be formatted when the value is shown in a
form field.  Before the fieldE<039>s value is output, it is passed to
the C<format_field()> method if the format mode for the field
is set to 1.  The method is responsible for returning a formatted
version of the field.

  <null $customer.set_format_mode('date_inserted', 1)>

L<BLM::IndexedTableHandler> provides formatting for C<date>,
C<datetime>, C<timestamp>, char and varchar fields whose name is has
either the word "phone" or "date" in them.

If you donE<039>t want any default behavior or you want some other behaivor
you might consider overriding the C<format_field()> method.

  package BLM::Customer;
  
  use BLM::IndexedTableHandler;
  use Bedrock::Plugin;
  
  use strict;
  use warnings;
  
  use parent qw( BLM::IndexedTableHandler Bedrock::Plugin);
  
  sub format_field {
    my $self = shift;
    my ($field, $value) = @_;
  
    for ( $field ) {
      /(firstname|lastname)/ && do {
        $value = ucfirst(lc($value));
        return $value;
      };
  
    }
  
    return $self->SUPER::format_field($field, $value);
  }
  
  1;

=head2 set_phone_field

  set_phone_field(field, value)

Removes extraneous data from a phone number field and returns and/or
sets the column value to just the digits of the phone number.  If the
resulting length of the object is 10 or 7 then the column is set to
just the digits, otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the digits are just returned to the caller.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=head2 set_upsert_mode

Sets I<upsert> mode. See L</get_upsert_mode>

=head2 table_name

Returns the name of the table.

=head2 validate_email

 validate_email( email )

Returns true or false depending on validity of email address.  This
doesnE<039>t mean this address is associated with a real email account,
just that it might. ;-)

=head1 CONFIGURING YOUR TABLE HANDLER

When you instantiate your table handler you can also pass a
configuration object that contains configuration information for your
tables.

You can define custom setters and getters for any of the columns in
your table. When you instantiate the class, pass a configuration
object that contains the custom setters and getters. The format of the
configuration object you passed looks something like this:

 { tables => {
     table_name => {
       set => { column_name => CODEREF | FUNCTION NAME,
                column_name => CODEREF | FUNCTION NAME,
                ...
              },
       get => { column_name => CODEREF | FUNCTION NAME
                ...
              }
     },
    }
 }

You B<do not> need to provide a setter and getter for every column.

Here's an example of serializer to store a JSON text object in the database.

Example:

  my $config = {
    tables => {
      user => {
        set => {
          profile => sub {
            my ( $f, $v ) = @_;
            return q{} if !$v;
            return ref $v ? JSON->new->encode($v) : $v;
          },
        },
        get => {
          profile => sub {
            my ( $f, $v ) = @_;
            return {} if !$v;
            return JSON->new->decode($v);
          },
        }
      }
    }
  };

 my $ith = Bedrock::IndexedTableHandler->new($dbi, 0, $config, 'users');

See L<Bedrock::Model> to learn about a mechanism to include your custom
setter/getters as part of the table definition.

=head1 CAVEATS

=head2 checkbox fields

Because checkbox fields are not manifested in the CGI C<QUERY_STRING>
when form data is submitted and the checkbox is not checked, you may
find that using a simplistic approach to updating the fields in your
object may result in checkbox fields being ignored.  For example, the
Bedrock code:

  <foreach $input.keys()>
     <null $player.set($_, $input.get($_)>
  </foreach>

would never actually update a checkbox field that was unchecked.
Therefore, as shown above the "more correct" approach to setting
the values of your object from your HTML form:

  <foreach $player.fields()>
     <null $player.set($_, $input.get($_))>
  </foreach>

...guarantees that each field in the table will be set, even if it is
set to a null value.

If you rely on the single argument version of the C<set> method youE<039>re
in luck (at least if youE<039>re database field being rendered as a
checkbox is a boolean).  Since C<html_form()> renders C<tinyint> or
C<boolean> fields as checkboxes, C<set> will make sure that any
C<tinyint> field in the record is set, regardless of whether it exists
in the C<$input> object.

=head1 AUTHOR

Rob Lauer - rlauer6@comcast.net

=head1 SEE ALSO

L<BLM::DBHandler>

=cut
