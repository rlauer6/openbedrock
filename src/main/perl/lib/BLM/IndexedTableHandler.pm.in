#!@PERL@

# $Id$

package BLM::IndexedTableHandler;

use strict;
use Data::Dumper;

BEGIN
{
    use Exporter ();
    use vars	qw($VERSION @ISA @ENV @EXPORT_OK @EXPORT);
    $VERSION = do { my @r = (q$Revision$ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
}

use BLM::DBHandler;
use Bedrock::Array;

use Bedrock::HTML::Helper qw(
			     create_html_element
			     create_label_name
			     create_xhtml_element
			     create_radio_buttons
			     create_select_list
			   );

use BLM::IndexedTableHandler::RecordSet;

@ISA = qw(BLM::DBHandler);

=pod

=head1 PUBLIC

C<BLM::IndexedTableHandler> -- Base class for a MySQL table handler

=head1 SYNOPSIS

Create a perl module to handle the MySQL table named F<foo>...

  package BLM::Foo;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  1;

  my $foo_handler = BLM::Foo->new($dbi);

=head1 DESCRIPTION

C<BLM::IndexedTableHandler> is a base class used to construct a package
for updating, deleting, and searching a MySQL table.  The class
handles the relatively mundane tasks associated with managing a table.
These include for example, inserts, deletes, and updates.

It is also a class designed to aid in the contruction of a web
application by providing a host of methods that help construct HTML
forms typically used in support of table maintenance and other aspects of web
application development.

Essentially, C<BLM::IndexedTableHandler> through itE<039>s super-class
represents a MySQL table and thus is named according to the tableE<039>s
name.  In the synopsis above the super-class C<BLM::Foo> represents
the MySQL table C<foo>.

Primarily designed to be a base class to allow you to override some of
the methods in order to provide your own table handling behaviors,
C<BLM::IndexedTableHandler> can certainly be used "naked" with no
overridden methods as in the synopsis above.

Methods you might want to consider overriding include:

  set
  search 
  find

...and especially the methods that provide some HTML snippets for
constructing the HTML form for editing your table.

B<Example of overriding one of the HTML construction methods...>

  package BLM::Birds;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  sub create_timestamp_field {
      my ($self, $field_name, $attributes, $labels, $lists) = @_;

      return $self->SUPER::create_timestamp_field($field_name, $attributes, $labels, $lists) unless $field_name =~/last_spotted/;

      return &calendar("birds", "last_spotted", $self->{last_spotted});
}

  sub calendar {
    my ($form_name, $field_name, $value) = @_;

    my $html =<<eot;
  <table cellpadding="0" border="1" cellspacing="0">
    <tr>
      <td valign="center"><input name="$field_name" type="text" size="19" value="$value" maxlength="19"></td>
      <td valign="center"><input type="image" onClick='javascript:popUpCalendar(document.$form_name.$field_name, document.$form_name.$field_name, "m/d/yyyy"); return false' src="/img/calendar.gif"></td>
    </tr>
  </table>
  eot

    return $html;
  } 

These HTML construction methods are described in more detail later in
this documentation.

The MySQL table should conform to certain conventions.  It is assumed
to have an indexed (unique) field named C<id> which is defined as an
C<auto_increment field>.

Your class which sub classes C<BLM::IndexedTableHandler> should be
named such that the suffix is the table name.  The program assumes the
actual MySQL table name is lower cased.  So, in the C<SYNOPSIS> above,
assuming we have an example table named C<foo> that looks something
like:

  create table foo (
   id int auto_increment primary key,
   lname varchar(32),
   fname varchar(32),
   email varchar(64)
  );

...and assuming I pass a handle to an open database to the Foo
constructor, I would get a whole lot of stuff necessary for building a
typical Bedrock application for free!

  <sqlconnect --data-source="dbi:mysql:bedrock_site" --username="fred" --password="flintstone" --db="dbi">

  <plugin:Foo $dbi>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Gina', 'email', 'gina@bedrock.com')>
  <null $Foo.save()>

Update the record...

  <null $Foo.set('fname', 'Geena')>
  <null $Foo.save()>

Return a list of all records in table C<foo>...

  <null --define-var="foo_list" $Foo.find()> 

Find a record in table C<foo> where the C<lname> field start with 'Lolla'...

  <null --define-var="Foo" $Foo.find('lname', 'Lolla')>

=head1 DOCUMENTATION

=head2 Getting Started

Using the template from the C<SYNOPSIS> above, create your
C<BLM::table_name> package and copy this somewhere within the Bedrock
perl path. Typically this might be somewhere like:

  /var/www/vhosts/www.mysite.com/perl5/BLM

...or wherever you told perl to look for perl modules.  If you are
using Bedrock as a cgi then you might have added include paths to
F<perl.INC> or if you are using C<mod_perl> then you might have used
the C<PerlSwitches> directive in your Apache configuration file.

  package BLM::Foo;

  use strict;
  use vars qw(@ISA);

  use BLM::IndexedTableHandler;

  @ISA = qw(BLM::IndexedTableHandler);

  1;

YouE<039>ll then want to create your MySQL table.

 create table foo (
   id    int auto_increment primary key,
   name  varchar(32),
   email varchar(32)
 );


 $ cp Foo.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Foo.pm

You then instantiate C<IndexedTableHandler> objects either directly
from your Bedrock page :-( as shown above using the
C<E<lt>pluginE<gt>> tag:

  <plugin:Foo $dbi>

...or you can do this from your siteE<039>s Application Plugin object
which might typically provide a factory method for instantiating
objects to handle your table.  This is the preferred method and the
details below will guide you in creating an Application Plugin that
creates your database handling object.

=head2 The Gory Details

First you should create an application plugin configuration file.
Assuming our Application Plugin will be named C<Example>, weE<039>ll create
a configuration file named F<example.xml> as show below:

   <object> 
    <scalar name="binding">example</scalar> 
    <scalar name="module">BLM::Startup::Example</scalar> 
    <object name="config"> 
     <scalar name="data_source">dbi:mysql:bedrock_site</scalar>
     <scalar name="username">fred</scalar>
     <scalar name="password">flintstone</scalar>
    </object> 
   </object> 

This file should be added to your site's configuration by placing the
file in the F<CONFIG_PATH/config.d/startup>
directory. C<CONFIG_PATH> is the path you set in the Apache
configuration file to tell Bedrock where to find your virtual host's
local configuration information.

 SetEnv CONFIG_PATH /var/www/vhosts/www.mysite.com/config

Note the binding name for this object is I<example> and will be
referenced in the Bedrock example below.

Now create the Application Plugin perl module.

  package BLM::Startup::Example;
  
  use vars qw(@ISA);
  use strict;
  use Bedrock::Hash;
  
  # - My example BLM::IndexedTableHandler for handling the 'foo' table
  use BLM::Foo;
  
  @ISA = qw(Bedrock::Hash);
  
  sub TIEHASH {
    my ( $class, $ctx, $config ) = @_;
  
    my $self = bless {}, $class;
    $self->{ctx}    = $ctx;
    $self->{config} = $config;

    # mysql_client_found_rows allows up the UPDATE statement to return
    # true if it updates a row that has no changes.  Ex: update
    # mytable set x=1 where x=1

     if ($config->{data_source}) {
       $self->{dbi} = DBI->connect($config->{data_source}.":mysql_client_found_rows=1",
                                   $config->{username}, 
                                   $config->{password}, 
                                   { PrintError => 1, 
                                     RaiseError => (exists $config->{raise_error}) || 0
                                   }
                                  );
     }
    $self;
  }

  # - factory method for creating Foo handlers
  sub foo {
      my $self = shift;
  
      return BLM::Foo->new($self->{dbi}, @_);
  }
  
  1;

Again, this perl module should be installed somewhere where perl will
find the module when you web applicaion is executing.

  $ cp Example.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Startup/Example.pm

As you can see, the application plugin provides a factory method named
C<foo> that simply returns a C<foo> object.  The C<foo> object is a
C<BLM::IndexedTableHandler>.

=head2 Bedrock Web Development with C<BLM::IndexedTableHandler>

Now create a sample Bedrock page to test your object.

  <null --define-var="fred" $example.foo()>
  <null --define-var="wilma" $example.foo()>
  
  <html>
  <body>
  <pre>
  <trace --output $fred>
  </pre>
  <null $fred.set('lname', 'Flintstone',
                  'fname', 'Fred',
                   'email', 'fflintstone@bedrock.com')>
  <null $fred.save()>
  
  <null $wilma.set('lname', 'Flintstone', 
                   'fname', 'Wilma', 
                    'email', 'wflintstone@bedrock.com')>
  <null $wilma.save()>
  <null --define-var="flintstones" $wilma.find('lname', 'Flintstone')>
  
  <pre>
  <hr>
  <trace --output $flintstones>
  </pre>

  <table>
    <tr>
      <th>First</th>
      <th>Last</th>
      <th>E-Mail</th>
    </tr>
    <foreach $flintstones>
    <tr>
      <td><var $fname></td>
      <td><var $lname></td>
      <td><var $email></td>
    </tr>
    </foreach>
    </table>
  </body>
  </html>

=head2 Constructing HTML Forms

If the the C<BLM::IndexedTableHandler> did nothing more than handle
the I<insert>, I<update>, I<delete> drudgery for MySQL records and
provide some query tools that would probably be enough.  Probably, but
there is still much tedium and re-hashed HTML snippets that we all use
in every Bedrock application we write that makes developing HTML apps
a chore.

By standardizing on how we might want to handle specific MySQL field
types within applications it is possible to provide a template of an
HTML form that might help us create database applications with Bedrock
and MySQL. Enter the C<html_form()> method.

The C<html_form()> method will create a template for a completely
usable HTML form for editing your MySQL table.  This form interprets
the various field types within a MySQL table and creates appropriate
form objects.  It will also properly set the data values within the
form for the current object.  

The rendered inside a 2-column table where the first column contains
the field names and the second column contains the HTML input element
that allows entry or editing of the data values.  A row in the table
is written for each field in the table.  Field names are converted to a
more readable from from the column names in the MySQL table using the
following conventions:

=over 4

=item * underscores ('_') are converted to blanks

=item * the first letter of each word in the resulting string is converted to upper case

=back

Examples:

 first_name       => First Name
 last_name        => Last Name
 primary_position => Primary Position
 e_mail_address   => E Mail Address

The HTML form is rendered in three parts, a head, a body and a footer.

You can probably reduce most Bedrock applications that handle a MySQL
table to something like the Bedrock snippet below:

 <html>
 <head>
 <body>
  
 <null --define-var="foo" $example.foo($input.id)>

 <if $input.action --eq "save">
   <null $foo.set($input)>
   <null $foo.save()>
 <elseif $input.action --eq "find">
  <null --define-var="foo_find_list" $foo.search($input)>
  <if $foo_find_list.length() --eq "1">
     <null --define-var="foo" $foo_find_list.get(0)>
  <elseif $foo_find_list.length()>
 <foreach $foo_find_list>
 <a href="?id=<var $_.id>"><var $_.id></a><br>
 </foreach>
        <null --define-var="foo" $example.foo()>
        <null $foo.set($search_field, $input.get($search_field))>
  </if>
 </if>


 <var $foo.html_form_header()>
 <var $foo.html_form_body()>
 <var $foo.html_form_footer()>

 </form>
 </body>
 </html>

The C<html_form_body> method currently has support for the following MySQL field types:

=over 4 

=item int

An C<int> field will be converted to an HTML <input> object with a size of 5.

=item char

A C<char(n)> field will be converted to an HTML <input> object with a size of n.

=item varchar

A C<varchar(n)> field will be converted to an HTML <input> object with a size of n.

=item enum

An C<enum> field will be converted into a <select> or <input (radio)>
object where the options and values are equal to the specification
within the definition of the C<enum> field.

If the number of elements in the enumeration is 4 or less, then the
C<html_form()> method will produce a set of radio buttons.  If the
list is greater than 3, the method will produce a <select> object.
This behavior can be overridden as described in the overloaded version
of the C<html_form()> method (see the full documentation on
C<html_form()>) for details.

For example if your field is defined as below:

 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |

The C<html_form()> method would create a select box as follows:

 <select name="pant_size">
   <option value="S">S</option>
   <option value="M">M</option>
   <option value="L" selected>L</option>
   <option value="XL">XL</option>
   <option value="XXL">XXL</option>
   <option value="XXXL">XXXL</option>
 </select>

=item set

A set field is converted to either a <select> element that allows
mulitple selections or a series of checkboxes.  If the number of
elements in the set is 4 or less then the set is represented by a
series of check boxes, otherwise it is represented as a multi-select
list.

=item tinyint

A C<tinyint> or C<boolean> field is converted into a check box object.

=item date

A C<date> field is converted to an <input> object with a length of 10.
Upon display, this field is shown as a standard MySQL date field of
the form YYYY-MM-DD.  Before being saved to a table, this field will
be converted to the YYYY-MM-DD format if the format is MM/DD/YYYY or
MM/DD/YY.  See C<set> for more details on how form fields are
converted to MySQL data types before being saved.

=item timestamp

C<timestamp> fields are treated in a similar fashion to C<date> fields
except they are 19 characters in length and support a suffix of HH:MM
PM.

=item text

C<text> fields are converted into a <textarea> object with 40 columns
and 5 rows.  These attributes can be overridden (see the full
documentation for the C<html_form_body()> method.

=back

=head1 METHODS

=cut

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my ($dbi, $id, $config, $table_name) = @_;

    my $self = {};

    $class =~/^(.*)::(.*?)(=.*)?$/;

    $table_name = $table_name || lc($2) or die "Unable to determine table name.";

    $self->{config} = $config;

# - avoid redundant creation of data structure for each row in a list
#   i.e. if this object is being constructed thusly:
#
#   $another = $me->new($dbi, $id);
#
#   which is done from find() for example, then we really don't want to 
#   create whole bunch of arrays that hold the table directory, one will do nicely thanks
#
    unless ( ref($this) && defined $this->{_field_list} ) {
      my $sth = $dbi->prepare("show fields from $table_name");
      $sth->execute;

      my $fields = {};
      my $id_found;
      my $idx = 0;

      while (my $ref = $sth->fetchrow_hashref) {
	$ref->{idx} = ++$idx;
	$fields->{$ref->{Field}} = $ref;
	if (($ref->{Field} eq 'id') && 
	    ($ref->{Key} eq 'PRI') && 
	    ($ref->{Extra} eq 'auto_increment')) {
	  $id_found = $ref;
	}
      }

      die "Table must have an indexed field named [id] and it must be auto_increment!" 
	unless $id_found;
      $sth->finish;

      $self->{_table_dir} = $fields;
      $self->{_field_list} = [sort {$fields->{$a}->{idx} <=> $fields->{$b}->{idx}} keys %$fields];

      if ($self->{config}->{tables}->{$table_name}->{labels}) {
	$self->{_labels} = $self->{config}->{tables}->{$table_name}->{labels};
      }

      if ($self->{config}->{tables}->{$table_name}->{lists}) {
	$self->{_lists} = $self->{config}->{tables}->{$table_name}->{lists};
      }

      if ($self->{config}->{tables}->{$table_name}->{attributes}) {
	$self->{_attributes} = $self->{config}->{tables}->{$table_name}->{attributes};
      }

      if ($self->{config}->{tables}->{$table_name}->{search_fields}) {
	$self->{_search_fields} = [];
	foreach (@{$self->{config}->{tables}->{$table_name}->{search_fields}}) {
	  push @{$self->{_search_fields}}, $_->{exact};
	  push @{$self->{_search_fields}}, $_->{field};
	}
      }
    }
    else {
      @{$self}{keys %$this} = values %$this if $this;
      foreach (@{$self->{_field_list}}) {
	$self->{$_} = undef;
      }
      die unless $self->{config};
    }

    $self->{_table} = $table_name;

    bless $self, $class;
    $self->{dbi} = $self->{db} = $dbi;

    my $dir = $self->{_table_dir};

    foreach ( @{$self->{_field_list}} ) {
      if ( $dir->{$_}->{Type} eq 'timestamp') {
	$self->set_display_only( $_ );
      }
    }

    if ( $id ) {
      my $ref = $self->Select("select * from $table_name where id = ?", $id);
      foreach (keys %$ref) {
	$self->set($_, $ref->{$_});
      }
    }

    $self->{max_rows} = 50;
    $self;
}

=head2 delete

Deletes the currently defined row from the database.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "delete">
     <null $foo.delete()>
     <null --define-var="foo" $factory.foo()>
  </if>

=cut

sub delete {
    my $self = shift;

    $self->Do("delete from ".$self->{_table}." where id = ?", $self->{id});

    foreach (@{$self->{_field_list}}) {
	$self->{$_} = undef;
    }
}

sub init_config {
    my $self = shift;
    my $table = $self->{_table};

    my $config = $self->{config}->{tables} || {};

    my $table_config = $config->{$table} || {};
    my %default = (set => '', get => '', attributes => {}, labels => '');

    foreach my $type ('set', 'get', 'attributes', 'labels') {
	my $config = $table_config->{$type} || {};
	foreach (@{$self->{_field_list}}) {
	    $config->{$_} = $default{$type} unless exists $config->{$_};
	}
	$table_config->{$type} = $config;
    }

    $self->{config}->{tables}->{$table} = $table_config;

    return $self->{config};
}

=pod

=head2 dbi

Returns the handle the DBI object representing the open database connection.

=cut

sub dbi {
    return $_[0]->{dbi};
}

=pod

=head2 get

=cut

# - Default getter method checks to see whether there is method override specified
#   in tagx.xml
sub get {
    my ($self, $key) = @_;
    
    my $getters = $self->{config}->{tables}->{$self->{_table}}->{get};

    if (my $method = $getters->{$key}) {
	if ($self->can($method)) {
	    return $self->can($method)->($self, $key);
	}
	else {
	    die "You've specified a field formatter, but there is no method \'$method\'";
	}
    }
    else {
	return $self->{$key};
    }
}

sub _set {
  my $self = shift;
  my $key;
  my $value;

  my $setters = $self->{config}->{tables}->{$self->{_table}}->{set};

  my $dir = $self->{_table_dir};

  while (@_) {
    $key = shift;
    $value = shift;

    if (my $method = $setters->{$key}) {
	if ($self->can($method)) {
	    $self->{$key} = $self->can($method)->($self, $key, $value);
	}
	else {
	    die "You've specified a field formatter, but there is no method \'$method\'";
	}
    }
    elsif ($dir->{$key}->{Type} eq 'date') {
	if ($value =~/\d{1,2}\/\d{1,2}\/\d{4}/) {
	    $value = sprintf("%04d-%02d-%02d", (split "/", $value)[2, 0, 1]);
	}
	elsif ($value =~/\d{1,2}\/\d{1,2}\/\d{2}/) {
	    my @date = split "/", $value;
	    $date[2] += 2000 if $date[2] < 20;
	    $date[2] += 1900 if $date[2] > 20;
	    $value = sprintf("%04d-%02d-%02d", @date[(2, 0, 1)]);
	}
	$self->{$key} = $value;
    }
    elsif ($dir->{$key}->{Type} =~/set/) {
	if (ref($value)) {
	    $self->{$key} = join(",",@$value);
	}
	else {
	    $self->{$key} = $value;
	}
    }
    else {
	$self->{$key} = $value;
    }
  }
}

=pod

=head2 set

  set(field name, value, ...)

Sets the field name(s) to the specified value(s).

  set($input)

Calling C<set> with the C<$input> object as the parameter (or in general a hash) will
result in the field names for your table being set from the hash.  That is to say...

  <null $player.set($input)>

is equivalent too...

   <foreach keys $input>
     <null $player.set($_, $input.get($_))>
   </foreach>

or more correctly...

  <foreach $player.fields()>
     <null $player.set($_, $input.get($_))>
  </foreach>

Additionally, the C<set()> method will do some basic manipulation of
input data in order to support MySQL datatypes.

=cut

sub set {
    my $self = shift;

# - if there is only one argument to set then assume
#   the argument is an object (typicaly $input) and we're 
#   setting the field values from that object...
    if (@_ == 1) {
	my $dir = $self->{_table_dir};
	my $ref = shift;

	foreach (@{$self->{_field_list}}) {
	    if (exists $ref->{$_}) {
		$self->_set($_, $ref->{$_});
	    }
# - drudge! if the field type is a 'tinyint', i.e. boolean, then this was 
#   rendered as a checkbox.  Unfortunately, an HTML checkbox that is not checked
#   does not manifest itself in the QUERY_STRING.  Therefore, we're going out a bit 
#   on a limb here, but if you've asked this method to use an object to set the 
#   field values, then most likely this is the $input object AND we'll attempt to 
#   handle the checkbox problem for you...so if the field value is NOT in the input
#   object AND the field type is tinyint...set the value to '0'
	    elsif ($dir->{$_}->{Type} =~/(tinyint|set|enum)/) {
		$self->_set($_, 0);
	    }
	}
    }
    else {
	$self->_set(@_);
    }
}


=pod

=head2 save

This method will C<update> a record or C<insert> a new record into the
database.  If the C<id> field is null or "0" it will assume a new
record is to be added to the table, otherwise the record with
corresponding C<id> will be updated.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "save">
    <null $foo.set($input)>
    <null $foo.save()>
  </if>

=cut

sub save {
  my $self = shift;

  if ( $self->{id} ) {
    $self->_update;
  }
  else {
    $self->_insert;
  }

  my $table_name = $self->{_table};
  my $ref = $self->Select("select * from $table_name where id = ?", $self->{id});

  foreach (keys %$ref) {
    $self->set($_, $ref->{$_});
  }
}


=pod

=head set_field

 set_field( field-name, value )

Formats a field before storing it to the database.  This method is
only called if I<format mode> is selected for the given field.

 <null $customer.set_format_mode('date_entered', 1)>

 <null $customer.save()>

C<BLM::IndexedTableHandler> has built-in formatters for field whose
names contain the words date, time or phone and whose types are
date/datetime, timestamp, char or varchar.

If the field type is B<date>, B<datetime>, B<timestamp> and the column
name contains the words date or time, AND format mode is selected,
then the field is formatted appropriately before being inserted into
the database.

If the field type is B<char> or B<varchar> and the column name
contains the word B<phone> the field is formatted as a phone number
(Either xxx-yyyy or (zzz) xxx-yyyy).

If you don't like this behavior or wish to apply other transformations
of the data prior to the data being written to the database, you can
override this method.

=cut


sub set_field {
  my $self = shift;
  my ($field, $value) = @_;

  return if $self->get_display_only( $field );

  my $type = $self->get_field_type( $field );
  $value =~s/^\s*(.*?)\s*/$1/;

  for ( $field ) {

    /phone/ && $type=~/char/ && do {
      
      if ( $value ) {
	$self->{$field} = $self->set_phone_field( $self->{$field} );
	die "invalid phone format: $value\n"
	  unless $self->{$field};
      }
      last;
    };
      
# rules of engagement:
# - if the date is of the form mm/dd/yy[yy] then we 
#   we need to reformat the field to yyyy-mm-dd in order
#   to insert this successfully into a MySQL database date field
#   * if the year portion is yy (2-digit), we'll assume it is in this
#     century if the value is < 20, i.e. 08 = 2008
#   * if the year portion is > 20 and < 100 then we will assume
#     the year is in the 20th century, i.e. 1900+yy
# - if the date is of the form yyyy-mm-dd then we will leave it alone
# - if the field is a timestamp and there is a date, but no time...
#   * if the date is the current date, we will add the current time
#   * if the date is not today, then the time added will bee 00:00:00
# - if the field is null, let it be
# - if the field is not of a recognized format, let it be


    /(date|time)/ && $type =~/(date|datetime|timestamp)/ && do {

      my $date;
      my ($mm, $dd, $year);
      
      if ($value =~/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/ ) {
	($mm, $dd, $year) = ($1,$2,$3);
	if ($year < 20) {
	  $year += 2000;
	}
	elsif ($year < 100) {
	  $year += 1900;
	}
	$date = sprintf("%04d-%02d-%02d", $year, $1, $2);
      }
      elsif ($value =~/^\s*(\d{4}-\d{2}-\d{2})/) {
	$date = $1;
      }
      else {
	$date = $value;
      }

      if ( $type =~/(timestamp|datetime)/) {
	if ($value =~/(\d{1,2}):(\d{1,2})(:\d{1,2})*\s*(AM|PM)*$/i) {
	  my ($hh, $mi, $sec, $ampm) = ($1, $2, $3, $4);
	  $sec =~s/://;

	  $date .= sprintf(" %02d:%02d:%02d", ((uc($ampm) eq "PM") ? $hh + 12 : $hh), $mi, $sec);
	}
	else {
	  my ($cday, $cmon, $cyear) = (localtime)[(3,4,5)];
	  if ($cday == $dd && $cmon == $mm-1 && $year == 1900+$cyear) {
	    $date .= sprintf(" %02d:%02d:%02d", (localtime)[(2,1,0)]);
	  }
	  else {
	    $date .= " 00:00:00";
	  }
	}
      }

      $self->{$field} = $date;
      last;
    };
    
    $self->{$field} = $value;
  }
}


sub _format_fields_for_insert {
  my $self = shift;

  my $dir = $self->{_table_dir};

  foreach my $field (@{$self->{_field_list}}) {
    if ( $self->get_format_mode( $field ) ) {
      $self->set_field( $field, $self->{$field} );
    }
  }
}

sub _insert {
  my $self = shift;

  $self->_format_fields_for_insert;

  my $query = "insert into %s (%s) values (%s)";
  $self->{id} = 0;
  $query = sprintf($query,
		   $self->{_table}, 
		   join(",", @{$self->{_field_list}}),
		   join(",", split "", "?" x scalar(@{$self->{_field_list}}))
      );


  $self->Do($query, @{$self}{@{$self->{_field_list}}});

  $self->{id} = $self->{dbi}->{mysql_insertid};
}

sub _update {
  my $self = shift;

  $self->_format_fields_for_insert;

  my @fields = grep { !/^id$/ } @{$self->{_field_list}};

  my $query = sprintf("update %s set %s where id = ?",
		      $self->{_table},
		      join(",", map { "$_ = ?" } @fields)
      );

  $self->Do($query, @{$self}{@fields}, $self->{'id'});

  return $self->{rows};
}


sub _find {
  my $self = shift;
  
  my $sql = sprintf("select id from %s ", $self->{_table});
  
  if (@_) {
    $sql .= "where ";
  }
  
  my @args = ();
  my @where_clause;
  
  while ( @_ ) {
    my $exact_flag = shift;
    my $field = shift;
    my $value = shift;
    
    push @where_clause, sprintf(" %s %s ?", $field,  $exact_flag ? "=" : "like");
    push @args, $exact_flag ? $value : $value."%";
  }
  
  if ( @where_clause ) {
    $sql .= join(" and ", @where_clause);
  }
  
  my @list;
 
  my $ref;

  eval {
    $ref = $self->SelectList($sql, @args);
  };

  die "Could not execute query:\n$sql\n$@"
    if $@;

  my $idx = 0;

  if ( @$ref ) {
    foreach ( @{$ref} ) {
      my $obj = $self->new($self->{dbi}, $_->{id}, $self->{config}, $self->{_table});
      $obj->{idx} = ++$idx;
      push @list, $obj;
    }

    return BLM::IndexedTableHandler::RecordSet->new( @list );
  }
  else {
    return Bedrock::Array->new();
  }
}

# - an intelligent 'find'
sub key_fields {
  my $self = shift;
  my @fields = @{$self->{_field_list}};
  
  my $dir = $self->{_table_dir};
  my @keys;
  
  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'UNI';
  }

  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'MUL';
  }
    
  return Bedrock::Array->new(@keys);
}

sub set_search_field {
  my $self = shift;
  my ($exact_flag, $field) = @_;

  $self->{_search_fields} = [] unless $self->{_search_fields};

  push @{$self->{_search_fields}}, $exact_flag, $field;
}

sub set_key_fields {
  my $self = shift;

  my @unique;
  my @mul;

  my $dir = $self->{_table_dir};
  my %fields;

  foreach (keys %{$dir}) {
    $fields{$dir->{$_}->{idx}} = $_;
    push @unique, $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'UNI';
    push @mul,  $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'MUL';
  }

  foreach (sort @unique) {
    $self->set_search_field(0, $fields{$_});
  }

  foreach (sort @mul) {
    $self->set_search_field(1, $fields{$_});
  }
}

=head2 search

  search($input) 

This is essentially the same as C<find> except it attempts to
intelligently figure out what you want to search by looking at the
fields in the object you pass and matching these up with the potential
indexes in the table.

Suppose you have a form that represents the table and each field in
the form corresponds to a field in the database. Potentially you could
search by any of the fields in the database using the C<find> method.

For example:

  <if $input.lname>
    <null --define-var="foo_list" $foo.find('lname', $input.lname)>
  <elsif $input.fname>
    <null --define-var="foo_list" $foo.find('fname', $input.fname)>
  <elsif $input.email>
    <null --define-var ="foo" $foo.find_unique('email', $input.email)>   
  </if>

This begs the question of what to do when multiple fields are
populated and what order should the search be done in?

C<search> tries to guess all of this for you by looking at the indexes
you have created for the table and the order you have defined the
fields.

The search will proceed by looking at C<UNIQUE> index fields first
then fields indexed as C<MUL> (i.e. the index allows duplicate keys).
Within each index it will use the order in which the fields have been
defined in the table to see if the field is defined in the form.  If
it is, then it will use that field as the search key, otherwise it
will go to the next index field.  If there are no index fields it will
simply follow the order of the fields as defined in the table.

Give the table F<foo> defined below:

 +-----------+-------------------------------------+------+-----+---------+----------------+
 | Field     | Type                                | Null | Key | Default | Extra          |
 +-----------+-------------------------------------+------+-----+---------+----------------+
 | id        | int(11)                             | NO   | PRI | NULL    | auto_increment |
 | lname     | varchar(32)                         | YES  | MUL | NULL    |                |
 | fname     | varchar(32)                         | YES  |     | NULL    |                |
 | email     | varchar(64)                         | YES  | UNI | NULL    |                |
 | comments  | text                                | YES  |     | NULL    |                |
 | hat_size  | char(1)                             | YES  |     | NULL    |                |
 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |
 | active    | tinyint(1)                          | YES  |     | NULL    |                |
 +-----------+-------------------------------------+------+-----+---------+----------------+


The statement:

 <null --define-var="foo_list" $foo.search($input)>

...would look to see if C<$input.email> had a value first, if so it
would conduct a search equivalent to:

 <null --define-var="foo_list" $foo.find('email', $input.email)>

if C<$input.email> was not defined, it would then look at
C<$inpt.lname> and if that were defined would conduct a search
equivalent to:

 <null --define-var="foo_list" $foo.find('lname', $input.lname)>

C<search> would then proceed similarly through the non-indexed fields
(C<fname>, C<comments>, C<hat_size>, C<pant_size>, and C<active>).

=cut

sub search {
    my $self = shift;
    my $input = shift;

    $self->set($input);
    $self->set_key_fields() unless $self->{_search_fields};
    
    my @search_args;
    
    if ($self->{_search_fields} && @{$self->{_search_fields}}) {
      my @search_fields = @{$self->{_search_fields}};
      while (@search_fields) {
	my $exact_flag = shift @search_fields;
	my $field_name = shift @search_fields;
	
	if ($self->{$field_name}) {
	  push @search_args, $exact_flag, $field_name, $input->{$field_name};
	}
	  }
    }
    
# still uncomfortable with assuming certain wildcard/non-wildcard searching
    unless (@search_args) {
      foreach (@{$self->{_field_list}}) {
	if ($input->{$_}) {
	  push @search_args, 0, $_, $input->{$_};
	}
      }
    }

    return $self->_find(@search_args);
}

=pod

=head2 find

  find(id)

Returns the row in the table with an C<id> = to the specified id.

  find (field, value)

Returns an array of hash references to row objects that match the field and 
value passed.

  find()

Return all rows (up to C<max_rows>) in table.

=over 5

=item id

MySQL id of the row to return.

=item field

name of a column in a MySQL table

=item value

value of the column specifed in C<field> to search for

=back

=head3 Example - Return all rows.

  <null --define-var="players" $player.find()>

Returns all rows in table.  Typically this is used for relatively
small tables, hence, a maximum value of 50 is used to limit the number
of elements returned.

If you B<really> want to return more rows, then set C<max_rows>.

  <null $player.max_rows(100)>

For an unlimited number...

  <null $player.max_rows()>   

=head3 Example - Return a specific record based on the primary key

 <null --define-var="player" $player.find($input.id)>

=head3 Example - Return a list by searching a field.

 <null --define-var="players" $player.find('fname', 'Jo')>

Would return all an array of player objects where the field F<fname> is like Jo%

I<Note:> This method will always return an array even if there is only 1 row that matches
the criteria.

=cut

sub find {
  my $self = shift;
  
  if (@_ == 1) {
    die "usage: find(n), where n > 0\n"
      unless $_[0] =~/^\d+$/ && $_[0];

    my $ref = $self->_find(1, 'id', @_);
    return $ref ? $ref->[0] : undef;
  }
  elsif ( @_ ) {
      return $self->_find(0, @_);
    }
  else {
    return $self->_find;
  }
}

=pod

=head2 find_unique

  find_unique(field, value)

Returns an single object where C<field> is like C<value>.

  <null --define-var="pujols" $player.find_unique('lname', 'Pujols')>

=cut

sub find_unique {
  my $self = shift;
  my $ref = $self->_find(1, @_);

  return $ref ? $ref->[0] : undef;
}


=pod

=head2 fields

 fields()

Returns an array containg the field names.

=cut

sub fields {
  my $self = shift;

  return Bedrock::Array->new(@{$self->{_field_list}});
}


=pod

=head2 asref

 asref()

Returns a hash object containing just the fields and their values.
This is not a particular useful object as it is not endowed with the
magic of the C<BLM::IndexedTableHandler> class, however some may find
it more satisfying than seeing all of the internal guts of the class'
object hierarchy.

=cut

sub asref {
  my $self = shift;

  my $ref = {};
  @{$ref}{@{$self->{_field_list}}} = @{$self}{@{$self->{_field_list}}};

  return Bedrock::Hash->new(%$ref);
}


sub get_formatted_field_length {
  my $self = shift;
  my $field = shift;

  my $type = $self->get_field_type( $field );

  for ( $field ) {
    /phone/ && $type =~/char/ && do {
      return 14;
    };

    /(date|time)/ && $type =~/time/ && do {
      return 20;
    };

    /date/ && $type =~/date/ && do {
      return 10;
    };

    $type =~/\((\d+)\,?.*\)/ && return $1;

    $type eq 'boolean' && return 1;
  }

  return undef;
}



=pod 

=head2 get_field_length

 get_field_length(field-name)

Returns the length of a field.

=cut

sub get_field_length {
  my ($self, $field_name) = @_;
  
  my $type = $self->get_field_type( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    return $self->get_formatted_field_length( $field_name );
  }
  elsif ($type =~/\((\d+)\,?.*\)/) {
    return $1;
  }
  elsif ( $type eq 'date' ) {
    return 10;
  }
  elsif ( $type eq 'datetime' ) {
    return 20;  # 12/45/78 01:34:67 90
  }
  elsif ( $type eq 'timestamp' ) {
    return 20;
  }
  elsif ( $type eq 'boolean' ) {
    return 1;
  }

  return undef;
}

sub get_field_type {
  my $self = shift;
  my $field_name = shift;

  return $self->{_table_dir}->{$field_name}->{Type};
}

sub _get_options {
  my $self = shift;
  
  my ($option_type, $field_type) = @_;
  my $options = {};
  
  my ($table_name, $type) = split ":", $option_type;
  $options->{type} = $type || 'select';
  
  if ($table_name) {
    if ($table_name =~/\,/) {
      $options->{list} = [map { {id=>$_, item => $_}} split ",", $table_name];
    }
    else {
      $options->{list} = $self->SelectList(sprintf("select * from %s order by id", $table_name));
    }
  }
  else {
    $field_type =~/(enum|set)(\(.*?\))/;
    $options->{list} = [map { {id => $_, item => $_} } eval $2];
    if ($field_type =~/enum/  &&  @{$options->{list}} > 4) {
      unshift @{$options->{list}}, {id => undef, item => "None"};
    }
  }
  
    return $options;
}

=pod

=head2 get_enum_values

 get_enum_values( column-name )

Return an array of possible values for a C<set> or C<enum> field type.

Given a table with an enum column `doc_type':

  +----------+-------------------+------+-----+---------+----------------+
  | Field    | Type              | Null | Key | Default | Extra          |
  +----------+-------------------+------+-----+---------+----------------+
  | id       | int(11)           | NO   | PRI | NULL    | auto_increment |
  | doc_type | enum('a','b','c') | YES  |     | NULL    |                |
  +----------+-------------------+------+-----+---------+----------------+


  <null:list $document.get_enum_values('doc_type')>
  <trace --output $list>

  [
  [0] .. (a)
  [1] .. (b)
  [2] .. (c)
  ]

=cut

sub get_enum_values {
  my $self = shift;
  my $column = shift;

  my $dir = $self->{_table_dir};

  die "usage: get_enum_value( column-name )\n" 
    unless $column && $dir->{$column};

  my @list; 

  if ( $dir->{$column}->{Type} =~/(enum|set)(\(.*?\))/) { 
    @list = eval $2;
  }
  else {
    die "column: [$column] is not an enum or set field type\n";
  }
  
  return Bedrock::Array->new( @list );
}

sub create_date_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $length = $self->get_field_length( $field_name );
  
  my $value = $self->get_formatted_field( $field_name );
  my $size = length($value) > $length ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );
  
  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
                              maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}});
  
}

sub create_char_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $_, 
			      value     => $value, 
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}})
}


sub create_select_field {
    my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
    my $value;
    
    if ($self->{_table_dir}->{$field_name}->{Type} =~/set/) {
      $value = [split ",", $self->{$field_name}];
    }
    else {
      $value = $self->{$field_name};
    }
    
  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

    return create_select_list($field_name, $value, $attributes, $options->{list});
  }

sub create_radio_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;

  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

  return create_radio_buttons($field_name, $self->{$field_name}, $attributes, $options->{list});
}

sub get_formatted_field {
  my $self = shift;
  my $field_name = shift;

  my $value = $self->get( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    $value = $self->format_field( $field_name, $value );
  }

  return $value;
}

sub format_field {
  my $self = shift;
  my ($field_name, $value) = @_;

  my $type = $self->get_field_type ( $field_name );
  
  for ( $field_name ) {
    /date/ && $type =~/date/ && do {
      $value = $self->get_date_field( $field_name );
      last;
    };
    
    /phone/ && $type =~/char/ && do {
      $value = $self->get_phone_field( $field_name );
      last;
    };
  }

  return $value;
}

sub create_varchar_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;
 
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      =>'text', 
			      name      => $field_name, 
                              value     => $value,
                              maxlength => $length,
			      size      => $size
			     ),
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}


sub create_tinyint_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  return $self->create_checkbox_field($field_name, $attributes, $labels, $lists);
  
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type  =>"checkbox", 
			      name  =>$field_name, 
			      value => 1
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : (), 
			     $self->{$field_name} ? ("checked" => undef) : ());
}

sub create_checkbox_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  $options = $options || { list => [  {id=>1, item=>""} ] };
  
  my $value;

  if ($self->{_table_dir}->{$field_name}->{Type} =~/set/) {
    $value = [split ",", $self->{$field_name}];
  } else {
    $value = $self->{$field_name};
  }

  my @values = ref($value) ? @$value : ($value);

  my @items = map {$_->{item}} @{$options->{list}};

  my $html;

  foreach my $ref (@{$options->{list}}) {
    $html .= sprintf("%s&nbsp;<b>%s</b>&nbsp;&nbsp;&nbsp;",
		     create_html_element('input',
					 (type=>"checkbox", name=>$field_name, value=> $ref->{id}), 
					 $attributes ? %{$attributes->{input}} : (), 
					 scalar(grep { $ref->{id} eq $_ } @values) ? ("checked" => undef) : ()
					),
		     $ref->{item});
  }

  return $html;
}


sub create_int_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ( $size > length($value) )  ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}

sub create_timestamp_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = length($value) || $size;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      => 'text', 
			       name      => $field_name, 
			       value     => $value,
			       maxlength => $size,
			       size      => $size,
			      ),
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_decimal_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ($size > length($value)) ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      =>'text', 
			       name      => $field_name, 
                               value     => $self->{$field_name}, 
			       maxlength => $size,
			       size      => $size
			      ), 
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_text_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $disabled = $self->get_display_only( $field_name );
  return sprintf("%s%s</textarea>", 
		 create_html_element( 'textarea', 
				      (
				       name => $field_name, 
				       rows => 5, 
				       cols => 40
				      ), 
				      $disabled ? (disabled => undef) : (),
				      $attributes ? %{$attributes->{textarea}} : ()),
		 $self->{$_}
		);
}

=pod

=head2 html_form_header

 html_form_header(attributes)

=cut

sub html_form_header {
  my $self = shift;
  my $attributes = shift || {};
  
  return create_html_element( 'form', 
			      ( 
			       name   => $self->{_table}, 
			       method => "post", 
			       action => $ENV{PATH_INFO}
			      ), 
			      %$attributes
			    );
}

=pod

=head2 html_form_footer

 html_form_footer(attributes)

Creates a row of buttons (I<save>, I<delete>, I<find>, I<new>) that
submit the form and set the C<action> hidden element.

=cut

sub html_form_footer {
  my $self = shift;
  my $attributes = shift || $self->{_attributes} || {};
  my %hidden = @_;

  my @html;
  my $form_name = $self->{_table};
  
  my $form_element = sprintf("document.%s", $form_name);
  
  my $onclick = qq{%s%s.action.value='%s'; %s.submit();};
  my @buttons = ("find", "save", "delete", "new");

  foreach (@buttons) {
    $attributes->{$_} = {} unless exists $attributes->{$_};
  }
  
  $attributes->{delete}->{disabled} = undef unless $self->{id};
  $attributes->{new}->{disabled} = undef unless $self->{id};
  
  foreach ("save","delete","find", "new") {
    push @html, create_html_element( 'input', 
				     (
				      type => "Button", 
				      value => ucfirst($_), 
				      onClick => sprintf( $onclick, 
							  $_ eq "new" ? qq{$form_element.id.value='0';}: "",
							  $form_element, $_, $form_element
							)
				     ), 
				     %{$attributes->{$_}})
  }
  
  push @html, create_html_element('input', (type => "hidden", name=>"action", value=>""));
  push @html, create_html_element('input', (type => "hidden", name=>"table", value=>$self->{_table}));
  
  # additional hidden input elements you might want to carry along
  foreach (keys %hidden) {
    push @html, create_html_element('input', (type  => "hidden", 
					      name  => $_, 
					      value => $hidden{$_}
					     )
				   );
      
  }

  # add the format mode for these fields
  foreach (@{$self->{_field_list}}) {
    push @html, create_html_element('input', (type => "hidden", name=>"format_mode", value=> "$_"))
      if $self->get_format_mode( $_ );
  }

  return sprintf("%s\n%s\n", join("&nbsp;\n", @html), "</form>\n");
}

=pod

=head2 html_form_body

 html_form_body(attributes, labels, lists)

=cut

sub html_form_body {
  my $self = shift;
  my $attributes = shift || $self->{_attributes} || {};
  my $labels = shift || $self->{_labels} || {};
  my $lists = shift || $self->{_lists} || {};
  
  my $dir = $self->{_table_dir};

  my $html = create_html_element("table", %{$attributes->{table}})."\n";
  
  foreach (@{$self->{_field_list}}) {
    
    # if no "maxlength" is given for an input field and a "size" is given, then use that as maxlength
    if ($attributes->{$_} && $attributes->{$_}->{input}->{size}) {
      $attributes->{$_}->{input}->{maxlength} = $attributes->{$_}->{input}->{size} 
	unless $attributes->{$_}->{input}->{maxlength};
    }
    
    # - first check to see if this is a pick list
    my $options;
    $options = $self->_get_options($lists->{$_}, $dir->{$_}->{Type}) 
      if $lists->{$_} || $dir->{$_}->{Type} =~/(enum|set)/;
    
    if ( $lists->{$_} ) {
      if ($options->{type} =~/(select|radio|checkbox)/) {
	my $input_element;

	if ($options->{type} eq 'select' ) {
	  $input_element = $self->create_select_field( $_, 
						       $attributes->{$_}, 
						       $labels, 
						       $lists, 
						       $options
						     );
	} elsif ($options->{type} eq 'radio') {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} elsif ($options->{type} eq 'checkbox') {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $input_element
			);
      }
    } elsif ($dir->{$_}->{Type} =~/(enum|set)/) {
      if ($options && @{$options->{list}} > 4) {
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $self->create_select_field($_, $attributes->{$_}, $labels, $lists, $options)
			);
      } else {
	my $input_element;
	if ($dir->{$_}->{Type} =~/enum/) {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} else {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$attributes->{tr}}),
			 create_html_element('th', %{$attributes->{th}}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$attributes->{td}}),
			 $input_element
			);
      }
    } elsif ($dir->{$_}->{Type} =~/tinyint/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_tinyint_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($dir->{$_}->{Type} =~/varchar/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_varchar_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/int/) {
      next if $_ =~/^id$/;
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_int_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($dir->{$_}->{Type} =~/^char/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_char_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/date/) {
      
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_date_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/timestamp/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_timestamp_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/text/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_text_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($dir->{$_}->{Type} =~/decimal/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$attributes->{tr}}),
		       create_html_element('th', %{$attributes->{th}}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$attributes->{td}}),
		       $self->create_decimal_field($_, $attributes->{$_}, $labels, $lists)
		      );
    }
  }
  
  $html .= "</table>\n";
  $html .= create_html_element('input', (type=>"hidden", value=>$self->{id}, name=>"id"));
  
  return $html;
}


=pod

=head2 handler

  handler($input)

Method that invokes various methods of your table handler object
depending upon the value of the C<action> CGI variable.

The values of the C<action> CGI variable support are:

=over 5

=item save

Saves the field values in the C<$input> object to the MySQL table.
Supports both updates and inserts depending on whether the C<id> field
is set to 0 (insert) or a non-zero (update) value.

Returns the table handler object.

=item delete

Deletes the row in the MySQL table indicated by the value of C<id>.

Return the table handler object.

=item new

Creates a new table handler object.

Returns a new table handler object.

=item find

Performs a query against the MySQL table depending upon the fields
(CGI variables) that are set in the C<$input> object.

If 1 or more rows found after executing the query, the method will
returns either C<BLM::IndexedTableHandler::RecordSet> object.

If no rows are found after executing the query, the method will return
a table handler object.

=back

=cut


sub handler {
  my $self = shift;
  my $input = shift;

  if ( $input->{format_mode} ) {
    my @mode = ref($input->{format_mode}) ? @{$input->{format_mode}} : ($input->{format_mode});
    foreach ( @mode ) {
      $self->set_format_mode($_, 1);
    }
  }

  if ($input->{action} eq 'save') {
    $self->set($input);
    $self->save();
    return $self;
  } elsif ($input->{action} eq 'delete') {
    $self->delete();
    $self->{id} = 0;
    foreach (@$self->{_field_list}) {
      $self->set($_, undef);
    }
    return $self;
  } elsif ($input->{action} eq 'new') {
    return $self;
  } elsif ($input->{action} eq 'find') {
    my $list = $self->search($input);
    if ($list && @$list >= 1) {
      return $list;
    } else {
      return $self;
    }
  } else {
    return $self;
  }
}

=pod

=head2 get_display_only

 get_display_only( field-name )

Returns true or false depending on whether the field is set to be a
display-only field

=cut

sub get_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  return $self->{_display_only}->{$field_name};
}


=pod

=head2 set_display_only

 set_display_only( field-name )

Set the field to be display only.  This prevents user input to this field.

=cut

sub set_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  $self->{_display_only}->{$field_name} = 1;
}


# - Some default pseudo field type handlers

=pod

=head2 get_format_mode( field-name )

Returns a boolean value that determines if a field should be formatted
when it is show in a form field.

=cut

sub get_format_mode {
  my $self = shift;
  my $key = shift;

  $self->{_format_mode} = {} unless $self->{_format_mode};

  return $self->{_format_mode}->{$key};
}


=pod 

=head2 set_format_mode

 set_format_mode( field-name, mode )

Indicate that a field should be formatted when the value is shown in a
form field.  Before the fieldE<039>s value is output, it is passed to
the C<format_field()> method if the format mode for the field
is set to 1.  The method is responsible for returning a formatted
version of the field.

  <null $customer.set_format_mode('date_inserted', 1)>

C<BLM::IndexedTableHandler> provides formatting for C<date>,
C<datetime>, C<timestamp>, char and varchar fields whose name is has
either the word "phone" or "date" in them.

If you don't want any default behavior or you want some other behaivor
you might consider overriding the C<format_field()> method.

  package BLM::Customer;
  
  use BLM::IndexedTableHandler;
  use Bedrock::Plugin;
  
  use strict;
  use vars qw(@ISA);
  
  @ISA = qw( BLM::IndexedTableHandler Bedrock::Plugin);
  
  sub format_field {
    my $self = shift;
    my ($field, $value) = @_;
  
    for ( $field ) {
      /(firstname|lastname)/ && do {
        $value = ucfirst(lc($value));
        return $value;
      };
  
    }
  
    return $self->SUPER::format_field($field, $value);
  }
  
  1;

=cut

sub set_format_mode {
  my $self = shift;
  my ($key, $mode) = @_;

  $self->{_format_mode} = {} unless $self->{_format_mode};
  $self->{_format_mode}->{$key} = $mode;
}



# +---------------+
# | PHONE NUMBERS |
# +---------------+

=pod

=head2 set_phone_field

  set_phone_field(field, value)

Removes extraneous data from a phone number field and returns and/or
sets the column value to just the digits of the phone number.  If the
resulting length of the object is 10 or 7 then the column is set to
just the digits, otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the digits are just returned to the caller.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_phone_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value =~s/[^\d]//g;
    $value =~/^(\d{7}|\d{10})$/;
    $value = ($1 ? $1 : undef);

  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}

=pod

=head2 get_phone_field

 get_phone_field( field-name )

Returns a formatted phone number.  If the phone number length is 7 digits:

 555-1212

If the phone number legnth is 10 digits:

 (888) 555-1212 

Example:

 <var $customer.get_phone_field('work_phone')>

=cut

sub get_phone_field {
  my ($self, $key) = @_;
  
  if ($self->{$key}) {
    my $str = $self->{$key};
    
    if (length($str) == 7) {
      return sprintf("%s-%s", unpack "a3a4", $str);
    } elsif (length($str) == 10) {
      return sprintf("(%s) %s-%s", unpack "a3a3a4", $str);
    } else {
      return $self->{$key}; # I have no idea what you're up to here dude!
    }
  } else {
    return $self->{$key};
  }
}

=pod

=head2 set_date_field

 set_date_field(field-name, value)

Use this method to set the value of a date field.  The idea being, you
may have a user enter a date in either YYYY-MM-DD format or
MM/DD/YY[YY] formats and this method will format the date properly for
insertion into a MySQL date field.

Example:

  <null $player.set_date_field('birthday', $input.birthday)>

=cut


sub set_date_field {
  my ($self, $key, $value) = @_;

  if ($value) {
    my @date = split /[\/-]/, $value;
    
    if (3 == scalar(@date) ) {
      if ($value =~/-/) {
	$value = sprintf("%4d-%02d-%02d", @date);
      } else {
	$date[2] += 2000 if $date[2] < 30;
	$value = sprintf("%4d-%02d-%02d", @date[(2,0,1)]);
      }
    }
  }
  
  return $value;
}



=pod

=head2 now

Return the current date and time YYYY-MM-DD HH24:MI:SS format.

 <var $customer.now()>

=cut

sub now {
  my $self = shift;

  return $self->Select("select now() as n")->{n};
}

=pod

=head2 curdate

Return the current date in YYYY-MM-DD format.

 <var $customer.curdate()>

=cut

sub curdate {
  my $self = shift;

  return $self->Select("select curdate() as d")->{d};
}

=pod

=head2 curtime

Return the current time in HH24:MI:SS format.

 <var $customer.curtime()>

=cut

sub curtime {
  my $self = shift;
  return $self->Select("select curtime() as t")->{t};
}


=pod

=head2 get_date_field

 get_date_field( field-name )

Returns a MM/DD/YYYY or MM/DD/YYYYY HH:MI:SS formatted date or
datetime value from a MySQL YYYY-MM-DD date.

Example:

 <input type="text" name="birthday" value="<var $player.get_date_field('birthday')>">

=cut

sub get_date_field {
  my ($self, $key) = @_;

  return undef unless $self->{$key} && $self->{$key} !~/0000\-00\-00/;

  my @date = split("-", $self->{$key});

  $date[3] = $1 if $date[2] =~/\d{2} (\d{2}:\d{2}:\d{2})/;

  my $fmt_date = sprintf("%02d/%02d/%04d", @date[(1,2,0)]);
  $fmt_date .= ' ' . $date[3] if $date[3] && $date[2] !~/00:00:00/;

  return $fmt_date;
}

=pod

=head2 set_email_field

 set_email_field(field, value)

Validates and returns and/or sets the column valued to an email
address. If the email is valid, then the column is set to the value,
otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the email address is just returned to the caller if valid.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_email_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value = $self->validate_email( $value ) ? $value : undef;
  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}


=pod

=head2 validate_email

 validate_email( email )

Returns true or false depending on validity of email address.  This
doesnE<039>t mean this address is associated with a real email account,
just that it might. ;-)

=cut

sub validate_email {
  my $self = shift;
  my $email = shift;

  return $email =~/^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/;
}

=head1 CAVEATS

=head2 checkbox fields

Because checkbox fields are not manifested in the CGI C<QUERY_STRING>
when form data is submitted and the checkbox is not checked, you may
find that using a simplistic approach to updating the fields in your
object may result in checkbox fields being ignored.  For example, the
Bedrock code:

  <foreach $input.keys()>
     <null $player.set($_, $input.get($_)>
  </foreach>

would never actually update a checkbox field that was unchecked.
Therefore, as shown above the "more correct" approach to setting
the values of your object from your HTML form:

  <foreach $player.fields()>
     <null $player.set($_, $input.get($_))>
  </foreach>

...guarantees that each field in the table will be set, even if it is
set to a null value.

If you rely on the single argument version of the C<set> method youE<039>re
in luck (at least if youE<039>re database field being rendered as a
checkbox is a boolean).  Since C<html_form()> renders C<tinyint> or
C<boolean> fields as checkboxes, C<set> will make sure that any
C<tinyint> field in the record is set, regardless of whether it exists
in the C<$input> object.

=head1 AUTHOR

Rob Lauer - rlauer@signatureinfo.com

=head1 SEE ALSO

DBHandler

=cut

# $Log$
# Revision 1.13  2011/11/28 21:20:51  eutl420
# - added the ability to carry along extra fields by passing them to html_form_footer()
# - ability to set "display only" fields via set_display_only() method
# - ability to set formatting on/off for fields via set_format_mode() method
#
# Revision 1.12  2011/11/21 14:08:10  eutl420
# - incrementally improving pod
# - in the _find() method we now eval the call to SelectList so that we can display the query in the error, also
#   return an empty array when no rows are found
# - in the one argument form of find(), check to make sure the argument is a valid id (i.e. int > 0)
# - the set_phone_field() method did not actually set the field as advertised
# - new methods:
#   + get_enum_values() which returns an array of possible values for an field type of `enum'
#   + set_email_field() which validates and sets an email field
#   + validate_emai() uses a regexp to validate a supposed email address
#
# Revision 1.11  2011/11/16 14:37:50  eutl420
# pod
#
# Revision 1.10  2011/11/14 22:36:32  eutl420
# - code in new() that avoids redundant operations when being instantiated from a reference should make sure that
#   this is in fact a first class BLM::IndexedTableHandler and not one that was simply a sub-class.  We check for
#   the member _field_list to make sure that the reference is in fact legit.
# - more pod cleanup
#
# Revision 1.9  2011/11/14 15:01:11  eutl420
# - this is being re-added to the Bedrock project
# - cleaned up pod and added some documentation for existing methods
# - added new methods
#   + asref() returns just a hash reference of the record's column values
#   + now() returns result of MySQL NOW() function
#   + curtime() returns result of MySQL CURTIME() function
#   + curdate() returns result of MySQL CURDATE() function
#
# Revision 1.8  2011/11/13 16:08:28  eutl420
# - adding back to project
#
# Revision 1.6  2011/07/17 16:56:08  eutl420
# - build .pm from .pm.in, added @PERL@
#
# Revision 1.5  2011/07/12 19:10:35  eutl420
# set VERSION from cvs Revision keyword
#
# Revision 1.4  2009/12/31 00:04:41  rlauer
# docs need work - wip
#
# Revision 1.3  2009/12/28 20:32:33  rlauer
# move SIS:: up to Bedrock::
#
# Revision 1.2  2008/12/03 14:01:18  alans
# We now use a hard-coded value for module $VERSION rather than a munged
# version of the expansion of the CVS 'Revision' keyword; the module API
# version number is orthogonal to the identifyer in the source control
# system.
#
# This change makes it safe to import the Bedrock codebase into another
# source repository (even CVS!) without breaking the code. We hit this
# issue when we first released the libbedrock-perl .deb package, for which
# we imported the release tarball sources into the 'bedrock-deb' CVS project.
#
# Revision 1.1  2008/11/25 14:32:27  rlauer
# added as part of Bedrock 2.0.0 reorg
#

1;
