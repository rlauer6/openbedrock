package BLM::IndexedTableHandler;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use vars qw/$VERSION/;

our $VERSION = sprintf("%s.%s", (split(/\./, '@PACKAGE_VERSION@'))[0], "01");

use Bedrock::Array;

use Bedrock::HTML::Helper qw(
			     create_html_element
			     create_label_name
			     create_xhtml_element
			     create_radio_buttons
			     create_select_list
			   );

use BLM::IndexedTableHandler::RecordSet;
use Data::Dumper;
use Scalar::Util qw/reftype/;

use parent qw/BLM::DBHandler/;

=pod

=head1 PUBLIC

C<BLM::IndexedTableHandler> -- Base class for a MySQL table handler

=head1 SYNOPSIS

  my $foo_ith = new BLM::IndexedTableHandler( $dbi, $id, undef, 'foo' );

  # foo handler with locking
  my $foo_ith = new BLM::IndexedTableHandler( $dbi, { id => $id, 
                                                      table_name => 'foo',
                                                      lock => 1
                                                     }
                                                );

Using C<BLM::IndexedTableHandler> as a base class:

  package BLM::Foo;

  use parent BLM::IndexedTableHandler;

  1;

 my $foo_ith = new BLM::Foo( $dbi );


=head1 DESCRIPTION

C<BLM::IndexedTableHandler> is a base class used to construct a
package for updating, deleting, and searching a MySQL table.  The
class handles the relatively mundane tasks associated with managing
the rows of a table.  These include for example, inserts, deletes, and
updates.

It is also a class designed to aid in the contruction of a web
application by providing a host of methods that help construct HTML
forms typically used in support of table maintenance and other aspects
of web application development.

Essentially, C<BLM::IndexedTableHandler> through itE<039>s super-class
represents a MySQL table and thus is named according to the tableE<039>s
name.  In the synopsis above the super-class C<BLM::Foo> represents
the MySQL table C<foo>.

C<BLM::IndexedTableHandler> is a sub-class of C<BLM::DBHandler>.

Although primarily designed to be a base class that allows you to
override methods so you can implement your own table handling
behaviors, C<BLM::IndexedTableHandler> can be used I<naked> with no
overridden methods as in the synopsis above.

Methods you might want to consider overriding include:

=over 5

=item save

=item delete

=item set

=item search 

=item find

=item handler

=back

...and especially the methods that provide some HTML snippets for
constructing the HTML form for editing your table.

B<Example of overriding one of the HTML construction methods...>

  package BLM::Birds;

  use parent BLM::IndexedTableHandler;

  sub create_timestamp_field {
      my ($self, $field_name, $attributes, $labels, $lists) = @_;

      return $self->SUPER::create_timestamp_field($field_name, $attributes, $labels, $lists) unless $field_name =~/last_spotted/;

      return &calendar("birds", "last_spotted", $self->{last_spotted});
}

  sub calendar {
    my ($form_name, $field_name, $value) = @_;

    my $html =<<eot;
  <table cellpadding="0" border="1" cellspacing="0">
    <tr>
      <td valign="center"><input name="$field_name" type="text" size="19" value="$value" maxlength="19"></td>
      <td valign="center"><input type="image" onClick='javascript:popUpCalendar(document.$form_name.$field_name, document.$form_name.$field_name, "m/d/yyyy"); return false' src="/img/calendar.gif"></td>
    </tr>
  </table>
  eot

    return $html;
  } 

These HTML construction methods are described in more detail later in
this documentation.

I<The MySQL table should conform to certain conventions.  It must have
an indexed (unique) field named C<id> which is defined as an
C<auto_increment field>.>

Your class, which sub classes C<BLM::IndexedTableHandler>, should be
named such that the suffix is the table name.  The program assumes the
actual MySQL table name is lower case.  So, in the C<SYNOPSIS> above,
assuming we have an example table named C<foo> that looks something
like:

  create table foo (
   id int auto_increment primary key,
   lname varchar(32),
   fname varchar(32),
   email varchar(64)
  );

...and assuming I pass a handle to an open database to C<BLM:Foo>
constructor, I would get a whole lot of stuff necessary for building a
typical Bedrock application for free!

HereE<039>s a Bedrock example of using this module, although typically
C<BLM::IndexedTableHandler> is used as part of your application in an
Application Plugin.

  <sqlconnect --data-source="dbi:mysql:bedrock_site" --username="fred" --password="flintstone" --db="dbi">

  <plugin:Foo $dbi>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Gina', 'email', 'gina@openbedrock.com')>
  <null $Foo.save()>

  <null $Foo.reset()>
  <null $Foo.set('lname', 'Lollabrickada', 'fname', 'Geena', 'email', 'geena@openbedrock.com')>
  <null $Foo.save()>

Update a record...

  <null $Foo.set('email', 'geena123@openbedrock.com')>
  <null $Foo.save()>

Return a list of all records in table C<foo>. I<Note that the
C<find()> method returns a list of C<BLM::IndexedTableHandler> objects
suitable for use in the same way you used the original object.  If you
want just a hash reference of the fields of the record, you can use
the C<asref()> method of an object or a record set.>

  <null --define-var="foo_list" $Foo.find()> 

Just return a hash reference containing the key/values pairs instead
of an array of C<BLM::IndexedTableHandler> objects.

  <trace --outptut $foo_list.asref()>

Return a list of records in table C<foo> where the C<lname> field
starts with 'Lolla'...

   <null --define-var="lollas" $Foo.find('lname', 'Lolla')>

Find a record in table C<foo> where the C<lname> field exactly matched
'Lolla'...

   <null --define-var="lolla" $Foo.find_unique('lname', 'Lolla')>

Return a list of records in table C<foo> where the C<lname> field
exactly matched 'Lolla'...

   <null --define-var="lollas" $Foo.find(1, 'lname', 'Lolla')>


=head1 DOCUMENTATION

=head2 Getting Started

Using the template from the C<SYNOPSIS> above, create your
C<BLM::table_name> package and install it somewhere where Perl will
find it.  Typically in a web application, you might keep your Perl
modules together with your other web assets, for example:

  /var/www/vhosts/www.mysite.com/perl5/BLM

...or wherever you told Perl to look for Perl modules.  If you are
using Bedrock as a CGI (instead of C<mod_perl>) then you might have
added include paths to F<perl.INC> or if you are using C<mod_perl>
then you might have used the C<PerlSwitches> directive in your Apache
configuration file.

  package BLM::Foo;

  use parent BLM::IndexedTableHandler;

  1;

YouE<039>ll then want to create your MySQL table.

 create table foo (
   id    int auto_increment primary key,
   name  varchar(32),
   email varchar(32)
 );


 $ cp Foo.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Foo.pm

You then instantiate C<IndexedTableHandler> objects either directly
from your Bedrock page :-( as shown above using the
C<E<lt>pluginE<gt>> tag:

  <plugin:Foo $dbi>

...or you can do this from your siteE<039>s Application Plugin object
which might typically provide a factory method for instantiating
objects to handle your table.  This is the preferred method and the
details below will guide you in creating an Application Plugin that
creates your database handling object.

=head2 The Gory Details

First you should create an application plugin configuration file.
Assuming our Application Plugin will be named C<Example>, weE<039>ll create
a configuration file named F<example.xml> as show below:

   <object> 
    <scalar name="binding">example</scalar> 
    <scalar name="module">BLM::Startup::Example</scalar> 
    <object name="config"> 
     <scalar name="data_source">dbi:mysql:bedrock_site</scalar>
     <scalar name="username">fred</scalar>
     <scalar name="password">flintstone</scalar>
    </object> 
   </object> 

This file should be added to your site's configuration by placing the
file in the F<CONFIG_PATH/config.d/startup>
directory. C<CONFIG_PATH> is the path you set in the Apache
configuration file to tell Bedrock where to find your virtual host's
local configuration information.

 SetEnv CONFIG_PATH /var/www/vhosts/www.mysite.com/config

Note the binding name for this object is I<example> and will be
referenced in the Bedrock example below.

Now create the Application Plugin perl module.

  use strict;
  use warnings;

  package BLM::Foo;

  use parent BLM::IndexedTableHandler;

  package BLM::Startup::Example;
  
  use parent Bedrock::Application::Plugin;
  
  # - factory method for creating Foo handlers
  sub foo {
      my $self = shift;
  
      return BLM::Foo->new($self->dbi, @_);
  }
  
  1;

Again, this Perl module should be installed somewhere where Perl will
find the module when your web applicaion is executing.

  $ cp Example.pm /var/www/vhosts/www.mysite.com/perl5/BLM/Startup/Example.pm

As you can see, the application plugin provides a factory method named
C<foo> that simply returns a C<foo> object.  The C<foo> object is a
C<BLM::IndexedTableHandler>.

=head2 Bedrock Web Development with C<BLM::IndexedTableHandler>

Now create a sample Bedrock page to test your object.

  <null --define-var="fred" $example.foo()>
  <null --define-var="wilma" $example.foo()>
  
  <html>
  <body>
  <pre>
  <trace --output $fred>
  </pre>
  <null $fred.set('lname', 'Flintstone',
                  'fname', 'Fred',
                   'email', 'fflintstone@bedrock.com')>
  <null $fred.save()>
  
  <null $wilma.set('lname', 'Flintstone', 
                   'fname', 'Wilma', 
                    'email', 'wflintstone@bedrock.com')>
  <null $wilma.save()>
  <null --define-var="flintstones" $wilma.find('lname', 'Flintstone')>
  
  <pre>
  <hr>
  <trace --output $flintstones>
  </pre>

  <table>
    <tr>
      <th>First</th>
      <th>Last</th>
      <th>E-Mail</th>
    </tr>
    <foreach $flintstones>
    <tr>
      <td><var $fname></td>
      <td><var $lname></td>
      <td><var $email></td>
    </tr>
    </foreach>
    </table>
  </body>
  </html>

=head2 Constructing HTML Forms

If the the C<BLM::IndexedTableHandler> did nothing more than handle
the I<insert>, I<update>, I<delete> drudgery for MySQL records and
provide some query tools that would probably be enough.  Probably, but
there is still much tedium and re-hashed HTML snippets that we all use
in every Bedrock application we write that makes developing HTML apps
a chore.

By standardizing on how we might want to handle specific MySQL field
types within applications it is possible to provide a template of an
HTML form that might help us create database applications with Bedrock
and MySQL. Enter the C<html_form_*()> methods.

The C<html_form_*> methods will create a template for a completely
usable HTML form that implements a basic CRUD application for updating
your MySQL table.  The C<html_form_body()> method interprets the
various field types within a MySQL table and creates appropriate form
objects.  It will also properly set the data values within the form
based on the values in the current object.

The form is rendered inside a 2-column table where the first column
contains the field names and the second column contains the HTML input
element that allows entry or editing of the data values.  A row in the
table is written for each field in the table.  Field names are
converted to a more readable from from the column names in the MySQL
table using the following conventions:

=over 4

=item * underscores ('_') are converted to blanks

=item * the first letter of each word in the resulting string is converted to upper case

=back

Examples:

 first_name       => First Name
 last_name        => Last Name
 primary_position => Primary Position
 e_mail_address   => E Mail Address

The HTML form is rendered in three parts, a head, a body and a footer
using the three methods C<html_form_header()>, C<html_form_body()> and
C<html_form_footer()>.

You can probably reduce most Bedrock applications that handle a MySQL
table to something like the Bedrock snippet below:

 <html>
 <head>
 <body>
  
 <null --define-var="foo" $example.foo($input.id)>

 <if $input.action --eq "save">
   <null $foo.set($input)>
   <null $foo.save()>
 <elseif $input.action --eq "find">
  <null --define-var="foo_find_list" $foo.search($input)>
  <if $foo_find_list.length() --eq "1">
    <null --define-var="foo" $foo_find_list.get(0)>
  <elseif $foo_find_list.length()>
   <foreach $foo_find_list>
     <a href="?id=<var $_.id>"><var $_.id></a><br>
   </foreach>

   <null --define-var="foo" $example.foo()>
   <null $foo.set($search_field, $input.get($search_field))>
  </if>
 </if>

 <var $foo.html_form_header()>
 <var $foo.html_form_body()>
 <var $foo.html_form_footer()>

 </form>
 </body>
 </html>

or you can use the L</handler> method which pretty much performs a
similar function as the logic above.

The C<html_form_body()> method currently has support for the following
MySQL field types:

=over 4 

=item int

An C<int> field will be converted to an HTML <input> object with a size of 5.

=item char

A C<char(n)> field will be converted to an HTML <input> object with a size of n.

=item varchar

A C<varchar(n)> field will be converted to an HTML <input> object with a size of n.

=item enum

An C<enum> field will be converted into a <select> or <input (radio)>
object where the options and values are equal to the specification
within the definition of the C<enum> field.

If the number of elements in the enumeration is 4 or less, then the
C<html_form()> method will produce a set of radio buttons.  If the
list is greater than 3, the method will produce a <select> object.
This behavior can be overridden as described in the overloaded version
of the C<html_form()> method (see the full documentation on
C<html_form()>) for details.

For example if your field is defined as below:

 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |

The C<html_form()> method would create a select box as follows:

 <select name="pant_size">
   <option value="S">S</option>
   <option value="M">M</option>
   <option value="L" selected>L</option>
   <option value="XL">XL</option>
   <option value="XXL">XXL</option>
   <option value="XXXL">XXXL</option>
 </select>

=item set

A set field is converted to either a <select> element that allows
mulitple selections or a series of checkboxes.  If the number of
elements in the set is 4 or less then the set is represented by a
series of check boxes, otherwise it is represented as a multi-select
list.

=item tinyint

A C<tinyint> or C<boolean> field is converted into a check box object.

=item date

A C<date> field is converted to an <input> object with a length of 10.
Upon display, this field is shown as a standard MySQL date field of
the form YYYY-MM-DD.  Before being saved to a table, this field will
be converted to the YYYY-MM-DD format if the format is MM/DD/YYYY or
MM/DD/YY.  See C<set> for more details on how form fields are
converted to MySQL data types before being saved.

=item timestamp

C<timestamp> fields are treated in a similar fashion to C<date> fields
except they are 19 characters in length and support a suffix of HH:MM
PM.

=item text

C<text> fields are converted into a <textarea> object with 40 columns
and 5 rows.  These attributes can be overridden (see the full
documentation for the C<html_form_body()> method.

=back

I<The method C<html_form_body_with_class> will create the same form
with class and id attributes that correspond to your table name.>

=head1 METHODS

=head2 new

 new( dbi, id, config, table-name )
 new( dbi, id, table-name )
 new( dbi, { id => id, table_name => table-name, config => config, lock => 0 |1  })

Polymorphims run amok, but pick your poison...these are unambiquous
signatures. My preference in Bedrock is...

  <plugin:IndexedTableHandler $dbi 'table-name'>

=over 5

=item dbi

An instance of a C<DBI> object representing an open connection to a
MySQL database.

=item id

The C<id> field which uniquely identifies a record in the MySQL table.

=item config

Configuration object containing an object named C<tables> that
contains options for handling MySQL tables.

=item table-name

The name of the MySQL table.

=item lock

The lock mode.

 0 => no locking
 1 => FOR UPDATE
 2 => LOCK IN SHARE MODE

=over 5

=item LOCK IN SHARE MODE

I<SELECT ... LOCK IN SHARE MODE sets a shared mode lock on any rows that
are read. Other sessions can read the rows, but cannot modify them
until your transaction commits. If any of these rows were changed by
another transaction that has not yet committed, your query waits until
that transaction ends and then uses the latest values.> - from http://dev.mysql.com

=item FOR UPDATE

I<SELECT ... FOR UPDATE locks the rows and any associated index entries,
the same as if you issued an UPDATE statement for those rows. Other
transactions are blocked from updating those rows, from doing SELECT
... LOCK IN SHARE MODE, or from reading the data in certain
transaction isolation levels. Consistent reads ignore any locks set on
the records that exist in the read view. (Old versions of a record
cannot be locked; they are reconstructed by applying undo logs on an
in-memory copy of the record.)> - from http://dev.mysql.com

=back

B<Note that row level locking in MySQL is only available with the InnoDB
engine.  The row is locked immediately when the object is instatiated
for the give C<id>.  You should commit the record to release the lock.>

=item max_rows

Indicates the maximum number of rows that should be returned for
select methods (C<find()>, C<select()>, C<select_list()>).  The
default is 0 which indicates "no limit".

=back

=cut

sub _new_with_query {
  my $self = shift;
  
  my %args = %{$_[0]};
  
  die "you must pass a database handle (dbi)\n"
    unless exists $args{dbi};

  $self->dbi(delete $args{dbi});
  
  if ( exists $args{table_name} ) {
    $self->set_table_name(delete $args{table_name});
  }
  else {
    $self->set_table_name($self->_table_name);
  }
  
  die "possibly not a table object\n"
    unless $self->get_table_name;

  my @bind_vars;
  my @query;
  
  die "no columns to query\n"
    unless keys %args;
  
  foreach my $key (keys %args) {
    my $column = $key;
    
    # '!foo' => 1, e.g.
    # '!foo' => undef  (is not null)
    my $isnt;
    $isnt = $column =~/^\s*!/;
    $column =~s/\!//;
    
    if ( defined $args{$key} ) {
      push @bind_vars, $args{$key};
      push @query, sprintf("%s %s ?", $column, $isnt ? '<>' : '=', $args{$key});
    }
      else {
	push @query, sprintf("%s is %s null", $column, $isnt ? "not" : "");
      }
  }
  
  my $filter = sprintf("select id from %s where %s", $self->get_table_name, join(" and ", @query)); 
  
  my $sth = $self->dbi->prepare($filter);
  
  $sth->execute(@bind_vars);
    my $ref = $sth->fetchrow_hashref;
  
  return $ref->{id} ? $ref->{id} : 0;
}

sub _new_with_options {
  my $self = shift;
  my $opts = shift;

  my ($id, $config, $table_name, $max_rows) = @{$opts}{qw/id config table_name max_rows/};

  $self->{_config} = $config;
  $self->{_table} = $table_name;
  $self->max_rows($max_rows);

  $self->lock( $opts->{lock} );

  return $id ? $id : 0;
}

sub _new_with_id {
  my $self = shift;
  
  my @args = @_;
  my $id;

  # new(dbi, id, config)  <>  ref, scalar, ref
  # new(dbi, id, table-name) <>  ref, scalar, scalar
  # new(dbi, id, config, table-name) <> ref, scalar, ref, scalar
  if ( @args == 2 && ref($_[1]) ) {
    $id = shift;
    $self->{_config} = shift;
  }
  elsif ( @args == 2 ) {
    $id = shift;
    $self->{_table} = shift;
  }
  else {
    $id = shift;
    $self->{_config} = shift;
    $self->{_table} = shift;
  }
  
  return $id ? $id : 0;
}

sub dbi {
  my $self = shift;

  if ( @_ ) {
    my $dbi = shift;
  
    die "[$dbi] not a DBI object\n"
      unless ref($dbi) && ref($dbi) =~/DBI::db/;

    die "BLM::IndexedTableHandler currently only supports MySQL tables.\n"
      unless $dbi->get_info(17) =~/mysql/i;
    
    $self->{_dbi} = $self->{_db} = $dbi;
  }

  return $self->{_dbi};
}

sub _table_name {
  my $class = ref( $_[0] ) || $_[0];
  
  # probably not a good class name 'table', but we'll support it
  $class =~ /(::)?([^:]+)$/ ? lc($2) : undef;
}

sub set_table_name { $_[0]->{_table} = $_[1] };
sub set_config { $_[0]->{_config} = $_[1] };

sub _get_table_dir {
  my $self = shift;

  my $table_name = $self->get_table_name;
  
  my $sth = $self->dbi->prepare('show fields from ' . $table_name);
  $sth->execute;
    
  my $fields = {};
  my $id_found;
  my $idx = 0;
  
  while (my $ref = $sth->fetchrow_hashref) {
    $ref->{idx} = ++$idx;
    $fields->{$ref->{Field}} = $ref;
    
    if ( ($ref->{Field} eq 'id') && 
	 ($ref->{Key} =~/pri/i) && 
	 ($ref->{Extra} =~/auto_increment/i)) {
      $self->{_id} = $ref;
    }
  }

  die "Table must have an indexed field named [id] and it must be auto_increment!" 
    unless $self->{_id};
  
  $sth->finish;
  
  $self->{_table_dir} = $fields;
  $self->{_field_list} = [sort {$fields->{$a}->{idx} <=> $fields->{$b}->{idx}} keys %$fields];
	
  if ( $self->get_table_config->{$table_name}->{labels} ) {
    $self->{_labels} = $self->get_table_config->{$table_name}->{labels};
  }
  
  if ( $self->get_table_config->{$table_name}->{lists} ) {
    $self->{_lists} = $self->{_config}->{tables}->{$table_name}->{lists};
  }
  
  if ( $self->get_table_config->{$table_name}->{attributes}) {
    $self->{_attributes} = $self->get_table_config->{$table_name}->{attributes};
  }
  
  if ( $self->get_table_config->{$table_name}->{search_fields} ) {
    $self->{_search_fields} = [];
    
    foreach ( @{$self->get_table_config->{$table_name}->{search_fields}} ) {
      push @{$self->{_search_fields}}, $_->{exact};
      push @{$self->{_search_fields}}, $_->{field};
    }
  }

  return $self->{_table_dir};
}


sub new {
  my $this = shift;
  my $class = ref($this) || $this;
  my @args = @_;

  my $self = bless {}, $class;
  my $id;

  if ( ref($args[0]) && ref($args[0]) !~/DBI::db/i ) {
    
    $id = $self->_new_with_query(@args);
  }
  # new( dbi, hash-ref )
  elsif ( ref($args[0]) && ref($args[0]) =~/DBI::db/ ) {
    $self->dbi(shift @args);
    if (ref($args[0]) && reftype($args[0]) eq 'HASH') {
      $id = $self->_new_with_options(@args);
    }
    else {
      $id = $self->_new_with_id(@args);
    }
  }
  else {
    die "usage: new BLM::IndexedTableHandler(...)\n";
  }
  
  if ( ref($this) ) {
    $self->set_table_name($this->get_table_name());
  }
  elsif ( ! $self->get_table_name ) {
    $self->set_table_name($self->_table_name);
  }
      
  die "Unable to determine table name"
    unless $self->get_table_name;
      
  # validate config object
  unless ( ref($self->get_config) && $self->get_config->{tables} ) {
    $self->set_config({});
  }
  
  # - avoid redundant creation of data structure for each row in a list
  #   i.e. if this object is being constructed thusly:
  #
  #   $another = $me->new($dbi, $id);
  #
  #   which is done from find() for example, then we really don't want to 
  #   create multiple arrays that hold the table directory, one will do nicely thanks
  #
  if ( ref($this) && $this->can('get_field_list') ) {
    # grab all the same hidden values from the reference class instance
    @{$self}{keys %$this} = values %$this;

    # ...but the values of the columns in the table
    foreach ( $self->get_fields() ) {
      $self->{$_} = undef;
    }
  }
      
  $self->get_table_dir;
      
  foreach ( $self->get_fields ) {
    if ( $self->get_field_type($_) eq 'timestamp') {
      $self->set_display_only( $_ );
    }
  }
      
  if ( $id ) {
    my $query = "select * from %s where id = ? %s";
    
    my $lock_mode = { 0 => '',
		      1 => 'for update',
		      2 => 'lock in share mode'
		    }->{$self->lock || 0};
    
    my $ref = $self->select( sprintf($query, $self->get_table_name, $lock_mode), $id );
    
    foreach (keys %$ref) {
      $self->{$_} = $ref->{$_};
    }
  }
     
  $self->set_upsert_mode(0); # default legacy behavior
    
  $self;
}

=pod

=head2 lock

 lock(true | false)

Set lock mode for a select query.  If lock mode is set, then a select
query will include the 'for update' clause.

=cut

sub lock {
  my $self = shift;

  $self->{_lock} = $_[0]
    if ( @_ );

  return $self->{_lock};
}

sub get_attributes {
  return $_[0]->{_attributes} || {};
}

sub get_labels {
  return $_[0]->{_labels} || {};
}

sub get_lists {
  return $_[0]->{_lists} || {};
}


=head2 delete

 delete()
 delete( id )
 delete( column-name )

Deletes the currently defined row from the database, a specified
record identified by C<id> or removes a column from the object so that
it will not be updated on subsequent saves.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "delete">
     <null $foo.delete()>
     <null --define-var="foo" $factory.foo()>
  </if>

=over 5

=item id

The C<id> of the record you wish to delete.  If no value is given for
C<id> the current object is deleted if the C<id> column is set.

=item column-name

The name of a column in the table.  If this value is passed then the
member will be deleted from the object allowing you to update a record
without updating that particular column.  I<Note that the C<save()>
method will read the record back into the object after it has been
updated, thus restoring that column to the object.>

=back

=cut

sub delete {
  my $self = shift;
  my $id = shift || $self->{id};
  
  if ( $id && $id =~/^\d+$/ ) {
    $self->reset();

    return $self->_delete( $id );
  }
  elsif ( $id && grep { /$id/} @{$self->get_field_list} ) {
    return delete $self->{$id};
  }
}

sub _delete {
  my $self = shift;
  my $id = shift;

  $self->Do("delete from ". $self->{_table}." where id = ?", $id);

  return $self->{rows};
}

=pod

=head2 null

 null( column, ... )
 null( array-ref )

Sets the specified column (or columns) to NULL (undef).  Pass a list
of column names or an array reference of column names.

=cut

sub null {
  my $self = shift;

  my @list = ref($_[0]) ? @{$_[0]} : @_;

  my @fields = $self->get_fields();

  foreach my $column_name ( @list) {
    if ( $self->is_field($column_name) ) {
      $self->{$column_name} = undef;
    }
  }
}

=pod

=head2 is_null

 is_null( field-name )

Returns true if the field is NULL, false if it is not NULL.  Not that
the empty string is NOT a NULL value.

Example:

  <if $contact.is_null('username')>
    ...
  </if>

=cut

sub is_null { ! defined $_[0]->{$_[1]}; }

=pod

=head2 is_field

 is_field( name )

Returns true if C<name> is a column in the table.  Returns false if it is not.

=cut

sub is_field { exists $_[0]->{_table_dir}->{$_[1]}; }

=pod

=head2 reset

 reset( [delete] )

Clears (sets columns to NULL) all of the columns in the object or if
the C<delete> flag is set, will remove the column from the set of
columns with data to save or insert.

In some cases, you may not want a value of NULL in your column and
want an insert or update to only update the columns that have been
explicitly set.  In that case, use C<insert()> instead of C<save()> as
C<insert()> will only insert columns that have explicitly been set
with a value (unlike C<save()> which will insert NULL for columns not
explicitly set).

So, when using C<reset()> you may want to reset the object to a state
where no columns have been explicitly set.

 $ith->reset(1);

An example of this may be when your columns have
default values and also have constraints.  Consider the column
definition below:

 first_name varchar(32) not null default '';

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->save();

The above example will cause a NOT NULL constraint exception. Now consider:

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->insert();

 $ith->reset();
 $ith->set('last_name', 'Jones');

In the example above, the first record is written and the second causes and exception. And then consider...

 my $ith = new BLM::IndexedTableHandler($dbi, 0);

 $ith->set('last_name', 'Smith');
 $ith->insert();

 $ith->reset(1);
 $ith->set('last_name', 'Jones');

...and both records are now written.

=cut

sub reset {
  my $self = shift;
  my $delete = shift;
  
  foreach (@{$self->get_field_list}) {
    if( $delete ) {
      delete $self->{$_};
    }
    else {
      $self->{$_} = undef;
    }
  }
}


=pod

=head2 encrypt

 encrypt( column-name, secret )

Encrypts (updates) a column with C<secret> using the MySQL
C<aes_encrypt()> function.

=cut

sub encrypt {
  my $self = shift;
  my ($column, $secret) = @_;

  return $self->Do(
		   sprintf("update %s set %s = aes_encrypt(%s, ?)", $self->{_table}, $column, $column), 
		   $secret
		  );
}


=pod

=head2 decrypt

Decrypt a column value using C<secret> and the MySQL C<aes_decrypt()> method.

 decrypt( column-name, secret )

=cut

sub decrypt {
  my $self = shift;
  my ($column, $secret) = @_;

  my $result = $self->select("select aes_decrypt(?, ?) as dummy", $self->{$column}, $secret);

  return $result->{dummy};
}

sub init_config {
  my $self = shift;

    # no configuration passed
  return unless $self->get_config && $self->get_table_config;
  
    my $config = $self->get_table_config;
  
  # not configuration info for this particular table
  return unless 
    my $table_config = $config->{$self->get_table_name};
  
  my %default = ( set        => '', 
		  get        => '', 
		  attributes => {}, 
		  labels      => ''
		);
  
    my @cols = $self->get_fields;
  
  foreach my $type (qw(set get attributes labels)) {
    my $config = $table_config->{$type} || {};
    foreach ( @cols ) {
      $config->{$_} = $default{$type} 
	unless exists $config->{$_};
    }
    
    $table_config->{$type} = $config;
  }
  
    $self->get_table_config->{$self->get_table_name} = $table_config;
  
  return $self->get_config;
}

sub keys {
  $_[0]->fields();
}

sub get_table_name {
  my $self = shift;

  return $self->{_table};
}

sub get_table_config {
  my $self = shift;

  return $self->get_config->{tables} || {};
}

sub get_table_dir {
  my $self = shift;

  return $self->{_table_dir} || $self->_get_table_dir;
}

sub config {
  $_[0]->get_config;
}

sub get_config {
  my $self = shift;

  return $self->{_config} || {};
}

=pod

=head2 get

 get(field)
 get(field, field, ...)

Returns the value of a field specified or a returns a Bedrock array of
the set of fields requested.  This behavior is consistent with the how
a Bedrock hash returns values.

=cut

sub get { 
  my $self = shift;
  
  if ( @_ > 1) {
    return Bedrock::Array->new(map { $self->_get($_) } @_);
  }
  else {
    return $self->_get(shift);
  }
}

# - Default getter method checks to see whether there is method override specified
#   in tagx.xml
sub _get {
  my ($self, $key) = @_;

  my $getters;

  if ( $self->get_table_config ) {
    $getters = $self->get_table_config->{$self->get_table_name}->{get};
  }

  return $self->{$key} unless $getters && $getters->{$key};

  my $method= $getters->{$key};

  if ( $method ) {
    if ( $self->can( $method ) ) {
      return $self->can($method)->($self, $key);
    }
    else {
      die "You've specified a field formatter, but there is no method \'$method\'";
    }
  }
}

sub _set {
  my $self = shift;
  my $key;
  my $value;

  my $setters = $self->get_table_config->{$self->get_table_name}->{set};

  while (@_) {
    $key = shift;
    $value = shift;

    my $type = $self->get_field_type($key);

    die "field $key does not exist in table\n"
      unless defined $type;

    if ( $type =~/(date|time)/ ) {
      $value = undef
	unless $value;
    }

    if (my $method = $setters->{$key}) {
	if ($self->can($method)) {
	  $self->{$key} = $self->can($method)->($self, $key, $value);
	}
	else {
	  die "You've specified a field formatter, but there is no method \'$method\'";
	}
    }
    elsif ( $type eq 'date') {
      if ($value && $value =~/\d{1,2}\/\d{1,2}\/\d{4}/) {
	$value = sprintf("%04d-%02d-%02d", (split "/", $value)[2, 0, 1]);
      }
      elsif ($value && $value =~/\d{1,2}\/\d{1,2}\/\d{2}/) {
	my @date = split "/", $value;
	$date[2] += 2000 if $date[2] < 20;
	    $date[2] += 1900 if $date[2] > 20;
	$value = sprintf("%04d-%02d-%02d", @date[(2, 0, 1)]);
      }
      $self->{$key} = $value;
    }
    elsif ( $type =~/set/) {
      if (ref($value)) {
	$self->{$key} = join(",",@$value);
	}
      else {
	$self->{$key} = $value;
      }
    }
    else {
      $self->{$key} = $value;
    }
  }
}

=pod

=head2 set

  set(field name, value, ...)

Sets the field name(s) to the specified value(s).

  set($input)

Calling C<set> with the C<$input> object as the parameter (or in
general a hash) will result in the field names for your table being
set from the hash.  That is to say...

  <null $player.set($input)>

is equivalent too...

   <foreach keys $input>
     <null $player.set($_, $input.get($_))>
   </foreach>

or more correctly...

  <foreach $player.fields()>
     <if $input --exists $_>
       <null $player.set($_, $input.get($_))>
     </if>
  </foreach>

You should be aware that the C<save()> method will not update fields
that are not in your object.  So to prevent updating all fields, you
could delete elements of the object thusly.

  <null $customer.delete('name')>

I<Note: HTML checkboxes that are NOT checked, will not manifest
themselves as elements in your C<$input> object.  This is a limitation
of the way the browser encodes these fields.  This could be
problematic since this method now does not know if you want to set the
field to null or if you want to skip updating that field.>

I<In this case, the C<set()> method has chosen to assume you want to
update the field and arbritrarily decides to assume that if the
checkbox field is missing from the hash reference, it is because it
was B<unchecked>.  If should explicitly carry along a value then for
checkbox fields.>

Additionally, the C<set()> method will do some basic manipulation of
input data in order to support MySQL date types.  If your input looks
like this:

  mm/dd/yyyy

...the method will convert the date to this:

  yyyy-mm-dd

...before attempting to save the data to a MySQL table.

=cut

sub set {
  my $self = shift;

  # - if there is only one argument to set then assume
  #   the argument is an object (typicaly $input) and we're 
  #   setting the field values from that object...
  if (@_ == 1) {
    my $ref = shift;
    die "use of set() with one argument requires a hash reference\n"
      unless ref($ref) && reftype($ref) eq 'HASH';

    foreach my $f ( $self->get_fields() ) {
      if (exists $ref->{$f}) {
	$self->_set($f, $ref->{$f});
      }
      # - drudge! if the field type is a 'tinyint', i.e. boolean, then this was 
      #   rendered as a checkbox.  Unfortunately, an HTML checkbox that is not checked
      #   does not manifest itself in the QUERY_STRING.  Therefore, we're going out a bit 
      #   on a limb here, but if you've asked this method to use an object to set the 
      #   field values, then most likely this is the $input object AND we'll attempt to 
      #   handle the checkbox problem for you...so if the field value is NOT in the input
      #   object AND the field type is tinyint...set the value to '0'
      elsif ($self->get_field_type($f) eq 'tinyint') {
	$self->_set($f, 0);
      }
    }
  }
  else {
    $self->_set(@_);
  }
}

=pod

=head2 get_field_type

 get_field_type(field)

Returns the fully articulated type of the field (int, varchar, enum,
set, etc) as manifested in a C<describe table> command.

=cut

sub get_field_type { $_[0]->{_table_dir}->{$_[1]}->{Type} };

# dumps private/public keys separately (debugging)

=pod

=head2 dumper

 dumper()

Return a two-element array of public/private information stored by the
class.  Typically used for debugging.

 [0] => Bedrock hash representing the public key/value pairs (column values)
 [1] => Bedrock hash of private key/value pairs

=cut

sub dumper {
  my $self = shift;
 
  my @private;
  my @public;

  foreach (CORE::keys %{$self}) {
    push @private, $_ if $_=~/^_/;
    push @public, $_ unless $_=~/^_/;
  }
  
  my $public_values = Bedrock::Hash->new;
  my $private_values = Bedrock::Hash->new;

  @{$public_values}{@public} = @{$self}{@public};
  @{$private_values}{@private} = @{$self}{@private};
 
  return Bedrock::Array->new($public_values, $private_values);
}


=pod

=head2 save

 save( [$input] )

This method will C<update> a record or C<insert> a new record into the
database.  If the C<id> field is null or "0" it will assume a new
record is to be added to the table, otherwise the record with the
corresponding C<id> will be updated.

The return value of the method is the value of the C<id> field.

You can optionally pass a hash which contains the key/value pairs for
columns of the record to set.  Only keys that correspond to valid
columns will be set.

  <null --define-var="foo" $factory.foo($input.id)>

  <if $input.action --eq "save">
    <null $foo.save($input)>
  </if>

I<Note that only the fields corresponding to the columns that exist in
the object are updated if the record exists. For new records, all
columns are inserted regardless of whether or not you have explicitly
provided a value for that column!  In other words, for UPDATES ONLY,
if you want to avoid updating a column, delete the member from the
object.>

  <null $foo.delete('bar')>

I<If you want to only insert those columns that you have explicitly
set and therefore let your table defaults take care of the rest of the
columns, set 'upsert' mode first.

 <null $foo.set_upsert_mode(1)>
 <null $foo.save()>

=cut

sub save {
  my $self = shift;
  my $input = shift;
  
  if ( ref($input) && reftype($input) eq 'HASH' ) {
    foreach ( $self->get_fields ) {
      $self->set($_, $input->{$_} )
	if exists $input->{$_};
    }
  }

  if ( $self->{id} ) {
    $self->_update;
  }
  else {
    if ( $self->get_upsert_mode ) {
      $self->_insert_some;
    }
    else {
      $self->_insert_all;
    }
  }

  my $table_name = $self->get_table_name;

  # update the record from the database
  my $ref = $self->select("select * from $table_name where id = ?", $self->{id});

  foreach (CORE::keys %$ref) {
    $self->set($_, $ref->{$_});
  }

  return $self->{id};
}

=pod

=head2 set_upsert_mode

=head2 get_upsert_mode

Sets the mode for inserts.  If I<upsert_mode> is set to 0, then the
C<save()> method attempts to save all columns (columns that are not
set are assumed to be null).  If I<upsert_mode> is set to 1, then
C<save()> on new columns acts like an update, only inserting columns
that have been explicitly set.  They can be set to null and will be
updated if set to undef.

Assuming a table named 'foo' has columns 'biz', 'baz', 'buz';

 create table foo (
   id  int          auto_increment primary key,
   biz varchar(10)  not null,
   baz varchar(10)  null,
   buz varchar(10)  not null default 'buzzzz'
 )

Example: Insert a new record, setting only the 'biz' column.

 my $record = new MyApp::Foo($dbi);
 $record->set_upsert_mode(1);
 $record->set('biz');
 $record->save();

Note that colum 'buz' is defined as 'not null' but has a default.  In
this case since we only insert column 'biz', the column will look this
after insertion.

Example: Insert a new record, setting all columns ('baz', 'buz', will be set to null)

 my $record = new MyApp::Foo($dbi);
 $record->set('biz');
 $record->save();

Note this will produce a NOT NULL exception on column 'buz' since we
attempt to insert all column and no value is given for 'buz'.

=cut

sub set_upsert_mode { goto &_upsert_mode; }
sub get_upsert_mode { goto &_upsert_mode; }

sub _upsert_mode {
  my $self = shift;

  if ( @_ ) {
    $self->{_upsert_mode} = shift;
  }
  
  return $self->{_upsert_mode};
}

sub _insert {
  my $self = shift;
  my $some_or_all = shift;

  $self->_format_fields_for_insert;

  my $query = "insert into %s (%s) values (%s)";
  $self->{id} = 0;

  my @fields = ($self->get_fields());

  if ( $some_or_all eq 'some' ) {
    @fields = map { exists $self->{$_} ? $_ : (); } @fields;
  }

  $query = sprintf($query,
                   $self->get_table_name,
                   join(",", @fields),
                   join(",", split "", "?" x scalar(@fields))
                  );

  $self->Do($query, @{$self}{@fields});

  $self->{id} = $self->dbi->{mysql_insertid};
}

sub _insert_some { push @_, 'some'; goto &_insert; }
sub _insert_all  { push @_, 'all'; goto &_insert; }

sub _update {
  my $self = shift;

  $self->_format_fields_for_insert;

  my @fields = grep { !/^id$/ } ($self->get_fields());
  @fields = map { exists $self->{$_} ? $_ : (); } @fields;

  my $query = sprintf("update %s set %s where id = ?",
		      $self->get_table_name,
		      join(",", map { "$_ = ?" } @fields)
      );

  $self->Do($query, @{$self}{@fields}, $self->{'id'});

  return $self->{rows};
}

=pod

=head2 set_field

 set_field( field-name, value )

Formats a field before storing it to the database.  This method is
only called if I<format mode> is selected for the given field.

 <null $customer.set_format_mode('date_entered', 1)>

 <null $customer.save()>

C<BLM::IndexedTableHandler> has built-in formatters for field whose
names contain the words date, time or phone and whose types are
date/datetime, timestamp, char or varchar.

If the field type is B<date>, B<datetime>, B<timestamp> and the column
name contains the words date or time, AND format mode is selected,
then the field is formatted appropriately before being inserted into
the database.

If the field type is B<char> or B<varchar> and the column name
contains the word B<phone> the field is formatted as a phone number
(Either xxx-yyyy or (zzz) xxx-yyyy).

If you donE<039>t like this behavior or wish to apply other transformations
of the data prior to the data being written to the database, you can
override this method.

=cut

sub set_field {
  my $self = shift;
  my ($field, $value) = @_;

  return if $self->get_display_only( $field );

  my $type = $self->get_field_type( $field );
  $value =~s/^\s*(.*?)\s*/$1/;

  for ( $field ) {

    /phone/ && $type=~/char/ && do {
      
      if ( $value ) {
	$self->{$field} = $self->set_phone_field( $field, $value );
	die "invalid phone format: $value\n"
	  unless $self->{$field};
      }
      last;
    };
      
# rules of engagement:
# - if the date is of the form mm/dd/yy[yy] then we 
#   we need to reformat the field to yyyy-mm-dd in order
#   to insert this successfully into a MySQL database date field
#   * if the year portion is yy (2-digit), we'll assume it is in this
#     century if the value is < 20, i.e. 08 = 2008
#   * if the year portion is > 20 and < 100 then we will assume
#     the year is in the 20th century, i.e. 1900+yy
# - if the date is of the form yyyy-mm-dd then we will leave it alone
# - if the field is a timestamp and there is a date, but no time...
#   * if the date is the current date, we will add the current time
#   * if the date is not today, then the time added will bee 00:00:00
# - if the field is null, let it be
# - if the field is not of a recognized format, let it be


    /(date|time)/ && $type =~/(date|datetime|timestamp)/ && do {

      my $date;
      my ($mm, $dd, $year);
      
      if ($value =~/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/ ) {
	($mm, $dd, $year) = ($1,$2,$3);
	if ($year < 20) {
	  $year += 2000;
	}
	elsif ($year < 100) {
	  $year += 1900;
	}
	$date = sprintf("%04d-%02d-%02d", $year, $1, $2);
      }
      elsif ($value =~/^\s*(\d{4}-\d{2}-\d{2})/) {
	$date = $1;
      }
      else {
	$date = $value;
      }

      if ( $type =~/(timestamp|datetime)/) {
	if ($value =~/(\d{1,2}):(\d{1,2})(:\d{1,2})*\s*(AM|PM)*$/i) {
	  my ($hh, $mi, $sec, $ampm) = ($1, $2, $3, $4);
	  $sec =~s/://;

	  $date .= sprintf(" %02d:%02d:%02d", ((uc($ampm) eq "PM") ? $hh + 12 : $hh), $mi, $sec);
	}
	else {
	  my ($cday, $cmon, $cyear) = (localtime)[(3,4,5)];
	  if ($cday == $dd && $cmon == $mm-1 && $year == 1900+$cyear) {
	    $date .= sprintf(" %02d:%02d:%02d", (localtime)[(2,1,0)]);
	  }
	  else {
	    $date .= " 00:00:00";
	  }
	}
      }

      $self->{$field} = $date;
      last;
    };
    
    $self->{$field} = $value;
  }
}

sub _format_fields_for_insert {
  my $self = shift;

  my $dir = $self->get_table_dir;

  foreach my $field ( $self->get_fields() ) {
    if ( $self->get_format_mode( $field ) ) {
      $self->set_field( $field, $self->{$field} )
	if exists $self->{$field};
    }
  }
}


sub _find {
  my $self = shift;
  
  my $sql = sprintf("select id from %s ", $self->{_table});

  my $limit = " limit " . $self->max_rows
    if $self->max_rows;

  if (@_) {
    $sql .= "where ";
  }
  
  my @args = ();
  my @where_clause;
  my @fields = $self->get_fields;

  while ( @_ ) {
    my $exact_flag = shift;
    my $field = shift;
    die "$self: invalid column name: [$field]\n"
      unless grep { /$field/ } @fields;

    my $value = shift;
    
    push @where_clause, sprintf(" %s %s ?", $field,  $exact_flag ? "=" : "like");
    push @args, $exact_flag ? $value : $value."%";
  }
  
  if ( @where_clause ) {
    $sql .= join(" and ", @where_clause);
  }
  
  my @list;
 
  my $ref;

  $sql .= $limit if defined $limit;

  eval {
    $ref = $self->select_list($sql, @args);
  };

  die "Could not execute query:\n$sql\n$@"
    if $@;

  my $idx = 0;

  if ( @$ref ) {
    foreach ( @{$ref} ) {
      my $obj = $self->new($self->dbi, $_->{id}, $self->get_config, $self->get_table_name);
      $obj->max_rows( $self->max_rows );
      $obj->{idx} = ++$idx;
      push @list, $obj;
    }

    return new BLM::IndexedTableHandler::RecordSet( @list );
  }
  else {
    return new BLM::IndexedTableHandler::RecordSet;
  }
}

# - an intelligent 'find'
sub key_fields {
  my $self = shift;
  my @fields = $self->get_fields();
  
  my $dir = $self->get_table_dir;
  my @keys;
  
  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'UNI';
  }

  foreach (@fields) {
    push @keys, $_ if $dir->{$_}->{Key} eq 'MUL';
  }
    
  return Bedrock::Array->new(@keys);
}


=pod

=head2 max_id

 max_id()

Returns the highest value for the id column in the table.

=cut

sub max_id {
  my $self = shift;
  
  return $self->select("select max(id) id from " . $self->get_table_name)->{id};
}

sub set_search_field {
  my $self = shift;
  my ($exact_flag, $field) = @_;

  $self->{_search_fields} = [] unless $self->{_search_fields};

  push @{$self->{_search_fields}}, $exact_flag, $field;
}

sub set_key_fields {
  my $self = shift;

  my @unique;
  my @mul;

  my $dir = $self->get_table_dir;
  my %fields;

  foreach (CORE::keys %{$dir}) {
    $fields{$dir->{$_}->{idx}} = $_;
    push @unique, $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'UNI';
    push @mul,  $dir->{$_}->{idx} if $dir->{$_}->{Key} eq 'MUL';
  }

  foreach (sort @unique) {
    $self->set_search_field(0, $fields{$_});
  }

  foreach (sort @mul) {
    $self->set_search_field(1, $fields{$_});
  }
}

=pod

=head2 select

 select([query, args]);

Returns an array of hashes containing the query results.

 select()

Returns a C<BLM::IndexedTableHandler::RecordSet> containing all
records in the table.

See also C<BLM::DBHandler>

=cut

sub select {
  my $self = shift;

  unless ( @_ ) {
    BLM::IndexedTableHandler::RecordSet->new($self->select_list("select * from " . $self->get_table_name));
  }
  else {
    $self->SUPER::select(@_);
  }
}

=head2 search

  search($input, [exact-flag]) 

This is essentially the same as C<find> except it attempts to
intelligently figure out what you want to search by looking at the
fields in the object you pass and matching these up with the potential
indexes in the table.

Suppose you have a form that represents the table and each field in
the form corresponds to a field in the database. Potentially you could
search by any of the fields in the database using the C<find> method.

For example:

  <if $input.lname>
    <null --define-var="foo_list" $foo.find('lname', $input.lname)>
  <elsif $input.fname>
    <null --define-var="foo_list" $foo.find('fname', $input.fname)>
  <elsif $input.email>
    <null --define-var ="foo" $foo.find_unique('email', $input.email)>   
  </if>

This begs the question of what to do when multiple fields are
populated and what order should the search be done in?

C<search> tries to guess all of this for you by looking at the indexes
you have created for the table and the order you have defined the
fields.

The search will proceed by looking at C<UNIQUE> index fields first
then fields indexed as C<MUL> (i.e. the index allows duplicate keys).
Within each index it will use the order in which the fields have been
defined in the table to see if the field is defined in the form.  If
it is, then it will use that field as the search key, otherwise it
will go to the next index field.  If there are no index fields it will
simply follow the order of the fields as defined in the table.

Give the table F<foo> defined below:

 +-----------+-------------------------------------+------+-----+---------+----------------+
 | Field     | Type                                | Null | Key | Default | Extra          |
 +-----------+-------------------------------------+------+-----+---------+----------------+
 | id        | int(11)                             | NO   | PRI | NULL    | auto_increment |
 | lname     | varchar(32)                         | YES  | MUL | NULL    |                |
 | fname     | varchar(32)                         | YES  |     | NULL    |                |
 | email     | varchar(64)                         | YES  | UNI | NULL    |                |
 | comments  | text                                | YES  |     | NULL    |                |
 | hat_size  | char(1)                             | YES  |     | NULL    |                |
 | pant_size | enum('S','M','L','XL','XXL','XXXL') | YES  |     | NULL    |                |
 | active    | tinyint(1)                          | YES  |     | NULL    |                |
 +-----------+-------------------------------------+------+-----+---------+----------------+


The statement:

 <null --define-var="foo_list" $foo.search($input)>

...would look to see if C<$input.email> had a value first, if so it
would conduct a search equivalent to:

 <null --define-var="foo_list" $foo.find('email', $input.email)>

if C<$input.email> was not defined, it would then look at
C<$inpt.lname> and if that were defined would conduct a search
equivalent to:

 <null --define-var="foo_list" $foo.find('lname', $input.lname)>

C<search> would then proceed similarly through the non-indexed fields
(C<fname>, C<comments>, C<hat_size>, C<pant_size>, and C<active>).

=cut

sub search {
    my $self = shift;
    my $input = shift;
    my $exact_flag = shift || 0;

    $self->set($input);
    $self->set_key_fields() unless $self->{_search_fields};
    
    my @search_args;
    
    if ($self->{_search_fields} && @{$self->{_search_fields}}) {
      my @search_fields = @{$self->{_search_fields}};
      while (@search_fields) {
	my $exact_flag = shift @search_fields;
	my $field_name = shift @search_fields;
	
	if ($self->{$field_name}) {
	  push @search_args, $exact_flag, $field_name, $input->{$field_name};
	}
      }
    }
    
    # still uncomfortable with assuming certain wildcard/non-wildcard searching
    unless (@search_args) {
      foreach ( $self->get_fields() ) {
	if ( $input->{$_} ) {
	  push @search_args, $exact_flag, $_, $input->{$_};
	}
      }
    }

    return $self->_find(@search_args);
}

=pod

=head2 find

  find( id )

Returns a C<BLM::IndexedTableHandler> object representing the row in
the table with an C<id> equal to the specified id.

  find ( field, value )

Returns an array of C<BLM::IndexedTableHandler> objects that B<start with> the 
value passed.

  find()

Returns an array of C<BLM::IndexedTableHandler> objects.  The number
of elements in the array is controlled by the current C<max_rows>
setting.  For all rows, set C<max_rows> to 0.

  find( match-flag, field, value, ...)

Returns an array of C<BLM::IndexedTableHandler> objects that match the
fields and values passed.  Each C<match-flag> is either 0,
indicating B<non-exact match> (starts with) or 1, indicating B<exact match>.

=over 5

=item id

MySQL id of the row to return.

=item field

Name of a column in a MySQL table

=item value

Value of the column specifed in C<field> to search for

=back

=head3 Example - Return all rows.

  <null $player.max_rows()>
  <null --define-var="players" $player.find()>

Returns all rows in the table.  Typically this is used for relatively
small tables.

Use the C<max_rows()> method to control the number of row to return.

  <null $player.max_rows(100)>

For an unlimited number...

  <null $player.max_rows()>   

=head3 Example - Return a specific record based on the primary key

 <null --define-var="player" $player.find($input.id)>

=head3 Example - Return a list by searching a field.

 <null --define-var="players" $player.find('fname', 'Jo')>

Would return an array of player objects where the field F<fname> is like Jo%

I<Note:> This method will always return an array even if there is only 1 row that matches
the criteria.

=head3 Example - Return rows based on matching more than 1 field.

 <null --define-var="players" $player.find(1, 'position', 1, 0, 'lname', 'R')>

Would return all of the records where the C<position> column was
B<equal> to 1 and the last name of the player started with 'R'.

=cut

sub find {
  my $self = shift;
  
  # id
  if (@_ == 1) {
    die "id must be integer\n"
      unless $_[0] =~/^\d+$/ && $_[0];

    return $self->new($self->dbi, $_[0]);
  }
  # like
  elsif ( @_ == 2) {
    return $self->_find(0, @_);
  }
  # match-flag, column, value
  elsif ( ! (@_ % 3) ) {
    return $self->_find( @_ );
  }
  # ?
  elsif ( @_ ) {
    die "invalid number of arguments\n";
  }
  # all rows
  else {
    return $self->_find;
  }
}

=pod

=head2 find_unique

  find_unique(field, value, ...)

Returns a C<BLM::IndexedTableHandler> reference to a
C<BLM::IndexedTableHandler> object representing the row where the
specified column values match exactly.

Note that this method does not guarantee that there is only 1 row that
matches that criteria, however it will always return at most 1 row.

Returns C<undef> if no rows match this criteria.

  <null --define-var="pujols" $player.find_unique('lname', 'Pujols')>

=cut

sub find_unique {
  my $self = shift;
  my @args;

  while (@_) {
    push @args, (1, shift, shift);
  }

  my $ref = $self->_find(@args);

  return $ref ? $ref->[0] : undef;
}


=pod

=head2 fields

 fields()
 columns()

Returns a Bedrock array containg the column names. C<fields()> and
C<columns()> are synonymous.

=cut

sub columns { goto &fields; };
sub fields  { Bedrock::Array->new( shift->get_fields() ); }

=pod

=head2 get_fields

Returns a list (not a reference) of field (column) names.  If you want
an array reference, call the poorly named C<get_field_list()>.

I<Note when invoked from a Bedrock page, Bedrock will always promotes
lists to C<Bedrock::Array> objects.>

 <null:fields $obj.get_fields()>

 my @list = $obj->get_fields();
 my $list = $obj->get_field_list();

=cut

sub get_field_list { shift->{_field_list} };
sub get_fields     { @{shift->get_field_list()} };

=pod

=head2 asref

 asref()
 asref( key, key, ... )

Returns a hash object containing just the values of the columns of the
table.  This is not a particular useful object as it is not endowed
with the magic of the C<BLM::IndexedTableHandler> class, however some
may find it more satisfying than seeing all of the internal guts of
the classE<039> object hierarchy.

If the C<key> argument is provided, the returned hash will contain
only the keys specified.  C<key> can be a scalar or an array
reference.

 <null:record $ith.asref( $ith.get_field_list(), 'my_extra_key') >

=cut

sub asref {
  my $self = shift;
  
  my $ref = {};
  my @cols;

  if ( @_ ) {
    push @cols,  map { (ref $_ ) ? @{$_} : $_ } @_;
  }
  else {
    @cols = $self->get_fields();
  }
    
  @{$ref}{@cols} = @{$self}{@cols};
  
  return bless $ref, 'Bedrock::Hash';
}

sub as_ref { goto &asref; }

sub get_formatted_field_length {
  my $self = shift;
  my $field = shift;

  my $type = $self->get_field_type( $field );

  for ( $field ) {
    /phone/ && $type =~/char/ && do {
      return 14;
    };

    /(date|time)/ && $type =~/time/ && do {
      return 20;
    };

    /date/ && $type =~/date/ && do {
      return 10;
    };

    $type =~/\((\d+)\,?.*\)/ && return $1;

    $type eq 'boolean' && return 1;
  }

  return undef;
}



=pod 

=head2 get_field_length

 get_field_length(field-name)

Returns the length of a field.

=cut

sub get_field_length {
  my ($self, $field_name) = @_;
  
  my $type = $self->get_field_type( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    return $self->get_formatted_field_length( $field_name );
  }
  elsif ($type =~/\((\d+)\,?.*\)/) {
    return $1;
  }
  elsif ( $type eq 'date' ) {
    return 10;
  }
  elsif ( $type eq 'datetime' ) {
    return 20;  # 12/45/78 01:34:67 90
  }
  elsif ( $type eq 'timestamp' ) {
    return 20;
  }
  elsif ( $type eq 'boolean' ) {
    return 1;
  }

  return undef;
}

sub _get_options {
  my $self = shift;
  my ($list_type, $field_type) = @_;

  # 1. counties:select
  # 2. counties
  # 3. Atlantic,Bergen,Burlington,...
  # 4. [ { id => 0, item => 'foo'} ... ]
  # 5. { type => 'select',
  #      list => [ { id => 0, item => 'foo'} ... ]
  #     }   

  my $options = {};

  if ( ref($list_type) && reftype($list_type) eq 'HASH') {
    $options = $list_type;
  }
  elsif (ref($list_type) && reftype($list_type) eq 'ARRAY') {
    $options->{list} = [map { {id => $_, item => $_} } @{$list_type}];
  }
  else {
 
    my ($table_name, $type) = split ":", $list_type;
    
    if ( $table_name ) {
      if ( $table_name =~/\,/ ) {
	my @list_items = split ",", $table_name;
	$options->{list} = [map { {id => $_, item => $_}} split ",", $table_name];
      }
      else {
	$options->{list} = $self->select_list(sprintf("select * from %s order by id", $table_name));
      }
    
    }
    else {
      $field_type =~/(enum|set)(\(.*?\))/;
      
      $options->{list} = [map { {id => $_, item => $_} } eval $2];
      
      if ($field_type =~/enum/  &&  @{$options->{list}} > 4) {
	unshift @{$options->{list}}, {id => undef, item => "None"};
      }
    }
  }

  $options->{type} = $options->{type} || (@{$options->{list}} > 4) ? 'select' : 'radio',

  return $options;
}

=pod

=head2 get_enum_values

 get_enum_values( column-name )

Return an array of possible values for a C<set> or C<enum> field type.

Given a table with an enum column 'doc_type':

  +----------+-------------------+------+-----+---------+----------------+
  | Field    | Type              | Null | Key | Default | Extra          |
  +----------+-------------------+------+-----+---------+----------------+
  | id       | int(11)           | NO   | PRI | NULL    | auto_increment |
  | doc_type | enum('a','b','c') | YES  |     | NULL    |                |
  +----------+-------------------+------+-----+---------+----------------+


  <null:list $document.get_enum_values('doc_type')>
  <trace --output $list>

  [
  [0] .. (a)
  [1] .. (b)
  [2] .. (c)
  ]

=cut

sub get_enum_values {
  my $self = shift;
  my $field = shift;

  my $type = $self->get_field_type($field);
  
  die "usage: get_enum_value( column-name )\n" 
    unless $type;

  my $list = new Bedrock::Array;

  if ( $type =~/(enum|set)(\(.*?\))/) { 
    push @$list, eval $2;
  }
  else {
    die "column: [$field] is not an 'enum' or 'set' field type\n";
  }
  
  return $list;
}

sub create_date_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $length = $self->get_field_length( $field_name );
  
  my $value = $self->get_formatted_field( $field_name );
  my $size = length($value) > $length ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );
  
  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
                              maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}});
  
}

sub create_char_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $_, 
			      value     => $value, 
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     %{$attributes->{input}})
}


sub create_select_field {
    my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
    my $value;
    
    if ($self->get_field_type($field_name) =~/set/) {
      $value = [split ",", $self->{$field_name}];
    }
    else {
      $value = $self->{$field_name};
    }
    
  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

    return create_select_list($field_name, $value, $attributes, $options->{list});
  }

sub create_radio_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;

  $attributes->{disabled} = undef
    if $self->get_display_only( $field_name );

  return create_radio_buttons($field_name,  $self->{$field_name}, $attributes, $options->{list});
#                             ^ column-name ^ current-value       ^ hash       ^ overrides
}

sub get_formatted_field {
  my $self = shift;
  my $field_name = shift;

  my $value = $self->get( $field_name );

  if ( $self->get_format_mode( $field_name ) ) {
    $value = $self->format_field( $field_name, $value );
  }

  return $value;
}

sub format_field {
  my $self = shift;
  my ($field_name, $value) = @_;

  my $type = $self->get_field_type ( $field_name );
  
  for ( $field_name ) {
    /date/ && $type =~/date/ && do {
      $value = $self->get_date_field( $field_name );
      last;
    };
    
    /phone/ && $type =~/char/ && do {
      $value = $self->get_phone_field( $field_name );
      last;
    };
  }

  return $value;
}

sub create_varchar_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $value = $self->get_formatted_field( $field_name );

  my $length = $self->get_field_length($field_name);

  my $size = ( $length < length($value) ) ? length($value) : $length;
 
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      =>'text', 
			      name      => $field_name, 
                              value     => $value,
                              maxlength => $length,
			      size      => $size
			     ),
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}


sub create_tinyint_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  return $self->create_checkbox_field($field_name, $attributes, $labels, $lists);
  
  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type  =>"checkbox", 
			      name  =>$field_name, 
			      value => 1
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : (), 
			     $self->{$field_name} ? ("checked" => undef) : ());
}

sub create_checkbox_field {
  my ($self, $field_name, $attributes, $labels, $lists, $options) = @_;
  
  $options = $options || { list => [  {id=>1, item=>""} ] };
  
  my $value;

  if ($self->get_field_type($field_name) =~/set/) {
    $value = [split ",", $self->{$field_name}];
  } else {
    $value = $self->{$field_name};
  }

  my @values = ref($value) ? @$value : ($value);

  my @items = map {$_->{item}} @{$options->{list}};

  my $html;

  foreach my $ref (@{$options->{list}}) {
    $html .= sprintf("%s&nbsp;<b>%s</b>&nbsp;&nbsp;&nbsp;",
		     create_html_element('input',
					 (type=>"checkbox", name=>$field_name, value=> $ref->{id}), 
					 $attributes ? %{$attributes->{input}} : (), 
					 scalar(grep { $ref->{id} eq $_ } @values) ? ("checked" => undef) : ()
					),
		     $ref->{item});
  }

  return $html;
}


sub create_int_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ( $size > length($value) )  ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element('input', 
			     (
			      type      => 'text', 
			      name      => $field_name, 
			      value     => $value,
			      maxlength => $size,
			      size      => $size
			     ), 
			     $disabled ? (disabled => undef) : (),
			     $attributes ? %{$attributes->{input}} : ());
}

sub create_timestamp_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;

  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = length($value) || $size;

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      => 'text', 
			       name      => $field_name, 
			       value     => $value,
			       maxlength => $size,
			       size      => $size,
			      ),
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_decimal_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $size = $self->get_field_length($field_name);
  
  my $value = $self->get_formatted_field( $field_name );
  $size = ($size > length($value)) ? $size : length($value);

  my $disabled = $self->get_display_only( $field_name );

  return create_html_element( 'input', 
			      (
			       type      =>'text', 
			       name      => $field_name, 
                               value     => $self->{$field_name}, 
			       maxlength => $size,
			       size      => $size
			      ), 
			      $disabled ? (disabled => undef) : (),
			      $attributes ? %{$attributes->{input}} : ()
			    );
}

sub create_text_field {
  my ($self, $field_name, $attributes, $labels, $lists) = @_;
  
  my $disabled = $self->get_display_only( $field_name );
  return sprintf("%s%s</textarea>", 
		 create_html_element( 'textarea', 
				      (
				       name => $field_name, 
				       rows => 5, 
				       cols => 40
				      ), 
				      $disabled ? (disabled => undef) : (),
				      $attributes ? %{$attributes->{textarea}} : ()),
		 $self->{$_}
		);
}

=pod

=head2 html_form_header

 html_form_header(attributes)

=cut

sub html_form_header {
  my $self = shift;
  my $attributes = shift || {};
  
  return create_html_element( 'form', 
			      ( 
			       name   => $self->{_table}, 
			       method => "post", 
			       action => $ENV{PATH_INFO}
			      ), 
			      %$attributes
			    );
}

=pod

=head2 html_form_footer

 html_form_footer(attributes)

Creates a row of buttons (I<save>, I<delete>, I<find>, I<new>) that
submit the form and set the C<action> hidden element.

=cut

sub html_form_footer {
  my $self = shift;
  my $attributes = shift || $self->get_attributes;
  my %hidden = @_;

  my @html;
  my $form_name = $self->{_table};
  
  my $form_element = sprintf("document.%s", $form_name);
  
  my $onclick = qq{%s%s.action.value='%s'; %s.submit();};
  my @buttons = ("find", "save", "delete", "new");

  foreach (@buttons) {
    $attributes->{$_} = {} unless exists $attributes->{$_};
  }
  
  $attributes->{delete}->{disabled} = undef unless $self->{id};
  $attributes->{new}->{disabled} = undef unless $self->{id};
  
  foreach ("save","delete","find", "new") {
    push @html, create_html_element( 'input', 
				     (
				      type => "Button", 
				      value => ucfirst($_), 
				      onClick => sprintf( $onclick, 
							  $_ eq "new" ? qq{$form_element.id.value='0';}: "",
							  $form_element, $_, $form_element
							)
				     ), 
				     %{$attributes->{$_}})
  }
  
  push @html, create_html_element('input', (type => "hidden", name=>"action", value=>""));
  push @html, create_html_element('input', (type => "hidden", name=>"table", value=>$self->{_table}));
  
  # additional hidden input elements you might want to carry along
  foreach (CORE::keys %hidden) {
    push @html, create_html_element('input', (type  => "hidden", 
					      name  => $_, 
					      value => $hidden{$_}
					     )
				   );
      
  }

  # add the format mode for these fields
  foreach (@{$self->{_field_list}}) {
    push @html, create_html_element('input', (type => "hidden", name=>"format_mode", value=> "$_"))
      if $self->get_format_mode( $_ );
  }

  return sprintf("%s\n%s\n", join("&nbsp;\n", @html), "</form>\n");
}

=pod

=head2 html_form_body

 html_form_body(attributes, labels, lists, exclude-fields)
 html_form_body_with_class(attributes, labels, lists, exclude-fields)

=cut

sub html_form_body_with_class {
  my $self = shift;

  my $attributes = shift || $self->get_attributes;
  my $labels = shift || $self->get_labels;
  my $lists = shift || $self->get_lists;
  my $exclude_fields = shift || [];
  
  my $class = lc $1 if ref($self) =~/::(.*)$/;
  $class =~s/_/-/;

  foreach my $name ( $self->get_fields() ) {
    my $hyphenated_name = lc $name;
    $hyphenated_name =~s/_/-/g;

    $attributes->{$name} = {} unless $attributes->{$name};
    foreach my $form_type ( qw/input select textarea/ ) {
      $attributes->{$name}->{$form_type} = { class => $class . '-' . $form_type, id => $hyphenated_name };
    }
    $attributes->{$name}->{th} = { class => "$class-label", id => $hyphenated_name . '-' . 'label' };
  }

  $self->html_form_body( $attributes, $labels, $lists, $exclude_fields );
}

sub html_form_body {
  my $self = shift;
  my $attributes = shift || $self->get_attributes;
  my $labels = shift || $self->get_labels;
  my $lists = shift || $self->get_lists;
  my $exclude_fields = shift || [];

  my $exclude_field_list = {};
  map { $exclude_field_list->{$_} = 1; } @{$exclude_fields};

  my $html = create_html_element("table", %{$attributes->{table}})."\n";
  
  foreach ( $self->get_fields() ) {
    my $field_type = $self->get_field_type($_);
    
    next if exists $exclude_field_list->{$_};

    # if no "maxlength" is given for an input field and a "size" is given, then use that as maxlength
    if ($attributes->{$_} && $attributes->{$_}->{input}->{size}) {
      $attributes->{$_}->{input}->{maxlength} = $attributes->{$_}->{input}->{size} 
	unless exists $attributes->{$_}->{input}->{maxlength};
    }
    
    # - first check to see if this is a pick list
    my $options;
    $options = $self->_get_options( $lists->{$_}, $field_type ) 
      if $lists->{$_} || $field_type =~/(enum|set)/;
 
    my $tr_attributes = $attributes->{$_}->{tr} || {};
    my $th_attributes = $attributes->{$_}->{th} || {};
    my $td_attributes = $attributes->{$_}->{td} || {};
  
    if ( $lists->{$_} ) {
      if ($options->{type} =~/(select|radio|checkbox)/) {
	my $input_element;

	if ($options->{type} eq 'select' ) {
	  $input_element = $self->create_select_field( $_, 
						       $attributes->{$_}, 
						       $labels, 
						       $lists, 
						       $options
						     );
	} elsif ($options->{type} eq 'radio') {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} elsif ($options->{type} eq 'checkbox') {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$tr_attributes}),
			 create_html_element('th', %{$th_attributes}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$td_attributes}),
			 $input_element
			);
      }
    } elsif ($field_type =~/(enum|set)/) {
      if ($options && @{$options->{list}} > 4) {
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$tr_attributes}),
			 create_html_element('th', %{$th_attributes}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$td_attributes}),
			 $self->create_select_field($_, $attributes->{$_}, $labels, $lists, $options)
			);
      } else {
	my $input_element;
	if ($field_type =~/enum/) {
	  $input_element = $self->create_radio_field($_, $attributes->{$_}, $labels, $lists, $options)
	} else {
	  $input_element = $self->create_checkbox_field($_, $attributes->{$_}, $labels, $lists, $options)
	}
	
	$html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
			 create_html_element('tr', %{$tr_attributes}),
			 create_html_element('th', %{$th_attributes}),
			 $labels->{$_} || create_label_name($_), 
			 create_html_element('td', %{$td_attributes}),
			 $input_element
			);
      }
    } elsif ($field_type =~/tinyint/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_tinyint_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($field_type =~/varchar/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_varchar_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($field_type =~/int/) {
      next if $_ =~/^id$/;
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_int_field($_, $attributes->{$_}, $labels, $lists)
		      );
      
    } elsif ($field_type =~/^char/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_char_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($field_type =~/date/) {
      
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_date_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($field_type =~/timestamp/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_timestamp_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($field_type =~/text/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_text_field($_, $attributes->{$_}, $labels, $lists)
		      );
    } elsif ($field_type =~/decimal/) {
      $html .= sprintf("%s\n%s%s</th>%s%s</td>\n</tr>\n",
		       create_html_element('tr', %{$tr_attributes}),
		       create_html_element('th', %{$th_attributes}),
		       $labels->{$_} || create_label_name($_), 
		       create_html_element('td', %{$td_attributes}),
		       $self->create_decimal_field($_, $attributes->{$_}, $labels, $lists)
		      );
    }
  }

  $html .= "</table>\n";
  $html .= create_html_element('input', (type=>"hidden", value=>$self->{id}, name=>"id"));
  
  return $html;
}

=pod

=head2 handler

  handler($input)

Method that invokes various methods of your table handler object
depending upon the value of the C<action> CGI variable.

The values of the C<action> CGI variable support are:

=over 5

=item save

Saves the field values in the C<$input> object to the MySQL table.
Supports both updates and inserts depending on whether the C<id> field
is set to 0 (insert) or a non-zero (update) value.

Returns the table handler object.

=item delete

Deletes the row in the MySQL table indicated by the value of C<id>.

Return the table handler object.

=item new

Creates a new table handler object.

Returns a new table handler object.

=item find

Performs a query against the MySQL table depending upon the fields
(CGI variables) that are set in the C<$input> object.

If 1 or more rows found after executing the query, the method will
returns either C<BLM::IndexedTableHandler::RecordSet> object.

If no rows are found after executing the query, the method will return
a table handler object.

=back

=cut


sub handler {
  my $self = shift;
  my $input = shift;

  if ( $input->{format_mode} ) {
    my @mode = ref($input->{format_mode}) ? @{$input->{format_mode}} : ($input->{format_mode});
    foreach ( @mode ) {
      $self->set_format_mode($_, 1);
    }
  }

  if ($input->{action} eq 'save') {
    $self->set($input);
    $self->save();
    return $self;
  } elsif ( $input->{action} eq 'delete' ) {
    die "no id\n"
      unless $input->{id};

    $self->delete($input->{id});
    $self->{id} = 0;
    foreach (@{$self->{_field_list}}) {
      $self->set($_, undef);
    }
    return $self;
  } elsif ($input->{action} eq 'new') {
    return $self;
  } elsif ($input->{action} eq 'find') {
    my $list = $self->search($input);
    if ($list && @$list >= 1) {
      return $list;
    } else {
      return $self;
    }
  } else {
    return $self;
  }
}

=pod

=head2 get_display_only

 get_display_only( field-name )

Returns true or false depending on whether the field is set to be a
display-only field

=cut

sub get_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  return $self->{_display_only}->{$field_name};
}


=pod

=head2 set_display_only

 set_display_only( field-name )

Set the field to be display only.  This prevents user input to this field.

=cut

sub set_display_only {
  my $self = shift;
  my $field_name = shift;

  $self->{_display_only} = {} unless $self->{_display_only};
  $self->{_display_only}->{$field_name} = 1;
}


# - Some default pseudo field type handlers

=pod

=head2 get_format_mode( field-name )

Returns a boolean value that determines if a field should be formatted
when it is show in a form field.

=cut

sub get_format_mode {
  my $self = shift;
  my $key = shift;

  $self->{_format_mode} = {} unless $self->{_format_mode};

  return $self->{_format_mode}->{$key};
}


=pod 

=head2 set_format_mode

 set_format_mode( field-name, mode )

Indicate that a field should be formatted when the value is shown in a
form field.  Before the fieldE<039>s value is output, it is passed to
the C<format_field()> method if the format mode for the field
is set to 1.  The method is responsible for returning a formatted
version of the field.

  <null $customer.set_format_mode('date_inserted', 1)>

C<BLM::IndexedTableHandler> provides formatting for C<date>,
C<datetime>, C<timestamp>, char and varchar fields whose name is has
either the word "phone" or "date" in them.

If you donE<039>t want any default behavior or you want some other behaivor
you might consider overriding the C<format_field()> method.

  package BLM::Customer;
  
  use BLM::IndexedTableHandler;
  use Bedrock::Plugin;
  
  use strict;
  use vars qw(@ISA);
  
  @ISA = qw( BLM::IndexedTableHandler Bedrock::Plugin);
  
  sub format_field {
    my $self = shift;
    my ($field, $value) = @_;
  
    for ( $field ) {
      /(firstname|lastname)/ && do {
        $value = ucfirst(lc($value));
        return $value;
      };
  
    }
  
    return $self->SUPER::format_field($field, $value);
  }
  
  1;

=cut

sub set_format_mode {
  my $self = shift;
  my ($key, $mode) = @_;

  $self->{_format_mode} = {} unless $self->{_format_mode};
  $self->{_format_mode}->{$key} = $mode;
}



# +---------------+
# | PHONE NUMBERS |
# +---------------+

=pod

=head2 set_phone_field

  set_phone_field(field, value)

Removes extraneous data from a phone number field and returns and/or
sets the column value to just the digits of the phone number.  If the
resulting length of the object is 10 or 7 then the column is set to
just the digits, otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the digits are just returned to the caller.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_phone_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value =~s/[^\d]//g;
    $value =~/^(\d{7}|\d{10})$/;
    $value = ($1 ? $1 : undef);

  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}

=pod

=head2 get_phone_field

 get_phone_field( field-name )

Returns a formatted phone number.  If the phone number length is 7 digits:

 555-1212

If the phone number legnth is 10 digits:

 (888) 555-1212 

Example:

 <var $customer.get_phone_field('work_phone')>

=cut

sub get_phone_field {
  my ($self, $key) = @_;
  
  if ($self->{$key}) {
    my $str = $self->{$key};
    
    if (length($str) == 7) {
      return sprintf("%s-%s", unpack "a3a4", $str);
    } elsif (length($str) == 10) {
      return sprintf("(%s) %s-%s", unpack "a3a3a4", $str);
    } else {
      return $self->{$key}; # I have no idea what you're up to here dude!
    }
  } else {
    return $self->{$key};
  }
}

=pod

=head2 set_date_field

 set_date_field( field-name, value )
 set_date_field( value )

Use this method to set the value of a date field.  The idea being, you
may have a user enter a date in either YYYY-MM-DD format or
MM/DD/YY[YY] formats and this method will format the date properly for
insertion into a MySQL date field.

Passing only the C<value> argument will return the formatted value.

Example:

  <null $player.set_date_field('birthday', $input.birthday)>

=cut


sub set_date_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }


  if ( $value ) {
    my @date = split /[\/-]/, $value;
    
    if (3 == scalar(@date) ) {
      if ($value =~/-/) {
	$value = sprintf("%4d-%02d-%02d", @date);
      } else {
	$date[2] += 2000 if $date[2] < 30;
	$value = sprintf("%4d-%02d-%02d", @date[(2,0,1)]);
      }
    }
  }

  $self->{$key} = $value
    if defined $key;

  return $value;
}


=pod

=head2 now

Return the current date and time YYYY-MM-DD HH24:MI:SS format.

 <var $customer.now()>

=cut

sub now {
  my $self = shift;

  return $self->select("select now() as n")->{n};
}

=pod

=head2 curdate

Return the current date in YYYY-MM-DD format.

 <var $customer.curdate()>

=cut

sub curdate {
  my $self = shift;

  return $self->select("select curdate() as d")->{d};
}

=pod

=head2 curtime

Return the current time in HH24:MI:SS format.

 <var $customer.curtime()>

=cut

sub curtime {
  my $self = shift;

  return $self->select("select curtime() as t")->{t};
}


=pod

=head2 date_format

 date_format( date, format-string )

 date_format( field-name, format-string) 

Returns the result of the MySQL DATE_FORMAT function.

 <var $obj.date_format('2011-01-01', '%a')>

 <var $obj.date_format('date_filed', '%a')>

Sat

=cut

sub date_format {
  my $self = shift;
  my ($date, $fmt, $utc) = @_;
  $date = ($date =~/^[\-0-9]+$/) ? $date : $self->{$date};

  my $hour = $utc ? -5 : 0;
 
  my $ref = $self->select("select date_format( date_add(?, INTERVAL ? HOUR), ?) date_fmt",$date, $hour, $fmt);

  return $ref->{date_fmt};
}

=pod

=head2 get_date_field

 get_date_field( field-name )

Returns a MM/DD/YYYY or MM/DD/YYYYY HH:MI:SS formatted date or
datetime value from a MySQL YYYY-MM-DD date.

Example:

 <input type="text" name="birthday" value="<var $player.get_date_field('birthday')>">

=cut

sub get_date_field {
  my ($self, $key) = @_;

  return undef unless $self->{$key} && $self->{$key} !~/0000\-00\-00/;

  my @date = split("-", $self->{$key});

  $date[3] = $1 if $date[2] =~/\d{2} (\d{2}:\d{2}:\d{2})/;

  my $fmt_date = sprintf("%02d/%02d/%04d", @date[(1,2,0)]);
  $fmt_date .= ' ' . $date[3] if $date[3] && $date[2] !~/00:00:00/;

  return $fmt_date;
}

=pod

=head2 set_email_field

 set_email_field(field, value)

Validates and returns and/or sets the column valued to an email
address. If the email is valid, then the column is set to the value,
otherwise it is set to undef.

If only the column value is passed and not the column name, then
nothing is set, the email address is just returned to the caller if valid.

Example:

  <null $customer.set_phone_number('work_phone', $input.work_phone)>
  <var $customer.set_phone_number($input.work_phone)>

=cut

sub set_email_field {
  my $self = shift;
  my $key;
  my $value;

  if ( @_ == 2) {
    ($key, $value) = @_;
  } else {
    $value = $_[0];
  }

  if ( $value ) {
    $value = $self->validate_email( $value ) ? $value : undef;
  }

  $self->{$key} = $value if @_ == 2;

  return $value;
}


=pod

=head2 validate_email

 validate_email( email )

Returns true or false depending on validity of email address.  This
doesnE<039>t mean this address is associated with a real email account,
just that it might. ;-)

=cut

sub validate_email {
  my $self = shift;
  my $email = shift;

  return $email =~/^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/;
}

=head1 CAVEATS

=head2 checkbox fields

Because checkbox fields are not manifested in the CGI C<QUERY_STRING>
when form data is submitted and the checkbox is not checked, you may
find that using a simplistic approach to updating the fields in your
object may result in checkbox fields being ignored.  For example, the
Bedrock code:

  <foreach $input.keys()>
     <null $player.set($_, $input.get($_)>
  </foreach>

would never actually update a checkbox field that was unchecked.
Therefore, as shown above the "more correct" approach to setting
the values of your object from your HTML form:

  <foreach $player.fields()>
     <null $player.set($_, $input.get($_))>
  </foreach>

...guarantees that each field in the table will be set, even if it is
set to a null value.

If you rely on the single argument version of the C<set> method youE<039>re
in luck (at least if youE<039>re database field being rendered as a
checkbox is a boolean).  Since C<html_form()> renders C<tinyint> or
C<boolean> fields as checkboxes, C<set> will make sure that any
C<tinyint> field in the record is set, regardless of whether it exists
in the C<$input> object.

=head1 AUTHOR

Rob Lauer - rlauer6@comcast.net

=head1 SEE ALSO

C<BLM::DBHandler>

=cut

1;
