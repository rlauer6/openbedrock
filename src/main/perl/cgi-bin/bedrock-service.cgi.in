#!/usr/bin/env perl

use strict;
use warnings;

use Bedrock qw(choose is_cli);
use Carp qw(croak);
use English qw(-no_match_vars);
use File::Basename qw(fileparse);
use Module::Load;

# ==============================================================================
# MAIN DISPATCH LOGIC
# ==============================================================================

# 1. Determine the Service Name from the script filename
#    e.g. "/cgi-bin/autocomplete.cgi" -> "autocomplete"

my $service_name = choose {
  return $ENV{BEDROCK_SERVICE_NAME}
    if $ENV{BEDROCK_SERVICE_NAME};

  # mod_cgi
  return $ENV{REDIRECT_BEDROCK_SERVICE_NAME}
    if $ENV{REDIRECT_BEDROCK_SERVICE_NAME};

  my ($source) = grep { !!$_ } ( @ENV{qw(SCRIPT_FILENAME SCRIPT_NAME)}, $PROGRAM_NAME );

  my ( $name, $path, $ext ) = fileparse( $source, qr/\.[^.]*$/ );

  # 2. Normalize to Perl Class Case (Kebab/Snake -> CamelCase)
  #    e.g. "autocomplete"      -> "Autocomplete"
  #    e.g. "customer-lookup"   -> "CustomerLookup"
  #    e.g. "system_status"     -> "SystemStatus"
  $name =~ s/(?:^|[-_])(.)/uc($1)/ge;

  return $name;
};

# 3. Construct the full Class Name
my $service_class = choose {
  # special case to run Bedrock::Service as a CLI script
  return 'Bedrock::Service'
    if $service_name eq 'BedrockService';

  return $service_name =~ /\ABedrock::Service/xsm ? $service_name : "Bedrock::Service::$service_name";
};

# 4. Load and Execute
eval {
  load $service_class;
  my $service = $service_class->new;

  if ( $service_class eq 'Bedrock::Service' && !is_cli() ) {
    print <<'END_OF_HTML';
Content-type: text/html
Status: 400 Bad Request


<!DOCTYPE HTML>
<html>
 <head>
   <title>Bedrock Service</title>
   <style>
    .error {
      color: red;
      font-weight: 600;
    }
   </style>
 </head>
 <body>
  <h1>Configuration Error</h1>
  <p class="error">
   It appears you are trying to run a web service but you have not defined a service name. You must either:<br/>
   <ul>
    <li>Set BEDROCK_SERVICE_NAME in the environment</li>
    <li>Create a symbolic link like `bedrock-user-lookup.cgi` to `bedrock-service.cgi`</li>
  </ul> 
  </p>
 </body>
</html>
END_OF_HTML
    exit;
  }

  return $service->handler();
};

# Log the crash to the error log before dying
croak "Failed to execute service [$service_class] from [$PROGRAM_NAME]:\n$EVAL_ERROR"
  if $EVAL_ERROR;

__END__

=pod

=head1 NAME

bedrock-service.cgi - Universal Dispatcher for Bedrock Services

=head1 SYNOPSIS

  # 1. Copy the dispatcher to your C<cgi-bin> directory
  cp $(perl -MFile::ShareDir=dist_file -e 'print dist_file("Bedrock", "bedrock-service-cgi");') \
    /var/www/cgi-bin/

  # 2. Deploy a new service via Symlink
  cd /var/www/cgi-bin
  ln -s bedrock-service.cgi autocomplete.cgi
  ln -s bedrock-service.cgi customer-lookup.cgi

  -or-

  # 3. generate an Apache configuration
  /var/www/cgi-bin/bedrock-service.cgi --service Autocompete --mod-cgi --base-uri /api
  set the environment variable BEDROCK_SERVICE_NAME

  See C<perldoc Bedrock::Service::CLI> for details regarding how to use
  F<bedrock-service.cgi> as a command line tool.

=head1 DESCRIPTION

This script acts as a "Front Controller" for Bedrock Services running
in a CGI environment. It eliminates the need to write unique wrapper
scripts for every new service you deploy.

Instead of creating a new C<.cgi> file for every service, you simply
create a symbolic link to this script. The dispatcher uses the name of
the symbolic link to determine which C<Bedrock::Service> class to load
and execute. While this is a convenient method for quickly deploying
services, you can also use F<bedrock-service.cgi> without symnlinks by
setting environment variables in your Apache configuration.

F<bedrock-service.cgi> executed as a command line tool can generate
these configurations for you.

=head1 NAMING CONVENTIONS

The dispatcher uses a strict convention to map the script filename
(the symlink) to a Perl package name. It assumes all services live
under the C<Bedrock::Service::*> namespace.

It performs the following transformations:

=over 4

=item 1. Strips the Extension

C<autocomplete.cgi> -> C<autocomplete>

=item 2. Converts Kebab-Case/Snake_Case to CamelCase

=over 4

=item * C<autocomplete> -> C<Autocomplete>

=item * C<customer-lookup> -> C<CustomerLookup>

=item * C<system_status> -> C<SystemStatus>

=back

=item 3. Prepends the Namespace

C<CustomerLookup> -> C<Bedrock::Service::CustomerLookup>

=back

=head1 EXAMPLES

  Symlink Name          | Loads Class
  ----------------------|----------------------------------
  autocomplete.cgi      | Bedrock::Service::Autocomplete
  user-session.cgi      | Bedrock::Service::UserSession
  api-v2-search.cgi     | Bedrock::Service::ApiV2Search

=head1 TROUBLESHOOTING

=head2 500 Internal Server Error

If you see a 500 error, check your server's error log. The dispatcher
traps load errors and prints them to STDERR.

Common causes:

=over 4

=item * The symlink name does not match the Perl module name (typos).

=item * The Perl module is not in C<@INC>.

=item * The Perl module has syntax errors.

=back

=head1 AUTHOR

Rob Lauer - <bigfoot@cpan.org>

=cut
