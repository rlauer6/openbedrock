#! @PERL@
# -*- perl -*-
# @configure_input@

# bedrock-create-site: copy and create artifacts needed for a Bedrock project

# Copyright (C) 2008 Signature Information Solutions, LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# This is a command line program to create the initial scaffolding for a
# Bedrock project. It's purpose is to automate the handful of necessary (but
# simple) steps; it also provides support for some optional (but common)
# setup steps (such as creating MySQL databases).
#
# See bedrock-create-site(1) for full documentation. You can run perldoc on
# this file to view the POD used to create the man page.
#
# Exits with zero (success) if we were successful in creating the entire
# project scaffolding. Exits with non-zero status if an error was
# encountered.
#
# Note that the program is designed to be idempotent; it can be invoked
# multiple times with the same arguments and it will behave as if it were
# invoked exactly once. This is useful in situations in which the program
# encounters an error (such as not being able to write a file due to
# permissions); once the reported issue has been corrected, the program may
# be re-invoked and it will pick up where it left off. You can use the -O
# (--overwrite) option to force existing files to be regenerated or
# otherwise overwritten.
#
# Usage:
#     $ bedrock-create-site [OPTION]...
#

package _PROG_BEDROCK_CREATE_SITE;

use strict;
use warnings;

# Fixup @INC so that all Perl mods needed by the prog can be found
# ___REPLACE_ME__BEGIN_BLOCK__CONFIGURED_PERL_INC___

use Carp qw( confess );

use Getopt::Long qw( GetOptions );

use File::Path qw( mkpath );
use File::Spec::Functions qw( catdir catfile );
use Hash::Util qw( lock_hash );

our $VERSION = '@VERSION@';  # filtered in at build time

my $PROG = 'bedrock-create-site';
my $BUILD_DATE = '@BUILD_DATE@';  # filtered in at build time
my $PROJECT_NAME = '@PACKAGE@';   # filtered in at build time

# Options
Getopt::Long::Configure(qw( bundling
                            bundling_override
                            no_auto_abbrev
                            no_auto_help
                            no_auto_version
                            no_getopt_compat
                            no_gnu_compat
                            no_ignore_case_always
                            no_pass_through
                            no_require_order
                            permute));

my $BE_VERBOSE = 0;
my $SHOW_HELP = 0;
my $SHOW_VERSION = 0;
my $DO_OVERWRITE_ALL = 0;



# These vars are package scoped so we can dereference them dynamically
our $DOMAIN_NAME;
our $WEBSITE_DIR;

# These vars are also package scoped for dynamic dereferencing. These are
# the fine-grained overwrite flags, mostly useful for allowing the user to
# specify exceptions to the global --overwrite option. Without fine grained
# exceptions, the user would have to specify /all/ files he wished to
# overwrite explicitly whenever he wished to prevent overwriting of just one
# or two.
our $DO_OVERWRITE_INDEX_DOT_ROC  = -1;  # dflt; 0 if explicitly disabled; 1 if enabled
our $DO_OVERWRITE_INDEX_DOT_ROCK = -1;  # dflt; 0 if explicitly disabled; 1 if enabled

# We keep a collection of all of our fine-grained overwrite opts so we can
# flip them all on if the user specifies the -O (--overwrite) global
# overwrite option. This simplifies code because only one option need be
# checked.
my %ALL_OVERWRITE_OPTS = ( DO_OVERWRITE_INDEX_DOT_ROC  => 'index.roc',
                           DO_OVERWRITE_INDEX_DOT_ROCK => 'index.rock');

# $var => { desc => str, sopt_name => str }
# Read 'sopt_name' as "short option name"
my %REQUIRED_STR_OPTS = ( DOMAIN_NAME => { sopt_name => 'd',
                                           desc => 'domain name'
                                         },
                          WEBSITE_DIR => { sopt_name => 's',
                                           desc => 'site directory'
                                         },
                        );
lock_hash %REQUIRED_STR_OPTS;

sub print_usage {
    my ($where) = @_;
    print $where <<"EOH";
Usage: $PROG [OPTIONS]
Creates the initial scaffolding for a Bedrock project.
See ${PROG}(1) for all the gory details.

Options with an asterisk (*) are required unless -h or -V is specified.

Note that the --nooverwrite-foo options represent the default behavior, but
are useful for specifying exceptions to the global --overwrite option.

Likewise, the --overwrite-foo options are useful for overwriting only a few
specific files, and not overwriting anything else (the default behavior is
to not overwrite existing files).

  -h, --help         Display this message and exit
* -d, --domain-name=NAME
                     Use NAME as the domain name
  -O, --overwrite    Overwrite any existing files
* -s, --site-dir=DIR Create the website in DIR
  -v, --verbose      Print program progress messages on stderr
  -V, --version      Print on stdout version info and exit

  --overwrite-index-dot-roc
                     Force overwriting of \$sitedir/htdocs/index.roc
  --nooverwrite-index-dot-roc
                     Do not overwrite \$sitedir/htdocs/index.roc

  --overwrite-index-dot-rock
                     Force overwriting of \$sitedir/htdocs/index.rock
  --nooverwrite-index-dot-rock
                     Do not overwrite \$sitedir/htdocs/index.rock
EOH
}

# prints program version info on stdout
sub print_version {
    print <<"EOV";
$PROG  (${PROJECT_NAME}) $VERSION
build date: ${BUILD_DATE}
Copyright (C) 2008 Signature Information Solutions, LLC

This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.
EOV
    return;
}

# Returns the function name of the calling function. Functions can use this
# as a generic way to get their own name without sprinkling clunky caller()
# invocations all over the place.
sub __func {
    # ($package, $filename, $line, $subroutine, $hasargs,
    #  $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);
    return (caller(1))[3];
}

# Checks for the existence of the user-specified site directory. If it does
# not exist, attempts to create it.
#
# @param $site_dir - (required) The directory in which the user wants his
#                    web site created.
#
# @return Does not return a meaningful value; exits with an error status on
#         error.
sub __maybe_create_site_directory_or_die {
    my ($site_dir) = @_;
    confess( __func, q{(): required '$site_dir' param not provided} )
        unless defined $site_dir;

    print STDERR "${PROG} (info): checking for the existence of site directory..."
        if $BE_VERBOSE;
    if (-d $site_dir) {
        print STDERR "found\n" if $BE_VERBOSE;
        return;
    }
    else {
        print STDERR "not found; creating\n" if $BE_VERBOSE;
        eval { mkpath( $site_dir ) };
        if ($@) {
            warn(qq{${PROG} (error): was unable to create site dir "${site_dir}": $@\n});
            exit 1;
        }
        print STDERR qq{${PROG} (info): successfully created site dir "$site_dir"\n}
            if $BE_VERBOSE;
    }
    return;
}

# Checks for the existence of all of our subdirs beneath the user-specified
# site directory. If any do not exist, attempts to create them.
#
# @param $site_dir - (required) The directory in which the user wants his
#                    web site created.
#
# @return Does not return a meaningful value; exits with an error status on
#         error.
sub __maybe_create_site_subdirs_or_die {
    my ($site_dir) = @_;
    confess( __func, q{(): required '$site_dir' param not provided} )
        unless defined $site_dir;

    # FIXME: maybe change 'config' to 'bedrock-config', or maybe even make
    #        it conf/bedrock-config

    # FIXME: move startup BLM directory out of the web document tree!

    # Most of these are obvious. The others are:
    #     config    - home to Bedrock configuration file, 'tagx.xml'
    #     logs/html - home to Bedrock page logs
    #
    # Also note that we create a symlink from:
    #     htdocs/admin/cgi-bin
    # to:
    #     cgi-bin
    my @subdirs = (qw(
                       conf
                       config
                       cgi-bin

                       cgi-bin/Perl
                       cgi-bin/Perl/BLM
                       cgi-bin/Perl/BLM/Startup

                       htdocs
                       htdocs/admin
                       htdocs/img
                       logs
                       logs/html
                       session
                    ));

    foreach my $dir (map { catdir($site_dir, $_) } @subdirs) {
        print STDERR qq{${PROG} (info): checking for the existence of dir "$dir"...}
            if $BE_VERBOSE;
        if (-d $dir) {
            print STDERR "found\n" if $BE_VERBOSE;
            next;
        }
        else {
            print STDERR "not found; creating\n" if $BE_VERBOSE;
            eval { mkpath( $dir ) };
            if ($@) {
                warn(qq{${PROG} (error): was unable to create dir "${dir}": $@\n});
                exit 1;
            }
            print STDERR qq{${PROG} (info): successfully created dir "$dir"\n}
                if $BE_VERBOSE;
        }
    }

    my $new = catdir( $site_dir, 'htdocs/admin/cgi-bin' );
    print STDERR qq{${PROG} (info): checking for the existence of dir symlink "$new"...}
        if $BE_VERBOSE;
    if (-d $new) {
# FIXME: check target of the link
        print STDERR "found\n" if $BE_VERBOSE;
        return;
    }

    print STDERR "not found; creating\n" if $BE_VERBOSE;
    eval {
        my $old = catdir( $site_dir, 'cgi-bin' );
        die qq{was unable to create symlinks from "$new" to "$old"\n}
            unless symlink($old, $new); # may throw fatal error
    };
    if ($@) {
        warn(qq{${PROG} (error): was unable to create symlink: $@\n});
        exit 1;
    }
    print STDERR qq{${PROG} (info): successfully created dir symlink "$new"\n}
        if $BE_VERBOSE;

    return;
}

# Checks for the existence of the user-specified site directory. If it does
# not exist, attempts to create it. Likewise for any subdirectories beneatch
# $site_dir that we use.
#
# @param $site_dir - (required) The directory in which the user wants his
#                    web site created.
#
# @return Does not return a meaningful value; exits with an error status on
#         error.
#
sub maybe_create_site_directory_tree_or_die {
    my ($site_dir) = @_;
    confess( __func, q{(): required '$site_dir' param not provided} )
        unless defined $site_dir;

    __maybe_create_site_directory_or_die( $site_dir );
    __maybe_create_site_subdirs_or_die( $site_dir );
}

# Worker function that always creates contents suitable for an index.rock
# file in the file specified in the $indexrock_path param.
#
# @param $indexrock_path - (required) Path where the file should be written.
#
# @return Does not return a meaningful value. Exits with an error status on
#         error.
sub __create_index_dot_rock_or_die {
    my ($indexrock_path) = @_;
    unless( open(INDEX_DOT_ROCK, ">$indexrock_path")) {
        warn(qq{${PROG} (error): was unable to open file for writing "${indexrock_path}": $!\n});
        exit 1;
    }
# FIXME: is hard-coded path to bedrock.jpg correct?
    my $now = localtime;  # e.g., "Thu Oct 13 04:54:34 2007"
    print INDEX_DOT_ROCK <<"EOF";
<html>
<body>
  <img src="/Bedrock/img/bedrock.jpg">
  <h1>Bedrock Appears to Work!</h1>
  <i>Autogenerated via $PROG on: $now</i>
  <h2>Environment</h2>
  <pre>
<trace --output \$env>
  </pre>
  <hr/>
  <h2>Session</h2>
  <pre>
<trace --output \$session>
  </pre>
</body>
</html>
EOF
    unless( close(INDEX_DOT_ROCK)) {
        warn (qq{${PROG} (warning): was error while closing file "$indexrock_path": $!}
              . qq{; continuing anyway\n});
    }
    return;
}
# Looks for an 'index.roc' file and an 'index.rock' file (or symlink), and
# creates one or both if not found ('index.rock', if created, will always be
# a regular file, and 'index.roc', if created, will always be a symlink to
# 'index.rock').
#
# This function obeys these fine-grained overwrite flags:
#     $DO_OVERWRITE_INDEX_DOT_ROC
#     $DO_OVERWRITE_INDEX_DOT_ROCK
#
# @param $site_dir - (required) The web site diretory as specified by the
#                    user. The index.rock and index.roc files will live in
#                    $site_dir/htdocs/
#
# @return Does not return a meaningful value. Exits with an error status on
#         error.
#
sub maybe_create_index_dot_rock_or_die {
    my ($site_dir) = @_;
    confess( __func, q{(): required '$site_dir' param not provided} )
        unless defined $site_dir;

    my $indexrock = catdir( $site_dir, 'htdocs', 'index.rock');
    my $indexroc  = catdir( $site_dir, 'htdocs', 'index.roc' );

    my $create_indexrock = 0;
    print STDERR qq{${PROG} (info): checking for the existince of file "$indexrock"...}
        if $BE_VERBOSE;
    if (-f $indexrock) {
        if ($DO_OVERWRITE_INDEX_DOT_ROCK) {
            print STDERR qq{found; will overwrite.\n};
            $create_indexrock = 1;
        }
        else {
            print STDERR qq{found; will not overwrite.\n};
        }
    }
    else {
        print STDERR qq{not found; will create.\n};
        $create_indexrock = 1;
    }

    if ($create_indexrock) {
        __create_index_dot_rock_or_die( $indexrock );
        print STDERR qq{${PROG} (info): successfully created file "$indexrock"\n}
            if $BE_VERBOSE;
    }

    my $create_indexroc = 0;
    print STDERR qq{${PROG} (info): checking for the existince of file "$indexroc"...}
        if $BE_VERBOSE;
    if (-f $indexroc) {
        if ($DO_OVERWRITE_INDEX_DOT_ROC) {
            print STDERR qq{found; will overwrite.\n};
            $create_indexroc = 1;
        }
        else {
            print STDERR qq{found; will not overwrite.\n};
        }
    }
    else {
        print STDERR qq{not found; will create.\n};
        $create_indexroc = 1;
    }

    if ($create_indexroc) {
        if (-f $indexroc) {
            # We need to unlink the symlink file if it already exists;
            # otherwise our symlink() command will fail.
            unless( unlink( $indexroc )) {
                warn(qq{${PROG} (error): was unable to unlink file "${indexroc}": $!\n});
                exit 1;
            }
        }
        eval {
            die qq{was unable to create symlinks from "$indexroc" to "$indexrock"\n}
                unless symlink($indexrock, $indexroc); # may throw fatal error
        };
        if ($@) {
            warn(qq{${PROG} (error): was unable to create symlink: $@\n});
            exit 1;
        }
        print STDERR qq{${PROG} (info): successfully created symlink "$indexroc"\n}
            if $BE_VERBOSE;
    }
    return;
}

# ----------------------------------------------------------------
# main of program begins here
# ----------------------------------------------------------------

unless ( GetOptions(
                    "h|help"          => \$SHOW_HELP,
                    "d|domain-name=s" => \$DOMAIN_NAME,
                    "O|overwrite"     => \$DO_OVERWRITE_ALL,
                    "overwrite-index-dot-roc!"  => \$DO_OVERWRITE_INDEX_DOT_ROC,
                    "overwrite-index-dot-rock!" => \$DO_OVERWRITE_INDEX_DOT_ROCK,
                    "s|site-dir=s"    => \$WEBSITE_DIR,
                    "V|version"       => \$SHOW_VERSION,
                    "v|verbose"       => \$BE_VERBOSE,
                   ))
{
    print_usage( \*STDERR );
    exit 1;
}

if ($SHOW_HELP) {
    print_usage( \*STDOUT );
    exit 0;
}

if ($SHOW_VERSION) {
    print_version;
    exit 0;
}

# The 'sort' simply makes the order deterministic, so repeated user errors
# are guaranteed to be reported consistently
foreach my $varname (sort keys %REQUIRED_STR_OPTS) {
    my $sopt = $REQUIRED_STR_OPTS{$varname}->{sopt_name};
    my $desc = $REQUIRED_STR_OPTS{$varname}->{desc};
    no strict 'refs';
    unless (defined $$varname) {
        use strict 'refs';
        warn "${PROG} (error): required $desc option not specified (see -${sopt})\n";
        print_usage( \*STDERR );
        exit 1;
    }
    unless (length $$varname) {
        use strict 'refs';
        warn "${PROG} (error): $desc may not be the empty string\n";
        exit 1;
    }
}

# Ensure all fine grained "overwrite" options have a true (1) or false (0)
# value. Any "overwrite" options not explicitly specified one way or the
# other by the user are set to correspond with the value of
# $DO_OVERWRITE_ALL.
foreach my $fgopt (sort keys %ALL_OVERWRITE_OPTS) {
    no strict 'refs';
    # we only muck with opts not explicitly set by the user
    next unless -1 == $$fgopt;
    $$fgopt = ($DO_OVERWRITE_ALL ? 1 : 0);
}

# Maybe print a summary of the configured options
if ($BE_VERBOSE) {
    my $longest_desc = 0;
    map { $longest_desc = $_ if $_ > $longest_desc }
        map { length $REQUIRED_STR_OPTS{$_}->{desc} } keys %REQUIRED_STR_OPTS;
    {
        no strict 'refs';
        printf STDERR qq{${PROG} (info): using %-*s: "%s"\n}, $longest_desc, $_->[0], $_->[1]
            foreach map { [ $REQUIRED_STR_OPTS{$_}->{desc }, $$_ ] }
                sort keys %REQUIRED_STR_OPTS;
    }

    # Summarize overwrite flags
    $longest_desc = 0;  # reset
    map { $longest_desc = $_ if $_ > $longest_desc }
        map { length } values %ALL_OVERWRITE_OPTS;
    printf STDERR qq{${PROG} (info): overwrite %-*s: %s\n}, $longest_desc, 'all',
        ($DO_OVERWRITE_ALL ? 'yes' : 'no');
    {
        no strict 'refs';
        printf STDERR qq{${PROG} (info): overwrite %-*s?: %s\n}, $longest_desc, $_->[0], $_->[1]
            foreach map { [ $ALL_OVERWRITE_OPTS{$_}, ( $$_ ? 'yes' : 'no' ) ] }
                sort keys %ALL_OVERWRITE_OPTS;
    }
}

maybe_create_site_directory_tree_or_die( $WEBSITE_DIR );
maybe_create_index_dot_rock_or_die( $WEBSITE_DIR );

exit 0;

__END__

#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball, DEB, or RPM, for
# instance), you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='Bedrock' \
#               --release='bedrock-1.6.6' \
#               --section='1' \
#               > /outputdir/bedrock-create-site.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#     'man -l -'
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  bedrock-create-site - create initial scaffolding for a Bedrock project


=head1 SYNOPSIS

  bedrock-create-site -h
  bedrock-create-site -V
  bedrock-create-site [options]


=head1 DESCRIPTION

C<bedrock-create-site> is part of the C<bedrock> project.

The C<bedrock-create-site> program is a command line program that may be
used to create the initial scaffolding for a Bedrock project. It's purpose
is to automate the handful of necessary (but simple) steps. It also provides
support for some optional (but common) setup steps (such as creating MySQL
databases).

There are two primary users of C<bedrock-create-site>: software developers
who need to setup a Bedrock-enabled site and packagers (of DEBs, RPMs,
whatever) of programs that use Bedrock as an implementation
technology. Software developers might run the program directly while mocking
up a project, or they may invoke the program from a Makefile (or
similar). Packagers may invoke the program from Makefiles, or maybe as a
worker tool invoked by a platform-specific installation framework (such as
L<debconf(7)>).

The program makes a number of assumptions about how you want your site
configured:

=over 4

=item *

The provided domain name will be used in the creation of files and in Apache
configuration directives. Specifically:

=over 4

=item *

The Apache 2.0.x configuration file will be named C<$DOMAIN_NAME.conf>

=item *

The specified C<$DOMAIN_NAME> will be used for the Apache C<ServerName>
directive. An alias named C<www.$DOMAIN_NAME> will also be created via the
Apache C<ServerAlias> directive.

=back

=back

The following tasks are always performed:

=over 4

=item *

The directory specified via the required C<--site-dir=DIR> option is created
(if it does not already exist).

=item *

The following directory structure is created beneath the specified site
directory. Only those directories which do not already exist are created:

    $sitedir/conf
    $sitedir/config
    $sitedir/cgi-bin
    $sitedir/cgi-bin/Perl
    $sitedir/cgi-bin/Perl/BLM
    $sitedir/cgi-bin/Perl/BLM/Startup
    $sitedir/htdocs
    $sitedir/htdocs/admin
    $sitedir/htdocs/img
    $sitedir/logs
    $sitedir/logs/html
    $sitedir/session

=item *

A symbolic link (symlink) is created from:

    $sitedir/htdocs/admin/cgi-bin

to:

    $sitedir/cgi-bin

=back

B<FIXME>: finish documenting steps that are always performed


The following tasks are only performed if explicitly requested via
corresponding command line options:

B<FIXME>: document option steps



=head1 OPTIONS

=over 4

=item -d, --domain-name=NAME

(Required) Specify the domain name to use (e.g., C<example.com>)

=item -h, --help

Print help usage message


=item -O, --overwrite

Causes any existing files to be overwritten (except for those explicitly
protected via C<--nooverwrite-*> options). The default behavior is to not
overwrite any existing files.

If you only want to overwrite a couple of files, you will be better off
using one of the finer-grained C<--overwrite-*> options.


=item --overwrite-index-dot-roc

Force overwriting of C<$sitedir/htdocs/index.roc>

=item --nooverwrite-index-dot-roc

Do not overwrite C<$sitedir/htdocs/index.roc>. This is the default behavior,
unless the global C<--overwrite> option has been specified.


=item --overwrite-index-dot-rock

Force overwriting of C<$sitedir/htdocs/index.rock>

=item --nooverwrite-index-dot-rock

Do not overwrite C<$sitedir/htdocs/index.rock>. This is the default
behavior, unless the global C<--overwrite> option has been specified.


=item -s, --site-dir=DIR

Create the web site in DIR. If DIR does not exist, it will be created (along
with any parent directories). For example, if you want your site created beneath:

    /var/www/vhosts/example.com

then specify the option like this:

    --site-dir=/var/www/vhosts/example.com


=item -V

Print the version of the program to stdout and then exit.


=item -v

Turn on verbose mode. Causes program to emit messages on C<stderr>
indicating what it is doing.

=back


=head1 EXAMPLES

B<FIXME>: document examples


=head1 DIAGNOSTICS

Exits with zero on success, non-zero on error. The program stops processing
at the first error that is encountered.


=head1 BUGS

=over 4

=item *

We currently check for the existence of the C<$sitedir/htdocs/admin/cgi-bin>
symlink, but we do not check that the target of that link is sane.

=back

If you find any others, please report them to the Signature Inforamation
Solutions, LLC Developers' mailing list:

  cjldev@signatureinfo.com


=head1 SEE ALSO

L<deb(5)>,
L<debconf(7)>,
L<rpm(8)>


=head1 AUTHORS

In late February 2008, Rob Lauer <RLauer@signatureinfo.com> wrote the first
incarnation of the ideas embodied in here in program called C<make_site.sh>

The C<bedrock-create-site> program is a re-implementation and an expansion
of those ideas written by Alan D. Salewski <ASalewski@signatureinfo.com>
working in close collaboration with Rob Lauer.


=head1 COPYRIGHT

Copyright 2008 Signature Information Solutions, LLC

This is free software. You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

=cut

