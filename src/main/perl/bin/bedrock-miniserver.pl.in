#!/usr/bin/env perl
#-*- mode: cperl-mode; -*-

########################################################################
# A lightweight HTTP server that supports Bedrock services, HTML and
# Bedrock documents
########################################################################
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Check out http://www.openbedrock.net
#    Copyright (C) 2026, TBC Development Group, LLC.
#    Copyright (C) 2001, Charles Jones, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

########################################################################
package Bedrock::MiniServer; ## no critic
########################################################################

use strict;
use warnings;

use Apache::Request::CGI;
use Bedrock qw(slurp_file is_hash is_array to_boolean benchmark choose $BEDROCK_DIST_DIR);
use Bedrock::Constants qw(:chars %LOG4PERL_LOG_LEVELS :booleans :http);
use Bedrock::BedrockConfig;
use Bedrock::Error qw(handle_error resolve_error_page);
use Bedrock::MiniServer::Context;
use Bedrock::Router;
use Benchmark;
use Data::Dumper;
use Carp;
use Cwd;
use English qw(-no_match_vars);
use IO::Scalar;
use JSON::Schema::Validate;
use List::Util qw(pairs);
use Log::Log4perl;
use POSIX qw(strftime);
use Module::Load;
use Scalar::Util qw(blessed reftype);
use Text::URLEncode qw(Htmlencode);
use YAML::Tiny;

use Role::Tiny::With;
with 'Bedrock::Logger';

our $version = '@PACKAGE_VERSION@';

use parent qw(HTTP::Server::Simple::CGI);

{
  no warnings 'once'; ## no critic
  $Log::Log4perl::Config::ALLOW_CODE = 1;  # allow us to use cspec for Log::Log4perl
}

########################################################################
sub new {
########################################################################
  my ( $class, $port, $family, %args ) = @_;

  my $bedrock_runtime = delete $args{bedrock_runtime} // {};

  my $self = $class->SUPER::new( $port, $family, %args );

  $self->{_bedrock_runtime} = $bedrock_runtime;

  return $self;
}

########################################################################
sub bedrock_server_config {
########################################################################
  my ($self) = @_;

  return $self->{_bedrock_runtime} // {};
}

########################################################################
sub handle_request {
########################################################################
  my ( $self, $cgi ) = @_;

  my $t0 = benchmark();

  # init logging for miniserver...
  my $logger = $self->_init_miniserver_logger( $self->bedrock_server_config->{log_level} );

  my $env = $self->bedrock_server_config->{env} // {};

  local @ENV{ keys %{$env} } = values %{$env};

  # check to see if request is for static or template asset
  if ( $self->_serve_alias($cgi) ) {
    $self->_log_complete(
      path         => $cgi->path_info,
      request_time => benchmark($t0)->[0],
      cgi          => $cgi,
      logger       => $logger,
    );

    return;
  }

  my ( $template, $route_params ) = $self->_resolve_template_route($cgi);

  if ($template) {
    # Resolve against PEBBLE_DIR like Apache::Bedrock
    my $pebble_dir = $self->bedrock_server_config->{PEBBLE_DIR} // $ENV{SERVER_ROOT} // Cwd::getcwd();

    my $fs_path = "$pebble_dir/$template";

    $logger->debug( sprintf 'Route matched! Checking filesystem for: [%s]', $fs_path );
    $logger->debug( sprintf 'Current Working Directory: %s',                Cwd::getcwd() );

    if ( -r $fs_path ) {
      $logger->debug('File found and readable. Invoking _serve_template.');
      $self->_serve_template( $cgi, $fs_path, $route_params );

      return $self->_log_complete(
        path         => $cgi->path_info,
        request_time => benchmark($t0)->[0],
        cgi          => $cgi,
        logger       => $logger
      );
    }
    else {
      $logger->error( sprintf 'ROUTING FAILURE: Match found (%s) but file not readable at [%s]', $template, $fs_path );
    }
  }

  # see if the request is handled by a service
  my ( $mount, $service ) = $self->_is_service($cgi);

  return $self->_not_found()
    if !$service;

  my $path_info = $self->_service( $cgi, $service, $mount );

  $self->_log_complete(
    cgi          => $cgi,
    request_time => benchmark($t0)->[0],
    path         => $cgi->path_info,
    path_info    => $path_info,  # the possibly remapped path
    logger       => $logger,
  );

  return;
}

########################################################################
sub _resolve_template_route {
########################################################################
  my ( $self, $cgi ) = @_;
  my $logger = Log::Log4perl->get_logger( ref $self );

  require Bedrock::Router;
  my $routes_config = $self->bedrock_server_config->{routes} || {};

  foreach my $mount ( keys %{$routes_config} ) {
    next if index( $cgi->path_info, $mount ) != 0;

    my $rel_path = substr $cgi->path_info, length $mount;
    $rel_path = "/$rel_path" if $rel_path !~ m{^/}xsm;

    # DIAGNOSTIC: Check structure before passing to Router
    my $rules = $routes_config->{$mount};

    # If rules is a HASH, we must convert it to an ARRAY for Bedrock::Router
    if ( ref($rules) eq 'HASH' ) {
      $logger->debug("Converting HASH routes to ARRAY for mount: $mount");
      $rules = [ map { { pattern => $_, template => $rules->{$_} } } keys %{$rules} ];
    }

    $logger->debug("Attempting route match: Mount[$mount] Path[$rel_path]");

    my $router = Bedrock::Router->new( { routes => $rules } );
    if ( my $match = $router->match($rel_path) ) {
      $logger->info("Route Match Found! Template: $match->{template}");
      return ( $match->{template}, $match->{params} );
    }
  }
  $logger->debug( "No route matched for: " . $cgi->path_info );
  return;
}

########################################################################
sub _service {
########################################################################
  my ( $self, $cgi, $service, $mount ) = @_;

  my $logger = Log::Log4perl->get_logger( ref $self );

  my $path_info = $self->_service_route( $cgi, $mount );

  # Virtualize the Environment for the Service
  local $ENV{SCRIPT_NAME} = $mount eq $SLASH ? $EMPTY : $mount;
  local $ENV{PATH_INFO}   = $path_info;

  $service->request(undef);
  $service->context(undef);
  $service->bedrock_handler(undef);

  my $r = Apache::Request::CGI->new();

  eval { $service->handler($r); };

  my $err = $EVAL_ERROR;

  if ( my $session = $service->session ) {
    if ( $session->can('closeBLM') ) {
      $session->closeBLM;
      $service->set( session => undef );  # so DESTROY does not try to closeBLM either
    }
  }

  if ($err) {
    handle_error( $r, $err );
    $logger->error("CRITICAL ERROR in $mount: $err");
  }

  return $path_info;
}

########################################################################
sub _service_route {
########################################################################
  my ( $self, $cgi, $mount ) = @_;

  # Calculates the "Service-Relative Path" (PATH_INFO).
  #
  # This logic enables "Virtual Mounting" by isolating the Service from
  # its public URL prefix. It prioritizes:
  # 1. Regex Rewrites: Checks the 'routes' config for complex mappings.
  # 2. Prefix Stripping: If mounted at '/api', a request to '/api/users'
  #    is translated to '/users' so the Service handles it correctly.
  # 3. Normalization: Ensures the path is never empty (defaults to '/').

  my $path_info = $self->_xlate_path( $mount, $cgi );

  if ( !$path_info && $mount ne $SLASH ) {
    $path_info = substr $cgi->path_info, length $mount;
  }

  $path_info ||= $SLASH;

  return $path_info;
}

########################################################################
sub _xlate_path {
########################################################################
  my ( $self, $mount, $cgi ) = @_;

  my $routes = $self->bedrock_server_config->{routes} || {};

  my $rules = $routes->{$mount};

  return
    if !$rules;

  # Route Translation / Rewriting
  my $path_info;

  my $path = $cgi->path_info;

  foreach my $pattern ( _sort_by_longest($rules) ) {
    my $regex = $pattern;
    my @vars;

    while ( $regex =~ m{(:[[:alnum:]_]+)}xsm ) {
      push @vars, $1;
      $regex =~ s/$1/([^\/]+)/xsm;
    }

    if ( my @captures = $path =~ m{\A$regex\z}xsm ) {
      my $target = $rules->{$pattern};

      for my $i ( 0 .. $#vars ) {
        my $token = $vars[$i];
        my $val   = $captures[$i];

        $target =~ s/$token/$val/xsm;
      }

      $path_info = $target;
      last;
    }
  }

  return $path_info;
}

########################################################################
sub _is_service {
########################################################################
  my ( $self, $cgi ) = @_;

  my $registry = $self->bedrock_server_config->{service_registry} || {};

  my $path = $cgi->path_info();

  foreach my $m ( _sort_by_longest($registry) ) {
    next if index( $path, $m ) != 0;

    return ( $m, $registry->{ $m // q{} } );
  }

  return;
}

########################################################################
sub _serve_alias {
########################################################################
  my ( $self, $cgi ) = @_;

  my $aliases = $self->bedrock_server_config->{aliases} // {};

  my $path = $cgi->path_info;

  foreach my $alias ( _sort_by_longest($aliases) ) {
    next if index( $path, $alias ) != 0;

    return $self->_serve_static( $cgi, $alias, $aliases->{$alias} );
  }

  return;
}

########################################################################
sub _init_miniserver_logger {
########################################################################
  my ( $self, $log_level ) = @_;

  my $logger = get_logger( ref $self );

  $log_level //= 'info';
  $logger->level( $LOG4PERL_LOG_LEVELS{$log_level} // $LOG4PERL_LOG_LEVELS{info} );

  return $logger;
}

########################################################################
sub _log_complete {
########################################################################
  my ( $self, %args ) = @_;

  $args{path_info} //= q{};

  foreach (qw(request_method user_agent referer)) {
    $args{$_} = $args{cgi}->$_ // q{};
  }

  $args{logger}->notice( sprintf '%s %s (%s) %s %s', @args{qw(request_method path request_time referer user_agent)} );

  return;
}

########################################################################
sub _not_found {
########################################################################
  my ($self) = @_;

  my $error_docs = $self->bedrock_server_config->{error_document} // {};
  my $aliases    = $self->bedrock_server_config->{aliases}        // {};

  my $error_page = $error_docs->{404};

  my $not_found_page = choose {
    return "$BEDROCK_DIST_DIR/htdocs/not-found.html"
      if !$error_page;

    # could be set as an absolute path
    return $error_page
      if -r $error_page;

    # or an alias
    foreach my $alias ( _sort_by_longest($aliases) ) {
      next if index( $error_page, $alias ) != 0;

      my $err_fs = $aliases->{$alias} . substr $error_page, length $alias;
      return $err_fs;
    }

    return;
  };

  my $content = -r $not_found_page ? slurp_file($not_found_page) : 'File not found';

  print "HTTP/1.0 404 Not Found\r\nContent-Type: text/html\r\n";
  print "Connection: close\r\n\r\n";
  print $content;

  return;
}

########################################################################
sub _sort_by_longest {
########################################################################
  my ($hash) = @_;

  return reverse sort { length($a) <=> length $b } keys %{$hash};
}

########################################################################
sub _serve_template {
########################################################################
  my ( $self, $cgi, $fs_path, $route_params ) = @_;

  # This simply re-uses the logic from _serve_static but bypasses
  # the alias/filesystem existence checks because we've already
  # resolved the path.

  # We call _serve_static but pass the full file path as the local_base
  # to force it to treat the file as the target.
  return $self->_serve_static( $cgi, $cgi->path_info, $fs_path, $route_params );
}

########################################################################
sub _serve_static {
########################################################################
  my ( $self, $cgi, $alias_url, $local_base, $route_params ) = @_;

  my $logger = Log::Log4perl->get_logger( ref $self );

  my $path = $cgi->path_info();

  # Calculate relative path
  my $rel_file = substr $path, length $alias_url;

  # 1. Security Check: Block directory traversal
  if ( $rel_file =~ /[.]{2}/xsm ) {
    print "HTTP/1.0 403 Forbidden\r\nConnection: close\r\n\r\n";
    return $TRUE;
  }

  # 2. Shadowing Detection
  # If alias maps to a FILE, but request implies it's a directory, decline.
  my $is_file_alias = ( -e $local_base && !-d $local_base )
    || ( !-e $local_base && $local_base =~ m{[.][[:alnum:]]+$}xsm );

  if ( $is_file_alias && length($rel_file) > 0 && $rel_file ne $SLASH ) {
    $logger->debug("serve_static: Shadowing detected for $path. Declining.");
    return $FALSE;
  }

  # Inside _serve_static
  my $fs_path = $local_base;
  if ( length $rel_file && $rel_file ne $SLASH ) {
    $fs_path .= $rel_file;
  }

  # Add this log to catch the 404 source
  if ( !-e $fs_path || !-r $fs_path ) {
    $logger->error("File system check failed for: $fs_path");
    return $FALSE;
  }

  # --- If we get here, we are definitely serving this file ---
  my ($ext) = $fs_path =~ /[.]([^.]+)$/xsm;
  $ext = lc( $ext || $EMPTY );

  my $server_config = $self->bedrock_server_config;

  my $type = $server_config->{mime_types}->{$ext} || 'text/plain';

  my $global_config = $server_config->{global_config} || {};

  if ( !$server_config->{parse_templates} || !$server_config->{template_extensions}->{$ext} ) {
    _serve_static_content( $fs_path, $type, $server_config->{no_cache} );
    return $TRUE;
  }

  my $tpl;

  # Create capture buffer and IO handle
  my $headers_out = $EMPTY;
  my $io          = IO::Scalar->new( \$headers_out );

  my $tagx_config = Bedrock::Config->new('tagx.xml');

  foreach ( keys %{$global_config} ) {
    $tagx_config->{$_} = $global_config->{$_};
  }

  if ( $global_config->{overrides} && is_hash( $global_config->{overrides} ) ) {
    my %processed_overrides;
    my $raw_overrides = $global_config->{overrides};

    foreach my $k ( keys %{$raw_overrides} ) {
      my $v = $raw_overrides->{$k};
      $v =~ s/[@]dist_dir[@]/$BEDROCK_DIST_DIR/xsmg;
      $processed_overrides{$k} = $v;
    }

    @{$tagx_config}{ keys %processed_overrides } = values %processed_overrides;
  }

  eval {
    # We only need to override the path info to trick the template
    # into thinking it is running inside the alias.
    # Everything else (Method, Query String, Extra Env) is already in global %ENV.

    local $ENV{SCRIPT_NAME} = $alias_url eq $SLASH ? $EMPTY : $alias_url;
    local $ENV{PATH_INFO}   = $rel_file;
    # ------------------------------------------------------

    require Bedrock::Template;
    require BLM::Startup::Header;
    require BLM::Startup::Input;
    require BLM::Startup::Env;
    require BLM::Startup::Bedrock;
    require BLM::Startup::Config;

    my $ctx = Bedrock::MiniServer::Context->new(
      $io,
      cgi          => $cgi,
      config       => $tagx_config,
      route_params => $route_params || {},
    );

    my $input   = BLM::Startup::Input->new( $ctx, $tagx_config->get_module_config('Input')     || {} );
    my $header  = BLM::Startup::Header->new( $ctx, $tagx_config->get_module_config('Header')   || {} );
    my $bedrock = BLM::Startup::Bedrock->new( $ctx, $tagx_config->get_module_config('Bedrock') || {} );
    my $env     = BLM::Startup::Env->new;

    ################################################################
    # Important!
    ################################################################
    # The miniserver expects that if you want session a object,
    # you declare it explicitly in the server configuration
    # file. You do this by setting a session section. If you use
    # the default `bedrock-miniserver.yml` configuration file, the
    # BLM::Startup::MemorySession session object will be created
    # for you. The miniserver will NOT search the MODULES array
    # for a session object (one where session=yes)!
    ################################################################

    my $session = _init_session( $ctx, $global_config );

    my $content = slurp_file($fs_path);

    $header->content_type($type);

    $tpl = Bedrock::Template->new(
      $content,
      header  => $header,
      input   => $input,
      session => $session,
      config  => bless( $tagx_config, 'BLM::Startup::Config' ),
      env     => $env,
      bedrock => $bedrock,
    );

    $tpl->set_source($fs_path);

    # Execute parsing first (populates $buffer via $ctx)
    my $output = $tpl->parse();

    # ...better do these now, while $header still has its headers...
    my $status_text = $header->get_status_line();
    my $is_redirect = $header->is_redirect;

    # BLMs must be explicitly closed
    foreach my $plugin ( $header, $input, $session, $env, $bedrock ) {
      next if !$plugin || !$plugin->can('closeBLM');

      $plugin->closeBLM;
    }

    # 1. Get the status line from the Header plugin logic
    # Returns "200 OK", "302 Found", etc.

    # 2. Delegate header printing...and there go the headers!
    $header->print_header($ctx);
    $io->close;

    print "HTTP/1.0 $status_text\r\n";
    print "Connection: close\r\n";

    if ( my $h_obj = $ctx->headers_out ) {
      foreach my $key ( sort keys %{$h_obj} ) {
        my $val    = $h_obj->{$key};
        my @values = is_array($val) ? @{$val} : ($val);

        foreach my $v (@values) {
          print "$key: $v\r\n";
        }
      }
    }

    print "\r\n";

    # 3. Only print body if NOT a redirect
    if ( !$is_redirect ) {
      print $output;
    }
  };

  my $err = $EVAL_ERROR;

  return $TRUE
    if !$err;

  $logger->error( Dumper( [ err => $err ] ) );

  $ENV{BEDROCK_ERROR_LOCATION} = resolve_error_page($tagx_config); ## no critic

  require Apache::Request::CGI;

  my $r = Apache::Request::CGI->new();

  my $buffer = $EMPTY;
  $tpl->set_output_handler( IO::Scalar->new( \$buffer ) );

  ######################################################################
  # Note: handle_error() usually requires a Text::TagX instance, but
  # actually only needs a 'show_error()' method. Bedrock::Template
  # instantiates a Text::TagX instances, stores it and provides a
  # show_error() method itself that delegates to the Text::TagX
  # instance...so yes this works.
  ######################################################################
  handle_error( $r, $err, $tpl );

  my $err_msg = "$err";

  if ( blessed($err) ) {
    if    ( $err->can('as_string') ) { $err_msg = $err->as_string; }
    elsif ( $err->can('mesg') )      { $err_msg = $err->mesg; }
    elsif ( $err->can('to_string') ) { $err_msg = $err->to_string; }
    else                             { $err_msg = Dumper($err); }
  }

  $logger->error("Template Parsing Failed for $fs_path: $err_msg");

  $buffer ||= $err_msg;

  print "HTTP/1.0 500 Internal Server Error\r\n";
  print "Content-Type: text/html\r\n";
  print "Connection: close\r\n\r\n";
  print $buffer;

  return $TRUE;

}

########################################################################
sub _serve_static_content {
########################################################################
  my ( $path, $content_type, $no_cache ) = @_;

  print "HTTP/1.0 200 OK\r\n";
  print "Content-Type: $content_type\r\n";
  print "Connection: close\r\n";

  if ( !to_boolean($no_cache) ) {
    my $last_modified = ( stat $path )[9];
    my $http_date     = strftime( '%a, %d %b %Y %H:%M:%S GMT', gmtime $last_modified );

    print "Last-Modified: $http_date\r\n";
    print "Cache-Control: max-age=86400, public\r\n";
  }

  print "\r\n";
  print scalar slurp_file($path);

  return $TRUE;
}

########################################################################
sub _init_session {
########################################################################
  my ( $ctx, $config ) = @_;

  my $session_config = $config->{session};

  return
    if !$session_config;

  my $class = $session_config->{module};

  load $class;

  my $session = $class->new( $ctx, $session_config->{config} // {} );

  return $session;
}

########################################################################
sub _render_template_error {
########################################################################
  my ( $err, $file_path ) = @_;

  my $msg = "$err";

  my $line;

  # Inspect Exception Object
  if ( blessed($err) ) {
    # 1. Try standard 'line' method
    if ( $err->can('line') ) {
      $line = $err->line;
    }
    # 2. Try TagX array-ref structure
    elsif ( is_array($err) && @{$err} && is_hash( $err->[0] ) ) {
      $line = $err->[0]->{line};
    }

    # 3. Extract Message
    if ( $err->can('as_string') ) {
      $msg = $err->as_string;
    }
    elsif ( is_array($err) && @{$err} && is_hash( $err->[0] ) ) {
      $msg = $err->[0]->{text} || "$err";
    }
  }
  # Fallback: Parse string for line number
  elsif ( $msg =~ /line\s+(\d+)/ixsm ) {
    $line = $1;
  }

  $msg = Htmlencode($msg);

  my $source = eval { slurp_file($file_path) } // $EMPTY;

  my @lines = split /\n/, $source;

  my $listing = $EMPTY;

  for my $i ( 0 .. $#lines ) {
    my $class = $line && $i == $line - 1 ? 'error' : 'code';
    $listing .= sprintf qq{<span class="%s"'>%4d: %s</span>\n}, $class, $i + 1, Htmlencode( $lines[$i] );
  }

  my $html = <<"END_OF_HTML";
<html>
  <head>
    <title>Template Error</title>
  </head>
  <body>
    <style>
    .error {
       background-color: #ffcccc;
       display: block;
       width: 100%;
     }

    .code {
      display: block:
      width: 100%;     
     }
    </style>

    <h1 style='color:red'>Template Error</h1>
    <pre><strong>$msg</strong></pre>
    <div style='border:1px solid #ccc; background:#f9f9f9; padding:10px; overflow:auto'>
      <pre>$listing</pre>
    </div>
  </body>
</html>
END_OF_HTML

  return $html;
}

########################################################################
package Bedrock::MiniServer::CLI; ## no critic
########################################################################
use Bedrock qw(choose slurp_json slurp_file $BEDROCK_DIST_DIR to_boolean is_hash is_array);
use Bedrock::Constants qw(%LOG4PERL_LOG_LEVELS);
use Bedrock::LoadConfig qw(load_config);
use CLI::Simple::Constants qw(:booleans :chars);
use Carp;
use Cwd;
use Data::Dumper;
use English qw(-no_match_vars);
use Module::Load;
use List::Util qw(pairs);

our $VERSION = '@PACKAGE_VERSION@';

use parent qw(CLI::Simple);

__PACKAGE__->use_log4perl;

########################################################################
sub main {
########################################################################
  my ( $class, $defaults ) = @_;

  my @option_specs = qw(
    config|c=s
    help|h
    log-level|l=s
    mount-point|m=s
    port|p=s
    service|s=s
    strict!
  );

  my @extra_options = qw(
    aliases
    dist_dir
    mime_types
    server_config
  );

  my $default_options = {
    mime_types => $defaults->{mime_types},
    aliases    => $defaults->{aliases},
    strict     => $TRUE,
  };

  my %commands = (
    default => \&cmd_start_server,
    start   => \&cmd_start_server
  );

  my $cli = Bedrock::MiniServer::CLI->new(
    option_specs    => \@option_specs,
    extra_options   => \@extra_options,
    default_options => $default_options,
    commands        => \%commands,
  );

  return $cli->run();
}

########################################################################
sub cmd_start_server {
########################################################################
  my ($self) = @_;

  my $server_config = $self->get_server_config;

  # Set log level EARLY for startup messages
  my $log_level = $server_config->{log_level} || 'info';
  my $logger    = Log::Log4perl->get_logger('Bedrock::MiniServer');
  $logger->level( $LOG4PERL_LOG_LEVELS{$log_level} // $LOG4PERL_LOG_LEVELS{info} );

  # Capture the 'sovereign' launch root
  my $server_root = Cwd::getcwd();
  local $ENV{SERVER_ROOT} = $server_root;

  # Ensure PEBBLE_DIR defaults to this root if set to '.' or undefined
  if ( ( $server_config->{PEBBLE_DIR} // $EMPTY ) eq $DOT || !$server_config->{PEBBLE_DIR} ) {
    $server_config->{PEBBLE_DIR} = $server_root;
  }

  # --- initialize runtime configuration
  my %runtime_config = (
    global_config    => $server_config,
    aliases          => $self->get_aliases,
    mime_types       => $self->get_mime_types,
    error_document   => {},
    service_registry => {},
    routes           => {},
    env              => {},
    log_level        => $server_config->{log_level} || 'info',
  );

  $server_config->{env} //= {};

  foreach my $k ( keys %{ $server_config->{env} } ) {
    $ENV{$k} = $server_config->{env}->{$k}; ## no critic
    $runtime_config{env}->{$k} = $server_config->{env}->{$k};
  }

  $runtime_config{error_document}  = $server_config->{error_document} || {};
  $runtime_config{parse_templates} = $server_config->{parse_templates};

  # default template extensions
  $runtime_config{template_extensions} = { map { $_ => 1 } qw(roc rock jroc jrock) };

  if ( is_array( $server_config->{template_extensions} ) ) {
    $runtime_config{template_extensions} = { map { $_ => 1 } @{ $server_config->{template_extensions} } };
  }

  $runtime_config{mime_types} = { %{ $self->get_mime_types }, %{ $server_config->{mime_types} // {} } };

  my $global_service_config = $server_config->{service_config} // {};

  if ( $server_config->{session} ) {
    $global_service_config->{session} = $server_config->{session};
  }

  if ( $server_config->{overrides} ) {
    $global_service_config->{overrides} = $server_config->{overrides};
  }

  _resolve_paths($global_service_config);  # in case any values here are paths with [@]dist_dir[@]

  $runtime_config{routes} = $server_config->{routes} || {};

  my ( $services_cfg, $aliases_cfg ) = @{$server_config}{qw(services aliases)};

  $services_cfg //= {};

  my $mount_point = $self->get_mount_point // $server_config->{mount_point} // $SLASH;
  if ( my $service = $self->get_service ) {
    $services_cfg->{$mount_point} = $self->get_service;
  }

  carp q{WARNING: No services defined! Use --service or add a 'services' block to your config.}
    if !keys %{$services_cfg};

  foreach my $mount ( keys %{$services_cfg} ) {
    my $class = $services_cfg->{$mount};
    $self->_mount_service( \%runtime_config, $mount, $class, $global_service_config );
  }

  $runtime_config{aliases} = { %{ $runtime_config{aliases} }, %{ $aliases_cfg // {} } };
  _resolve_paths( $runtime_config{aliases} );

  #
  # Create default alias for directory paths (e.g. /bedrock => index.roc
  #
  # directory_index:
  #   /bedrock:
  #     - index.html
  #     - index.roc
  #
  if ( my $directory_index = $server_config->{directory_index} ) {
    foreach my $dir ( keys %{$directory_index} ) {
      my $index = $directory_index->{$dir};
      my $file  = is_array($index) ? $index : [$index];

      $dir =~ s{/\z}{}xsm;

      foreach my $f ( @{$file} ) {
        $runtime_config{aliases}->{$dir}      = $f;
        $runtime_config{aliases}->{"$dir/"}   = $f;
        $runtime_config{aliases}->{"$dir/$f"} = $f;
      }
    }
  }

  my $port        = $self->get_port // $server_config->{port} // 8080;
  my $line_length = 80;

  $logger->notice( q{=} x $line_length );
  $logger->notice( sprintf 'BEDROCK MINISERVER RUNNING ON PORT: %s', $port );

  $logger->notice( q{-} x $line_length );
  $logger->notice('Services:');
  $logger->notice( q{-} x $line_length );

  foreach my $mount ( sort keys %{ $runtime_config{service_registry} } ) {
    my $svc = $runtime_config{service_registry}->{$mount};
    $logger->notice( sprintf '  %-20s -> %s', $mount, ref $svc );
  }

  if ( keys %{ $runtime_config{error_document} } ) {
    $logger->notice( q{-} x $line_length );
    $logger->notice('Error Documents:');
    $logger->notice( q{-} x $line_length );
    foreach my $code ( sort keys %{ $runtime_config{error_document} } ) {
      $logger->notice( sprintf '  %-5s -> %s', $code, $runtime_config{error_document}->{$code} );
    }
  }

  $logger->notice( q{-} x $line_length );
  $logger->notice('MIME Types:');
  $logger->notice( q{-} x $line_length );
  foreach my $type ( sort keys %{ $runtime_config{mime_types} } ) {
    $logger->notice( sprintf '  %-5s -> %s', $type, $runtime_config{mime_types}->{$type} );
  }

  if ( keys %{ $runtime_config{aliases} } ) {
    $logger->notice( q{-} x $line_length );
    $logger->notice('Static Asset Aliases:');
    $logger->notice( q{-} x $line_length );

    foreach my $alias ( sort keys %{ $runtime_config{aliases} } ) {
      $logger->notice( sprintf '  %-20s -> %s', $alias, $runtime_config{aliases}->{$alias} );
    }
  }

  if ( $runtime_config{parse_templates} ) {
    $logger->notice( q{-} x $line_length );
    $logger->notice( sprintf '* Bedrock template parsing ENABLED for (%s) files.',
      join ', ', keys %{ $runtime_config{template_extensions} } );
  }

  $logger->notice( q{=} x $line_length );

  # Instantiate with runtime_config
  Bedrock::MiniServer->new( $port, undef, bedrock_runtime => \%runtime_config )->run();

  return 0;
}

########################################################################
sub _resolve_paths {
########################################################################
  my ($path_map) = @_;

  foreach my $p ( values %{$path_map} ) {
    next if $p !~ /[@]dist_dir[@]/xsm;
    $p =~ s/[@]dist_dir[@]/$BEDROCK_DIST_DIR/xsm;
  }

  return;
}

########################################################################
sub _mount_service {
########################################################################
  my ( $self, $runtime_config, $mount, $class, $config ) = @_;

  if ( $class !~ /\ABedrock::Service/xsm ) {
    $class = "Bedrock::Service::$class";
  }

  eval {
    load $class;

    my $instance = $class->new(
      service_config => $config,
      registry       => $runtime_config->{service_registry},
      server_config  => $runtime_config,
    );

    $runtime_config->{service_registry}->{$mount} = $instance;
  };

  croak "Failed to mount $class at $mount: $EVAL_ERROR"
    if $EVAL_ERROR;

  return;
}

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  $self->set_dist_dir($BEDROCK_DIST_DIR);

  my $config_file = $self->get_config;

  if ($config_file) {
    my @paths = grep {defined} ( $EMPTY, $ENV{BEDROCK_CONFIG_PATH}, $ENV{CONFIG_PATH}, "$BEDROCK_DIST_DIR/config" );

    foreach my $p (@paths) {
      if ( $p && $p !~ m{\z/}xsm ) {
        $p = "$p/";
      }

      next if !-r "$p$config_file";

      $config_file = "$p$config_file";
      last;
    }
  }

  $self->_init_server_config($config_file);

  return;
}

########################################################################
sub _init_server_config {
########################################################################
  my ( $self, $config_file ) = @_;

  if ( !$config_file ) {
    $config_file = sprintf '%s/config/bedrock-miniserver.yml', $BEDROCK_DIST_DIR;
    $self->get_logger->warn( sprintf 'WARNING: attempting to use default miniserver configuration: %s', $config_file );
  }

  croak "Configuration file not found: $config_file"
    if !-r $config_file;

  my $config = slurp_file($config_file);

  while ( $config =~ s/[@]dist_dir[@]/$BEDROCK_DIST_DIR/xsmg ) { }

  open my $fh, '<', \$config
    or croak "ERROR: could not open handle on scalar\n";

  my $conf = load_config( $fh, 1 );

  if ( my $log_level = $self->get_log_level ) {
    $conf->{log_level} = $log_level;
  }

  close $fh;

  # validate the configuration against our schema
  $self->validate_config($conf);

  $conf->{_source} = $config_file;

  $self->set_server_config($conf);

  return $conf;
}

########################################################################
sub validate_config {
########################################################################
  my ( $self, $conf ) = @_;

  # Path to the schema file defined above
  my $schema_path = "$BEDROCK_DIST_DIR/config/miniserver-schema.json";

  return $TRUE
    if !-e $schema_path || !$self->get_strict;

  my $schema = slurp_json($schema_path);

  my $v  = JSON::Schema::Validate->new($schema);
  my $ok = $v->validate($conf);

  if ( !$ok ) {
    my $err = $v->error;
    croak sprintf "ERROR: CONFIGURATION ERROR at %s: %s\n", $err->{path}, $err->{message};
  }

  return $TRUE;
}

########################################################################
package main;
########################################################################

use strict;
use warnings;

use Data::Dumper;
use English qw(-no_match_vars);
use YAML::Tiny;

my $defaults = eval {
  local $RS = undef;
  my $data = <DATA>;
  $data =~ s/^=pod.*\z//xsm;

  return Load($data);
};

exit Bedrock::MiniServer::CLI->main($defaults);

__END__

---
mime_types: 
  css:  text/css
  js:   application/javascript
  png:  image/png
  jpg:  image/jpeg
  gif:  image/gif
  html: text/html
  roc:  text/html
  jroc: application/json
  ico:  image/x-icon

aliases:
  /bedrock/img: '@dist_dir@/img'
  /bedrock/css: '@dist_dir@/css'
  /bedrock/javascript: '@dist_dir@/css'

=pod

=head1 NAME

bedrock-miniserver.pl - Multi-tenant application server and template accelerator for Bedrock

=head1 SYNOPSIS

  # Run a full stack using a configuration file (Recommended)
  bedrock-miniserver.pl --config app.yml

  # Run a static-only server (No services, just files/templates)
  bedrock-miniserver.pl --config static.yml

  # Run a single service (Legacy/Quick-start mode)
  bedrock-miniserver.pl --service MyApp::Service --port 8080

=head1 DESCRIPTION

This script provides a standalone HTTP server for Bedrock
applications, built on top of C<HTTP::Server::Simple::CGI>. It serves
three distinct purposes:

=over 4

=item 1. B<Application Server>: Hosts multiple Bedrock Services
simultaneously on a single port, dispatching requests based on a
routing table.

=item 2. B<Template Accelerator>: Serves and parses static Bedrock
templates (F<.roc> files) directly from the filesystem, providing a
simulated Bedrock environment for rapid development.

=item 3. B<Static File Server>: Serves raw assets (Images, CSS, JS)
with efficient MIME-type handling and caching headers.

=back

=head1 OPTIONS

=over 4

=item B<--config | -c>

The path to the YAML configuration file defining the services,
aliases, and environment.

=item B<--service | -s>

The Perl class name of a Bedrock Service to run (e.g.,
C<MyApp::Service>).

=item B<--mount-point | -m>

The URL prefix where the CLI-specified service will be
mounted. Defaults to C</>.

=item B<--port | -p>

The port to listen on. Defaults to C<8080>.

=item B<--strict | --no-strict>

Enables or disables formal configuration validation. When enabled (default), 
the server validates the YAML configuration against a JSON schema 
(miniserver-schema.json) before startup. Use C<--no-strict> to bypass 
this check[cite: 1, 34, 37].

=item B<--log-level | -l>

Overrides the C<log_level> defined in the configuration file. This 
affects the verbosity of the server from the earliest stages of the 
boot process, including configuration validation and service mounting[cite: 1, 21, 22].

=back

=head1 BEDROCK TEMPLATE PARSING

In addition to hosting Services, the Miniserver acts as a "Smart Static Server."

When a request matches a file with a Bedrock extension (configured via
C<template_extensions>, typically F<.roc>), the server does B<not>
serve the raw source code. Instead, it:

=over 4

=item 1. B<Instantiates the Bedrock Stack>: It manually loads the "Big
5" startup objects that Bedrock pages expect:

=over 8

=item * C<$bedrock> (Utilities)

=item * C<$config> (Configuration, merged with F<tagx.xml>)

=item * C<$env> (Environment variables)

=item * C<$header> (HTTP Header control)

=item * C<$input> (CGI Parameters)

=back

=item 2. B<Enables Sessions>: If a session manager is explicitly configured
in the miniserver YAML, it initializes the session. 

I<Note: The miniserver does I<not> auto-discover session managers from your 
F<tagx.xml> configuration. You must add a C<session> block to your
F<bedrock-miniserver.yml>.>

A simple session manager to use is the SQLite manager. You can install the
C<BLM::Startup::SQLiteSession plugin> from the Bedorck CPAN repository.

L<http://cpan.openbedrock.net>

You'll find a SQL script you can use to create your database and
session table in plugin's distribution directory.

 perl -MFile::ShareDir=dist_file \
   -e 'print dist_file("BLM-Startup-SQLiteSession", "create-session-table.sql");'

 session:
   enabled: yes
   binding: session
   session: yes
   module: BLM::Startup::SQLiteSession
   config:
     data_source: dbi:SQLite:dbname=bedrock.db
     table_name: session
     expiry_secs: 900
     param: session
     log_level: info

=item 3. B<Parses the Template>: It renders the page using
C<Bedrock::Template>.

=item 4. B<Handles Errors>: If parsing fails, it generates a detailed
HTML error report with code highlighting, similar to the full
Apache::Bedrock handler.

=back

B<Usage:>

Simply define an alias pointing to your document root. Any F<.roc>
file accessed via that alias will be parsed automatically.

  # In bedrock-miniserver.yml
  aliases:
    /birds: ./htdocs/birds

  # Accessing http://localhost:8080/birds/index.roc now renders the template!

While F<.roc> is the standard extension, the list of extensions that 
trigger the accelerator is fully configurable via C<template_extensions> 
in the YAML. This allows for specialized templates, such as F<.jroc> for 
dynamic JSON generation[cite: 1, 23].

=head1 ARCHITECTURE

=head2 The Phase Gate (Overlay Routing)

The server uses a "Phase Gate" architecture to handle requests that
might be static files OR dynamic service calls.

=over 4

=item 1. B<Alias Check>: The server first checks if the request
matches a configured C<alias>.

=item 2. B<Existence Check>: If the request matches an alias, it
checks the filesystem.

=item 3. B<Fallthrough>: If the file does B<not> exist, the server
does not return a 404.  Instead, it allows the request to "fall
through" to the Service Registry.

=back

This allows you to mount a Service at C</> while still serving static
assets from an alias like C</css>, or to have specific static files 
"overlay" a dynamic application.

=head2 The Service Registry

The server maintains a registry of mounted services using "Longest
Prefix Match" routing.

  /       -> Bedrock::Service::RootApp
  /birds  -> Bedrock::Service::Autocomplete

=head2 Route Translation

When a request matches a service, the server B<translates> the path by
stripping the mount prefix before invoking the service. This allows
services to be written without knowledge of where they are mounted.

=head2 Advanced Routing (Regex Rewrites)

In addition to simple prefix stripping, the server supports complex 
URL remapping via the C<routes> configuration block. This allows 
mapping RESTful URLs to internal service paths using named captures 
and variable substitution.

Example:

  routes:
    /api:
      '^/user/(:id)$': '/user/view?id=$1'

In this example, a request to C</api/user/123> is translated to 
C</user/view?id=123> before being handed to the service.

=head2 Environment Virtualization

To ensure that Services and Templates are portable, the Miniserver 
manages the environment for each request. It manually calculates and 
overrides C<SCRIPT_NAME> and C<PATH_INFO> based on the mount point 
or alias, allowing code to operate correctly regardless of its 
location in the public URL space.

=head1 CONFIGURATION

The server configuration is driven by a YAML file (e.g.,
F<bedrock-miniserver.yml>).

  port: 8080
  
  # Control server verbosity (debug, info, warn, error, fatal)
  # Default: info
  log_level: debug 

  # 1. Environment Injection
  #    These variables are injected into %ENV at startup.
  env:
    DBI_TRACE: 1
    MY_API_KEY: "secret"

  # 2. Services
  services:
    /api: MyApp::Service::API
    /:    MyApp::Service::Root

  # 3. Aliases (Static & Accelerator)
  aliases:
    /css: ./htdocs/css
    /:    ./htdocs/root

  # 4. Directory Indices
  #    Automatically creates aliases for root paths.
  #    If multiple files are listed, they are prioritized in order.
  directory_index:
    /bedrock:
      - index.html
      - index.roc

  # 5. Advanced Routing (Regex Rewrites)
  #    Map complex URLs to internal paths before they hit the Service.
  #    Use (:name) to capture segments.
  routes:
    /api:
      # Maps /api/user/123 -> /user/view?id=123
      '^/user/(:id)$': '/user/view?id=$1'

  # 6. Accelerator Configuration
  parse_templates: yes
  template_extensions:
    - roc
    - jroc

  # 7. Session Manager (Used by both Services and Accelerator)
  session:
    module: BLM::Startup::MemorySession
    config:
      persistence_enabled: yes

  overrides:
    BEDROCK_CONFIG_PATH: ./config

=head1 CONFIGURATION VALIDATION

As of version 3.7.5, the Miniserver performs strict validation of its 
configuration file using B<JSON Schema>. This prevents misconfigurations 
from being interpreted as runtime server bugs.

The server looks for the schema definition at:
C<@dist_dir@/config/miniserver-schema.json>.

If the configuration contains unknown keys or invalid data types (e.g., 
providing a string where an array is expected for C<directory_index>), 
the server will refuse to start and provide a specific path to the 
error within the YAML file.

I<You can override this check using the C<--no-strict> option...although caveat emptor.>

=head1 ROUTE RESOLUTION 

The MiniServer employs a specific precedence logic when resolving incoming
requests to ensure behavior parity with C<Apache::Bedrock>.

=over 4

=item 1. Explicit Route Matching

The server first iterates through the C<routes:> list in the order defined
in the YAML configuration. The first route 
with a C<path> that matches the beginning of the request URI is selected.

=item 2. Default File Fallback

If no explicit route matches, the server attempts to locate a physical
file relative to the C<SERVER_ROOT>. If a directory is requested, it
searches for C<index.roc> or C<index.html> within that directory (if
the C<directory_index> object was specified for that directory.

=item 3. MIME Type Dependency

For B<alias> routes serving static assets, the server relies on the 
C<mime_types:> hash to set the C<Content-Type> header. 
If an extension is not defined in the configuration, the server defaults 
to C<text/plain>.

=item 4. Path Sovereignty

All C<mount>, C<alias>, and C<resource> paths are resolved relative to 
the C<SERVER_ROOT>, which is automatically determined by the location of 
the configuration file unless explicitly overridden.

=back

=head1 EXIT STATUS

Returns 0 on successful execution. Returns non-zero if a service class
fails to load or the configuration is invalid.

=head1 AUTHOR

Rob Lauer - <bigfoot@cpan.org>

=cut
