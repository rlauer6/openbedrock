#!/usr/bin/env perl
#
# ...a lightweight HTTP server harness for Bedrock services.
#
package main;

use strict;
use warnings;

# FILE-SCOPED LEXICALS (used to pass values to HTTP::Server::Simple::CGI subclass)
my %ALIAS;
my $MOUNT_POINT;
my $SERVICE_INSTANCE;
my $SERVICE_CLASS;
my %EXTRA_ENV;

# for static assets
my %MIME_TYPES = (
  css  => 'text/css',
  js   => 'application/javascript',
  png  => 'image/png',
  jpg  => 'image/jpeg',
  gif  => 'image/gif',
  html => 'text/html',
);

exit Bedrock::MiniServer::CLI->main();

########################################################################
package Bedrock::MiniServer; ## no critic
########################################################################

use strict;
use warnings;

use Apache::Request::CGI;
use Benchmark;
use Data::Dumper;
use English qw(-no_match_vars);
use List::Util qw(pairs);
use Log::Log4perl;
use POSIX qw(strftime);

use parent qw(HTTP::Server::Simple::CGI);

# allow us to use cspec for Log::Log4perl
{ ## no critic
  no warnings 'once'; ## no critic
  $Log::Log4perl::Config->allow_code(1);
}

########################################################################
sub handle_request {
########################################################################
  my ( $self, $cgi ) = @_;

  my $t0 = Benchmark->new;

  my $path = $cgi->path_info();

  # --- A. Static Asset Handling ---
  foreach my $alias ( keys %ALIAS ) {
    next if index( $path, $alias ) != 0;

    return $self->_serve_static( $cgi, $alias, $ALIAS{$alias} );
  }

  # --- B. Routing Logic ---
  # Only strip the mount point if it's NOT root.
  if ( $MOUNT_POINT ne q{/} && index( $path, $MOUNT_POINT ) == 0 ) {
    $path = substr $path, length $MOUNT_POINT;
  }

  $path ||= q{/};

  {
    ## no critic
    # --- C. Dynamic Environment Update ---
    $ENV{PATH_INFO}      = $path;
    $ENV{SCRIPT_NAME}    = $MOUNT_POINT eq q{/} ? q{} : $MOUNT_POINT;
    $ENV{REQUEST_METHOD} = $cgi->request_method();
    $ENV{QUERY_STRING}   = $ENV{QUERY_STRING} || q{};
    $ENV{REQUEST_URI}    = $cgi->path_info();
    $ENV{HTTP_COOKIE}    = $cgi->http('Cookie');
    $ENV{CONTENT_LENGTH} = $cgi->http('Content-Length');
    $ENV{CONTENT_TYPE}   = $cgi->http('Content-Type');
  }

  foreach my $p ( pairs %EXTRA_ENV ) {
    my ( $k, $v ) = @{$p};
    $ENV{$k} = $v; ## no critic
  }

  $SERVICE_INSTANCE->request(undef);
  $SERVICE_INSTANCE->context(undef);
  $SERVICE_INSTANCE->bedrock_handler(undef);

  my $r = Apache::Request::CGI->new();

  eval { $SERVICE_INSTANCE->handler($r); };

  my $err = $EVAL_ERROR;

  my $t1 = Benchmark->new;

  if ($err) {
    print "HTTP/1.0 500 Internal Server Error\r\n";
    print "Content-Type: text/plain\r\n\r\n";
    print "Bedrock Crashed: $err";
    $r->log->error( 'CRITICAL ERROR: ' . $err );
  }

  my $td = timediff( $t1, $t0 );

  $r->log->notice( sprintf '%s %s (%s)', $cgi->request_method, $path, timestr($td) );

  return;
}

########################################################################
sub _serve_static {
########################################################################
  my ( $self, $cgi, $alias_url, $local_base ) = @_;

  my $path     = $cgi->path_info();
  my $rel_file = substr $path, length $alias_url;

  if ( $rel_file =~ /[.]{2}/xsm ) {
    print "HTTP/1.0 403 Forbidden\r\n\r\n";
    return;
  }

  my $fs_path = $local_base . $rel_file;

  if ( -e $fs_path && -r $fs_path ) {
    my ( $dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks ) = stat $fs_path;

    my ($ext) = $fs_path =~ /[.]([^.]+)$/xsm;
    my $type = $MIME_TYPES{ lc( $ext || q{} ) } || 'text/plain';

    # 2. Format Date for HTTP Header (RFC 1123)
    my $http_date = strftime( '%a, %d %b %Y %H:%M:%S GMT', gmtime $mtime );

    print "HTTP/1.0 200 OK\r\n";
    print "Content-Type: $type\r\n";

    # 3. Cache Headers
    # "public" = safe for proxies/browsers
    # "max-age=86400" = valid for 1 day
    print "Last-Modified: $http_date\r\n";
    print "Cache-Control: max-age=86400, public\r\n";
    print "\r\n";

    local $RS = undef;
    if ( open my $fh, '<', $fs_path ) {
      print <$fh>;
      close $fh;
    }
  }
  else {
    print "HTTP/1.0 404 Not Found\r\n";
    print "Content-Type: text/plain\r\n\r\n";
    print "File not found: $path";
    print {*STDERR} "404 Not Found: $fs_path\n";
  }

  return;
}

########################################################################
package Bedrock::MiniServer::CLI; ## no critic
########################################################################

use Bedrock qw(choose slurp_file $BEDROCK_DIST_DIR to_boolean);
use Bedrock::LoadConfig qw(load_config);
use CLI::Simple::Constants qw(:booleans :chars);
use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use JSON qw(encode_json decode_json);
use Module::Load;
use List::Util qw(pairs);

use parent qw(CLI::Simple);

########################################################################
sub main {
########################################################################
  my %commands = (
    default => \&cmd_start_server,
    start   => \&cmd_start_server,
  );

  my @option_specs = qw(
    help|h
    mount-point|m=s
    port|p=s
    service|s=s
    config|c=s
  );

  my $cli = Bedrock::MiniServer::CLI->new(
    commands        => \%commands,
    option_specs    => \@option_specs,
    default_options => { mount_point => $SLASH, },
    extra_options   => [qw(dist_dir server_config)],
  );

  return $cli->run();
}

########################################################################
sub cmd_start_server {
########################################################################
  my ($self) = @_;

  # 1. Load Server Configuration (File or Defaults)
  my $server_config = $self->get_server_config;

  # 2. Environment Injection (Bootstrap Context)
  if ( $server_config->{env} && ref $server_config->{env} eq 'HASH' ) {
    foreach my $p ( pairs %{ $server_config->{env} } ) {
      my ( $k, $v ) = @{$p};
      $ENV{$k} = $v; ## no critic
      $EXTRA_ENV{$k} = $v;
    }
  }

  $ENV{GATEWAY_INTERFACE} = 'CGI/1.1'; ## no critic

  # 3. Resolve Service Class , env->cli->config
  my $service_class
    = $ENV{BEDROCK_SERVICE} || $self->get_service || $server_config->{service_class} || $server_config->{BEDROCK_SERVICE};

  croak "ERROR: no service!\nUse --service, BEDROCK_SERVICE or set service_class in configuration file.\n"
    if !$service_class;

  if ( $service_class !~ /\ABedrock::Service/xsm ) {
    $service_class = "Bedrock::Service::$service_class";
  }

  $SERVICE_CLASS = $service_class;

  # 4. Service Instantiation (Context Injection)
  # We pass the entire 'service_config' block. The Service decides what to do with it.
  $SERVICE_INSTANCE = eval {
    load $service_class;

    # regardless of how we got this class name we got one and it is
    # valid identify the service in the config, let's make sure
    # everyone knows the canonical name...
    my $service_config = $server_config->{service_config} // {};
    $service_config->{service_class} = $service_class;
    $ENV{BEDROCK_CLASS} = $service_class; ## no critic
    $self->set_service($service_class);

    # check to see if there is no session manager pre-defined and we
    # want the default...
    my $session_config = $service_config->{session};

    # skip if there is already a session configuration
    if ( !$session_config ) {
      if ( to_boolean( $service_config->{default_session}->{enabled} ) ) {
        $session_config = $service_config->{default_session};
        delete $session_config->{enabled};
        $service_config->{session} = $session_config;

        # the default will be to enable persistence...
        if ( to_boolean( $session_config->{config}->{persistence_enabled} ) ) {
          my ($session_file) = $service_class =~ /::([^:]+)\z/xsm;
          $session_file = sprintf 'memory-session-%s.dat', $session_file;
          $session_config->{config}->{session_file} //= $session_file;
        }
      }
    }

    return $service_class->new( service_config => $service_config );
  };

  croak "ERROR: could not load service: $service_class\n$EVAL_ERROR"
    if $EVAL_ERROR;

  # 5. Resolve Mount Point
  $MOUNT_POINT = $self->get_mount_point;

  # Fallback logic: CLI -> Config -> Default
  if ( $MOUNT_POINT eq q{/} ) {
    $MOUNT_POINT = $server_config->{server}->{mount_point} || $server_config->{mount_point} || q{/};
  }

  # 6. Setup Static Aliases
  %ALIAS = ();
  if ( $server_config->{aliases} && ref $server_config->{aliases} eq 'HASH' ) {
    %ALIAS = %{ $server_config->{aliases} };
  }

  # 7. Startup Banner
  my $port = $self->get_port || $server_config->{server}->{port} || $server_config->{port} || 8080;

  my $url = "http://localhost:$port$MOUNT_POINT";

  my $logger = $SERVICE_INSTANCE->request->log;

  $logger->notice( q{=} x 60 );
  $logger->notice('BEDROCK MINISERVER STARTUP');
  $logger->notice( q{=} x 60 );
  $logger->notice( sprintf '%-15s : %s', 'Service Class', $SERVICE_CLASS );
  $logger->notice( sprintf '%-15s : %s', 'Mount Point',   $MOUNT_POINT );
  $logger->notice( sprintf '%-15s : %s', 'Port',          $port );
  $logger->notice( sprintf '%-15s : %s', 'Config Source', $server_config->{_source} || 'Internal Defaults' );
  $logger->notice( sprintf '%-15s : %s', 'Access URL',    $url );
  $logger->notice( q{-} x 60 );
  $logger->notice('Static Asset Aliases:');

  if ( keys %ALIAS ) {
    foreach my $alias ( sort keys %ALIAS ) {
      $logger->notice( sprintf '  %-20s -> %s', $alias, $ALIAS{$alias} );
    }
  }
  else {
    $logger->notice('  (None defined)');
  }

  $logger->notice( q{=} x 60 );
  $logger->notice('Ready for requests...');

  $SIG{INT} = sub { ## no critic
    print {*STDERR} "\nStopping miniserver...\n";
    exit 0;
  };

  Bedrock::MiniServer->new($port)->run();

  return 0;
}

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  $self->set_dist_dir($BEDROCK_DIST_DIR);

  my $config_file = $self->get_config;

  if ($config_file) {
    my @paths = grep {defined} ( q{}, $ENV{BEDROCK_CONFIG_PATH}, $ENV{CONFIG_PATH}, $BEDROCK_DIST_DIR );
    foreach my $p (@paths) {
      if ( $p !~ m{\z/}xsm ) {
        $p = "$p/";
      }

      next if !"$p$config_file";
      $config_file = "$p$config_file";
      last;
    }
  }

  $config_file //= sprintf '%s/config/bedrock-miniserver.yml', $BEDROCK_DIST_DIR;

  croak "Configuration file not found: $config_file"
    if !-e $config_file;

  my $config = slurp_file($config_file);

  while ( $config =~ s/[@]dist_dir[@]/$BEDROCK_DIST_DIR/xsmg ) { }

  open my $fh, '<', \$config
    or croak "ERROR: could not open handle on scalar\n";

  my $conf = load_config( $fh, 1 );

  close $fh;

  $conf->{_source} = $config_file;

  $self->set_server_config($conf);

  return;
}

__END__

=pod

=head1 NAME

bedrock-miniserver.pl - Lightweight standalone development server for Bedrock applications

=head1 SYNOPSIS

  # Start with default settings (Port 8080, Mount Point /)
  bedrock-miniserver.pl --service MyApp::Service

  # Start on a specific port with a specific mount point
  bedrock-miniserver.pl --port 3000 --mount-point /app --service MyApp::Service

  # Get help
  bedrock-miniserver.pl --help

=head1 DESCRIPTION

This script provides a standalone HTTP server for Bedrock
applications, built on top of C<HTTP::Server::Simple::CGI>. It
simulates a CGI environment (modifying C<PATH_INFO>, C<SCRIPT_NAME>,
etc.) and dispatches requests to a specified Bedrock Service class.

It is designed primarily for development and testing, allowing you to
run Bedrock applications without a full Apache/mod_perl stack.

=head1 OPTIONS

=over 4

=item B<--service | -s>

B<Required>. The Perl class name of the Bedrock Service to instantiate
and run (e.g., C<MyApp::Service>). This class must implement a
C<handler()> method.

=item B<--port | -p>

The port to listen on. Defaults to C<8080>.

=item B<--mount-point | -m>

The URL path where the application is rooted. Defaults to C</>, or the
value of C<BEDROCK_ADMIN_DIR> in your configuration if set.

=back

=head1 DEVELOPER NOTES

=head2 Static Asset Serving

The miniserver handles static assets (CSS, JS, Images) internally to
mimic the behavior of a production web server alias configuration.

It automatically maps the following URL paths to the C<Bedrock>
distribution directory found in C<@INC>:

=over 4

=item * C</bedrock/css> -> C<.../Bedrock/css>

=item * C</bedrock/javascript> -> C<.../Bedrock/javascript>

=item * C</bedrock/img> -> C<.../Bedrock/img>

=back

When serving these assets, the server applies standard MIME types
based on file extensions and adds a C<Cache-Control: max-age=86400,
public> header to facilitate browser caching during development.

=head2 Logging and Log4perl

The server initializes C<Log::Log4perl> using the configuration file
shipped with the Bedrock distribution.

Since your service is a subclass of B<Bedrock::Service>, it uses the
logging facilities provided by the framework. To prevent developers
from being overwhelmed by internal framework logs, a specific logging
category B<C<Bedrock::Service>> has been defined in the default
configuration. You should target this category (or your own service's
class name) when tuning log levels for your application logic.

B<Locating the Configuration File:>

If you need to modify the logging behavior (e.g., changing the level
from INFO to DEBUG), you must edit the C<log4perl.conf> file located
in the installed distribution directory. You can find the exact path
by running the following command:

  perl -MBedrock -e 'print "$Bedrock::BEDROCK_DIST_DIR/config/log4perl.conf\n"'

=head1 CONFIGURATION

The server looks for a configuration file in the current directory,
then in C<BEDROCK_CONFIG_PATH>, C<CONFIG_PATH> and finally Bedrock's
distribution directory. If no configuration file is specified defaults
to the distribution's F<bedrock-miniserver.yml>.

B<Required Arguments:>

If you are using the default configuration, you B<must> supply the
service name using the C<--service> option:

  bedrock-miniserver.pl --service MyApp::Service

B<Default Session Behavior:>

When using the default configuration, the server automatically configures
B<BLM::Startup::MemorySession> with persistence enabled. It generates a
session storage file in the current directory named:

  memory-session-<service-name>.dat

If you provide your own configuration file, you must configure the
session manager and persistence settings manually.

=head1 EXIT STATUS

Returns 0 on successful execution (though the server runs typically
runs until interrupted), or non-zero if the service class cannot be
loaded.

=head1 SEE ALSO

L<Bedrock::Service>, L<Bedrock::LoadConfig>

=head1 AUTHOR

Rob Lauer - <bigfoot@cpan.org>

=cut
